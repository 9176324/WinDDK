!IF 0

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    makefile.def

Abstract:

    This is the standard makefile for the components of the NT project.
    It includes the following files:

        .\sources.      - developer supplies this file.  It defines the
                          required TARGETNAME, TARGETPATH, TARGETTYPE and
                          SOURCES as well as optional macros that control
                          the behavior of the compiler and linker:

        obj\_objects.mac  - built by BUILD.EXE from .\sources.


Targets:

    all       - Builds all targets in this make file

    clean     - Erase all targets that can be produced by this make
                file, ignoring errors.  Also rebuilds the depend target.

    depend    - Rebuilts source file dependencies, using BUILD.EXE tool


Useful Variables Set:

    CPUTYPE={I386|AXP64|ALPHA|MPPC|IA64|AMD64|ARM}

Optional Controls Variables (partial list), these are environment variables,
remember they can be set with env=value on the command line as well:

NOTE:  xxx_... is {MSC|386|axp64|alpha|MPPC|ia64|amd64} where MSC_ applies to the C8 compiler
       independent of the cpu type.  Specific cpu_ will take precedence
       over the equivalent MSC_ variable.

EXAMPLE:  To compile with codeview symbols for windbg:

          set NTDEBUG=ntsd
          set NTDEBUGTYPE=windbg
          set MSC_OPTIMIZATION=/Od


    nttest=filename

    umappl=filename

    NT_UP
            Define as 0 in environment to turn on MP.
            If undefined or equal to 1, you get UP.

    xxx_warning_level

    xxx_optimization

    xxx_STDCALL = 1 use _stdcall calling convention
                  0 use _cdecl calling convention

    ntdebug

    browser_info

    xxx_cppflags

    ntcppflags

    NT_INST - set to turn on instrumentation

    BASEDIR - \nt or \ntrel (default \nt)

    PRECOMPILED_CXX=1 - do precompiled headers for CXX instead of C files
                        note: precompiled headers can not be used on both
                        c and cxx files in a single directory.
!ENDIF

!if 0
! message You must use nmake version 1.30 or greater...
!endif

# See if the user wants BROWSER_INFO.
!ifdef BROWSER_INFO
USER_ENV_BROWSER_INFO=1
!endif

#
# Select build target and set platform specific variables.
#

!ifdef BUILD_ALLOW_ALL_WARNINGS
BUILD_ALLOW_LINKER_WARNINGS=1
BUILD_ALLOW_COMPILER_WARNINGS=1
!endif
BUILD_ALLOW_MIDL_WARNINGS=1

!ifndef BUILD_ALLOW_LINKER_WARNINGS
LINKER_WX_SWITCH=/WX
!else
LINKER_WX_SWITCH=
!endif

!ifndef BUILD_ALLOW_COMPILER_WARNINGS
COMPILER_WX_SWITCH=/WX
!else
COMPILER_WX_SWITCH=
!endif

!ifndef BUILD_ALLOW_MIDL_WARNINGS
MIDL_WX_SWITCH=/WX
!else
MIDL_WX_SWITCH=
!endif

!INCLUDE makefile.plt


!ifndef MASTER_VERSION_FILE
!if "$(POCKETPC)" == ""
MASTER_VERSION_FILE = $(SDK_INC_PATH)\ntverp.h
!endif
DEFAULT_VERSION_FILE=1
!endif

!if "$(SDK_INC_PATH)" != "" && exist($(SDK_INC_PATH)\ntverpmk.inc)
!include $(SDK_INC_PATH)\ntverpmk.inc
!endif

#
#  IDL/RDL/TDL build rules.
#

!ifdef IDL_RULES
IDL_OUT_DIR =.
IDL_HDR_OUT_DIR =.
RDL_OUT_DIR =.
RDL_HDR_OUT_DIR =.

! ifndef MIDL_INCS
MIDL_INCS = $(_OBJ_DIR)\$(TARGET_DIRECTORY)
! endif

!endif

!ifndef LANGUAGE
LANGUAGE=usa
!endif

# define a simple macro that can be used for the object subdir in makefile.inc/sources files

O = $(_OBJ_DIR)\$(TARGET_DIRECTORY)

#
# Include the developer supplied file that defines the TARGETNAME, TARGETPATH,
# TARGETTYPE and SOURCES macros.  Make sure it defines them.
#

!if defined(USE_CAPK)
# Kernel profiling - icecap api's come from the kernel or from rtl\icecap.c when building the kernel/hal/ntdll
USE_ICECAP4=1
PERFLIBS=
C_DEFINES=$(C_DEFINES) /D_CAPKERN=1
ASM_DEFINES=$(ASM_DEFINES) /D_CAPKERN=1
!endif

!if defined(USE_ICECAP) || defined(USE_ICECAP4) || defined(USE_DLP)
! ifdef USE_ICECAP
PERFFLAGS=-Gh
PERFLIBS=$(SDK_LIB_PATH)\icap.lib
! else
!  ifdef USE_ICECAP4
PERFFLAGS=/fastcap
!  else # USE_DLP
PERFFLAGS=/dlp
!  endif
!  ifndef PERFLIBS
PERFLIBS=$(SDK_LIB_PATH)\icecap.lib
!  endif
! endif
! if $(FREEBUILD)
NTDEBUG=ntsdnodbg
! else
NTDEBUG=ntsd
! endif
NTDEBUGTYPE=windbg
NTBBT=1
!endif

LATEST_WIN32_WIN95_VERSION=0x0400
LATEST_WIN32_WCE_VERSION=0x0300

#
# Set versions correctly for NT4/2000/XP/Longhorn
#
!if $(_NT_TARGET_VERSION) == 0x600     ## Windows Longhorn ##
LATEST_WIN32_IE_VERSION   =0x0605
LATEST_WIN32_WINNT_VERSION=0x0600
SUBSYSTEM_VERSION_CURRENT =4.10
SUBSYSTEM_VERSION_LATEST  =6.00
LINKER_APP_VERSION=6.0
LINKER_OS_VERSION=6.0

!elseif $(_NT_TARGET_VERSION) == 0x502     ## Windows .NET ##
# Server 2003 gold has _WIN32_IE=0x0602, and Server 2003 SP1 has _WIN32_IE=0x0603
LATEST_WIN32_IE_VERSION   =0x0603
LATEST_WIN32_WINNT_VERSION=0x0502
SUBSYSTEM_VERSION_CURRENT =4.10
SUBSYSTEM_VERSION_LATEST  =5.02
LINKER_APP_VERSION=5.2
LINKER_OS_VERSION=5.2

!elseif $(_NT_TARGET_VERSION) == 0x501     ## Windows XP   ##
# XP gold has _WIN32_IE=0x0600, XP SP1 has _WIN32_IE=0x0601, and XPSP2 _WIN32_IE=0x0603
LATEST_WIN32_IE_VERSION   =0x0603
LATEST_WIN32_WINNT_VERSION=0x0501
SUBSYSTEM_VERSION_CURRENT=4.10
SUBSYSTEM_VERSION_LATEST  =5.01
LINKER_APP_VERSION=5.1
LINKER_OS_VERSION=5.1

!elseif $(_NT_TARGET_VERSION) == 0x500 ## Windows 2000 ##
LATEST_WIN32_IE_VERSION   =0x0501
LATEST_WIN32_WINNT_VERSION=0x0500
SUBSYSTEM_VERSION_CURRENT=4.10
SUBSYSTEM_VERSION_LATEST  =5.00
LINKER_APP_VERSION=5.0
LINKER_OS_VERSION=5.0

!elseif $(_NT_TARGET_VERSION) == 0x400 ## Windows NT 4 ##
LATEST_WIN32_IE_VERSION   =0x0200
LATEST_WIN32_WINNT_VERSION=0x0400
SUBSYSTEM_VERSION_CURRENT =4.00
SUBSYSTEM_VERSION_LATEST  =4.00
LINKER_APP_VERSION=4.0
LINKER_OS_VERSION=4.0
!else
!message NMAKE : Uxxxx: _NT_TARGET_VERSION value is unknown.  Update Makefile.def to understand the new version.
!endif # _NT_TARGET_VERSION

#
# Set Windows CE/PocketPC variables.
#

!if "$(POCKETPC)" != ""

! if "$(POCKETPC_EMULATION)" != ""
WINCE_IMAGE = -WINDOWSCE:EMULATION
! else
WINCE_IMAGE = -WINDOWSCE
! endif

CVTRES_PLATFORM_FLAGS = $(WINCE_IMAGE)

!endif

#
# Run miscfiles rules during both compile and link phases.  Sources file
# can override by setting this a value other than 0
#

MISCFILES_DURING_LINK=0

!INCLUDE .\sources
SOURCES_USED=$(SOURCES_USED) .\sources

#
# Attempt to include the sources file from the target subdirectory.
#
!IF EXIST(.\$(TARGET_DIRECTORY)\sources)
! INCLUDE .\$(TARGET_DIRECTORY)\sources
SOURCES_USED=$(SOURCES_USED) .\$(TARGET_DIRECTORY)\sources
!ENDIF

!ifdef PASS1_LINK
MAKEDLL=1
!undef NOLINK
!endif

#
# Attempt to include the sources file from the parent target subdirectory.
#

!IF EXIST(..\$(TARGET_DIRECTORY)\sources)
! INCLUDE ..\$(TARGET_DIRECTORY)\sources
SOURCES_USED=$(SOURCES_USED) ..\$(TARGET_DIRECTORY)\sources
!ENDIF

!if $(LTCG_DRIVER) && "$(TARGETTYPE)" == "DRIVER"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_DRIVER_LIBRARY) && "$(TARGETTYPE)" == "DRIVER_LIBRARY"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_DYNLINK) && "$(TARGETTYPE)" == "DYNLINK"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_EXPORT_DRIVER) && "$(TARGETTYPE)" == "EXPORT_DRIVER"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_GDI_DRIVER) && "$(TARGETTYPE)" == "GDI_DRIVER"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_HAL) && "$(TARGETTYPE)" == "HAL"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_LIBRARY) && "$(TARGETTYPE)" == "LIBRARY"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_MINIPORT) && "$(TARGETTYPE)" == "MINIPORT"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_PROGRAM) && "$(TARGETTYPE)" == "PROGRAM"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_PROGLIB) && "$(TARGETTYPE)" == "PROGLIB"
LINK_TIME_CODE_GENERATION=1
!endif

!if $(LTCG_UMAPPL_NOLIB) && "$(TARGETTYPE)" == "UMAPPL_NOLIB"
LINK_TIME_CODE_GENERATION=1
!endif

# Allow separate LTCG definitions loosely based on SKU.

!if defined(LTCG_SRV) || defined(LTCG_WKS) || defined(LTCG_SRVWKS)
LINK_TIME_CODE_GENERATION=1
!endif

# Avoid publishing ANONYMOUS PCH objects to public.

!if defined(LINK_TIME_CODE_GENERATION) && defined(PASS1_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2" && !defined(NOLIB) && "$(TARGETTYPE)" != "DYNLINK" && "$(TARGETTYPE)" != "EXPORT_DRIVER"
NTNOPCH=1
!endif

# Allow alternate object directories.

!ifndef BUILD_ALT_DIR
BUILD_ALT_DIR=
! ifdef CHECKED_ALT_DIR
! if !$(FREEBUILD)
BUILD_ALT_DIR=d
!  endif
! endif
!endif

_OBJ_DIR = obj$(BUILD_ALT_DIR)


!if "$(BINPLACE_LOG)" != ""
BUILD_LOGS=$(BINPLACE_LOG)\..
!message BUILD_LOGS=$(BUILD_LOGS)
!if [-mkdir $(BUILD_LOGS)\sidebyside >nul 2>&1]
# !error Cannot make $(BUILD_LOGS)\sidebyside
!endif
!endif



!if defined(SXS_LOCALIZE_ASSEMBLY)
!  message $(BUILD_ERROR_MSG) SXS_LOCALIZE_ASSEMBLY is obsolete.
!endif

#
# This would be the default but so far everyone is an exception.
#  Comctl32.dll has multiple languages in the code .dll.
#  Gdiplus.dll has no resources.
#  Rtc is using system32 fallback + explicit satelltie dependency.
#
# Besides that, nobody yet needs this.
#

!if defined(SXS_LOCALIZE_ASSEMBLY_MUI) && "$(SXS_LOCALIZE_ASSEMBLY_MUI)" != "1"
!  message $(BUILD_ERROR_MSG) SXS_LOCALIZE_ASSEMBLY_MUI can only be set to 1.
!endif

!if defined(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY) && "$(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY)" != "1"
!  message $(BUILD_ERROR_MSG) SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY can only be set to 1.
!endif

!if defined(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY) && !defined(SXS_LANGUAGE)
!  message $(BUILD_ERROR_MSG) If you set SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY, you must also set SXS_LANGUAGE, and use SXS_LANGUAGE in your assembly identity.
!endif



#
# SXS Build
#
# Step by Step
#
# For building a monolithic application, foo.ext (where .ext is usually .exe but for example .scr).
# For building an application that hosts arbitrary (3rd party) code.
# For building a single file component like comctl32.dll.
# For building a multiple file component.
#
# Reference
#
# An assembly contains a manifest and one or more files, usually .dlls.
# The manifest can be in a resource in one of the files, or it can be in a seperate
#   .manifest file. For purposes of fitting on an 8.3 CD, .man is allowed.
#   For preprocessing, the source file can be .manifest-src.
# Build.exe is generally limited to building one .dll per directory, so
#   you can be building files for an assembly without building a manifest.
#
# To build/binplace a manifest:
#
#  SXS_MANIFEST required
#    This is the source file that contains your manifest.
#    It must end in .manifest or .manifest-src.
#    It is always preprocessed. Available macros include:
#      SXS_ASSEMBLY_NAME
#      SXS_ASSEMBLY_VERSION
#      SXS_ASSEMBLY_LANGUAGE
#      SXS_PROCESSOR_ARCHITECTURE
#
#  SXS_MANIFEST_IN_RESOURCES optional
#    This is defined or not, so you just say
#      SXS_MANIFEST_IN_RESOURCES=
#    or don't say anything.
#
#  SXS_ASSEMBLY_NAME and/or SXS_SHORT_ASSEMBLY_NAME required
#    One can be generated from the other.
#    SXS_SHORT_ASSEMBLY_NAME is used where 8.3 limits apply, like on the product CD.
#    Both of these macros can be hierarchical, using dot, dash, or underscore to seperate
#    elements. SXS_SHORT_ASSEMBLY_NAME should actually only contain 8 character elements.
#
#  SXS_ASSEMBLY_VERSION optional, defaults to 5.1.
#
#  SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT required
#    SXS_ASSEMBLY_LANGUAGE_INDEPENDENT is defined or not.
#    SXS_ASSEMBLY_LANGUAGE is four digits like
#      0409 for English US
#      0009 for English
#      0000 for language independent
#    We should make this easier as is done for resources (LANGUAGE => RCCODEPAGE), but for now we don't.
#
# To build/binplace a file into an assembly, a subset of the information
# needed for manifests is needed:
#
#  SXS_ASSEMBLY_NAME and/or SXS_SHORT_ASSEMBLY_NAME
#  SXS_ASSEMBLY_VERSION
#  SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT
#
# There are restrictions on the values of these macros and not all restrictions
# are currently enforced by the build. Enforcements that are present are done
# ifdef VERIFY_SOURCES in verify.src.
#

!if defined(SXS_MANIFEST) \
 || defined(SXS_BINPLACE_ALSO_ROOT) \
 || defined(SXS_ASSEMBLY_NAME) \
 || defined(SXS_ASSEMBLY_VERSION) \
 || defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) \
 || defined(SXS_ASSEMBLY_LANGUAGE)
VERIFY_SOURCES=1
!endif

!if "$(ALT_PROJECT)" == "WOW6432" || "$(ALT_PROJECT_TARGET)" == "WOW6432"
SXS_PDB_WOW6432_W_PREFIX=w
SXS_LOG_WOWBINS_W_ASMS_PREFIX=w
SXS_LOG_BINPLACE_WOW6432_PREFIX=wow6432^\
SXS_WOW6432=1
!endif

# Form this particularly so build.exe reports errors.
# Using !error doesn't work as well.
# It is based on what \nt\base\wow64\tools and verify.src do.
SXS_BUILD_ERROR_MSG=NMAKE : U1234: 'SXS_BUILD' ($(NTMAKEENV)\makefile.def)
SXS_MERGE_MODULE_ERROR_MSG=NMAKE : U1234: 'SXS_MERGE_MODULE_GENERATION' ($(NTMAKEENV)\makefile.def)

#
# There's two meta-modes of operation in SXS - Application manifest mode and component manifest mode.
# Depending on what you have defined in your sources file, you can simplify all of the build process
# down to a very minimal set of commands in your sources files and still get Fusionization goodness.
#
# Example:
#
# SXS_APPLICATION_MANIFEST=MyAppManifest.manifest
#
# (or)
#
# SXS_COMPONENT_MANIFEST=MyComponentManifest.manifest
#
# See the code below for what gets defined based on each - it's more or less the defaults, but
# explicitly spelled out.
#

# No fair using either app and component manifest, and specifying sxs_manifest, or using both by accident
!if defined(SXS_APPLICATION_MANIFEST) && defined(SXS_COMPONENT_MANIFEST)
!message $(SXS_BUILD_ERROR_MSG) You can have only one of SXS_APPLICATION_MANIFEST or SXS_COMPONENT_MANIFEST, not both
!elseif defined(SXS_MANIFEST) && ( defined(SXS_APPLICATION_MANIFEST) || defined(SXS_COMPONENT_MANIFEST) )
!message $(SXS_BUILD_ERROR_MSG) When using SXS_APPLICATION_MANIFEST or SXS_COMPONENT_MANIFEST, do not specify SXS_MANIFEST
!endif

# Applications get the following defaults that are not defaulted later:
# - SXS_ASSEMBLY_LANGUAGE=SXS_ASSEMBLY_LANGUAGE_INDEPENDENT
# - SXS_ASSEMBLY_NAME=Microsoft.Windows.$(PROJECT).$(TARGETNAME)
# - Manifest in resources
!if defined(SXS_APPLICATION_MANIFEST)
SXS_MANIFEST=$(SXS_APPLICATION_MANIFEST)
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
!if !defined(SXS_ASSEMBLY_NAME)
SXS_ASSEMBLY_NAME=Microsoft.Windows.$(_PROJECT_).$(TARGETNAME)
!endif
!if !defined(SXS_ASSEMBLY_LANGUAGE)
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!endif

# Components get the following defaulted:
# - SXS_ASSEMBLY_NAME=Microsoft.Windows.$(PROJECT).$(TARGETNAME)
# - Language independent
!elseif defined(SXS_COMPONENT_MANIFEST)
SXS_MANIFEST=$(SXS_COMPONENT_MANIFEST)
!if !defined(SXS_ASSEMBLY_NAME)
SXS_ASSEMBLY_NAME=Microsoft.Windows.$(_PROJECT_).$(TARGETNAME)
!endif
!if !defined(SXS_ASSEMBLY_LANGUAGE)
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!endif

!endif

!ifdef VERIFY_SOURCES
!include $(NTMAKEENV)\verify.src
!endif

!if defined(ISOLATION_AWARE_ENABLED)
C_DEFINES=$(C_DEFINES) -DISOLATION_AWARE_ENABLED=1
!endif

#
# NO_BINPLACE implies SXS_NO_BINPLACE
#
!if defined(NO_BINPLACE)
SXS_NO_BINPLACE=1
!endif

#
# Building an .exe implies SXS_NO_BINPLACE.
#
!if "$(TARGETTYPE)" == "PROGRAM"
SXS_NO_BINPLACE=1
!endif


#
# We can build SXS_ASSEMBLY_NAME out of SXS_SHORT_ASSEMBLY_NAME
# and vice versa.
#

!if !defined(SXS_ASSEMBLY_NAME) && defined(SXS_SHORT_ASSEMBLY_NAME)
SXS_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME)
!endif

!if !defined(SXS_SHORT_ASSEMBLY_NAME) && defined(SXS_ASSEMBLY_NAME)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_ASSEMBLY_NAME)
!endif

#
# Support the idea of a hierarchical 8.3 name, besides that this
# transform might be applied after the preceding assignment.
#
# eg: msft-vcrtl => msft\vcrtl
#

# Turn hierarchical names using [-._ ] as the element divider
# into hierarchical file system names. (Note that _ and . are not
# currently allowed in assembly names.)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:-=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:_=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:.=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME: =\)

# Shorten one special name that is likely to appear in long assembly names.
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:Microsoft=Msft)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:microsoft=msft)

!if defined(SXS_MANIFEST_IN_RESOURCES) && !defined(SXS_MANIFEST)
!message $(SXS_BUILD_ERROR_MSG) You must specify SXS_MANIFEST if you specify SXS_MANIFEST_IN_RESOURCES.
!endif

!if defined(SXS_ASSEMBLY_VERSION) && !defined(SXS_ASSEMBLY_NAME)
!message $(SXS_BUILD_ERROR_MSG) You may not specify SXS_ASSEMBLY_VERSION without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if (defined(SXS_ASSEMBLY_LANGUAGE) || defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT)) && !defined(SXS_ASSEMBLY_NAME)
!message $(SXS_BUILD_ERROR_MSG) You may not specify SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if defined(SXS_BINPLACE_ALSO_ROOT) && !defined(SXS_ASSEMBLY_NAME)
!message $(SXS_BUILD_ERROR_MSG) You may not specify SXS_BINPLACE_ALSO_ROOT without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if defined(MANAGED_CXX) || defined(MANAGED_CODE) || defined(MANAGED_VB)
# "managed" == urt, clr, .net, c#, vs7, mscoree, etc.
SXS_MANAGED=1
!else
# "unmanaged" == C++/C/assembly, native x86/ia64/amd64/etc.
SXS_MANAGED=0
!endif

!if defined(SXS_ASSEMBLY_NAME) # {

#
# SXS_ASSEMBLY_VERSION may only contain dots and digits.
# Removing them should leave nothing.
#
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_ASSEMBLY_VERSION)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:.=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:0=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:1=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:2=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:3=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:4=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:5=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:6=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:7=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:8=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:9=)
!if "$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS)" != ""
!message $(SXS_BUILD_ERROR_MSG) SXS_ASSEMBLY_VERSION ($(SXS_ASSEMBLY_VERSION)) may only contain dots and digits.
!endif

#
# ASSERT(SXS_ASSEMBLY_LANGUAGE xor SXS_ASSEMBLY_LANGUAGE_INDEPENDENT)
#
!if    (!defined(SXS_ASSEMBLY_LANGUAGE) && !defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT))
!message $(SXS_BUILD_ERROR_MSG) Must specify SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT.
!endif

!if ( defined(SXS_ASSEMBLY_LANGUAGE) &&  defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT))
!message $(SXS_BUILD_ERROR_MSG) Must not specify both SXS_ASSEMBLY_LANGUAGE and SXS_ASSEMBLY_LANGUAGE_INDEPENDENT.
!message ( SXS_ASSEMBLY_LANGUAGE=$(SXS_ASSEMBLY_LANGUAGE), SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=$(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) )
!endif

#
# Derive from SXS_ASSEMBLY_LANGUAGE from SXS_ASSEMBLY_LANGUAGE_INDEPENDENT.
#
!if defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) && !defined(SXS_ASSEMBLY_LANGUAGE)
SXS_ASSEMBLY_LANGUAGE=x-ww
!endif

#
# This is for Fusion stuff only. It does not need to match the nt subsystem version.
#
!if !defined(SXS_ASSEMBLY_VERSION)
SXS_ASSEMBLY_VERSION=5.1
!endif

#
# SxS Versions are Major.Minor.Release.Revision
#
!if defined(SXS_ASSEMBLY_VERSION) # {

!if !defined(SXS_ASSEMBLY_VERSION_PART_3)
SXS_ASSEMBLY_VERSION_PART_3_UNDEFINED=1
SXS_ASSEMBLY_VERSION_PART_3=0
!endif

!if !defined(SXS_ASSEMBLY_VERSION_PART_4)
SXS_ASSEMBLY_VERSION_PART_4=0
!endif

#
# If this is more than eight characters or not adequately unique, the user must specify it in their sources file.
#
!if "$(SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER)" == "" 
!if !defined(SXS_AUTO_VERSION) 
!if "$(SXS_ASSEMBLY_VERSION_PART_4)" != "0"
SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER=$(SXS_ASSEMBLY_VERSION:.=)$(SXS_ASSEMBLY_VERSION_PART_3)
!else
SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER=$(SXS_ASSEMBLY_VERSION:.=)$(SXS_ASSEMBLY_VERSION_PART_3)$(SXS_ASSEMBLY_VERSION_PART_4)
!endif
!else
SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER=$(SXS_ASSEMBLY_VERSION:.=)
!endif
!endif

SXS_ASSEMBLY_FULL_VERSION=$(SXS_ASSEMBLY_VERSION).$(SXS_ASSEMBLY_VERSION_PART_3).$(SXS_ASSEMBLY_VERSION_PART_4)

!endif # }

!if !defined(SXS_NO_BINPLACE) # {
#
# We might need SXS_ASSEMBLY_LANGUAGE and even SXS_ASSEMBLY_PROCESSOR_ARCHITECTURE
# in SXS_BINPLACE_DIR, esp. for example if we have any data only assemblies with
# the same name/version as code containing assemblies.
#
# Eventually the mapping from assembly metadata to run-time paths and
# build-time paths will be exposed by sxs.dll/sxs.lib consumed
# by build tools written in C/C++ (possibly just binplace).
# Build/Make are too constraining for our needs.
# For now we get by.
#
# "asms" is very special, it is the root of where assemblies are binplaced
# and it is the root of where they appear on the CD. This string appears in
# a number of places:
#   \nt\tools\PostBuildScripts
#   \nt\admin\ntsetup\inf\win4\inf\dosnet.inx
#   \nt\admin\ntsetup\inf\win4\inf\syssetup.inx
#
!if $(SXS_MANAGED)
SXS_BINPLACE_DIR1=managed_asms
!else
SXS_BINPLACE_DIR1=asms
!endif
# We place version in front of name due to restrictions on how the manifest
# file name related to the name of leaf directory it is in.
SXS_BINPLACE_DIR2=$(SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER)\$(SXS_SHORT_ASSEMBLY_NAME)
SXS_BINPLACE_DIR3=$(SXS_BINPLACE_DIR1)\$(SXS_BINPLACE_DIR2)
SXS_BINPLACE_SLASH_DIR3=\$(SXS_BINPLACE_DIR3)

#
# create msms destination directory
#
!if defined(SXS_GENERATE_MERGE_MODULE) # {

#
# if the generate mode is not defined, set it default : 0
#
!if !defined(SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP)
SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP=0
!else
SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP=1
!endif

!if "$(SXS_MERGE_MODULE_GUID)" == "" || "$(SXS_MERGE_MODULE_COMPONENT_GUID)" == ""  # {
!error $(SXS_MERGE_MODULE_ERROR_MSG) MergeModule GUID and MergeModule Component must be specified
!endif # }

!if !defined(SXS_MERGE_MODULE) # { use the manifest basename as the msm basename
SXS_MERGE_MODULE=$(SXS_MANIFEST_BASENAME).msm
!endif #}

!if !defined(SXS_MERGE_MODULE_LOCATION)
SXS_MERGE_MODULE_DESTINATION=asm_msm\$(SXS_BINPLACE_DIR2)
!else
#
#parse this string to generate the real path
#
SXS_MERGE_MODULE_LOCATION=$(SXS_ASSEMBLY_FULL_VERSION:.=)\$(SXS_MERGE_MODULE_LOCATION)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:-=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:_=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:.=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION: =\)
SXS_MERGE_MODULE_LOCATION=asm_msm\$(SXS_MERGE_MODULE_LOCATION)
!endif
!endif # }

BINPLACE_GENERATE_PLACEFILE=1
!if "$(BINPLACE_DESTINATIONS)" == ""
BINPLACE_DESTINATIONS=$(SXS_BINPLACE_DIR3)
!else
BINPLACE_DESTINATIONS=$(BINPLACE_DESTINATIONS):$(SXS_BINPLACE_DIR3)
!endif
BINPLACE_DESTINATIONS_NORETAIL=$(BINPLACE_DESTINATIONS)
!if defined(SXS_BINPLACE_ALSO_ROOT)
BINPLACE_DESTINATIONS=$(BINPLACE_DESTINATIONS):retail
!endif

!endif # !SXS_NO_BINPLACE }

#
# Optionally uniquize the .pdb names, so they can go in a flat directory (%_nttree%\symbols.pri\retail\dll)
#
!if !defined(SXS_LONG_PDB_NAME)
SXS_LONG_PDB_NAME=$(SXS_PDB_WOW6432_W_PREFIX)$(SXS_ASSEMBLY_NAME:.=)-$(SXS_ASSEMBLY_FULL_VERSION:.=)-$(TARGETNAME:.=)
!endif
!if !defined(SXS_NO_BINPLACE) #{
!if !defined(TARGETPDB) && "$(SXS_USE_LONG_PDB_NAME)" == "1" && !defined(SXS_AUTO_VERSION)
LINKER_FLAGS=$(LINKER_FLAGS) -pdb:$(TARGETPATH)\$(TARGET_DIRECTORY)\$(SXS_LONG_PDB_NAME).pdb
!endif
SXS_BINPLACE_FLAGS=-ChangeAsmsToRetailForSymbols
!endif #}

!endif # !SXS_ASSEMBLY_NAME }

!if defined(BINPLACE_LOG) && !defined(NO_SXS_LOG)
!if !defined(NO_BINPLACE) && ("$(TARGETTYPE)" == "NOTARGET" || "$(MAKEDLL)" != "" || "$(BUILD_PASS)" == "PASS2")
SXS_LOG_PASS=1
SXS_LOG_CMD= ( echo. )
!endif
!endif

!if defined(SXS_LOG_PASS) && !defined(APPEND_TOOL)
APPEND_TOOL=appendtool.exe
!endif

!if defined(SXS_MANIFEST) # {

#
# If removing .manifest or .Manifest from SXS_MANIFEST leaves it unchanged,
# it doesn't contain either one and is invalid.
#
!if "$(SXS_MANIFEST:.Manifest=)" == "$(SXS_MANIFEST)" \
    && "$(SXS_MANIFEST:.manifest=)" == "$(SXS_MANIFEST)"
!message $(SXS_BUILD_ERROR_MSG) SXS_MANIFEST ($(SXS_MANIFEST)) must contain ".Manifest", it must end in ".Manifest or ".Manifest-src"
!endif

SXS_MANIFEST_SOURCE_FILENAME=$(SXS_MANIFEST:..\=)

SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_SOURCE_FILENAME)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.manifest-src=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Manifest-src=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.manifest=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Manifest=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.man=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Man=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.man-src=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Man-src=)

#
# Always make .man file in the obj directory.
#
SXS_MANIFEST_OBJ1=$(O)\$(SXS_MANIFEST_BASENAME).man

#
# If TARGETPDB is defined, we'll use the linker's default PDB name.
# if SXS_AUTO_VERSION is on, derive the PDB name from ntverp.h & sxsmanifest.h
# by preprocessing a .lnk file to provide the right -pdb flag to LINKER
#
!if defined(SXS_AUTO_VERSION) && !defined(TARGETPDB) && "$(SXS_USE_LONG_PDB_NAME)" == "1"
SXS_PDB_NAMER=$(O)\$(SXS_MANIFEST_BASENAME)_pdb.lnk
!endif

!if !defined(SXS_MANIFEST_IN_RESOURCES) # {

#
# OBJ is files in obj\i386.
# BIN is binplaced files, possibly also in obj\i386.
#
# The binplaced file must be 8.3.
# The obj\i386 file
#  - should allow .exes to be run from obj\i386 that don't have manifest-in-resources
#  - not override manifest-in-resources
#
SXS_MANIFEST_BIN_FILENAME=$(SXS_MANIFEST_BASENAME).man

!if !defined(NO_BINPLACE) && !defined(SXS_NO_BINPLACE) && ("$(BUILD_PASS)" == "PASS1" || "$(BUILD_PASS)" == "PASSALL")
SXS_MISCFILES=$(SXS_MISCFILES) $(SXS_MANIFEST_OBJ1)
!endif

# Make a .manifest file identical to the .man file (we just copy it).
!if "$(TARGETTYPE)" != "NOTARGET" && ("$(MAKEDLL)" != "" || "$(BUILD_PASS)" == "PASS2")
SXS_MANIFEST_OBJ2=$(O)\$(TARGETNAME).$(TARGETEXT).manifest
!endif

!else # } SXS_MANIFEST_IN_RESOURCES { #

SXS_MANIFEST_BIN_FILENAME=$(TARGETNAME).$(TARGETEXT)

!if !defined(SXS_MANIFEST_RESOURCE_ID) # {
!if defined(ISOLATION_AWARE_ENABLED) || "$(TARGETTYPE)" == "DYNLINK"
SXS_MANIFEST_RESOURCE_ID=ISOLATIONAWARE_MANIFEST_RESOURCE_ID
!elseif "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "PROGLIB" || "$(TARGETTYPE)" == "UMAPPL_NOLIB"
SXS_MANIFEST_RESOURCE_ID=CREATEPROCESS_MANIFEST_RESOURCE_ID
!endif
!endif # }

#
# Putting manifests in resources requires no editing of the .rc file.
# We can do this via forceinclude-file or forceinclude-string.
# I thought rc.exe had a forceinclude-file feature like the C++ compiler.
# By the time I realized that it doesn't, it seemed better to press ahead
# with simulating it than not depend on it. There is unlikely any other way
# to support SXS_MANIFEST_IN_RESOURCES without requiring "nonlocal" .rc file
# edits (ie: without further fanning out how many files need to touched in how
# many places by clients who want to build sxs assemblies).
#
RCOPTIONS=-DSXS_MANIFEST_OBJ1="\"$(SXS_MANIFEST_OBJ1:\=/)\"" $(RCOPTIONS)
INCPATHRC=$(INCPATHRC)
RC_FORCE_INCLUDE_STRING=$(RC_FORCE_INCLUDE_STRING)^
^#include "windows.h"^
^/* RT_MANIFEST is in winuser.h and winuser.rh */^
$(SXS_MANIFEST_RESOURCE_ID) RT_MANIFEST SXS_MANIFEST_OBJ1
#RC_FORCE_INCLUDE_FILES=$(RC_FORCE_INCLUDE_FILES);$(BASE_INC_PATH)\SxsManifestInResource.rc2
#RC_FORCE_INCLUDE_STRING=

!endif # } SXS_MANIFEST_IN_RESOURCES

!if defined(SXS_LOG_PASS) # {
#
# data for PostBuild/ManifestMangler
#

!if $(SXS_MANAGED)
SXS_BINPLACE_LOG=$(BINPLACE_LOG)-managed-sxs
!else
SXS_BINPLACE_LOG=$(BINPLACE_LOG)-sxs
!endif

!if !defined(APPEND_CMD)
APPEND_CMD=$(APPEND_TOOL) -file $(SXS_BINPLACE_LOG) -
!endif
SXS_LOG_CMD= ( $(SXS_LOG_CMD) ) &                                          \
        ( echo                                                             \
        SXS_ASSEMBLY_NAME="$(SXS_ASSEMBLY_NAME)"                           \
        SXS_ASSEMBLY_VERSION="$(SXS_ASSEMBLY_FULL_VERSION)"                \
        SXS_ASSEMBLY_LANGUAGE="$(SXS_ASSEMBLY_LANGUAGE)"                   \
        SXS_MANIFEST="$(SXS_LOG_BINPLACE_WOW6432_PREFIX)$(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BIN_FILENAME)"  \
!if defined(SXS_LOCALIZE_ASSEMBLY_MUI)
        SXS_LOCALIZE_ASSEMBLY_MUI=$(SXS_LOCALIZE_ASSEMBLY_MUI) \
!endif
!if defined(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY)
        SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY=$(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY) \
!endif
        | $(APPEND_TOOL) -file $(BUILD_LOGS)\sidebyside\binplace_$(COMPUTERNAME).log-sxs - )

  
#
# Produce manifest-related, including
#       Required: catalog,
#       Optional: merge module
#
!if !defined(SXS_NO_BINPLACE) # {

!if 1 #{ begin create log-file-entry for Assembly Catalog

!if !defined(SXS_FUSIONLIST_TXT_DATA_VALIDLANGS)
SXS_FUSIONLIST_TXT_DATA_VALIDLANGS=all
!endif
!if !defined(SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS)
SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS=-
!endif
!if !defined(SXS_FUSIONLIST_TXT_DATA_VALIDARCHS)
SXS_FUSIONLIST_TXT_DATA_VALIDARCHS=all
!endif
!if !defined(SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG)
SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG=all
!endif

#
# Filename ValidLangs Exceptions ValidArchs ValidDebug AltName
#
!if !defined(SXS_FUSIONLIST_TXT_DATA)       #{
SXS_FUSIONLIST_TXT_DATA=\
 $(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BASENAME).cat \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDLANGS) \
 $(SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS) \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDARCHS) \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG)
!endif  #}

!if !defined(SXS_FUSIONLIST_TXT_DATA_WOW)   #{
SXS_FUSIONLIST_TXT_DATA_WOW=\
 $(SXS_BINPLACE_DIR1)\x86\$(SXS_BINPLACE_DIR2)\$(SXS_MANIFEST_BASENAME).cat \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDLANGS) \
 $(SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS) \
 ia64;amd64 \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG)
!endif  #}

!endif  #} end create log-file-entry for Assembly Catalog

!if defined(SXS_GENERATE_MERGE_MODULE)   # { begin create log-file-entry for Assembly MergeModule

#
# the msm-log lsitfile is in the format of
#   SourceFileDirectory | Destination-MSM-Filename | MergeModuleID | MergeModuleComponent ID
#
!if !defined(SXS_MERGE_MODULE_TXT_DATA)   #{
SXS_MERGE_MODULE_TXT_DATA=\
 $(SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP),\
 $(SXS_MERGE_MODULE_GUID),\
 ..\$(SXS_MERGE_MODULE_LOCATION)\$(SXS_MERGE_MODULE),\
 ..\$(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BASENAME).man,\
 $(SXS_MERGE_MODULE_COMPONENT_GUID)

!endif # }

!endif # } end create log-file-entry for Assembly MergeModule

!endif # SXS_NO_BINPLACE }

!endif # SXS_LOG_PASS }

!endif # SXS_MANIFEST }

!if !$(SXS_MANAGED) && defined(SXS_LOG_PASS) && (defined(SXS_FUSIONLIST_TXT_DATA) || defined(SXS_FUSIONLIST_TXT_DATA_WOW)) # {

# $(COMPUTERNAME) for unique per build machine names in a distributed build environment.
# These files are combined in postbuild.
SXS_NEWPRS_FUSIONLIST_TXT=$(BUILD_LOGS)\fusionlist_$(COMPUTERNAME).txt


!if defined(SXS_FUSIONLIST_TXT_DATA)
SXS_LOG_CMD=( $(SXS_LOG_CMD) ) & ( echo $(SXS_FUSIONLIST_TXT_DATA) | $(APPEND_TOOL) -file $(SXS_NEWPRS_FUSIONLIST_TXT) - )
!endif
!if defined(SXS_FUSIONLIST_TXT_DATA_WOW)
SXS_LOG_CMD=( $(SXS_LOG_CMD) ) & ( echo $(SXS_FUSIONLIST_TXT_DATA_WOW) | $(APPEND_TOOL) -file $(SXS_NEWPRS_FUSIONLIST_TXT) - )
!endif
!endif # }

!if !$(SXS_MANAGED) && defined(SXS_LOG_PASS) && defined(SXS_MERGE_MODULE_TXT_DATA) # {
SXS_MERGEMODULE_LIST_TXT=$(BUILD_LOGS)\sxsMsmList_$(COMPUTERNAME).txt
!if defined(SXS_MERGE_MODULE_TXT_DATA)
SXS_LOG_CMD=( $(SXS_LOG_CMD) ) & ( echo $(SXS_MERGE_MODULE_TXT_DATA) | $(APPEND_TOOL) -file $(SXS_MERGEMODULE_LIST_TXT) - )
!endif

!endif # }


#
# Do this independently of the presence of any other SXS options
# to aid .manifest preprocessing in the absense of any other sxs build support,
# like for users of CreateActCtx. The MultiRes test case uses this.
#
!if !$(SXS_MANAGED) && !defined(SXS_PROCESSOR_ARCHITECTURE)
!if defined(SXS_WOW6432)
SXS_PROCESSOR_ARCHITECTURE=wow64
!elseif defined(_BUILDARCH)
SXS_PROCESSOR_ARCHITECTURE=$(_BUILDARCH)
!elseif $(386)
SXS_PROCESSOR_ARCHITECTURE=x86
!elseif $(IA64)
SXS_PROCESSOR_ARCHITECTURE=ia64
!else
!message $(SXS_BUILD_ERROR_MSG) Cannot determine processorArchitecture.
!endif
!endif

# makefile.def debugging support
!if defined(BUILD_DEBUG)
TYPE=rem
NOECHO=
!else
TYPE=@type
NOECHO=@
!endif

!if defined(LOCALIZED_RESOURCES) && !defined(RCCODEPAGE)
! if "$(LANGUAGE)" == "JPN" || "$(LANGUAGE)" == "jpn"
RCCODEPAGE=932
! elseif "$(LANGUAGE)" == "KOR" || "$(LANGUAGE)" == "kor"
RCCODEPAGE=949
! elseif "$(LANGUAGE)" == "CHS" || "$(LANGUAGE)" == "chs"
RCCODEPAGE=936
! elseif "$(LANGUAGE)" == "CHP" || "$(LANGUAGE)" == "chp"
RCCODEPAGE=936
! elseif "$(LANGUAGE)" == "CHT" || "$(LANGUAGE)" == "cht"
RCCODEPAGE=950
! endif
!endif

#
# Set far east specific defines based on the project
#
DO_FE_SB=0

!if "$(ALT_PROJECT_TARGET)" == ""
ALT_PROJECT_TARGET=.
!endif

!if "$(ALT_PROJECT)" == "FE"  || \
    "$(ALT_PROJECT)" == "CHT" || \
    "$(ALT_PROJECT)" == "CHS" || \
    "$(ALT_PROJECT)" == "CHP" || \
    "$(ALT_PROJECT)" == "JPN" || \
    "$(ALT_PROJECT)" == "KOR" || \
    "$(ALT_PROJECT)" == "NEC_98"
C_DEFINES=$(C_DEFINES) -DDBCS -DKKBUGFIX
ASM_DEFINES=$(ASM_DEFINES) -DDBCS -DKKBUGFIX
DO_FE_SB=1
!endif

!if "$(ALT_PROJECT)" == "CHT"
C_DEFINES=$(C_DEFINES) -DTAIWAN
ASM_DEFINES=$(ASM_DEFINES) -DTAIWAN
!elseif "$(ALT_PROJECT)" == "CHS" || "$(ALT_PROJECT)" == "CHP"
C_DEFINES=$(C_DEFINES) -DPRC
ASM_DEFINES=$(ASM_DEFINES) -DPRC
!elseif "$(ALT_PROJECT)" == "JPN"
C_DEFINES=$(C_DEFINES) -DJAPAN
ASM_DEFINES=$(ASM_DEFINES) -DJAPAN
!elseif "$(ALT_PROJECT)" == "KOR"
C_DEFINES=$(C_DEFINES) -DKOREA
ASM_DEFINES=$(ASM_DEFINES) -DKOREA
!elseif "$(ALT_PROJECT)" == "NEC_98"
C_DEFINES=$(C_DEFINES) -DJAPAN -DNEC_98
ASM_DEFINES=$(ASM_DEFINES) -DJAPAN -DNEC_98
!elseif "$(ALT_PROJECT)" != ""
C_DEFINES=$(C_DEFINES) -D_$(ALT_PROJECT)_
!endif

!IF "$(ALT_PROJECT)" == "HYDRA"
ASM_DEFINES=$(ASM_DEFINES) -D_HYDRA_
HYDRA=1
!ENDIF

!IF "$(ALT_PROJECT)" == "JANUS"
ASM_DEFINES=$(ASM_DEFINES) -D_JANUS_
C_DEFINES=$(C_DEFINES) -D_JANUS_
JANUS=1
!ENDIF

!IF ("$(NO_W32_SB)" == "" && "$(W32_SB)" == "1")
DO_FE_SB=1
! ENDIF

!IF "$(DO_FE_SB)" == "1"
C_DEFINES=$(C_DEFINES) -DFE_SB -DFE_IME
ASM_DEFINES=$(ASM_DEFINES) -DFE_SB
!ENDIF

!IF "$(ALT_PROJECT)" == "DS"
# Nothing, just -D_DS_ from above
!ENDIF

!ifdef RESOURCE_ONLY_DLL
# Resource only DLL's have no exports, no entrypoint, no code, no data, no debug symbolic.
LINKER_DBG_SECTION=-debug:NONE
NO_DLL_EXPORTS=1
!undef NTBBT
!undef DLLENTRY
!undef NOLINK
NO_BROWSER_FILE=1
LINK_NO_RELEASE=1
MAKEDLL=1
TARGETLIBS=
LINKLIBS=
USE_NOLIBS=1
NO_NTDLL=1
AFX_FORCE_STDAFX=
AFX_FORCE_USRDLL=
MFC_LIBS=
!else
LINKER_DBG_SECTION=-debug
AFX_FORCE_STDAFX=/include:__afxForceSTDAFX
AFX_FORCE_USRDLL=/include:__afxForceUSRDLL
!endif

!ifdef PURE_FORWARDER_DLL
BUFFER_OVERFLOW_CHECKS=0
USE_NOLIBS=1
NO_NTDLL=1
TARGETLIBS=
!endif

!ifdef DEPRECATE_DDK_FUNCTIONS
C_DEFINES=$(C_DEFINES) -DDEPRECATE_DDK_FUNCTIONS
!endif

!IFNDEF TARGETPATH
! ERROR Your .\sources. file must define the TARGETPATH= macro
!ENDIF

!if "$(TARGETPATH)" == "obj" || "$(TARGETPATH)" == "OBJ"
TARGETPATH=$(_OBJ_DIR)
!endif

!if "$(TARGETPATHLIB)" == "obj" || "$(TARGETPATHLIB)" == "OBJ"
TARGETPATHLIB=$(_OBJ_DIR)
!endif

!ifdef TARGETPATHLIB
! if ("$(TARGETTYPE)" == "DYNLINK") || ("$(TARGETTYPE)" == "EXPORT_DRIVER")
!  if "$(MAKEDLL)" == ""
# Pass 1 of a two pass build.  Make sure TargetPath is the same as targetpathlib.
NO_BROWSER_FILE=1
TARGETPATH=$(TARGETPATHLIB)
!  endif
! endif
!else
TARGETPATHLIB=$(TARGETPATH)
!endif

!IF ("$(TARGETPATH)" == "$(BASEDIR)\lib") || ("$(TARGETPATH)" == "$(BASEDIR)\LIB")
!  ERROR Setting TARGETPATH= $(BASEDIR)\lib in .\sources is not valid - please use obj.
!ENDIF

!IFNDEF TARGETTYPE
! ERROR Your .\sources. file must define the TARGETTYPE= macro
!ENDIF

!IFNDEF TARGETNAME
! IF "$(TARGETTYPE)" != "NOTARGET"
!  ERROR Your .\sources. file must define the TARGETNAME= macro
! ELSE
TARGETNAME=
! ENDIF
!ENDIF

!IFNDEF SOURCES
! ERROR Your .\sources. file must define the SOURCES= macro
!ENDIF

!ifndef COFFBASE_TXT_FILE
COFFBASE_TXT_FILE = $(NTMAKEENV)\coffbase.txt
!endif

!IFNDEF UMBASE
! IFDEF COFFBASE
UMBASE=@$(COFFBASE_TXT_FILE),$(COFFBASE)
! ELSE
!  if $(WIN64)
!    if $(AMD64)
UMBASE=@$(COFFBASE_TXT_FILE),usermode64
!    else
#     Enable this for IA64 too
UMBASE=@$(COFFBASE_TXT_FILE),usermode
!    endif
!  else
UMBASE=@$(COFFBASE_TXT_FILE),usermode
!  endif
! ENDIF
!ENDIF

LINKLIBS=$(LINKLIBS) $(PERFLIBS)

!if !defined(ATL_VER) || ("$(ATL_VER)" == "10")
ATL_VER=21
!endif

!if "$(ATL_VER)" == "70"
! if defined(USE_ATL) || defined(USE_STATIC_ATL)
ATL_INCLUDES=$(ATL_INC_ROOT)\atlmfc71
ATL_DEFINES=/D_ATL_STATIC_REGISTRY
!  ifdef DEBUG_CRTS
ATL_LIBS=$(ATL_LIB_PATH)\atlsd.lib
!  else
ATL_LIBS=$(ATL_LIB_PATH)\atls.lib
!  endif
ATL_LIBS=$(ATL_LIBS) $(ADDITIONAL_ATL_LIBS)
BUFFER_OVERFLOW_CHECKS=1
! endif
!else
! if defined(USE_ATL)
ATL_INCLUDES=$(ATL_INC_ROOT)\atl$(ATL_VER)
ATL_DEFINES=/D_ATL_DLL
!  if "$(ATL_VER)" == "10"
ATL_LIBS=
!  else
ATL_LIBS=$(ATL_LIB_PATH)\atl.lib $(ADDITIONAL_ATL_LIBS)
!  endif
! elseif defined(USE_STATIC_ATL)
ATL_INCLUDES=$(ATL_INC_ROOT)\atl$(ATL_VER)
ATL_LIBS=$(ADDITIONAL_ATL_LIBS)
ATL_DEFINES=/D_ATL_STATIC_REGISTRY
! endif
!endif

!if !defined(WTL_VER)
WTL_VER=10
!endif

!if defined(USE_WTL)
!ifdef WTL_INC_PATH
WTL_INCLUDES=$(WTL_INC_PATH)\wtl$(WTL_VER)
!else
WTL_INCLUDES=$(SDK_INC_PATH)\wtl$(WTL_VER)
!endif
!endif

!IF DEFINED(USE_MFC) || DEFINED(USE_MFCUNICODE)

!if "$(PLATFORM_MFC_VER)" != "0x0600"
# MFC versions before 6.0 need NT4/Win95 values.  Override at your own risk.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0400
!endif
!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0300
!endif
!else   # MFC post 6x defaults to the current version of IE/Win2k.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
!endif
!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)
!endif
!endif

!ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0400
!endif

!ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0300
!endif

#---------------------------------------------------------#
# this set of defines establishes the "correct" build     #
# environment for an app that needs to use MFC.  the      #
# app's sources file only needs to specify USE_MFC=1      #
# and this makefile will set the enviroment up correctly. #
#---------------------------------------------------------#

! ifndef UMENTRY
!  ifdef USE_MFCUNICODE
UMENTRY=wwinmain
!  else
UMENTRY=winmain
!  endif
! endif

! if "$(TARGETTYPE)" == "DYNLINK" && !defined(RESOURCE_ONLY_DLL)
!  ifndef DLLENTRY
DLLENTRY=_DllMainCRTStartup
!  endif
! endif

! ifndef UMTYPE
UMTYPE=windows
! endif

UMENTRYABS=

# Allow other MFC's.
#  To do so, you need to:
#    1. Define MFC_INCLUDES to point to your MFC headers.
#    2. Define MFC_LIBS to point to your MFC libraries (specifically, the dll
#       library)
#    3. Define USE_MSVCRT=1 if you don't want to link with the NT CRT DLL.
#
#  Note:
#     There is only one type of build (_AFXDLL or MFC in a DLL linking to the
#     CRT in a dll).
#     You should disable the alternate MFC's if compiling for RISC platforms.
#     You need to handle specifying the correct libs for Check/Free and
#     Ansi/Unicode.

! if !defined(USE_MSVCRT) && !defined(USE_NOLIBS) && !defined(USE_MSVCRT40)
!  if defined(USE_STATIC_MFC)
USE_LIBCMT=1
!  else
USE_CRTDLL=1
!  endif
! endif

# Add MFC_FLAGS in just in case there's old sources files that use it.

MFC_DEFINES=$(MFC_DEFINES) $(MFC_FLAGS) -D_AFX_NOFORCE_LIBS -D_MFC_VER=$(PLATFORM_MFC_VER)

! ifdef DEBUG_CRTS
MFC_DEFINES=$(MFC_DEFINES) -D_AFX_ENABLE_INLINES
! endif

! IFDEF USE_MFCUNICODE
MFC_DEFINES=$(MFC_DEFINES) -DUNICODE -D_UNICODE
! ENDIF

# Assume Latest MFC (4.0 for now)

! ifndef USE_STATIC_MFC
MFC_DEFINES=$(MFC_DEFINES) -D_AFXDLL
LINKER_FLAGS = $(LINKER_FLAGS) $(AFX_FORCE_STDAFX)
! endif
! ifdef MFC_USRDLL
MFC_DEFINES=$(MFC_DEFINES) -D_USRDLL
LINKER_FLAGS = $(LINKER_FLAGS) $(AFX_FORCE_USRDLL)
! endif

# MFC 4 uses Native EH only

!ifndef USE_NATIVE_EH
USE_NATIVE_EH=1
!endif
USE_RTTI=1

# UNICODE must use the UNICODE entrypoint

! ifdef USE_MFCUNICODE
!  if "$(UMENTRY)" == "winmain"
UMENTRY = wwinmain
!  else if "$(UMENTRY)" == "main"
UMENTRY = wmain
!  endif
! endif

! ifndef MFC_VER
MFC_VER=42
! else if "$(MFC_VER)" == "40" && !defined(USE_STATIC_MFC)
!undef USE_MSVCRT
!undef USE_CRTDLL
USE_MSVCRT40=1
! endif

!ifndef MFC_INC_PATH
MFC_INC_PATH=$(MFC_INC_ROOT)\mfc$(MFC_VER)
!endif

! ifndef MFC_DAO_INC
MFC_DAO_INC=$(MFC_INC_ROOT)\dao350
! endif

! ifndef MFC_INCLUDES
MFC_INCLUDES=$(MFC_INC_PATH);$(MFC_DAO_INC)
!  ifdef MFC_LANGUAGE
MFC_INCLUDES=$(MFC_INC_PATH)\l.$(MFC_LANGUAGE);$(MFC_INCLUDES)
!  endif
! endif

! ifndef MFC_LIBS
!  ifdef USE_STATIC_MFC

!   ifdef DEBUG_CRTS
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\uafxcwd.lib
!    else
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\nafxcwd.lib
!    endif
!   else
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\uafxcw.lib
!    else
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\nafxcw.lib
!    endif
!   endif

!  else                # USE_STATIC_MFC

!   ifdef DEBUG_CRTS
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)ud.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)ud.lib  \
         $(MFC_LIB_PATH)\mfcd$(MFC_VER)ud.lib \
         $(MFC_LIB_PATH)\mfcn$(MFC_VER)ud.lib \
         $(MFC_LIB_PATH)\mfco$(MFC_VER)ud.lib
!    else
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)d.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)d.lib  \
         $(MFC_LIB_PATH)\mfcd$(MFC_VER)d.lib \
         $(MFC_LIB_PATH)\mfcn$(MFC_VER)d.lib \
         $(MFC_LIB_PATH)\mfco$(MFC_VER)d.lib
!    endif
!   else
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)u.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)u.lib
!    else
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER).lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER).lib
!    endif
!   endif
MFC_LIBS=$(MFC_STATIC_LIB) $(MFC_LIBS)

!  endif               # USE_STATIC_MFC
! endif                # MFC_LIBS
!endif                 # USE_MFC

!IFNDEF UMTYPE
!if "$(TARGETTYPE)" == "DYNLINK"
UMTYPE=console
!ifndef SUBSYSTEM_VERSION
SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSION_CURRENT)
!endif
!else
UMTYPE=nt
!endif
!ENDIF

!ifdef USE_MFC30
LIBC_DEFINES=
!else
! ifdef DEBUG_CRTS
DCRT=d
LIBC_DEFINES = -D_DEBUG
! else
DCRT=
LIBC_DEFINES = -DNDEBUG
! endif
!endif

# MSVCRT20==MSVCRT40==CRTDLL==MSVCRT
!if defined(USE_MSVCRT20)
USE_MSVCRT=1
! undef USE_MSVCRT20
!elseif defined(USE_MSVCRT40)
USE_MSVCRT=1
! undef USE_MSVCRT40
!elseif defined(USE_CRTDLL)
USE_MSVCRT=1
! undef USE_CRTDLL
!endif

#
# cl.exe now always defines _MT.  If a single-threaded CRT is needed,
#   the appropriate switches to undefined _MT will go into CRT_BUILD_FLAGS (/MT /D_MT).
#   Note: they don't go in LIBC_DEFINES because rc.exe can't handle /MT.
#

!if defined(USE_CRTDLL) || defined(USE_MSVCRT)

! if !$(MPPC)
LIBC_LIB=$(CRT_LIB_PATH)\msvcrt$(DCRT).lib
!  if defined(USE_IOSTREAM)
LIBC_LIB=$(LIBC_LIB) $(CRT_LIB_PATH)\msvcirt$(DCRT).lib
!  endif
!  if defined(USE_STL)
LIBC_LIB=$(LIBC_LIB) $(CRT_LIB_PATH)\msvcprt$(DCRT).lib
!  endif
LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1 -D_MT=1
! endif

!elseif defined(USE_IERT)
! ERROR USE_IERT is no longer supported.  Switch to USE_LIBCMT or USE_MSVCRT.
!elseif defined(USE_LIBCMT)

LIBC_LIB=$(CRT_LIB_PATH)\libcmt$(DCRT).lib
! if defined(USE_IOSTREAM)
LIBC_LIB=$(CRT_LIB_PATH)\libcimt$(DCRT).lib $(LIBC_LIB)
! endif
! if defined(USE_STL)
LIBC_LIB=$(CRT_LIB_PATH)\libcpmt$(DCRT).lib $(LIBC_LIB)
! endif
LIBC_DEFINES=$(LIBC_DEFINES) -D_MT=1

!elseif defined(USE_LIBCNTPR)

LIBC_LIB=$(SDK_LIB_PATH)\libcntpr.lib
CRT_BUILD_FLAGS=/MT /U_MT

!elseif (defined(USE_NTDLL) || \
       "$(TARGETTYPE)" == "DRIVER" || \
       "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
       defined(USE_SYSDLL) )

LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1
LIBC_LIB=

!elseif defined(USE_NOLIBS) || \
       "$(TARGETTYPE)" == "HAL" || \
       "$(TARGETTYPE)" == "GDI_DRIVER"

NO_NTDLL=1
LIBC_LIB=

!elseif defined(USE_MSVCRT20)

LIBC_LIB=$(CRT_LIB_PATH)\msvcrt2$(DCRT).lib
LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1 -D_MT=1

!elseif defined(USE_MSVCRT40)

LIBC_LIB=$(CRT_LIB_PATH)\msvcrt4$(DCRT).lib
LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1 -D_MT=1

!else

LIBC_LIB=$(CRT_LIB_PATH)\libc$(DCRT).lib
CRT_BUILD_FLAGS=/MT /U_MT
! if defined(USE_IOSTREAM)
LIBC_LIB=$(CRT_LIB_PATH)\libci$(DCRT).lib $(LIBC_LIB)
! endif
! if defined(USE_STL)
LIBC_LIB=$(CRT_LIB_PATH)\libcp$(DCRT).lib $(LIBC_LIB)
! endif

!endif

!if defined(USE_VCCOM)
LIBC_LIB = $(SDK_LIB_PATH)\vccomsup.lib $(LIBC_LIB)
!endif

!IFNDEF GPSIZE
GPSIZE= 0
!ENDIF

!ifdef NTLIBPATH
LIBRARY_PATH = $(NTLIBPATH)\*\lib
!else
LIBRARY_PATH = $(SDK_LIB_PATH)
!endif

!if defined(USE_MFC) ||  defined(USE_MFCUNICODE)
LIBC_LIB = $(MFC_LIBS) $(LIBC_LIB)
!endif

!if defined(USE_ATL) || defined(USE_STATIC_ATL)
LIBC_LIB = $(LIBC_LIB) $(ATL_LIBS)
# Piggy back on MFC_DEFINES for now.
MFC_DEFINES = $(MFC_DEFINES) $(ATL_DEFINES)
!endif

!if $(386) && defined(USE_MSLU)
# MSLU goes after MFC/ATL/CRT but before everything else
LIBC_LIB = $(LIBC_LIB) $(SDK_LIB_PATH)\unicows.lib
!endif

NT_LIBS=$(LIBRARY_PATH)\ntdll.lib
GUI32_LIBS=$(LIBRARY_PATH)\gdi32.lib \
           $(LIBRARY_PATH)\user32.lib

NT_CRT=$(LIBRARY_PATH)\nt.lib
WIN32_LIBS=$(LIBC_LIB) \
           $(LIBRARY_PATH)\advapi32.lib \
           $(LIBRARY_PATH)\kernel32.lib

NTSS_LIBS=$(NT_LIBS) $(NT_CRT) $(BASE_LIB_PATH)\smdll.lib

OS2_LIBS=$(NT_LIBS)  $(SDK_LIB_PATH)\os2dll.lib

!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
# Building a WDM driver.  Default the subsystem version to the DDK version # (currently 1.0)
! ifndef SUBSYSTEM_VERSION
SUBSYSTEM_VERSION=1.10
! endif
!endif

!ifndef SUBSYSTEM_VERSION
! ifndef EXPECTED_WINVER
SUBSYSTEM_WINVER   = ,4.00
! else
SUBSYSTEM_WINVER   = ,$(EXPECTED_WINVER)
! endif
SUBSYSTEM_CONVER   = ,4.00
SUBSYSTEM_OS2VER   =
SUBSYSTEM_NATVER   =,$(SUBSYSTEM_VERSION_LATEST)
!else
SUBSYSTEM_WINVER   = ,$(SUBSYSTEM_VERSION)
SUBSYSTEM_CONVER   = ,$(SUBSYSTEM_VERSION)
SUBSYSTEM_OS2VER   = ,$(SUBSYSTEM_VERSION)
SUBSYSTEM_NATVER   = ,$(SUBSYSTEM_VERSION)

# Set the appropriate default WIN32_xxxxx values

! if "$(SUBSYSTEM_VERSION)" == "4.00"
!  ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0400
!  endif
!  ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0400
!  endif
!  ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0400
!  endif
!  ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0300
!  endif
! elseif "$(SUBSYSTEM_VERSION)" == "3.51"
!  ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0351
!  endif
!  ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0300
!  endif
!  ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0300
!  endif
!  ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0200
!  endif
!  ifndef WINVER_VERSION
WINVER_VERSION=0x0400            # Special case - WINVER was 4.00 for NT 3.51
!  endif
! elseif "$(SUBSYSTEM_VERSION)" == "3.50"
!  ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0350
!  endif
!  ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0300
!  endif
!  ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0300
!  endif
!  ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0100
!  endif
!  ifndef WINVER_VERSION
WINVER_VERSION=0x0400            # Special case - WINVER was 4.00 for NT 3.50
!  endif
! endif
!endif

CRT_INCLUDES=$(CRT_INC_PATH)
!ifdef USE_IOSTREAM
CRT_INCLUDES=$(CRT_INCLUDES);$(IOSTREAMS_INC_PATH)
!endif
!ifdef USE_STL
CRT_INCLUDES=$(CRT_INCLUDES);$(STL6_INC_PATH)
!endif

!IF "$(UMTYPE)" == "nt"

SUBSYSTEM=native$(SUBSYSTEM_NATVER)
UMINCL=$(CRT_INCLUDES)

STD_CALL_ENTRY=1
UMENTRY=-entry:NtProcessStartup

UMLIBS=$(UMLIBS) $(NT_LIBS) $(NT_CRT)
NOT_TERMINAL_SERVER_AWARE=1

!ELSEIF "$(UMTYPE)" == "windows"

SUBSYSTEM=windows$(SUBSYSTEM_WINVER)
UMINCL=$(CRT_INCLUDES)

! IF "$(UMENTRY)" == "winmain"
UMENTRY=-entry:WinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wwinmain"
UMENTRY=-entry:wWinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wmain"
UMENTRY=-entry:wmainCRTStartup
! ELSEIF "$(UMENTRYABS)" == ""
UMENTRY=-entry:mainCRTStartup
! ELSE
UMENTRY=-entry:$(UMENTRYABS)
! ENDIF

UMLIBS=$(UMLIBS) $(WIN32_LIBS) $(GUI32_LIBS)

!ELSEIF "$(UMTYPE)" == "console"

SUBSYSTEM=console$(SUBSYSTEM_CONVER)
UMINCL=$(CRT_INCLUDES)

! IF "$(UMENTRY)" == "winmain"
UMENTRY=-entry:WinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wwinmain"
UMENTRY=-entry:wWinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wmain"
UMENTRY=-entry:wmainCRTStartup
! ELSEIF "$(UMENTRYABS)" == ""
UMENTRY=-entry:mainCRTStartup
! ELSE
UMENTRY=-entry:$(UMENTRYABS)
! ENDIF

!IF !$(MPPC)
UMLIBS=$(UMLIBS) $(WIN32_LIBS)
!ENDIF

!ELSEIF "$(UMTYPE)" == "ntss"

SUBSYSTEM=native$(SUBSYSTEM_NATVER)
UMINCL=$(CRT_INCLUDES)

STD_CALL_ENTRY=1
UMENTRY=-entry:NtProcessStartup
NOT_TERMINAL_SERVER_AWARE=1

!IF !$(MPPC)
UMLIBS=$(UMLIBS) $(NTSS_LIBS)
!ENDIF

!ELSEIF "$(UMTYPE)" == "os2"

SUBSYSTEM=os2$(SUBSYSTEM_OS2VER)
UMINCL=$(SDK_INC_PATH)\os2;$(CRT_INCLUDES)

STD_CALL_ENTRY=1
UMENTRY=-entry:NtProcessStartup
NOT_TERMINAL_SERVER_AWARE=1

UMLIBS=$(UMLIBS) $(OS2_LIBS)

!ELSE
! ERROR Invalid UMTYPE value - $(UMTYPE)
!ENDIF  # UMTYPE tests


#
# If you edit this line you need to modify $(BASEDIR)\sdktools\build\build.c
#

NTINCLUDES=$(OAK_INC_PATH);$(SDK_INC_PATH)

#
# Let drivers include files such as ntddk.h.
# WDM drivers\libs can only include wdm.h type of files though ...
# DDK_INC_PATH must be first for precedence.
#
!IF "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
NTINCLUDES=$(NTINCLUDES);$(WDM_INC_PATH)
!ELSEIF "$(DRIVERTYPE)" == "fs" || "$(DRIVERTYPE)" == "FS"
NTINCLUDES=$(NTINCLUDES);$(DDK_INC_PATH);$(IFSKIT_INC_PATH)
!ELSEIF "$(TARGETTYPE)" == "DRIVER"        || \
        "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
        "$(TARGETTYPE)" == "MINIPORT"      || \
        "$(TARGETTYPE)" == "DRIVER_LIBRARY"
NTINCLUDES=$(NTINCLUDES);$(DDK_INC_PATH);$(WDM_INC_PATH)
!ENDIF

#
# Add Windows Driver Framework inc if it is a WDF driver
#
!IF DEFINED(USE_WDF_DYNAMIC) || defined(USE_WDF_STATIC)
NTINCLUDES=$(NTINCLUDES);$(WDF_ROOT)\inc
!ENDIF

!IFNDEF CBSTRING
! IF "$(MAJORCOMP)" == "ntos" || \
     "$(MAJORCOMP)" == "NTOS" || \
     "$(TARGETTYPE)" == "DRIVER"         || \
     "$(TARGETTYPE)" == "DRIVER_LIBRARY" || \
     "$(TARGETTYPE)" == "GDI_DRIVER"     || \
     "$(TARGETTYPE)" == "HAL"            || \
     "$(TARGETTYPE)" == "EXPORT_DRIVER"  || \
     "$(TARGETTYPE)" == "MINIPORT"
!    IF "$(DRIVERTYPE)" != "VXD"
CBSTRING= -cbstring
!    ENDIF
! ELSE
CBSTRING=
! ENDIF
!ENDIF


!if "$(TARGETTYPE)" == "DRIVER_LIBRARY"
TARGETTYPE=LIBRARY
!endif

#
#  Add PROJECT_INC_PATH to NTINCLUDES, if NO_PRIVATE_INC is not set
#
!IFDEF PROJECT_INC_PATH
! IFNDEF NO_PRIVATE_INC
NTINCLUDES=$(PROJECT_ROOT)\inc;$(PROJECT_ROOT)\inc\$(O);$(PROJECT_INC_PATH);$(NTINCLUDES)
! ENDIF
!ENDIF

NTINCLUDES=$(O);$(NTINCLUDES)

!IFDEF INCLUDES_FROM
! IF [process-includes-from $(INCLUDES_FROM) >__makefile.def.tmp]
! ENDIF
! INCLUDE __makefile.def.tmp
! IF [del __makefile.def.tmp >nul 2>nul]
! ENDIF
!ENDIF

!IFDEF LIBS_FROM
! IF [process-libs-from $(LIBS_FROM) >__makefile.def.tmp]
! ENDIF
! INCLUDE __makefile.def.tmp
! IF [del __makefile.def.tmp >nul 2>nul]
! ENDIF
!ENDIF

!if "$(POCKETPC)" == ""
!IFNDEF COMPILER_WARNINGS
COMPILER_WARNINGS=-FI$(SDK_INC_PATH)\warning.h $(PROJECT_COMPILER_WARNINGS)
!ifdef USE_LINT
LINT_FORCEDINCS=$(LINT_FORCEDINCS) -header($(SDK_INC_PATH)\warning.h)
!endif
!ENDIF
!endif

# If you change this to 600, fix MIDL_OPTIMIZATION default below.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
!endif

!ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=$(LATEST_WIN32_WIN95_VERSION)
!endif

!ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=$(LATEST_WIN32_WCE_VERSION)
!endif

!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)
!endif

!ifndef WINVER_VERSION
!if defined(CHICAGO_PRODUCT)
WINVER_VERSION=$(WIN32_WIN95_VERSION)
!elseif defined(POCKETPC)
WINVER_VERSION=$(WIN32_WCE_VERSION)
!else
WINVER_VERSION=$(WIN32_WINNT_VERSION)
!endif
!endif

!ifdef UNDEF_WINVER
_WINVER_VERSION=/UWINVER
!else
_WINVER_VERSION=/DWINVER=$(WINVER_VERSION)
!endif

!IF defined(POCKETPC)

NO_NTDLL=1
! IFNDEF WIN32_DEFINE
WIN32_DEFINE=-DWIN32=300 -D_WIN32_WCE=$(WIN32_WCE_VERSION) $(_WINVER_VERSION)
!  if "$(POCKETPC_EMULATION)" != ""
WIN32_DEFINE = $(WIN32_DEFINE) -D_WIN32_WCE_EMULATION
!  endif
! ENDIF

!ELSEIF defined(CHICAGO_PRODUCT)

NO_NTDLL=1
! IFNDEF WIN32_DEFINE
WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=$(WIN32_WIN95_VERSION) $(_WINVER_VERSION)
! ENDIF

!ELSEIF $(MPPC)

! IFNDEF MAC_INCLUDES
MAC_INCLUDES=$(BASEDIR)\com\macdcom\dll\src\inc
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)\mppc
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)\mppc\macos
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)\mppc\mrc
! ENDIF

NTINCLUDES= $(MAC_INCLUDES);$(NTINCLUDES)

NO_NTDLL=1
WIN32_DEFINE=-DPOWERMAC=1

!ELSE

WIN32_DEFINE=-DWIN32=100 -D_NT1X_=100 -DWINNT=1 -D_WIN32_WINNT=$(WIN32_WINNT_VERSION) $(_WINVER_VERSION)

!ENDIF

WIN32_DEFINE = $(WIN32_DEFINE) -D_WIN32_IE=$(WIN32_IE_VERSION)

INCLUDES     = $(INCLUDES: =)
NTINCLUDES   = $(NTINCLUDES: =)
UMINCL       = $(UMINCL: =)
MFC_INCLUDES = $(MFC_INCLUDES: =)
USER_INCLUDES =$(USER_INCLUDES: =)
ATL_INCLUDES = $(ATL_INCLUDES: =)
WTL_INCLUDES = $(WTL_INCLUDES: =)

# MFC, ATL, WTL, and USER first

INCPATH0=-I$(MFC_INCLUDES:;= -I) -I$(ATL_INCLUDES:;= -I) -I$(WTL_INCLUDES:;= -I) -I$(USER_INCLUDES:;= -I)
INCPATH1=-I$(MFC_INCLUDES:;= -I) -I$(ATL_INCLUDES:;= -I) -I$(WTL_INCLUDES:;= -I) -I$(USER_INCLUDES:;= -I)

# INCLUDES if set

!ifdef INCLUDES
INCPATH0 = $(INCPATH0) -I$(INCLUDES:;= -I)
INCPATH1 = $(INCPATH1) -I$(INCLUDES:;= -I)
!endif

# Finally NT and UM

INCPATH0=$(INCPATH0) -I$(NTINCLUDES:;= -I) -I$(UMINCL:;= -I)
INCPATH1=$(INCPATH1) -I$(NTINCLUDES:;= -I) -I$(UMINCL:;= -I)

# Remove empty "-I " settings (INCL/NTINCLUDES/UMINCL/MFC_INCLUDES macros may be empty above)

INCPATH0=$(INCPATH0:-I =)
INCPATH1=$(INCPATH1:-I =)
!ifdef USE_LINT
LINT_INCLUDES=-i$(TARGET_DIRECTORY)\ -i. $(LINT_PRECOMPPATH) $(INCPATH1:-I=-i)
!endif

!IFNDEF DLLENTRY
DLLENTRY=-noentry
!ELSE
! if "$(DLLENTRY:-entry:=)" == "$(DLLENTRY)"
DLLENTRY=-entry:$(DLLENTRY)
! endif
!ENDIF

!IF $(MPPC)
DLLENTRY=-noentry
!ENDIF

!IFNDEF DLLBASE
! IFDEF COFFBASE
DLLBASE=@$(COFFBASE_TXT_FILE),$(COFFBASE)
! ELSE
DLLBASE=@$(COFFBASE_TXT_FILE),$(TARGETNAME)
! ENDIF
!ENDIF

!IFNDEF DLLDEF
DLLDEF=$(@B).def
!ENDIF

!IFNDEF BOOTBASE
! IFDEF FRAZZLE
BOOTBASE=0xd0100000,0xd0104000
! ELSE
BOOTBASE=0xd0ff0000,0xd0ff4000
! ENDIF
!ENDIF

!IFNDEF DRIVERBASE
DRIVERBASE=0x10000
!ENDIF

!IFNDEF HALBASE
HALBASE=0x80010000
!ENDIF

!if "$(URTBASE)" != ""
# Allow 1.1 or 2.0 - default to 1.0 if nothing (or unknown).
!if "$(URT_VER)" == "1.1"
COMPLUS_VERSION=$(URT_VER_1_1)
!elseif "$(URT_VER)" == "2.0"
COMPLUS_VERSION=$(URT_VER_2_0)
!else
COMPLUS_VERSION=$(URT_VER_1_0)
!endif

URTTARGET=$(URTBASE)\urt\$(COMPLUS_VERSION)
PATH=$(PATH);$(URTTARGET)

# Do this even if we're not building managed code so dirs w/o MANAGED_xxx set can still use resgen/al/etc.
!if [set path=$(PATH)]
!endif
!endif

!if (defined(MANAGED_CODE) || defined(MANAGED_VB) || defined(MANAGED_CXX))

#
# If there's a different path for the managed compiler, use it.
#

! if defined(MANAGED_TOOL_PATH)
PATH=$(MANAGED_TOOL_PATH);$(PATH)
! endif

! if [set path=$(PATH)]
! endif

VC7_SYMBOLS=1
#
# The managed compilers emits comdat'd debug symbols that aren't related to anything else - if
# opt:ref is used, you can't effectively debug your code (yeah it's a lame bug).
#
LINKER_NOREF=1
!endif

!if (defined(MANAGED_CODE) || defined(MANAGED_VB))
#
# Figure out the target type if the user didn't specify.
#

! if !defined(MANAGED_TARGET_TYPE)
!  if "$(TARGETTYPE)" == "PROGRAM"
!   if "$(UMTYPE)" != "console"
MANAGED_TARGET_TYPE=winexe
!   else
MANAGED_TARGET_TYPE=exe
!   endif
!  elseif "$(TARGETTYPE)" == "DYNLINK"
MANAGED_TARGET_TYPE=library
!  endif
! endif

#
# tlbimp doesn't support /baseaddress - dummy up rebase_cmd so it can be called in makefile.inc
#

REBASE_CMD=rebase.exe -i $(COFFBASE_TXT_FILE) $@

#
# Generate a macro file to include for managed code base address
#

! if !defined(GENBASEMAC_CMD)
GENBASEMAC_CMD=$(_NTBINDIR)\tools\genbasemac.pl
! endif
! if "$(GENBASEMAC_CMD)"!=""
!    if !exist($(GENBASEMAC_CMD))
!     message NMAKE : Uxxxx: unable to find $(GENBASEMAC_CMD)
!    endif
!    message BUILD: $(GENBASEMAC_CMD) $(O) $(TARGETNAME) $(COFFBASE_TXT_FILE)
!    IF ([-perl $(GENBASEMAC_CMD) $(O) $(TARGETNAME) $(COFFBASE_TXT_FILE)])
!    ENDIF
!    IF EXIST( $(O)\coffbase.mac )
!        INCLUDE $(O)\coffbase.mac
!    ELSE
MANAGED_COFFBASE=0x400000
!    ENDIF
! endif

#
# Build up list of referenced modules for c# compiler
#

! if "$(REFERENCES)" != ""
!  IF $(386)
REFERENCES=$(REFERENCES:*=I386)
!  ELSEIF $(IA64)
REFERENCES=$(REFERENCES:*=IA64)
!  elseif $(AMD64)
REFERENCES=$(REFERENCES:*=AMD64)
!  endif
REFERENCES=$(REFERENCES: =)
MANAGED_REFERENCES=/r:$(REFERENCES:;= /r:)
! endif

#
# Define the standard switches
#

!if $(FREEBUILD)
MANAGED_DBG_FLAGS=/optimize+ /debug:pdbonly
!else
!if defined(MANAGED_VB)
MANAGED_DBG_FLAGS=/debug:full /define:DEBUG=1
!else
MANAGED_DBG_FLAGS=/debug:full /define:DEBUG
!endif
!endif

!if "$(MANAGED_RESOURCES)" != ""
MANAGED_RESOURCES=$(MANAGED_RESOURCES: =)
MANAGED_RESOURCES=/resource:$(MANAGED_RESOURCES:;= /resource:)
!endif

MANAGED_CODE_BUILD_TOOL= \
!if defined(MANAGED_VB)
    $(VB_NET_COMPILER_NAME)
!else
    $(CS_COMPILER_NAME)
!endif

MANAGED_CODE_DEFAULT_REFERENCES= \
    /r:Accessibility.dll \
    /r:Microsoft.Vsa.dll \
    /r:System.Configuration.Install.dll \
    /r:System.Data.dll \
    /r:System.Design.dll \
    /r:System.DirectoryServices.dll \
    /r:System.dll \
    /r:System.Drawing.Design.dll \
    /r:System.Drawing.dll \
    /r:System.EnterpriseServices.dll \
    /r:System.Management.dll \
    /r:System.Messaging.dll \
    /r:System.Runtime.Remoting.dll \
    /r:System.Runtime.Serialization.Formatters.Soap.dll \
    /r:System.Security.dll \
    /r:System.ServiceProcess.dll \
    /r:System.Web.dll \
    /r:System.Web.RegularExpressions.dll \
    /r:System.Web.Services.dll \
    /r:System.Windows.Forms.Dll \
    /r:System.XML.dll

MANAGED_CODE_BUILD_SWITCHES= \
    $(MANAGED_CODE_DEFAULT_REFERENCES) \
    /target:$(MANAGED_TARGET_TYPE) \
    /out:$(TARGET) \
    /baseaddress:$(MANAGED_COFFBASE) \
    $(MANAGED_STD_FLAGS) \
    $(MANAGED_REFERENCES) \
    $(MANAGED_RESOURCES)

MANAGED_CODE_BUILD_CMD = \
    $(MANAGED_CODE_BUILD_TOOL) \
    $(MANAGED_CODE_BUILD_SWITCHES) \
    $(SOURCES)

REFERENCE_DIR=$(PROJECT_ROOT)\Reference\$(TARGET_DIRECTORY)

! IF "$(SERVICEBASE)" == ""
SERVICEBASE=http://localhost
! ENDIF

#
# Managed code always defined MAKEDLL (it's a single pass build after all).
#

MAKEDLL=1

!endif		# MANAGED_CODE || MANAGED_VB

#
# Map lower case to upper case for variables that can be specified from the
# command line.
#

!IFDEF nttest
NTTEST=$(nttest)
!ENDIF

!IFDEF makedll
MAKEDLL=$(makedll)
!ENDIF

#
# Include the list of object files (defined as the OBJECTS macro) that was
# built by BUILD program, using the SOURCES= macro defined in the sources.
# file.  Use macro substitution to build the supported target objects.
#

!if !exist($(_OBJ_DIR)\_objects.mac)
!if [-build -O]
!endif
!endif

!if "$(BINPLACE_LOG)" != ""
!if [-mkdir $(BINPLACE_LOG)\.. > nul 2>&1]
!endif
!endif


!INCLUDE $(_OBJ_DIR)\_objects.mac

!IF $(386)
OBJECTS=$(386_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(386_DLLLIBOBJECTS)
!ELSEIF $(MPPC)
OBJECTS=$(MPPC_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(MPPC_DLLLIBOBJECTS)
!ELSEIF $(IA64)
OBJECTS=$(IA64_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(IA64_DLLLIBOBJECTS)
!ELSEIF $(AMD64)
OBJECTS=$(AMD64_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(AMD64_DLLLIBOBJECTS)
!ELSEIF $(ARM)
OBJECTS=$(ARM_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(ARM_DLLLIBOBJECTS)
!ENDIF

!ifdef MAC_RESOURCE
MAC_RESOURCE_OBJECT=$(_OBJ_DIR)\$(TARGET_DIRECTORY)\$(MAC_RESOURCE:.r=.rsc)
OBJECTS=$(OBJECTS) $(MAC_RESOURCE_OBJECT)
!endif

#
# BUILD.EXE defines the NOLINK variable to disable the building of any
# test executables when it is recursing on a dirs. file to build components
# in subdirectories.
#

!IF "$(BUILDMSG)" != "Stop."
! IFDEF NOLINK
!  UNDEF NTTEST
!  UNDEF MAKEDLL
! ELSE
!  IFDEF nolink
!   UNDEF NTTEST
!   UNDEF MAKEDLL
!  ENDIF
! ENDIF # DEF NOLINK
!ENDIF # BUILDMSG != "Stop."

!IF (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
DYNLINK_LIB=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
DYNLINK_LIBDIR=$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
!ENDIF

!IF "$(TARGETNAMEP)" != ""
DYNLINK_LIBP=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAMEP).lib
DYNLINK_LIBPDIR=$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\$(TARGETNAMEP).lib
!ENDIF

!IF !$(MPPC)
DYNLINK_EXP=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp
!ENDIF

#
# Determine type of target link we are doing
#
!IF "$(TARGETTYPE)" == "PROGLIB"
!  IF "$(TARGETEXT)" == ""
TARGETEXT=exe
!endif
TARGETLIB=
!ELSEIF "$(TARGETTYPE)" == "PROGRAM"
!  IF "$(TARGETEXT)" == ""
TARGETEXT=exe
!endif
!ifdef USE_NTDLL
TARGETLIB=$(SDK_LIB_PATH)\ntdll.lib
!else
TARGETLIB=
!endif
!ELSEIF "$(TARGETTYPE)" == "DYNLINK"

! IF "$(MAKEDLL)" != ""
!  IF "$(TARGETNAME)" == "ntdll"
TARGETLIB=

!  ELSEIF defined (USE_NTDLL)           # USE_NTDLL never links with LIBC_LIB
TARGETLIB=$(WIN32DLL_LIBS) $(SDK_LIB_PATH)\ntdll.lib

!  ELSEIF defined (USE_SYSDLL)          # USE_SYSDLL uses either kernel32 (Win95) or ntdll (NT) for CRT support
!   if defined(CHICAGO_PRODUCT)
TARGETLIB=$(WIN32DLL_LIBS) $(SDK_LIB_PATH)\kernel32.lib
!   else
TARGETLIB=$(WIN32DLL_LIBS) $(SDK_LIB_PATH)\ntdll.lib
!   endif
!  ELSEIF defined (NO_NTDLL)            # NO_NTDLL never links with ntdll
TARGETLIB=$(WIN32DLL_LIBS) $(LIBC_LIB)

!  ELSE                                 # Everything else uses ntdll after libc.
TARGETLIB=$(WIN32DLL_LIBS) $(LIBC_LIB) $(SDK_LIB_PATH)\ntdll.lib

!  ENDIF
!  IF "$(TARGETEXT)" == ""
TARGETEXT=dll
!  ENDIF
! ELSE # "$(MAKEDLL)" != ""
TARGETEXT=lib
TARGETLIB=
! ENDIF # "$(MAKEDLL)" != ""

!ELSEIF "$(TARGETTYPE)" == "LIBRARY"
TARGETEXT=lib
TARGETLIB=

!ELSEIF "$(TARGETTYPE)" == "DRIVER"
TARGETEXT=sys
!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
TARGETLIB=$(DDK_LIB_PATH)\wdm.lib
!ELSEIF "$(DRIVERTYPE)" == "VXD"
TARGETEXT=vxd
!ELSE
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
!ENDIF

#
# Add Windows Driver Framework lib if it is a WDF driver
#
!IF DEFINED(USE_WDF_DYNAMIC)
TARGETLIB=$(TARGETLIB) \
          $(WDF_ROOT)\lib\*\WdfDynam.lib \
          $(WDF_ROOT)\lib\*\\WdfLdr.lib \
          $(WDF_ROOT)\lib\*\\WdfDriverEntry.lib \
          $(DDK_LIB_PATH)\wdmsec.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib 
!ELSEIF DEFINED(USE_WDF_STATIC)
TARGETLIB=$(TARGETLIB) \
          $(WDF_ROOT)\lib\*\WdfStatic.lib \
          $(DDK_LIB_PATH)\csq.lib \
          $(DDK_LIB_PATH)\wdmsec.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib 
!ENDIF

!ELSEIF "$(TARGETTYPE)" == "EXPORT_DRIVER"
! IF "$(MAKEDLL)" != ""
TARGETEXT=sys
!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
TARGETLIB=$(DDK_LIB_PATH)\wdm.lib
!ELSE
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
!ENDIF

#
# Add Windows Driver Framework lib if it is a WDF export driver
#
!IF DEFINED(USE_WDF_DYNAMIC)
TARGETLIB=$(TARGETLIB) \
          $(WDF_ROOT)\lib\*\WdfDynam.lib \
          $(WDF_ROOT)\lib\*\WdfLdr.lib \
          $(WDF_ROOT)\lib\*\WdfDriverEntry.lib \
          $(DDK_LIB_PATH)\wdmsec.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib 
!ELSEIF DEFINED(USE_WDF_STATIC)
TARGETLIB=$(TARGETLIB) \
          $(WDF_ROOT)\lib\*\WdfStatic.lib \
          $(DDK_LIB_PATH)\csq.lib \
          $(DDK_LIB_PATH)\wdmsec.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib 
!ENDIF

! ELSE
TARGETEXT=lib
TARGETLIB=
! ENDIF

!ELSEIF "$(TARGETTYPE)" == "HAL"
! IF "$(MAKEDLL)" != ""
TARGETEXT=dll
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib
! ELSE
TARGETEXT=lib
TARGETLIB=
! ENDIF

!ELSEIF "$(TARGETTYPE)" == "MINIPORT"
TARGETEXT=sys

!ELSEIF "$(TARGETTYPE)" == "GDI_DRIVER"

TARGETEXT=dll
TARGETLIB=$(DDK_LIB_PATH)\win32k.lib
!ifdef USE_LIBCNTPR_FOR_GDI_DRIVER_CRTS
TARGETLIB=$(SDK_LIB_PATH)\libcntpr.lib $(TARGETLIB)
!endif
!ENDIF # TARGETTYPE


TARGET=

!ifdef PASS1_NOLIB
!ifdef NTTARGETFILE1
USE_MAKEFILE_INC=1
!undef NTTARGETFILE1
!endif
!ifdef NTTARGETFILES
USE_MAKEFILE_INC=1
!undef NTTARGETFILES
!endif
!undef TARGETEXEFILES
!undef MISCFILES
!endif

!IF "$(TARGETTYPE)" != "UMAPPL_NOLIB" && !defined(PASS1_NOLIB)

! IF "$(OBJECTS)" != ""
TARGET=$(TARGETPATH)\*\$(TARGETNAME).$(TARGETEXT)
! ELSEIF "$(OBJLIBFILES)" != "" && "$(TARGETTYPE)" == "LIBRARY"
TARGET=$(TARGETPATH)\*\$(TARGETNAME).$(TARGETEXT)
! ENDIF

!ENDIF # TARGETTYPE != UMAPPL_NOLIB

!IFDEF NOTARGETLIB
TARGETLIB=
!ENDIF

!IFNDEF MACHINE_TARGETLIBS
MACHINE_TARGETLIBS=$(TARGETLIB) $(TARGETLIBS)
!ENDIF

!if (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
TARGETOBJFILES=$(TARGETOBJFILES) $(OBJECTS)
!ENDIF

!IF "$(NOLINK)" == "" ||                                     \
    ("$(NOLINK)" != "" && !defined(PASS1_NOLIB) && ("$(TARGETTYPE)"=="LIBRARY" ||     \
                        (   ("$(TARGETTYPE)"=="DYNLINK" ||   \
                         "$(TARGETTYPE)"=="PROGLIB" || \
                         "$(TARGETTYPE)"=="EXPORT_DRIVER" || \
                         "$(TARGETTYPE)"=="HAL")    &&       \
                            "$(MAKEDLL)" == "")              \
                           )                                 \
    )


! IF "$(NOLINK)" != "" && "$(TARGET)" != ""
!  ifndef NO_DLL_EXPORTS
TARGETLIBFILES=$(TARGETLIBFILES) $(TARGETPATH)\*\$(TARGETNAME).lib
!  endif
! ELSE
TARGETEXEFILES=$(TARGETEXEFILES) $(TARGET)
! ENDIF

!ENDIF # NOLINK == "" || building .lib file for dll

!if "$(UMAPPL)" == ""
# Turn off UMEXEFILES/UMOBJFILES (handles case where it's conditional in sources file
# and build doesn't realize it when generating _objects.mac).
UMEXEFILES=
UMOBJFILES=
!else
# Temporary - add old UMEXE/UMOBJFILES support until new build.exe prop's everywhere
! if !defined(UMEXEFILES) || !defined(UMOBJFILES)
UMOBJFILES=obj\*\$(UMAPPL:*=.obj obj\*\).obj
!  IFNDEF NOLINK
!   IF "$(UMAPPLEXT)" == ".com"
UMEXEFILES=obj\*\$(UMAPPL:*=.com obj\*\).com
!   ELSEIF "$(UMAPPLEXT)" == ".exe"
UMEXEFILES=obj\*\$(UMAPPL:*=.exe obj\*\).exe
!   ELSEIF "$(UMAPPLEXT)" == ".scr"
UMEXEFILES=obj\*\$(UMAPPL:*=.scr obj\*\).scr
!   ELSE
!    ERROR Unsupport UMAPPLEXT = $(UMAPPLEXT)
!   ENDIF
!  ENDIF
! endif
!endif

!IF "$(NTTEST)" != ""

TARGETOBJFILES=$(TARGETOBJFILES) $(O)\$(NTTEST).obj

! IFNDEF NOLINK

TARGETEXEFILES=$(TARGETEXEFILES) $(O)\$(NTTEST).exe

! ENDIF # NDEF NOLINK
!ENDIF # NTTEST != ""

!IFDEF USE_LINT
! IFNDEF LINT_OUTPUT
LINT_OUTPUT=$(TARGETNAME)
! ENDIF
! IFNDEF LINT_EXT
LINT_EXT=tmp
! ENDIF
! IF "$(LINT_TYPE)" == "all"
TARGETLOBFILES1=
TARGETLOBFILES2=$(O)\$(LINT_OUTPUT).$(LINT_EXT)
! ELSEIF "$(LINT_TYPE)" == "lob"
TARGETLOBFILES1=$(TARGETOBJFILES:.obj=.lob)
TARGETLOBFILES2=
! ELSE
TARGETLOBFILES1=
TARGETLOBFILES2=$(TARGETOBJFILES:.obj=.lob)
! ENDIF
!ELSE
TARGETLOBFILES1=
TARGETLOBFILES2=
!ENDIF

#
# Define NT_UP as 0 in environment to turn on MP.
# If undefined or equal to 1, you get UP.
#

!IFNDEF NT_UP
NT_UP=1
!ENDIF

!IF "$(NT_UP)"=="0"
NT_UP_DEFINES=
!ELSE
NT_UP_DEFINES=-DNT_UP=1
!ENDIF

!IFNDEF NT_INST
NT_INST=0
!ENDIF

#
# User defined variables (environment variables or command line).
# A cpu specific definition will take precedence over the MSC definition.
#
# xxx_WARNING_LEVEL
# xxx_OPTIMIZATION
# xxx_CPPFLAGS
#

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF

DEFAULT_MSC_OPT = /Oxs

#
# End of user defined variables.
#

STD_DEFINES=-DCONDITION_HANDLING=1 $(NT_UP_DEFINES) \
            -DNT_INST=$(NT_INST) $(WIN32_DEFINE) $(NT_PNP_POWER_DEFINES) \
            $(NT_PNP_STUB_DEFINES)

!IFNDEF NOT_LEAN_AND_MEAN
STD_DEFINES = $(STD_DEFINES) -DWIN32_LEAN_AND_MEAN=1
!ENDIF

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
TARGET_DBG_DEFINES= -DDEVL=1 -DDBG=1
!else
TARGET_DBG_DEFINES= -DDEVL=1
!endif

!if !defined(RESOURCE_ONLY_DLL) || \
    ("$(NTDEBUG)" == "ntsd") || \
    ("$(NTDEBUG)" == "ntsdnodbg") || \
    ("$(NTDEBUG)" == "cvp") || \
    ("$(NTDEBUG)" == "sym")
DBGFLAGS=/Zi
!else
DBGFLAGS=
!endif

!ifdef OFFICIAL_BUILD_MACHINE
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES) -DOFFICIAL_BUILD=1
!endif

!ifndef __BUILDMACHINE__
__BUILDMACHINE__=$(USERNAME: =)
!endif
!if exist ($(BASEDIR)\__blddate__)
!include $(BASEDIR)\__blddate__
!endif
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES)\
!ifdef BUILDDATE
    -D__BUILDDATE__=$(BUILDDATE)\
!endif
    -D__BUILDMACHINE__=$(__BUILDMACHINE__)

!IF "$(PRECOMPILED_OPTION)" == ""
! IF "$(PRECOMPILED_INCLUDE)" != ""
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.hxx=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.hpp=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.cxx=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.cpp=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_PCH)" == ""
PRECOMPILED_PCH=$(PRECOMPILED_INCLUDE:.hxx=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.hpp=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.h=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.cxx=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.cpp=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.c=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:..\=)
!  ENDIF
!  IF "$(PRECOMPILED_OBJ)" == ""
PRECOMPILED_OBJ=$(PRECOMPILED_PCH:.pch=.obj)
!  ENDIF
! ENDIF
!ENDIF

!IF "$(PRECOMPILED_OPTION)" == ""
! IF "$(PRECOMPILED_INCLUDE)" != ""
!  IF "$(PRECOMPILED_PCH)" != ""
HEADERFILE=/Fp$(O)\$(PRECOMPILED_PCH)
!  ENDIF
!  IF "$(PRECOMPILED_OBJ)" != ""
HEADEROBJNAME=$(O)\$(PRECOMPILED_OBJ)
HEADEROBJ=/Fo"$(MAKEDIR)\$(HEADEROBJNAME)"
!  ENDIF

!  IF !$(MPPC)
!   IF "$(PRECOMPILED_CXX)" == ""
PRECOMPILED=/Yu$(PRECOMPILED_INCLUDE:..\=) $(HEADERFILE)
PRECOMPILED_CXX=
!   ELSE
PRECOMPILED=
PRECOMPILED_CXX=/Yu$(PRECOMPILED_INCLUDE:..\=) $(HEADERFILE)
!   ENDIF
!  ENDIF
PRECOMPILED_TARGET=$(O)\$(PRECOMPILED_PCH)
! ELSE
PRECOMPILED=
PRECOMPILED_CXX=
! ENDIF
!ELSE
! IF "$(PRECOMPILED_CXX)" == ""
PRECOMPILED=$(PRECOMPILED_OPTION)
PRECOMPILED_CXX=
! ELSE
PRECOMPILED=
PRECOMPILED_CXX=$(PRECOMPILED_OPTION)
! ENDIF
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET)
! IF "$(PRECOMPILED_TARGET)" != ""
HEADERFILE=/Fp$(PRECOMPILED_TARGET)
! ENDIF
! IF "$(PRECOMPILED_OBJ)" != ""
HEADEROBJNAME=$(PRECOMPILED_OBJ)
HEADEROBJ=/Fo$(HEADEROBJNAME)
! ENDIF
!ENDIF

!IF "$(NTNOPCH)" != ""
# Need to do this conditionally.  If the pch obj exists, it's likely existing files
# reference it (ie: this isn't a clean build).  Keep the file ref but delete the
# pch stuff so links will work.
!ifdef HEADEROBJNAME
!if !exist($(HEADEROBJNAME))
HEADEROBJNAME=
HEADEROBJ=
PRECOMPILED_OBJ=
!endif
!endif
PRECOMPILED=
PRECOMPILED_CXX=
PRECOMPILED_INCLUDE=
PRECOMPILED_TARGET=
PRECOMPILED_PCH=
!ENDIF



USECXX_FLAG=$(USECXX_FLAG:p=P)

!IF ("$(PRECOMPILED_CXX)" == "") && ("$(USECXX_FLAG)" == "")
PRECOMPILED_FLAG=$(PRECOMPILED_FLAG) /Tc
!ELSE
PRECOMPILED_FLAG=$(PRECOMPILED_FLAG) /Tp
!ENDIF


#
# Set linker options
#

#
# Merge _PAGE with PAGE, _TEXT with .text, and make sure
# INIT sections are discardable
#

!if !$(MPPC)
!ifdef LINKER_NOREF
LINK_REF_FLAG=-OPT:NOREF -OPT:NOICF
!else
! ifdef LINKER_NOICF
LINK_REF_FLAG=-OPT:REF -OPT:NOICF
! else
LINK_REF_FLAG=-OPT:REF -OPT:ICF
! endif
!endif
!endif

!ifdef NOT_TERMINAL_SERVER_AWARE
TSLINKER_FLAG=
!else
!       if $(_NT_TOOLS_VERSION) >= 0x700
TSLINKER_FLAG=/tsaware
!       else
TSLINKER_FLAG=
!       endif
!endif

DEFAULT_LINK_LIB_IGNORE=4010,4037,4039,4065,4070,4078,4087,4089,4221
!if "$(BUILD_PRODUCT)" == "NT" || defined(LINK_ALLOW_MISSING_BASE_ADDRESS)
# Missing base address not interesting for OS (entire product rebased at postbuild time)
DEFAULT_LINK_LIB_IGNORE=$(DEFAULT_LINK_LIB_IGNORE),4198
!endif

!ifdef LINK_LIB_IGNORE
LINK_LIB_IGNORE_FLAG=-IGNORE:$(LINK_LIB_IGNORE),$(DEFAULT_LINK_LIB_IGNORE)
!else
LINK_LIB_IGNORE_FLAG=-IGNORE:$(DEFAULT_LINK_LIB_IGNORE)
!endif

!IF $(IA64) || $(AMD64)
LINK_LIB_IGNORE_FLAG= $(LINK_LIB_IGNORE_FLAG),4108,4088,4218
!ENDIF

!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# 4218: non-native module found; restarting link with /LTCG
# 4235: /LTCG specified but no code generation required; remove /LTCG from the link command line to improve linker performance
LINK_LIB_IGNORE_FLAG= $(LINK_LIB_IGNORE_FLAG),4218,4235
!endif

!ifdef LINK_NO_RELEASE
LINK_RELEASE=
!else
LINK_RELEASE=/release
!endif

!ifdef USE_INCREMENTAL_LINKING
LINK_INCREMENTAL_FLAG = -OPT:NOREF \
                        $(LINK_LIB_IGNORE_FLAG)
!else
LINK_INCREMENTAL_FLAG = $(LINK_REF_FLAG) \
                        $(LINK_LIB_IGNORE_FLAG) \
                        -INCREMENTAL:NO \
                        -FULLBUILD \
                        $(LINK_RELEASE)
!endif

!ifdef LARGE_ADDRESS_AWARE
LINKER_FLAGS = $(LINKER_FLAGS) -LARGEADDRESSAWARE
!endif

LINK_TIME_CODE_GENERATION_LINKER_FLAGS=
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# If NTPOGO is true or NTPOGO_TARGENAME is defined, a package is
# generated in $(_NTTREE)\POGO\$(NTPOGO_TARGETNAME) that contains
# all of files necessary to build a POGO instrumented/optimized binary.
# pgi.cmd and pgo.cmd are generated to do the PGI and PGO builds.
!if (defined(NTPOGO) || defined(NTPOGO_TARGETNAME)) && defined(_NTPOGODIR)
!if !defined(NTPOGO_TARGETNAME)
NTPOGO_TARGETNAME=$(TARGETNAME)
!endif
NTPOGO_TARGETDIR=$(_NTTREE)\$(_NTPOGODIR)\$(NTPOGO_TARGETNAME)
!if [rmdir /s /q $(NTPOGO_TARGETDIR)]
!endif
!if [-mkdir $(NTPOGO_TARGETDIR) > nul 2>&1]
!endif
# Profiling has to be turned off for POGO.
!if [@echo findstr -i -v -r "[-/^]order:@" link.rsp ^> pogo.rsp > $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo findstr -i -v -r "[-/^]order:@" link.rsp ^> pogo.rsp > $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
# Kernel?
!if (("$(MAJORCOMP)" == "ntos" || "$(MAJORCOMP)" == "NTOS") && \
     ("$(MINORCOMP)" == "init" || "$(MINORCOMP)" == "INIT")) || \
    ("$(TARGETTYPE)" == "HAL")
!if [@copy $(ENDUSER_LIB_PATH)\pogortntos.lib $(NTPOGO_TARGETDIR)]
!endif
!if [@echo link @pogo.rsp -ltcg:PGI pogortntos.lib -d2:-PogoNtoskrnl >> $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo link @pogo.rsp -ltcg:PGO -d2:-PogoNtoskrnl >> $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
# Driver?
!elseif (("$(TARGETTYPE)" == "DRIVER") || ("$(TARGETTYPE)" == "EXPORT_DRIVER"))
!if [@copy $(ENDUSER_LIB_PATH)\pogortsys.lib $(NTPOGO_TARGETDIR)]
!endif
!if [@echo link @pogo.rsp -ltcg:PGI pogortsys.lib -d2:-PogoKmode >> $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo link @pogo.rsp -ltcg:PGO -d2:-PogoKmode >> $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
# Neither kernel or driver?
!else
!if [@copy $(ENDUSER_LIB_PATH)\pogort.lib $(NTPOGO_TARGETDIR)]
!endif
!if [@echo link @pogo.rsp -ltcg:PGI pogort.lib >> $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo link @pogo.rsp -ltcg:PGO >> $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
!endif
LINKER_FLAGS=$(LINKER_FLAGS) -linkrepro:$(NTPOGO_TARGETDIR)
!endif
LINK_TIME_CODE_GENERATION_LINKER_FLAGS=-ltcg
LINKER_FLAGS=$(LINKER_FLAGS) $(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
!endif

!if $(MPPC)
LINKER_FLAGS =  $(LINKER_FLAGS) \
                -SECTION:INIT,d \
                $(LINK_INCREMENTAL_FLAG) \
                -NODEFAULTLIB

!else
LINKER_FLAGS =  $(LINKER_FLAGS) \
                -MERGE:_PAGE=PAGE \
                -MERGE:_TEXT=.text \
                -SECTION:INIT,d \
                $(LINK_INCREMENTAL_FLAG) \
                -NODEFAULTLIB

!endif

LINKER_FLAGS=$(LINKER_FLAGS) $(LINKER_WX_SWITCH)

LINK_OS_VERSIONS = -version:$(LINKER_APP_VERSION) -osversion:$(LINKER_OS_VERSION)

!IF $(MPPC)

#*****MacPPC linker flags

TARGET_DIRECTORY=mppc
UMLIBS=$(UMLIBS:*=mppc)
LINKLIBS=$(LINKLIBS:*=mppc)
DLLDEF=$(DLLDEF:*=mppc)
PRECOMPILED_TARGET= $(PRECOMPILED_TARGET:*=mppc)
PRECOMPILED_OBJ= $(PRECOMPILED_OBJ:*=mppc)
PRECOMPILED_OPTION= $(PRECOMPILED_OPTION:*=mppc)

#
# Set the default creator and type.  If were building a dll then use
# cfmg and shlb, for apps use ???? and APPL.
#

!ifndef MAC_CREATOR
!if "$(TARGETTYPE)" == "DYNLINK"
MAC_CREATOR=cfmg
!else
MAC_CREATOR=????
!endif
!endif

!ifndef MAC_TYPE
!if "$(TARGETTYPE)" == "DYNLINK"
MAC_TYPE=shlb
!else
MAC_TYPE=APPL
!endif
!endif

#
# MAC_CREATOR and MAC_TYPE may contain embedded spaces.  To do this we need to
# enclose their operand in quotes.  Now get rid of the quotes leaving the spaces
#

MAC_CREATOR=$(MAC_CREATOR:^"=)
MAC_TYPE=$(MAC_TYPE:^"=)

#
# Setup for the linker
#


!if "$(TARGETTYPE)"=="DYNLINK"
LINKER_FLAGS=$(LINKER_FLAGS) -mac:nobundle -dll -def:$(DLLDEF)
LINKER_FLAGS=$(LINKER_FLAGS) -mac:MFILEPAD
LINKER_FLAGS=$(LINKER_FLAGS) -mac:init="$(MAC_INITPROC)"
LINKER_FLAGS=$(LINKER_FLAGS) -mac:term="$(MAC_TERMPROC)"
!else
LINKER_FLAGS=-mac:bundle
!endif

LINKER_FLAGS=$(LINKER_FLAGS) -mac:type="$(MAC_TYPE)"
LINKER_FLAGS=$(LINKER_FLAGS) -mac:creator="$(MAC_CREATOR)"
LINKER_FLAGS=$(LINKER_FLAGS) -debug:FULL
LINKER_FLAGS=$(LINKER_FLAGS) -debugtype:both
LINKER_FLAGS=$(LINKER_FLAGS) -NODEFAULTLIB

#*****End Mac linker flags
!ELSE
LINKER_FLAGS = $(LINKER_FLAGS) $(LINKER_DBG_SECTION) -debugtype:cv $(LINK_OS_VERSIONS)
!ENDIF

LIBRARIAN_FLAGS = $(LINK_LIB_IGNORE_FLAG) $(LIBRARIAN_FLAGS) $(LINKER_WX_SWITCH) -nodefaultlib
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) -machine:$(MACHINE_TYPE)

LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS =
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS = -ltcg
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) $(LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS)
!endif

!ifndef LIB_NAME
LIB_NAME=lib
!endif

LIBRARIAN=$(LIB_NAME) -out:$@ $(LIBRARIAN_FLAGS)

!ifndef LINK_NAME
LINK_NAME=link
!endif

LINKER=$(LINK_NAME) -out:$@ -machine:$(MACHINE_TYPE)

#
# SXS_PDB_NAMER is a file built in the obj directory, containing a -pdb flag for LINKER
#     eg: -pdb:obj\i386\MicrosoftWindowsGdiPlus-1.0.3790.127-gdiplus.pdb
# The pdb file name is derived from ntverp.h, $O, $(SXS_PDB_WOW6432_W_PREFIX)
# $(SXS_ASSEMBLY_NAME) and $(TARGETNAME)
# SXS_PDB_NAMER is not always used, but is always built if SXS_MANIFEST_OBJ1 is built.
#
!if defined(SXS_PDB_NAMER)
LINKER=$(LINKER) @$(SXS_PDB_NAMER)
!endif

!if defined(NTPROFILEINPUT) && ("$(TARGETTYPE)" == "LIBRARY")
! message NTPROFILEINPUT s/b removed in: $(MAKEDIR).
!endif

!IF defined(NTPROFILEINPUT) || defined(EXEPROFILEINPUT)
ORDER=-order:@$(@B).prf
!ENDIF

!IFDEF DLLORDER
ORDER=-order:@$(DLLORDER)
!ENDIF

!if "$(SUBSYSTEM_NATVER)" != ",5.02"
! ifndef DRIVER_ALIGNMENT
DRIVER_ALIGNMENT=0x80
! endif
! ifndef HAL_ALIGNMENT
HAL_ALIGNMENT=0x80
! endif
! ifndef KERNEL_ALIGNMENT
KERNEL_ALIGNMENT=0x80
! endif
!endif

!if $(AMD64)
!ifdef DRIVER_ALIGNMENT
DRIVER_ALIGN_SWITCH=-align:$(DRIVER_ALIGNMENT)
!endif
!ifdef HAL_ALIGNMENT
HAL_ALIGN_SWITCH=-align:$(HAL_ALIGNMENT)
!endif
!ifdef KERNEL_ALIGNMENT
KERNEL_ALIGN_SWITCH=-align:$(KERNEL_ALIGNMENT)
!endif
!else
!ifdef DRIVER_ALIGNMENT
DRIVER_ALIGN_SWITCH=-align:$(DRIVER_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!ifdef HAL_ALIGNMENT
HAL_ALIGN_SWITCH=-align:$(HAL_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!ifdef KERNEL_ALIGNMENT
KERNEL_ALIGN_SWITCH=-align:$(KERNEL_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!endif

#
# [GorN] 3/30/2000
#
#    WPP section (WMI tracing preprocessor)
#
#    env. vars:
#
#    RUN_WPP=list of files to run wpp on
#    WPP_REVISION=override default revision
#


!if !defined(WPP_REVISION)
WPP_REVISION=rev1
!endif

!if !defined(WPP_NAME)
WPP_NAME=tracewpp.exe
!endif

!if $(ANSI_ANNOTATION)
WPP_MAKEFILE_FLAGS=-DWPP_ANSI_ANNOTATION
!endif

!if defined(RUN_WPP)
RUN_WPP=$(WPP_MAKEFILE_FLAGS) -cfgdir:$(WPP_CONFIG_PATH)\$(WPP_REVISION) -odir:$(O) $(RUN_WPP)


#  execute wpp now

!  if [-$(WPP_NAME) $(RUN_WPP)]
!  endif

!  if exist(obj\_tracewpp.mac)
!     include obj\_tracewpp.mac
WPP_TARGETS=$(WPP_EXTRA_TARGETS)
!  endif
BINPLACE_FLAGS = $(BINPLACE_FLAGS) -:TMF
C_DEFINES=$(C_DEFINES) -DRUN_WPP
!else
WPP_TARGETS=
!endif



#
# LINT section
#
# Main env. vars:
# USE_LINT=1 to turn on PC-lint processing
# LINT_TYPE={all,lob,<nothing>}
#           all - processes all $(SOURCES) files at once
#           lob - processes $(SOURCES) individually and then consolidates
#           <nothing> - processes $(SOURCES) individually (like John Daly's tool)
#
# Other env. vars:
# LINT_PATH=path to PC-lint directory (default=$(BASEDIR)\lint)
# LINT_APP=name of PC-lint executable (default=lint-nt)
# LINT_OUTPUT=base name of lint output file (default=$(TARGETNAME))
# LINT_EXT=extension of output files (default=tmp)
# LINT_FORCEDINCS=list of forced include files. same as in -FI compiler switch
# LINT_OPTS=options passed to PC-lint (default=+v -zero)
# LINT_PRECOMPPATH=paths that were used for precompiled header.
#                  - some components generate a pch in
#                    a separate step and use the pch amongst several
#                    subdirs. This env. var. lets one specify the
#                    include paths used for the pch.
#
!ifdef USE_LINT

# Convert CDEFINES which may contain /DSYMBOL1, -DSYMBOL2 to
# -dSYMBOL1 and -dSYMBOL2 which PC-Lint wants
LINT_DEFS=$(CDEFINES:-D=-d)
LINT_DEFINES=$(LINT_DEFS:/D=-d)

! ifndef LINT_PATH
LINT_PATH=$(BASEDIR)\lint
! endif

! ifndef LINT_APP
LINT_APP=$(LINT_PATH)\lint-nt
! endif

!ifndef LINT_OPTS
LINT_OPTS=+v -zero
!endif

! if "$(LINT_TYPE)" == "all"
!  ifndef LINT_ALL_CMD
LINT_ALL_CMD=$(LINT_APP) $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt -os($(O)\$(LINT_OUTPUT).$(LINT_EXT))
!  endif
! else
!  if "$(LINT_TYPE)" == "lob"
!   ifndef LINT_CMD
LINT_CMD=$(LINT_APP) -u $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt +os($(O)\$(LINT_OUTPUT).$(LINT_EXT)) -oo($@)
!   endif
!   ifndef LINT_CMD2
LINT_CMD2=$(LINT_APP) $(LINT_OPTS) -i$(LINT_PATH)\ std.lnt +os($(O)\$(LINT_OUTPUT).$(LINT_EXT)) $(O)\*.lob
!   endif
!  else
!   ifndef LINT_CMD
LINT_CMD=$(LINT_APP) $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt +os($(O)\$(LINT_OUTPUT).$(LINT_EXT))
!   endif
!  endif
! endif
!else
LINT_CMD2=
!endif

!ifndef LINT_CMD2
LINT_CMD2=
!endif

#
# Standard inference rules for C files that produce object files.
#

!if $(AMD64)
.SUFFIXES:
!endif

.SUFFIXES: .asm .asmx .c .class .cs .cpp .cxx .exe .f .java .obj .odl .p .rc .rcpp .res .resx .resz .resources .s .sdl .tdl .thk .txt .vb

#
# Processor specific control and options.
#

#
# Make IA64 LKG6 the default.
#

!if $(IA64) || $(AMD64)
LKG6COMPILER=1
!endif

#
# cl.exe now defaults to /GS, so BO_FLAGS must explicitly default to /GS-
#
!ifdef LKG6COMPILER
BO_FLAGS=/GS-
!endif

DRIVER_ENTRY=DriverEntry
GDI_DRIVER_ENTRY=DrvEnableDriver

!if defined(USE_WDF_DYNAMIC) || defined(USE_WDF_STATIC)
BUFFER_OVERFLOW_CHECKS=1
!endif

!include $(TARGET_DIRECTORY)mk.inc


!ifdef VERIFIER_DDK_EXTENSIONS
!if "$(TARGETTYPE)" == "DRIVER" && \
    (!DEFINED(DRIVERTYPE) || "$(DRIVERTYPE)" == "") && \
    !DEFINED(USE_WDF) && !DEFINED(USE_WDF_STATIC) && !DEFINED(USE_WDF_DYNAMIC)
C_DEFINES=$(C_DEFINES) -DVERIFIER_DDK_EXTENSIONS
ENTRY_SUFFIX=_DDK$(ENTRY_SUFFIX)
TARGETLIB=$(DDK_LIB_PATH)\DDK_EXT.LIB $(TARGETLIB)
!endif
!endif

!ifndef LINKER_STACKSIZE
!ifdef LINKER_STACKCOMMITSIZE
LINKER_STACKSIZE = -STACK:$(DEFAULT_STACKRESERVE),$(LINKER_STACKCOMMITSIZE)
!else
LINKER_STACKSIZE = -STACK:$(DEFAULT_STACKRESERVE),$(DEFAULT_STACKCOMMIT)
!endif
!endif

!if defined(USE_WDF_DYNAMIC) || defined(USE_WDF_STATIC)
DRIVER_ENTRY=FxDriverEntry
!endif

LINKER_STACKSIZE_DLL=-STACK:0x40000,0x1000


LIBRARY_OBJS=$(IMPLIB_OBJS) $(MFC_STATIC_LIB) $(LINKLIBS) $(OBJECTS)

!if "$(TARGETTYPE)" != "DRIVER" && \
    "$(TARGETTYPE)" != "EXPORT_DRIVER" && \
    "$(TARGETTYPE)" != "MINIPORT" && \
    "$(TARGETTYPE)" != "GDI_DRIVER"
LINKER_FLAGS = $(LINKER_FLAGS) -merge:.rdata=.text
!endif

LINKER_FLAGS=$(LINKER_FLAGS) /pdbcompress

!if $(DELAYLOAD_SUPPORTED)
! if "$(DELAYLOAD)" != ""
!  if "$(DLOAD_ERROR_HANDLER)" != ""
!   if "$(DLOAD_ERROR_HANDLER)" == "KERNEL32" || \
       "$(DLOAD_ERROR_HANDLER)" == "kernel32.dll" || \
       "$(DLOAD_ERROR_HANDLER)" == "KERNEL32.DLL" || \
       "$(DLOAD_ERROR_HANDLER)" == "Kernel32.DLL" || \
       "$(DLOAD_ERROR_HANDLER)" == "Kernel32.dll"
DLOAD_ERROR_HANDLER = kernel32
!   endif
!   if "$(DLOAD_FORCE_ERROR_CHECK)" != ""
# force delayload checking as if this module used kernel32 as its error handler
BINPLACE_FLAGS = -dl $(TARGETNAME).$(TARGETEXT),FORCE $(BINPLACE_FLAGS)
!   else
BINPLACE_FLAGS = -dl $(TARGETNAME).$(TARGETEXT),$(DLOAD_ERROR_HANDLER) $(BINPLACE_FLAGS)
!   endif
!  else
!   if "$(NOLINK)" == ""
! message BUILDMSG: Warning: DLOAD_ERROR_HANDLER not specified in $(MAKEDIR)
!   endif
!  endif
!  if "$(DLOAD_ERROR_HANDLER)" == "kernel32"
CRTLIBS=$(CRTLIBS) $(BASE_LIB_PATH)\kernel32dloadhandler.lib
TARGETLIBS = $(TARGETLIBS) $(SDK_LIB_PATH)\kernl32p.lib
!  else
CRTLIBS=$(CRTLIBS) $(CRT_LIB_PATH)\delayimp.lib
!  endif
DELAYLOAD = $(DELAYLOAD: =)
DELAYLOAD_FLAGS = /delayload:$(DELAYLOAD:;= /delayload:)
!  ifdef DELAYLOAD_UNLOAD_SUPPORT
DELAYLOAD_FLAGS = $(DELAYLOAD_FLAGS) /delay:unload
!  endif
LINKER_FLAGS = $(LINKER_FLAGS) $(DELAYLOAD_FLAGS)
C_DEFINES=$(C_DEFINES) /DDELAYLOAD_VERSION=$(DELAYLOAD_VERSION)
! endif
!endif

#
# Clear the suffixes list so we can ensure only pass zero stuff will be built
#
!IFDEF PASS0ONLY
.SUFFIXES:
!ENDIF


DRIVER_SWITCH = -driver

!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
DRIVER_SWITCH = $(DRIVER_SWITCH) -driver:wdm
!else if "$(DRIVERTYPE)" == "VXD"
DRIVER_SWITCH = -vxd $(SDK_LIB_DEST)\i386\vxdwraps.clb
!endif

!ifdef BINARY_PUBLISH_DIR
! ifndef BINARY_PUBLISH_FILES
!  error Must define BINARY_PUBLISH_FILES if defining BINARY_PUBLISH_DIR
! endif

BINARY_PUBLISH_ROOT=$(BASEDIR)\$(_PROJECT_)\$(PROJECT_BINDROP_DIR)
BINARY_PUBLISH_ROOT=$(BINARY_PUBLISH_ROOT)\$(BINARY_PUBLISH_DIR)
BINARY_PUBLISH_ROOT=$(BINARY_PUBLISH_ROOT)\$(TARGET_DIRECTORY)\$(BUILD_TYPE)

!endif

!if defined(BINARY_PUBLISH) || defined(BINARY_PUBLISH_DIR) || !defined(_NTTREE)

#
# since we're generating binary drops of this source there's no need to
# binplace the files.  The files should be binplaced from the binary_release
# directory.
#

NO_BINPLACE=1

!endif

!ifdef NO_BINPLACE

BINPLACE_CMD=echo Skip Binplace:
BINPLACE_FLAGS=

!else

! ifndef BINPLACE_PLACEFILE
!  if defined(BINPLACE_GENERATE_PLACEFILE)
BINPLACE_PLACEFILE = $(O)\placefil.txt
!  elseif "$(BUILD_PRODUCT)" == "IE"
BINPLACE_PLACEFILE = $(BINPLACE_PLACEFILE_DIR)\ieplace.txt
!  else
BINPLACE_PLACEFILE = $(BINPLACE_PLACEFILE_DIR)\placefil.txt
!  endif
! endif

! ifdef BINPLACE_GENERATE_PLACEFILE
MAKE_PLACEFILE_CMD=for %i in ($(SXS_MISCFILES) $(TARGET)) do echo %~nxi $(BINPLACE_DESTINATIONS) >> $(BINPLACE_PLACEFILE)
!  if defined(SXS_LOG_PASS) && defined(SXS_ASSEMBLY_NAME) && "$(TARGETTYPE)" != "NOTARGET"
MAKE_PLACEFILE_CMD=( $(MAKE_PLACEFILE_CMD) ) && ( for /f "delims=:" %i in ('echo $(BINPLACE_DESTINATIONS_NORETAIL)') do for %j in ($(TARGET))  do echo %i\%~nxj | $(APPEND_TOOL) -file $(BINPLACE_LOG)\..\symbolcd_cablists_asms_$(COMPUTERNAME).lst - )
!  endif
!  ifdef BINPLACE_ADDITIONAL_PLACEFILES
#
# BINPLACE_ADDITIONAL_PLACEFILES is a semicolon delimited list of additional placefiles.
# The last parameter is the output (which we also use as an input, so we repeat it).
#
MAKE_PLACEFILE_CMD=( $(MAKE_PLACEFILE_CMD) ) && ( merge_placefiles $(BINPLACE_ADDITIONAL_PLACEFILES:;= ) $(BINPLACE_PLACEFILE) $(BINPLACE_PLACEFILE) )
!endif
!else
MAKE_PLACEFILE_CMD=echo.
! endif

BINPLACE_FLAGS = -P $(BINPLACE_PLACEFILE) $(BINPLACE_FLAGS) $(SXS_BINPLACE_FLAGS)

! if !defined(BUILD_NO_SYMCHK)
BINPLACE_FLAGS = -:DBG -j $(BINPLACE_FLAGS)
! endif

_NTTREE= $(_NTTREE)\$(ALT_PROJECT_TARGET)

# If NTDBGFILES is defined then use binplace to split the symbols.
# Define BINPLACE flags as needed if separate .DBG file requested.

! IFDEF NTDBGFILES
BINPLACE_DBGFLAGS_NT = -S $(_NTTREE)\Symbols
!  ifdef NTDBGFILES_PRIVATE
BINPLACE_DBGFLAGS_NT = $(BINPLACE_DBGFLAGS_NT) -n $(_NTTREE)\Symbols.pri
!  endif
! else
BINPLACE_DBGFLAGS_NT=
! ENDIF

! if "$(VERIFY_LC)" == "1"
!  ifndef LC_PATH
LC_PATH=.
!  endif
BINPLACE_LC_FLAGS = -G $(LC_PATH)\$(@F).lc
BINPLACE_LC_MISCFLAGS = -G $(LC_PATH)\$(**F).lc
! else
BINPLACE_LC_FLAGS=
BINPLACE_LC_MISCFLAGS=
! endif

BINPLACE_FLAGS=-R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS)
BINPLACE_TOOL=@binplace

BINPLACE_CMD = $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_FLAGS) $@

!endif

BINPLACE_CMD_NT=$(BINPLACE_CMD)

!ifdef NTDUMPAMAP
MAPDUMP_CMD = link -dump -map $@ | sort /R /+62 > $(_NTDUMPAMAP)\$(@B).srt
!else
MAPDUMP_CMD =
!endif

#
# Define this macro so including make files can supply a yes prompt
# as appropriate.  Put the "yes." file in a visible place for OEM's
# so they can make too.
#

!IFNDEF NOPASS0

#
# Pass Zero Inference Rules: IDL files (MIDL) and MC files
#

.SUFFIXES: .h .idl .mc .odl .tdl .asn .thk .mof

! IF $(386)
PASS0_OBJECTS=$(PASS0_386_OBJECTS)
! ELSEIF $(MPPC)
PASS0_OBJECTS=$(PASS0_MPPC_OBJECTS)
! ELSEIF $(IA64)
PASS0_OBJECTS=$(PASS0_IA64_OBJECTS)
! ELSEIF $(AMD64)
PASS0_OBJECTS=$(PASS0_AMD64_OBJECTS)
! ELSEIF $(ARM)
PASS0_OBJECTS=$(PASS0_ARM_OBJECTS)
! ENDIF

!ENDIF  # IFNDEF NOPASS0

!ifndef MIDL
MIDL = midl
!endif
MKTYPLIB = mktyplib
ASN = asn1
# Disable midl timestamps wherever possible
MIDL_FLAGS=$(MIDL_FLAGS) -no_stamp -nologo $(MIDL_WX_SWITCH)

!IFDEF USE_OLE_MC
MC = mc -o
!ELSE
MC = mc
!ENDIF
MOFCOMP = mofcomp

!IF "$(IDL_TYPE)" == "ole" || "$(IDL_TYPE)" == ""
IDL_TYPE=OLE
!ELSEIF "$(IDL_TYPE)" == "rpc"
IDL_TYPE=RPC
!ENDIF

!IFNDEF PASS0_HEADERDIR
PASS0_HEADERDIR=.
!ENDIF

!IF "$(WIN32_WINNT_VERSION)" == "0x0500"
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION_NT5)
!ELSEIF "$(WIN32_WINNT_VERSION)" == "0x0501"
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION_NT5)
!ELSE
! IF "$(WIN32_WINNT_VERSION)" != "$(LATEST_WIN32_WINNT_VERSION)"
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION_NT4)
! ENDIF
!ENDIF

!IF DEFINED(MIDL_NO_ROBUST)
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION_NO_ROBUST)
!ENDIF

# If the user specified a midl protocol, switch to it.  This assumes that it
# is defaulted in makefile.plt to "-protocol all" or ""

!ifdef MIDL_PROTOCOL
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION:-protocol all=)
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION) -protocol $(MIDL_PROTOCOL)
!endif

! ifdef MIDL_TLBDIR
MIDL_TLBSWITCH=/tlb $(MIDL_TLBDIR)\$(<F:.idl=.tlb)
! else
MIDL_TLBSWITCH=
! endif


!ifndef PACKING
!if $(MPPC)
PACKING= -Zp2
!else
PACKING= -Zp8
!endif
!endif

!IF "$(IDL_TYPE)" == "OLE"

#! IF DEFINED(PASS0_CLIENTDIR) || DEFINED(PASS0_SERVERDIR)
#!  ERROR PASS0_CLIENTDIR and PASS0_SERVERDIR can only be used with IDL_TYPE=RPC!
#! ENDIF

! IFNDEF PASS0_SOURCEDIR
PASS0_SOURCEDIR=.
! ENDIF

! IFNDEF MIDL_UUIDDIR
MIDL_UUIDDIR=$(PASS0_SOURCEDIR)
! ENDIF

! ifndef PASS0_UUIDDIR
PASS0_UUIDDIR=$(MIDL_UUIDDIR)
! endif

!ifdef USE_IDLBASED_DLLDATA
DLLDATA_NAME=$(<F:.idl=_dlldata.c)
!else
DLLDATA_NAME=dlldata.c
!endif

! IFNDEF NO_PASS0_RULES
.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    -dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    -iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{..\}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    -dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    -iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$(O)}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    -dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    -iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<
! ENDIF

!ELSEIF "$(IDL_TYPE)" == "RPC"

#! IF DEFINED(PASS0_SOURCEDIR) || DEFINED(MIDL_UUIDDR)
#!  ERROR PASS0_SOURCEDIR and MIDL_UUIDDIR can only be used with IDL_TYPE=OLE!
#! ENDIF

! IFNDEF PASS0_CLIENTDIR
PASS0_CLIENTDIR=$(TARGETPATH)
! ENDIF

! IFNDEF PASS0_SERVERDIR
PASS0_SERVERDIR=$(PASS0_CLIENTDIR)
! ENDIF

! IFNDEF NO_PASS0_RULES
.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    -sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{..\}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    -sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$(O)}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    -sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

! ENDIF

!ELSE

! ERROR Invalid IDL_TYPE value. Supported values: OLE and RPC.

!ENDIF  # IDL_TYPE

CPPXX = $(C_PREPROCESSOR_FLAGS:/Tc=)
CPPXX = $(CPPXX:-Tc=)

!IFNDEF NO_PASS0_RULES

! IFNDEF MC_SOURCEDIR
! IFDEF PASS0_SOURCEDIR
MC_SOURCEDIR=$(PASS0_SOURCEDIR)
! ELSE
MC_SOURCEDIR=$(PASS0_CLIENTDIR)
! ENDIF
! ENDIF

.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<
.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<

{..\}.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<
{..\}.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<

{$(O)}.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<
{$(O)}.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<

# ManagedObjectFormat files
#   First preprocess MOF via the C pre processor
#   Next separate MOF into MOF and MFL, then concatenate them and
#   finally compile into binary form
{..\}.mof{$(O)}.mof:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP

{}.mof{$(O)}.mof:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
{$(O)}.mof{$(O)}.bmf:
    $(MOFCOMP) -N:root\wmi -Amendment:ms_409 -MFL:$(O)\MFL.MFL -MOF:$(O)\MOF.MOF $<
    wmimofck -y$(O)\MOF.MOF -z$(O)\MFL.MFL $(O)\MOFMFL.MOF
    $(MOFCOMP) -WMI -B:$@ $(O)\MOFMFL.MOF

!ifdef USE_MIDL_FOR_MKTYPLIB

MIDL_MKTYPLIB_FLAGS = \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext \
    -c_ext \
    $(C_DEFINES) -D__MKTYPLIB__ \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $(MKTYPLIB_FLAGS:-h =-header ) \
    -tlb $@ \
    -cpp_cmd $(MIDL_CPP) \
    -mktyplib203

.odl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..\}.odl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

.tdl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..\}.tdl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

!else

.odl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<NOKEEP
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

{..\}.odl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<NOKEEP
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

.tdl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<NOKEEP
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

{..\}.tdl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<NOKEEP
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

!endif


# OSSINFO must be set in the *environment* for the ASN compiler to find its
# configuration file, $(OSSINFO)\ossinfo.

! ifndef OSSINFO
OSSINFO=$(SDK_LIB_DEST)
! endif

! ifndef ASNDEFAULTFILE
ASNDEFAULTFILE=$(OSSINFO)\asn1dflt.z4
! endif

! ifndef ASNSYNTAX
ASNSYNTAX=-1990
! endif

ASNFLAGS=$(ASNDEFAULTFILE) $(ASNSYNTAX) $(ASNFLAGS)

# if ASNDBG is explicitly set, let that control whether the voluminous ASN
# symbols are supressed.  Otherwise, suppress the symbols for free builds.

! ifdef ASNDBG
!  if $(ASNDBG) == 0
ASNFLAGS=-minimize $(ASNFLAGS)
!  endif
! elseif $(FREEBUILD)
ASNFLAGS=-minimize $(ASNFLAGS)
! endif

{}.asn{$(PASS0_HEADERDIR)}.h:
    $(ASN) $(ASNFLAGS) -out $(PASS0_HEADERDIR)\$(@B) $<

!ENDIF

#
# Default language ID to US English (0x0409)
#

!IFDEF RCCODEPAGE
RCOPTIONS=$(RCOPTIONS) -c $(RCCODEPAGE)
!ENDIF

!IFNDEF RCNOFONTMAP
RCOPTIONS=-z "MS Sans Serif,Helv/MS Shell Dlg" $(RCOPTIONS)
!ENDIF

SXS_RC_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES)
SXS_RC_MANIFEST_DEFINES=$(SXS_RC_MANIFEST_DEFINES:"\"=""")
SXS_RC_MANIFEST_DEFINES=$(SXS_RC_MANIFEST_DEFINES:\""=""")
RCOPTIONS=$(SXS_RC_MANIFEST_DEFINES) $(RCOPTIONS)
!ifdef RCLANGUAGE
RCOPTIONS=-l $(RCLANGUAGE) $(RCOPTIONS)
!else
RCOPTIONS=-l 409 $(RCOPTIONS)
!endif

RC_COMPILER=rc $(RCOPTIONS)

INCPATHRC = $(INCPATH0: =)
INCPATHRC = $(INCPATHRC:-I=;)
INCPATHRC = $(INCPATHRC:/I=;)

CDEFINERC = $(CDEFINES:  = )
CDEFINERC = $(CDEFINERC:  = )

!if defined(RC_FORCE_INCLUDE_FILES)
# Concatenate the FORCE_INCLUDES files in front of the .rc file.
# We put nul in front because there is an extra leading semicolon which produces
# an extra leading plus sign.
RC_TEMP1=$(@R).rc_temp1
RC_FORCE_INCLUDE_FILES_CMD=copy nul$(RC_FORCE_INCLUDE_FILES:;=+)+$< $(RC_TEMP1)
INCPATHRC=$(INCPATHRC);..
!else
RC_TEMP1=$<
RC_FORCE_INCLUDE_FILES_CMD=
!endif

!if defined(RC_FORCE_INCLUDE_STRING)
RC_TEMP2=$(@R).rc_temp2
INCPATHRC=$(INCPATHRC);..
!else
RC_TEMP2=$(RC_TEMP1)
!endif

RC_TEMP=$(RC_TEMP2)

!if defined(SXS_MANIFEST_IN_RESOURCES)
MAKE_MANIFEST_CMD=nmake -nologo $(SXS_MANIFEST_OBJ1)
!else
MAKE_MANIFEST_CMD=
!endif

!IF $(MPPC)
{$(O)\}.rc{$(O)\}.res:
     $(RC_COMPILER) -r -m -fo $@ $(RC_DEFINES) $(RCXBANG) $(INCPATH0) $<
!ELSE
{$(O)\}.rc{$(O)\}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) -r -fo $@ $(CDEFINES) $(INCPATH0) $<
<<NOKEEP
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! IF defined(RC_FORCE_INCLUDE_STRING)
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<NOKEEP
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) -r -fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)
!ENDIF

!IF $(MPPC)
{..\}.rc{$(O)\}.res:
     $(RC_COMPILER) -r -m -fo $@ $(RC_DEFINES) $(RCXBANG) $(INCPATH0) $<
!ELSE
{..\}.rc{$(O)\}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) -r -fo $@ $(CDEFINES) $(INCPATH0) $<
<<NOKEEP
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! if defined(RC_FORCE_INCLUDE_STRING)
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<NOKEEP
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) -r -fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)
!ENDIF

!IF $(MPPC)
{}.rc{$(O)\}.res:
    $(RC_COMPILER) -r -m -fo $@ $(RC_DEFINES) $(RCXBANG) $(INCPATH0) $<
!ELSE
{}.rc{$(O)\}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) -r -fo $@ $(CDEFINES) $(INCPATH0) $<
<<NOKEEP
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! if defined(RC_FORCE_INCLUDE_STRING)
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<NOKEEP
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) -r -fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)
!ENDIF

!IF $(MPPC)

#
# The definitions for the resource compiler are the same as the definitions
# for the C compiler except we need to remove INC_OLE2 because the resource
# compiler doesn't understand the pragma's that the VC guys used to rename
# the macos include files.  Thus, the resource compiler can't parse the ole
# headers
#

RC_DEFINES=$(C_DEFINES:INC_OLE2=NO_OLE)

#
# Setup for the mac resource compiler
#

# Macintosh-specific resourse (.r) to .rsc rule
MRC_COMPILER=mrc -l 0x409

.SUFFIXES: .r

{..\}.r{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.rsc:
    $(MRC_COMPILER) -o $(@R).rsc $(RC_DEFINES) $(INCPATH0) $<

.r{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.rsc:
    $(MRC_COMPILER) -o $(@R).rsc $(RC_DEFINES) $(INCPATH0) $<
!ENDIF


{..\}.rc.rcpp:
    set include=$(INCPATHRC);$(INCLUDE)
    $(RC_COMPILER) -r -p -fo $(@R).tmp $(CDEFINERC) $<
    @set include=$(INCLUDE)

{}.rc.rcpp:
    set include=$(INCPATHRC);$(INCLUDE)
    $(RC_COMPILER) -r -p -fo $(@R).tmp $(CDEFINERC) $<
    @set include=$(INCLUDE)

.thk{$(O)\}.asm:
    thunk -o $@ $<

JVC = jvc /nologo

!ifndef JAVA_DEBUG_FLAGS
!if $(FREEBUILD)
JAVA_DEBUG_FLAGS = /O
!else
JAVA_DEBUG_FLAGS = /g
!endif
!endif

!ifndef JAVA_WARNING_FLAGS
JAVA_WARNING_FLAGS = /w4
!endif

JAVA_BASE_CLASS = \
    $(SDK_PATH)\classes\afc.zip; \
    $(SDK_PATH)\classes\classes.zip

JAVA_CLASS_PATH = $(JAVA_BASE_CLASS); $(MAKEDIR); $(USER_CLASS_PATH)
JAVA_CLASS_PATH = $(JAVA_CLASS_PATH: =)

JVC_FLAGS = /cp $(JAVA_CLASS_PATH) $(JAVA_DEBUG_FLAGS) $(JAVA_WARNING_FLAGS) /d $(O)

{$(MAKEDIR)}.java{$(O)\}.class:
    $(JVC) $(JVC_FLAGS) $<

#
# The DDK must support using VC 5 which does not support the /FC switch
# allow disabling of it
#

!ifdef DDK_VC5_COMPILE
USE_FC =
!else
USE_FC = /FC
!endif

ECHO_RSP = $(O)\echo.msg
CL_RSP   = $(O)\cl.rsp
CLCOD_RSP = $(O)\clcod.rsp
LINK_RSP = $(O)\lnk.rsp

{$(O)\}.cxx{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{..\}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{..\$(TARGET_DIRECTORY)\}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{$(O)\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{..\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{..\$(TARGET_DIRECTORY)\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{$(TARGET_DIRECTORY)\}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{$(TARGET_DIRECTORY)\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{..\}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{..\}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

{..\}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC)
$(CXX_COMPILER_FLAGS: =
)
$<
<<NOKEEP

{..\}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

{}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC) $<
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

{}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

{}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC) $<
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

{}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

# Expand spaces to newlines, replace double # signs with spaces.
EX_C_COMPILER_FLAGS=$(C_COMPILER_FLAGS: =^
)
EX_C_COMPILER_FLAGS=$(EX_C_COMPILER_FLAGS:^#^#= )

{..\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC) $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<NOKEEP

{..\$(TARGET_DIRECTORY)\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC) $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<NOKEEP

{$(O)\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC)
$(EX_C_COMPILER_FLAGS)
$<
<<NOKEEP

{}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC) $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<NOKEEP

{$(TARGET_DIRECTORY)\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC) $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<NOKEEP

{..\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC) $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<NOKEEP

{$(O)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC) $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<NOKEEP

{..\$(TARGET_DIRECTORY)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC) $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<NOKEEP

{$(O)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

{..\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

{..\$(TARGET_DIRECTORY)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

{}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC) $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<NOKEEP

{$(TARGET_DIRECTORY)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /Fc $(USE_FC) $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<NOKEEP

{}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

{$(TARGET_DIRECTORY)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

{}.c{$(TARGET_DIRECTORY)\}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E $(USE_FC) $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

#
# C# compiler rules
#

EX_MANAGED_COMPILER_FLAGS=$(MANAGED_STD_FLAGS)
{..\}.cs{$O\}.dll::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)

    @$(CS_COMPILER_NAME) @<<$(CS_RSP)
$(EX_MANAGED_COMPILER_FLAGS)
$<
<<NOKEEP

{..\}.vb{$O\}.dll::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(VB_NET_COMPILER_NAME) @<<$(VB_RSP)
$(EX_MANAGED_COMPILER_FLAGS)
$<
<<NOKEEP

#
# resgen rules
#

{}.resz{$(O)}.resources:
    resxgen.exe $< $*.resx
    resgen.exe $*.resx $@

{}.resx{$(O)}.resources:
    resgen.exe $< $@

{}.txt{$(O)}.resources:
    resgen.exe $< $@

#
# SDL proxy generation rules
#
.sdl.cs::
    webserviceutil /c:proxy /path:$<


!if "$(NTNOFUZZYLOOKUP)"=="1"
LIBRARY_OBJS=
!else
LIBRARY_OBJS = $(LIBRARY_OBJS) $(HEADEROBJNAME)
!endif

!ifdef USE_INCREMENTAL_LINKING
IMPLIB_DEPEND =
!else
IMPLIB_DEPEND = $(LIBRARY_OBJS)
!endif

#
# inference rules for preprocessing manifests
# It would be nice to go from .manifest to .manifest.obj, but nmake doesn't work that way.
# There is some precedent for going from .src to .manifest, but I'd rather generated files
# end in obj. But we can't go from .manifest to .manifestobj either, because of the case
# of manifests not in resources.
#
# .manifest-src is needed only for the unusual case of multiple manifests resources,
# when you write the .rc file lines by hand instead of us doing it for you, and
# then the .rc is not pushed into the objdir and it picks up the unpreprocessed one.
# For example: \nt\base\win32\fusion\tests\sxstest\testdata\Hello\ExeMultiRes.
#
# .man is for fitting in 8.3
#
.SUFFIXES: .manifest-src .manifest .man

# This string is needed in at least four places in the tree, so factor it to here.
SYSTEM_COMPATIBLE_ASSEMBLY_NAME=Microsoft.Windows.SystemCompatible
DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME=\
    -DSYSTEM_COMPATIBLE_ASSEMBLY_NAME="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\"" \
    -DLSYSTEM_COMPATIBLE_ASSEMBLY_NAME=L"\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\""

SYSTEM_COMPATIBLE_ASSEMBLY_VERSION=5.2
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3=$(VER_PRODUCTBUILD)
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4=$(VER_PRODUCTBUILD_QFE)

SXS_MANIFEST_DEFINES= \
 -DSXS_ASSEMBLY_NAME="\"$(SXS_ASSEMBLY_NAME)\"" \
 -DSXS_ASSEMBLY_LANGUAGE="\"$(SXS_ASSEMBLY_LANGUAGE)\"" \
 -DSXS_PROCESSOR_ARCHITECTURE="\"$(SXS_PROCESSOR_ARCHITECTURE)\"" \
 -DSXS_TARGET="\"$(TARGETNAME).$(TARGETEXT:lib=dll)\"" \
 $(DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME) \
 $(SXS_MANIFEST_DEFINES)
!ifdef SXS_AUTO_VERSION
# Some assemblies shipped with policy versions unrelated to their manifest version --
# in the event that the policy is now at a higher version than the corresponding
# assembly, we won't override it using our default behavior of using a policy version
# equal to the current assembly version. In this case provide an override mechanism:
# in sources set SXS_OVERRIDE_POLICY_VERSION=(major).(minor) and also use
# SXS_OVERRIDE_POLICY_VERSION as the version in your manifest and we will take care
# of adding the third and fourth parts and making it a string.
SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) -DSXS_MAJMIN_ASSEMBLY_VERSION=$(SXS_ASSEMBLY_VERSION) \
 -DSXS_OVERRIDE_POLICY_VERSION_MAJMIN=$(SXS_OVERRIDE_POLICY_VERSION)
!if !defined(SXS_ASSEMBLY_VERSION_PART_3_UNDEFINED)
SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) -DSXS_ASSEMBLY_VERSION_PART_3=$(SXS_ASSEMBLY_VERSION_PART_3)
!endif
!else
SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) -DSXS_ASSEMBLY_VERSION="\"$(SXS_ASSEMBLY_FULL_VERSION)\""
!endif
!if "$(SXS_LANGUAGE)" != ""
SXS_MANIFEST_DEFINES=-DSXS_LANGUAGE="\"$(SXS_LANGUAGE)\"" $(SXS_MANIFEST_DEFINES)
!endif



#MANIFEST_PREPROCESSOR_NAME=$(C_PREPROCESSOR_NAME)
# $(TARGET_CPP) does not include -FIwarning.h.
# Otherwise we have to filter the data through, like Perl:
# while (<>) {
#       if (!/^#pragma.+/ && !/^$/) {
#               print;
#       }
#}
!ifndef MANIFEST_PREPROCESSOR_NAME
!if defined(SXS_AUTO_VERSION)
MANIFEST_PREPROCESSOR_NAME=$(C_PREPROCESSOR_NAME)
!else
MANIFEST_PREPROCESSOR_NAME=preprocessor.exe
!endif
!endif

!if defined(SXS_AUTO_VERSION)
MANIFEST_VERSION_HEADER=$(SDK_INC_PATH)\sxsmanifest.h
MANIFEST_PREPROCESSOR_FLAGS=$(MANIFEST_PREPROCESSOR_FLAGS) \
    /EP /nologo /I$(SDK_INC_PATH)
MANIFEST_TRIMMER=perl -ne "print if (!/^.pragma/ && /^.+/)"
MANIFEST_PREPROCESS=$(MANIFEST_PREPROCESSOR_NAME) \
    $(MANIFEST_PREPROCESSOR_FLAGS) /FI$(MANIFEST_VERSION_HEADER) \
    $(SXS_MANIFEST_DEFINES) $< | $(MANIFEST_TRIMMER) > $@
!else
MANIFEST_PREPROCESS=$(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
!endif

!ifndef MANIFEST_VALIDATOR_SCHEMA
MANIFEST_VALIDATOR_SCHEMA=$(NTMAKEENV)\appschema.xml
!endif
!ifndef MANIFEST_VALIDATOR_NAME
MANIFEST_VALIDATOR_NAME=FusionManifestValidator /b /s:$(MANIFEST_VALIDATOR_SCHEMA)
!endif

#
# .manifest-src -> .man
#
{}.manifest-src{$(O)}.man:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest-src{$(O)}.man:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest-src{$(O)}.man:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# .manifest-src -> .manifest
#
{}.manifest-src{$(O)}.manifest:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest-src{$(O)}.manifest:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest-src{$(O)}.manifest:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# .manifest -> .man
#
{}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{$(SXS_MANIFEST_SOURCE)}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# .manifest -> .manifest
#
{}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{$(SXS_MANIFEST_SOURCE)}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESS)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# Standard inference rule for generating machine specific def files.
#

.SUFFIXES: .def .src

{..\}.src{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP

{}.src{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP

{..\}.def{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP

{}.def{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP

# one more level down for HALS
{..\..\}.src{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP

!ifdef NO_BROWSER_FILE
BROWSERFILE=
!else
! ifdef BROWSER_INFO
!  ifndef BROWSERFILE
!   if "$(TARGETNAME)" == ""
BROWSERFILE=
!   else
BROWSERFILE=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).bsc
!   endif
!  endif
! else
BROWSERFILE=
! endif
!endif

!if defined (USE_LINT) && ("$(LINT_TYPE)" != "all")

{}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)\}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)\}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)\}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)\}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)\}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)\}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
!endif
    $(LINT_CMD) $<

!endif

#
# Standard list of targets: all, clean and loc.  all is the default target.
#

!IFNDEF PASS0ONLY
all:  $(_OBJ_DIR)\_objects.mac \
        $(NTTARGETFILE0)  \
        $(WPP_TARGETS) \
        $(PASS0_OBJECTS) \
        PASS0_Pub    \
        PASS0_Binp   \
        $(PRECOMPILED_TARGET) \
        $(HEADEROBJNAME) \
        build_objects \
        $(SXS_MANIFEST_OBJ1) \
        $(SXS_MANIFEST_OBJ2) \
        $(SXS_PDB_NAMER) \
        $(TARGETLOBFILES1) \
        $(TARGETLIBFILES) \
        $(NTTARGETFILE1)  \
        $(TARGETEXEFILES) \
!if "$(BROWSERFILE)" != ""
        $(BROWSERFILE)   \
!endif
        $(TARGETLOBFILES2) \
        PASS1_Pub     \
        PASS1_Binp   \
        build_umobjects \
!ifndef NOLINK
        $(UMEXEFILES) \
!endif
!ifdef MANAGED_COVERAGE
        MANAGED_CODECOVER \
!endif
        $(NTTARGETFILES) \
        PASS2_Pub     \
        PASS2_Binp    \
! if !$(MISCFILES_DURING_LINK) || !defined(NOLINK)
!  if "$(MISCFILES: =)" != "" || defined(SXS_MISCFILES)
        $(MISCFILES) \
        $(SXS_MISCFILES) \
!   ifdef _NTTREE
        binplace_miscfiles \
!   endif
!  endif
! endif
!ifdef SXS_LOG_CMD
        sxs_log_cmd \
!endif
        BINARY_Pub  \
        LastStep
! if "$(BUILDMSG)" != ""
    @echo.
    @echo $(BUILDMSG)
! endif

LastStep:

# make a target that always build
sxs_log_cmd:
    $(SXS_LOG_CMD)

binplace_miscfiles: $(MISCFILES) $(SXS_MISCFILES)
!ifndef NO_BINPLACE
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) @<<
$**
<<NOKEEP
!endif

build_objects: $(TARGETOBJFILES)

build_umobjects: $(UMOBJFILES)

!ELSE   # PASS0ONLY

all:    $(NTTARGETFILE0)  \
        $(WPP_TARGETS) \
        $(PASS0_OBJECTS) \
    PASS0_Pub \
    PASS0_Binp
! IF "$(BUILDMSG)" != ""
    @echo.
    @echo $(BUILDMSG)
! ENDIF

!ENDIF  # PASS0ONLY

update:
    @echo Updating library.

$(_OBJ_DIR)\_objects.mac: $(SOURCES_USED)
    @echo Rebuilding $(_OBJ_DIR)\_objects.mac from $(SOURCES_USED).
    @build -OZf >nul 2>&1
    @echo $(_OBJ_DIR)\_objects.mac was rebuilt, please reinvoke NMAKE
    @md \ >nul 2>nul

!ifdef NO_BINPLACE
PASS0_BINP:

PASS1_BINP:

PASS2_BINP:

!else
PASS0_BINP:
!if defined(PASS0_BINPLACE) && "$(BUILD_PASS)" != "PASS1" && "$(BUILD_PASS)" != "PASS2"
    $(BINPLACE_TOOL) @<<
$(BINPLACE_FLAGS)
$(PASS0_BINPLACE)
<<NOKEEP
!endif

PASS1_BINP:
!if defined(PASS1_BINPLACE) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2"
    $(BINPLACE_TOOL) @<<
$(BINPLACE_FLAGS)
$(PASS1_BINPLACE)
<<NOKEEP
!endif

PASS2_BINP:
!if defined(PASS2_BINPLACE) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS1"
    $(BINPLACE_TOOL) @<<
$(BINPLACE_FLAGS)
$(PASS2_BINPLACE)
<<NOKEEP
!endif
!endif

PASS0_Pub:
!if defined(PASS0_PUBLISH) && "$(BUILD_PASS)" != "PASS1" && "$(BUILD_PASS)" != "PASS2"
    $(PUBLISH_CMD) -F <<
$(PASS0_PUBLISH:}=}
)
<<NOKEEP
!endif

PASS1_Pub:
!if defined(PASS1_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2" && !defined(PASS1_NOLIB)
    $(PUBLISH_CMD) -F <<
$(PASS1_PUBLISH:}=}
)
<<NOKEEP
!endif

PASS2_Pub:
!if defined(PASS2_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS1"
    $(PUBLISH_CMD) -F <<
$(PASS2_PUBLISH:}=}
)
<<NOKEEP
!endif

#
# Binary drop runs only during the link phase
#

BINARY_Pub:
!ifdef BINARY_PUBLISH
! if "$(BINPUBLISH)" == "1"
    $(BINDROP_CMD) -F <<
$(BINARY_PUBLISH:}=}
)
<<NOKEEP
! else
    @echo BINARY_PUBLISH_PROJECTS in environment doesn't contain $(_PROJECT_) -
    @echo binaries will not be published.
! endif
!else if defined(BINARY_PUBLISH_FILES)
! if "$(BINPUBLISH)" == "1"
    @cmd /v:on /c make_publish_spec.cmd $(BINARY_PUBLISH_ROOT) $(O) $(BINARY_PUBLISH_FILES) | $(BINDROP_CMD) -I
! else
    @echo BINARY_PUBLISH_PROJECTS in environment doesn't contain $(_PROJECT_) -
    @echo binaries will not be published.
! endif
!endif

#
# Currently, service tables are sorted according to profile data on WIN64,
# but not X86.
#
# 32-bit binaries built for Wow64 (ntdll, etc.) must also use the sorted
# tables.
#
# Use GENSRV_PREPROCESS for "normal" service table preprocessing, and
# GENSRV_PREPROCESS_WOW64 for wow64 binary generation.
#

GENSRV_PREPROCESS_WOW64 = $(C_PREPROCESSOR) $** | gensrv -prof $(BASE_INC_PATH)\services.prof > $@
!if $(IA64) || $(AMD64)
GENSRV_PREPROCESS = $(GENSRV_PREPROCESS_WOW64)
!else
GENSRV_PREPROCESS = $(C_PREPROCESSOR) $** > $@
!endif

!IF DEFINED(NTTARGETFILES) || DEFINED(NTTARGETFILE0) || DEFINED(NTTARGETFILE1) || DEFINED(USE_MAKEFILE_INC)
! INCLUDE .\makefile.inc
!ENDIF

!IF "$(PRECOMPILED_INCLUDE)" != ""
! ifdef PRECOMPILED_SOURCEFILE
!  ifdef PRECOMPILED_INCLUDE_BASENAME
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE) $(PRECOMPILED_SOURCEFILE)
!  else
PRECOMPILED_INCLUDE_BASENAME=$(?F)
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE)
!  endif
    @type <<
$(ECHO_PRECOMPILED_MSG1)
<<NOKEEP
    @$(C_COMPILER_NAME) @<< $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
$(EX_C_COMPILER_FLAGS)
/Yl$(TARGETNAME) /Yc$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE) $(HEADEROBJ)
<<NOKEEP
! else
!  ifndef PRECOMPILED_INCLUDE_BASENAME
PRECOMPILED_INCLUDE_BASENAME=$(?F)
!  endif
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE)
    @type <<$(O)\pch_hdr.src
$(ECHO_PRECOMPILED_MSG2)

#include "$(PRECOMPILED_INCLUDE_BASENAME)"

<<NOKEEP
    @$(C_COMPILER_NAME) @<< $(PRECOMPILED_FLAG)<<$(O)\pch_hdr.src
$(EX_C_COMPILER_FLAGS)
/Yl$(TARGETNAME) /Yc$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE) $(HEADEROBJ)
<<NOKEEP
#include "$(PRECOMPILED_INCLUDE_BASENAME)"
<<NOKEEP
! endif
!ENDIF

!if !defined(NOLINK) && "$(UMAPPL)" != ""

#
# Standard inference rule for User Mode object files that produce User Mode
# image files
#

$(UMEXEFILES): $(UMOBJS) $(BO_LIB) $(UMLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(HEADEROBJNAME: =
)
$(LINKER_OPTIDATA)
-subsystem:$(SUBSYSTEM)
-base:$(UMBASE)
$(UMENTRY)
$(UMRES: =
)
$(*R).obj
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
!endif

!if "$(BROWSERFILE)" != ""

! ifndef BSCMAKE_FLAGS
BSCMAKE_FLAGS = -nologo
! endif

$(BROWSERFILE) : \
! if "$(OBJECTS)" != "" || "$(OTHER_SBR_FILES)" != ""
                $(O)\*.sbr $(OTHER_SBR_FILES)
    -bscmake $(BSCMAKE_FLAGS) -o "$(BROWSERFILE)" @<<$(O)\bscmake.rsp
$(**: =
)
<<NOKEEP
! endif
!endif

#
# These dependencies produce the target binaries from the object files.
# These will trigger the sources to object inference rules to generate the
# object files.
#

!IF "$(TARGET)" != ""
! IF "$(TARGETTYPE)"=="PROGLIB"
$(TARGET:.exe=.lib) $(TARGET:.exe=.exp): \
!  if "$(BUILD_PASS)" != "PASS2"
                                         $(IMPLIB_DEPEND) \
!  endif
                                         $(DLLDEF)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(LIBRARY_OBJS: =
)
<<NOKEEP
    $(LINT_CMD2)

$(TARGET): $(OBJECTS) $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp $(UMRES) $(BO_LIB) $(UMLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(HEADEROBJNAME: =
)
$(LINKER_OPTIDATA)
-subsystem:$(SUBSYSTEM)
-base:$(UMBASE)
$(UMENTRY: =
)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)

! ELSEIF "$(TARGETTYPE)"=="PROGRAM"

!    if (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
$(TARGET): $(UMRES) $(OBJECTS) $(BO_LIB) $(CRTLIBS) $(UMLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
-subsystem:$(SUBSYSTEM)
-base:$(UMBASE)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(UMENTRY: =
)
$(LINKER_OPTIDATA)
$(HEADEROBJNAME: =
)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(LINT_CMD2)

!  ELSE  # MANAGED_CODE or MANAGED_VB is set

$(TARGET) : $(SOURCES)
    @type <<
$(MANAGED_CODE_BUILD_CMD)
<<NOKEEP
    @$(MANAGED_CODE_BUILD_TOOL) @<<
$(MANAGED_CODE_BUILD_SWITCHES)
$(SOURCES)
<<NOKEEP
    $(BINPLACE_CMD)

!  ENDIF # MANAGED_CODE || MANAGED_VB

! ELSEIF "$(TARGETTYPE)"=="DYNLINK"

!  ifdef NO_DLL_EXPORTS
DYNLINK_EXP=
!  elseif (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
$(DYNLINK_LIB) $(DYNLINK_EXP) : \
!   if "$(BUILD_PASS)" != "PASS2"
                                $(IMPLIB_DEPEND) $(DLLLIBOBJECTS) \
!   endif
                                $(DLLDEF)
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(LIBRARY_OBJS: =
)
<<NOKEEP
!   IF "$(DLLLIBOBJECTS)" != " "
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
$(@R).lib
$(DLLLIBOBJECTS)
<<NOKEEP
!   ENDIF
    $(LINT_CMD2)
!  endif # NO_DLL_EXPORTS

!  IF "$(MAKEDLL)" != ""

!    if (!defined(MANAGED_CODE) && !defined(MANAGED_VB))

$(TARGET): $(DYNLINK_EXP) $(OBJECTS) $(BO_LIB) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
-dll
$(ORDER: =
)
$(LINKER_OPTIDATA)
-base:$(DLLBASE)
-subsystem:$(SUBSYSTEM)
$(DLLENTRY: =
)
$(HEADEROBJNAME: =
)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(MAPDUMP_CMD)

!  ELSE  # MANAGED_CODE || MANAGED_VB is set

$(TARGET) : $(SOURCES)
    $(MANAGED_CODE_BUILD_CMD)
!  IF "$(SERVICEPROXY)" != ""
    copy /y $(TARGET) $(REFERENCE_DIR)\tempproxy.dll
    webserviceutil /base:$(SERVICEBASE) /command:makeSDL /assembly:$(REFERENCE_DIR)\tempproxy.dll /out:$(PROXYPATH)
    del $(REFERENCE_DIR)\tempproxy.dll
!  ENDIF
    $(BINPLACE_CMD)

!  ENDIF # MANAGED_CODE || MANAGED_VB

!  ENDIF # "$(MAKEDLL)" != ""

! ELSEIF "$(TARGETTYPE)"=="LIBRARY"

$(TARGET): $(OBJECTS) $(OBJLIBFILES)
    @-erase $@ >nul 2>nul
    -$(LIBRARIAN) @<<
$(HEADEROBJNAME: =
)
$(OBJECTS: =
)
$(OBJLIBFILES: =
)
<<NOKEEP

    $(LINT_CMD2)
! ELSEIF "$(TARGETTYPE)"=="DRIVER" || \
    "$(TARGETTYPE)"=="MINIPORT"

$(TARGET): $(OBJECTS) $(BO_LIB) $(MACHINE_TARGETLIBS) $(CRTLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
$(ORDER: =
)
$(SECTION_INFO1)
$(SECTION_INFO2)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
-base:$(DRIVERBASE)
!  IF "$(DRIVERTYPE)" == "VXD"
-def:$(DLLDEF)
!  ELSE
$(DRIVER_ALIGN_SWITCH)
-subsystem:native$(SUBSYSTEM_NATVER)
-entry:$(DRIVER_ENTRY)$(ENTRY_SUFFIX)
!endif
-out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)

! ELSEIF "$(TARGETTYPE)"=="GDI_DRIVER"

$(TARGET): $(OBJECTS) $(BO_LIB) $(MACHINE_TARGETLIBS) $(CRTLIBS) $(GDI_DRIVER_LIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
-dll
$(ORDER: =
)
$(SECTION_INFO1)
$(SECTION_INFO2)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(DRIVER_ALIGN_SWITCH)
-subsystem:native$(SUBSYSTEM_NATVER)
-base:$(DRIVERBASE)
-entry:$(GDI_DRIVER_ENTRY)$(GDI_ENTRY_SUFFIX)
-out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)

! ELSEIF "$(TARGETTYPE)"=="EXPORT_DRIVER"

$(DYNLINK_EXP) $(DYNLINK_LIB) : \
!  if "$(BUILD_PASS)" != "PASS2"
                                $(BO_LIB) $(LINKLIBS) $(DLLLIBOBJECTS) \
!  endif
                                $(DLLDEF) $(OBJECTS)
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(OBJECTS)
$(LINKLIBS)
<<NOKEEP
!  if "$(DLLLIBOBJECTS)" != " "
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
$(DYNLINK_LIB)
$(DLLLIBOBJECTS)
<<NOKEEP
!  endif
    $(LINT_CMD2)

!  IF "$(MAKEDLL)" != ""
$(TARGET): $(DYNLINK_EXP) $(OBJECTS) $(BO_LIB) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(ORDER: =
)
$(LINKER_STACKSIZE_DLL)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(DRIVER_ALIGN_SWITCH)
-subsystem:native$(SUBSYSTEM_NATVER)
-base:$(DRIVERBASE)
-entry:$(DRIVER_ENTRY)$(ENTRY_SUFFIX)
-out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
!  ENDIF

! ELSEIF "$(TARGETTYPE)"=="HAL"

!  IF "$(MAKEDLL)" == ""
$(TARGET) $(TARGET:.lib=.exp): $(DLLDEF) $(O)\*.obj $(LINKLIBS)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(O)\*.obj
$(LINKLIBS)
<<NOKEEP
!  ELSE
$(TARGET:.dll=.lib) $(TARGET:.dll=.exp): $(DLLDEF) $(O)\*.obj $(LINKLIBS)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(O)\*.obj
$(LINKLIBS)
<<NOKEEP

$(TARGET): $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp $(OBJECTS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(HAL_ALIGN_SWITCH)
-subsystem:$(SUBSYSTEM)
-base:$(HALBASE)
-dll
-entry:HalInitSystem$(ENTRY_SUFFIX)
-out:$(TARGET)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)
!  ENDIF
! ENDIF
!ENDIF

!IFNDEF NOLINK

! IF "$(NTTEST)" != ""

obj\$(TARGET_DIRECTORY)\$(NTTEST).exe: $(NTRES) obj\$(TARGET_DIRECTORY)\$(NTTEST).obj  \
                        $(BO_LIB) $(KERNEL_LIBS) \
                        $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(NTTEST_LINK_OPTIONS: =
)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(KERNEL_ALIGN_SWITCH)
-subsystem:$(SUBSYSTEM)
$(**: =
)
<<NOKEEP
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(MAPDUMP_CMD)

    $(LINT_CMD2)
! ENDIF
!ENDIF

!IF DEFINED(USE_LINT) && ("$(LINT_TYPE)" == "all")

$(O)\$(LINT_OUTPUT).$(LINT_EXT): $(TARGETOBJFILES)
    $(LINT_ALL_CMD) $(SOURCES)
!ENDIF

$(O)\*.res : $(MASTER_VERSION_FILE)

!if defined(SXS_MANIFEST_OBJ2)
$(SXS_MANIFEST_OBJ2) : $(SXS_MANIFEST_OBJ1)
    copy $(SXS_MANIFEST_OBJ1) $(SXS_MANIFEST_OBJ2)
!endif

!if defined(SXS_PDB_NAMER)
$(SXS_PDB_NAMER) : $(SXS_MANIFEST_OBJ1)
    $(MANIFEST_PREPROCESSOR_NAME) $(MANIFEST_PREPROCESSOR_FLAGS) -DSXS_WANT_ASSEMBLY_VERSION \
    $(SXS_MANIFEST_DEFINES) -DSXS_PRE=-pdb:$O\$(SXS_PDB_WOW6432_W_PREFIX)$(SXS_ASSEMBLY_NAME:.=) \
    -DSXS_POST=$(TARGETNAME:.=).pdb $(MANIFEST_VERSION_HEADER) | $(MANIFEST_TRIMMER) > $@
!endif

#
# [GorN] 3/30/2000
#
#    WPP. extra rules. Can't have them before the rule to build "all"
#

!if defined(RUN_WPP) && exist(obj\_tracewpp.mac)
WPP_DEFINE_RULES=1
!  include obj\_tracewpp.mac
!endif

!ifdef MANAGED_COVERAGE
!include $(MANAGED_COVERAGE)
!endif

