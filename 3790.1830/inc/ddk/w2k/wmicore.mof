/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wmicore.mof

Abstract:

    This file defines all of the MOF classes "built in" to WMI. Typically
    this will be for all data providers that are shipped by MS. The list
    includes:

        WMI specific internal classes
        Power Management
        NDIS
        SMBIOS Data
        Keyboard
        Mouse
        Disk
        IDE
        Serial
        Temperature via ACPI

Revision History:

--*/

#pragma classflags("forceupdate")

//
// Wmi internal classes

[abstract]
class MS_WmiInternal
{
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("This class supplies the binary mof information"),
 guid("{05901221-D566-11d1-B2F0-00A0C9062910}"),
 locale("MS\\0x409")]
class MSWmi_MofData : MS_WmiInternal
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read
    ] uint32 Unused1;

    [WmiDataId(2),
     read
    ] uint32 Unused2;



    [WmiDataId(3),
     read
    ] uint32 Size;

    [WmiDataId(4),
     read
   ] uint32 Unused4;


    [WmiDataId(5),
     WmiSizeIs("Size"),
     read
    ] uint8 BinaryMofData[];
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("This class supplies additional information about a data provider. Querying this class with an instance name returned from another class query will return additional information about the instance"),
 guid("{C7BF35D0-AADB-11d1-BF4A-00A0C9062910}"),
 locale("MS\\0x409")]
class MSWmi_ProviderInfo : MS_WmiInternal
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    // CM_DRP_FRIENDLY_NAME
    [WmiDataId(1),
     read
    ] string FriendlyName;

    // CM_DRP_DEVICEDESC
    [WmiDataId(2),
     read
    ] string Description;

    // CM_DRP_LOCATION_INFORMATION
    [WmiDataId(3),
     read
    ] string Location;

    // CM_DRP_MFG
    [WmiDataId(4),
     read
    ] string Manufacturer;

    // CM_DRP_SERVICE
    [WmiDataId(5),
     read
    ] string Service;

    // CONSIDER: adding device capabilities
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("This class supplies the PnPDeviceId for a specific device"),
 guid("{C7BF35D2-AADB-11d1-BF4A-00A0C9062910}"),
 GuidName1("DATA_PROVIDER_PNPID_GUID"),
 locale("MS\\0x409")]
class MSWmi_PnPDeviceId : MS_WmiInternal
{
//
// Note to driver developers:
//
//    Support for this guid is required if properties in the wmi namespace
//    are to be mapped into another namespace via the view provider. 
//
//    This guid is automatically supported by WMI if the following conditions
//    are met:
//
//    1. The device registers with PDO instance names for all guids
//       (ie, WMIREG_FLAG_PDO_INSTANCE_NAMES)
//
//    If the driver cannot follow the rules above and WMI cannot support 
//    the guid automatically, then the driver can support it in its own
//    driver code. 


    [key, read]
     string InstanceName;
    [read] boolean Active;

    // Pnp device id
    [WmiDataId(1),
     Description("PnP Device Id for the device. This property is useful for mapping from the wmi namespace to the cimv2 namespace classes using the view provider"),
     read
    ] string PnPDeviceId;
};


[Dynamic, Provider("WMIProv"),
 WMI,
 Description("This class supplies the Instance names associated with a PnP Device Instance Id"),
 guid("{C7BF35D3-AADB-11d1-BF4A-00A0C9062910}"),
 GuidName1("DATA_PROVIDER_PNPID_INSTANCE_NAMES_GUID"),
 locale("MS\\0x409")]
class MSWmi_PnPInstanceNames : MS_WmiInternal
{
//
// Note to driver developers:
//
//    Support for this guid is required if properties in the wmi namespace
//    are to be mapped into another namespace via the view provider. 
//
//    This guid is automatically supported by WMI if the following conditions
//    are met:
//
//    1. The device registers with PDO instance names for all guids
//       (ie, WMIREG_FLAG_PDO_INSTANCE_NAMES)
//
//    If the driver cannot follow the rules above and WMI cannot support 
//    the guid automatically, then the driver can support it in its own
//    driver code. 


    [key, read]
     string InstanceName;
    [read] boolean Active;

    // Pnp device id
    [WmiDataId(1),
     Description("Count of instance names associated with this PnPId"),
     read
    ] uint32 Count;

    // Instance names
    [WmiDataId(2),
     WmiSizeIs("Count"),
     Description("Wmi Instance Names for the device. This property is useful for mapping from the wmi namespace to the cimv2 namespace classes using the view provider"),
     read
    ] string InstanceNameList[];
};

//
// SMBIOS data classes
//
[abstract]
class MS_SmBios
{
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("Raw SMBIOS Tables"),
 guid("{8F680850-A584-11d1-BF38-00A0C9062910}"),
 locale("MS\\0x409")

]
class MSSmBios_RawSMBiosTables : MS_SmBios
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read
    ] boolean Used20CallingMethod;

    [WmiDataId(2),
     read
    ] uint8 SmbiosMajorVersion;

    [WmiDataId(3),
     read
    ] uint8 SmbiosMinorVersion;

    [WmiDataId(4),
     read
    ] uint8 DmiRevision;


    [WmiDataId(5),
     read
    ] uint32 Size;

    [WmiDataId(6),
     WmiSizeIs("Size"),
     read
    ] uint8 SMBiosData[];

};

//
// Power management classes

[abstract]
class MSPower
{
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("The control sets whether the device should dynamically power on and off while the system is working."),
 guid("827c0a6f-feb0-11d0-bd26-00aa00b7b32a"),
 locale("MS\\0x409")]
class MSPower_DeviceEnable : MSPower
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read,
     write] boolean Enable;
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("This control indicates whether the device should be configured to wake a sleeping system."),
 guid("a9546a82-feb0-11d0-bd26-00aa00b7b32a"),
 locale("MS\\0x409")]
class MSPower_DeviceWakeEnable : MSPower
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read,
     write] boolean Enable;
};


//
// NDIS classes

[abstract]
class MSNdis
{
};

[WMI,
  guid("{B5BD98B7-0201-11d1-A50E-00A0C9062910}")]
class MSNdis_NetworkAddress : MSNdis
{
    [read, WmiDataId(1)]
      uint8    Address[6];
};

[WMI,
 guid("{B5BD98B8-0201-11d1-A50E-00A0C9062910}")]
class MSNdis_NetworkShortAddress : MSNdis
{
    [read, WmiDataId(1)]
      uint8    Address[2];
};

[WMI,
 guid("{60fc6b57-0f66-11d1-96a7-00c04fc3358c}")]
class MSNdis_NetworkLinkSpeed : MSNdis
{
	[read, WmiDataId(1)]    uint32	Outbound;
	[read, WmiDataId(2)]    uint32	Inbound;
};

///
///	GUIDs that do not translate to OIDs
///
///

[WMI, Dynamic, Provider("WMIProv"),
 guid("{981f2d7f-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Enumerate Adapter")]
class MSNdis_EnumerateAdapter : MSNdis
{
    [key, read]
    string		InstanceName;

    [read]
    boolean		Active;

    [read,
     Description("Device name."),
     WmiDataId(1)]    string	DeviceName;
};

[WMI, Dynamic, Provider("WMIProv"),
 guid("{981f2d80-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Notify Adapter Removal")]
class MSNdis_NotifyAdapterRemoval : WMIEvent
{
    [key, read]
    string		InstanceName;

    [read]
    boolean		Active;

    [read,
     Description("Device name."),
     WmiDataId(1)]    string	DeviceName;
};

[WMI, Dynamic, Provider("WMIProv"),
 guid("{981f2d81-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Notify Adapter Arrival")]
class MSNdis_NotifyAdapterArrival : WMIEvent
{
    [key, read]
    string		InstanceName;

    [read]
    boolean		Active;

    [read,
     Description("Device name."),
     WmiDataId(1)]    string	DeviceName;
};


[WMI, Dynamic, Provider("WMIProv"),
 guid("{981f2d82-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Enumerate VC")]
class MSNdis_NdisEnumerateVc : MSNdis
{
    [key, read]
    string		InstanceName;

    [read]
    boolean		Active;
};

[WMI, Dynamic, Provider("WMIProv"),
 guid("{981f2d79-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Notify VC Removal")]
class MSNdis_NotifyVcRemoval : WmiEvent
{
    [key, read]
    string		InstanceName;

    [read]
    boolean		Active;
};

[WMI, Dynamic, Provider("WMIProv"),
 guid("{182f9e0c-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Notify VC Arrival")]
class MSNdis_NotifyVcArrival : WMIEvent
{
    [key, read]
    string		InstanceName;

    [read]
    boolean		Active;
};


///
///
/// 	General GUIDs
///
///
[WMI, Dynamic, Provider("WMIProv"),
 guid("{5ec10354-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Hardware Status")]
class MSNdis_HardwareStatus : MSNdis
{
    [key, read]
    string		InstanceName;

    [read]
    boolean		Active;

    [read,
     Description("Current hardware status of the underlying NIC."),
     Values{"NdisHardwareStatusReady",
             "NdisHardwareStatusInitializing",
             "NdisHardwareStatusReset",
             "NdisHardwareStatusClosing",
             "NdisHardwarestatusNotReady"},
     ValueMap{"0",
             "1",
             "2",
             "3",
             "4"},
     WmiDataId(1)]    uint32    NdisHardwareStatus;

//
//	This is of the type:
//	typedef enum _NDIS_HARDWARE_STATUS
//	{
//	 	NdisHardwareStatusReady,
//		NdisHardwareStatusInitializing,
//		NdisHardwareStatusReset,
//		NdisHardwareStatusClosing,
//		NdisHardwarestatusNotReady
//	} NDIS_HARDWARE_STATUS, *PNDIS_HARDWARE_STATUS;
//
};

[WMI,Dynamic, Provider("WMIProv"),
 guid("{5ec10355-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Media Types Supported")]
class MSNdis_MediaSupported : MSNdis
{
    [key, read]
	string		InstanceName;

    [read]
    boolean		Active;

	[read,
     	Description("Number of media types supported."),
		WmiDataId(1)]    uint32  NumberElements;
    [read,
     	Description("List of media types the NIC supports."),
		WmiDataId(2),
		WmiSizeIs("NumberElements")]    uint32    NdisMediaSupported[];
};

[WMI,Dynamic, Provider("WMIProv"),
 guid("{5ec10356-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Media Types In Use")]
class  MSNdis_MediaInUse : MSNdis
{
    [key, read]
	string		InstanceName;

    [read]
	boolean		Active;

	[read,
     	Description("Number of media types in use."),
		WmiDataId(1)]    uint32  NumberElements;
    [read,
     	Description("List of media types the NIC is currently supporting."),
		WmiDataId(2),
		WmiSizeIs("NumberElements")]    uint32    NdisMediaInUse[];
};

[WMI, Dynamic, Provider("WMIProv"),guid("{5ec10357-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Maximum Lookahead Supported")]
class  MSNdis_MaximumLookahead : MSNdis
{
    [key, read]
	string		InstanceName;

	[read]
	boolean		Active;

    [read,
     	Description("The maximum number of bytes the NIC can always provide as lookahead data."),
		WmiDataId(1)]    uint32    NdisMaximumLookahead;
};



[WMI, Dynamic, Provider("WMIProv"),guid("{5ec10358-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Maximum Frame Size")]
class  MSNdis_MaximumFrameSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The maximum network packet size in bytes the NIC supports, not including a header."),
		WmiDataId(1)]    uint32    NdisMaximumFrameSize;
};

[WMI, Dynamic, Provider("WMIProv"),guid("{5ec10359-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Link Speed")]
class  MSNdis_LinkSpeed : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The maximum speed of the NIC (kbps)."),
		WmiDataId(1)]    uint32    NdisLinkSpeed;
};

[WMI, Dynamic, Provider("WMIProv"),guid("{5ec1035a-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Transmit Buffer Space")]
class  MSNdis_TransmitBufferSpace : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The amount of memory, in bytes, on the NIC available for buffering transmit data."),
		WmiDataId(1)]    uint32    NdisTransmitBufferSpace;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec1035b-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Receive Buffer Space")]
class  MSNdis_ReceiveBufferSpace : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The amount of memory on the NIC available for buffering receive data."),
		WmiDataId(1)]    uint32    NdisReceiveBufferSpace;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec1035c-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Transmit Block Size")]
class  MSNdis_TransmitBlockSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The minimum number of bytes that a single net packet occupies in the transmit buffer space of the NIC."),
		WmiDataId(1)]    uint32    NdisTransmitBlockSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec1035d-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Receive Block Size")]
class  MSNdis_ReceiveBlockSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The amount of storage, in bytes, that a single packet occupies in the receive buffer space of the NIC."),
		WmiDataId(1)]    uint32    NdisReceiveBlockSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec1035e-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Vendor ID")]
class  MSNdis_VendorID : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("A three-byte IEEE-registered vendor code, followed by a single byte the vendor assigns to identify a particular NIC."),
		WmiDataId(1)]    uint32    NdisVendorID;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec1035f-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Vendor Description")]
class  MSNdis_VendorDescription : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Zero-terminated string describing the NIC."),
		WmiDataId(1)]    string    NdisVendorDescription;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec10360-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Current Packet Filter")]
class  MSNdis_CurrentPacketFilter : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Current packet types that will be received and indicated by the NIC."),
		WmiDataId(1)]    uint32    NdisCurrentPacketFilter;

//
//	This is an inclusive OR of the following types:
//
//      NDIS_PACKET_TYPE_DIRECTED				0x00000001
//      NDIS_PACKET_TYPE_MULTICAST				0x00000002
//      NDIS_PACKET_TYPE_ALL_MULTICAST          0x00000004
//      NDIS_PACKET_TYPE_BROADCAST              0x00000008
//		NDIS_PACKET_TYPE_SOURCE_ROUTING         0x00000010
//		NDIS_PACKET_TYPE_PROMISCUOUS            0x00000020
//      NDIS_PACKET_TYPE_SMT                    0x00000040
//      NDIS_PACKET_TYPE_ALL_LOCAL              0x00000080
//      NDIS_PACKET_TYPE_GROUP                  0x00001000
//		NDIS_PACKET_TYPE_ALL_FUNCTIONAL         0x00002000
//      NDIS_PACKET_TYPE_FUNCTIONAL             0x00004000
//      NDIS_PACKET_TYPE_MAC_FRAME				0x00008000
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec10361-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Current Lookahead")]
class  MSNdis_CurrentLookahead : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of bytes of received packet data, excluding the header, that will be indicated to the protocol driver."),
		WmiDataId(1)]    uint32    NdisCurrentLookahead;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec10362-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Driver Version")]
class  MSNdis_DriverVersion : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The NDIS version in use by the NIC driver."),
		WmiDataId(1)]    uint16    NdisDriverVersion;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec10363-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Maximum Packet Total Size")]
class  MSNdis_MaximumTotalSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The maximum total packet length, in bytes, the NIC supports, including the header."),
		WmiDataId(1)]    uint32    NdisMaximumTotalSize;
};

//
//	This is an inclusive OR of the following types:
//
//		NDIS_PROT_OPTION_ESTIMATED_LENGTH		0x00000001
//		NDIS_PROT_OPTION_NO_LOOPBACK			0x00000002
//		NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT		0x00000004
//

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec10365-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS MAC Options")]
class  MSNdis_MacOptions : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("A bitmask that defines optional properties of the underlying driver or its NIC."),
		WmiDataId(1)]    uint32    NdisMacOptions;

//
//	This is an inclusive OR of the following types:
//	
//		NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA     0x00000001
//		NDIS_MAC_OPTION_RECEIVE_SERIALIZED      0x00000002
//		NDIS_MAC_OPTION_TRANSFERS_NOT_PEND      0x00000004
//		NDIS_MAC_OPTION_NO_LOOPBACK             0x00000008
//  	NDIS_MAC_OPTION_FULL_DUPLEX             0x00000010
//  	NDIS_MAC_OPTION_EOTX_INDICATION         0x00000020
//  	NDIS_MAC_OPTION_RESERVED                0x80000000
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec10366-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Media Connect Status")]
class  MSNdis_MediaConnectStatus : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The connection status of the NIC on the network."),
        Values{"NdisMediaStateConnected",
                "NdisMediaStateDisconnected"},
        ValueMap{"0",
                "1"},
		WmiDataId(1)]    uint32    NdisMediaConnectStatus;

//
//
//
// Defines the state of the LAN media
//
//	typedef enum _NDIS_MEDIA_STATE
//	{
//		NdisMediaStateConnected,
//		NdisMediaStateDisconnected
//	} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;
//
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{5ec10367-a61a-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Maximum Send Packets")]
class  MSNdis_MaximumSendPackets : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The maximum number of send packets the MiniportSendPackets function can accept."),
		WmiDataId(1)]    uint32    NdisMaximumSendPackets;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{447956f9-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Vendor's Driver Version")]
class  MSNdis_VendorDriverVersion : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The vendor-assigned version number of the NIC driver."),
		WmiDataId(1)]    uint32    NdisVendorDriverVersion;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{447956fa-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Transmits OK")]
class  MSNdis_TransmitsOk : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames transmitted without errors"),
		WmiDataId(1)]    uint32    NdisTransmitsOk;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{447956fb-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Receives OK")]
class  MSNdis_ReceivesOk : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames the NIC receives without errors and indicates to bound protocols."),
		WmiDataId(1)]    uint32    NdisReceivesOk;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{447956fc-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Transmit Errors")]
class  MSNdis_TransmitsError : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames a NIC fails to transmit."),
		WmiDataId(1)]    uint32    NdisTransmitsError;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{447956fd-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Receive Errors")]
class  MSNdis_ReceiveError : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames a NIC receives but does not indicate to the protocols due to errors."),
		WmiDataId(1)]    uint32    NdisReceiveError;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{447956fe-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Receive No Buffer")]
class  MSNdis_ReceiveNoBuffer : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames the NIC cannot receive due to lack of NIC receive buffer space."),
		WmiDataId(1)]    uint32    NdisReceiveNoBuffer;
};

///
///
///	CoNDIS general GUIDs
///
///

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad192-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Hardware Status")]
class  MSNdis_CoHardwareStatus : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     Description("Current hardware status of the underlying NIC."),
		WmiDataId(1)]    uint32	NdisCoHardwareStatus;
};


[WMI, Dynamic, Provider("WMIProv"), guid("{791ad193-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Media Types Supported")]
class  MSNdis_CoMediaSupported : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Number of media types supported."),
		WmiDataId(1)]    uint32  NumberElements;
    [read,
     	Description("List of media types the NIC supports."),
		WmiDataId(2),
		WmiSizeIs("NumberElements")]    uint32    NdisCoMediaSupported[];
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad194-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Media Types In Use")]
class  MSNdis_CoMediaInUse : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Number of media types in use."),
		WmiDataId(1)]    uint32  NumberElements;
    [read,
     	Description("List of media types the NIC is currently supporting."),
		WmiDataId(2),
		WmiSizeIs("NumberElements")]    uint32    NdisCoMediaInUse[];
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad195-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Link Speed")]
class  MSNdis_CoLinkSpeed : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The maximum inbound and outbound speeds of the NIC (kbps)."),
		WmiDataId(1)]	MSNdis_NetworkLinkSpeed	NdisCoLinkSpeed;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad196-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Vendor ID")]
class  MSNdis_CoVendorId : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("A three-byte IEEE-registered vendor code, followed by a single byte the vendor assigns to identify a particular NIC."),
		WmiDataId(1)]    uint32    NdisCoVendorID;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad197-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Vendor Description")]
class  MSNdis_CoVendorDescription : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Zero-terminated string describing the NIC."),
		WmiDataId(1)]    string    NdisCoVendorDescription;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad198-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Driver Version")]
class  MSNdis_CoDriverVersion : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The NDIS version in use by the NIC driver."),
		WmiDataId(1)]    uint16    NdisCoDriverVersion;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad19a-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS MAC Options")]
class  MSNdis_CoMacOptions : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("A bitmask that defines optional properties of the underlying driver or its NIC."),
		WmiDataId(1)]    uint32    NdisCoMacOptions;
//
//
//	NDIS MAC option bits for OID_GEN_CO_MAC_OPTIONS.
//
//		#define	NDIS_CO_MAC_OPTION_DYNAMIC_LINK_SPEED	0x00000001
//
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad19b-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Media Connect Status")]
class  MSNdis_CoMediaConnectStatus : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The connection status of the NIC on the network."),
        Values{"NdisMediaStateConnected",
                "NdisMediaStateDisconnected"},
        ValueMap{"0",
                "1"},
		WmiDataId(1)]    uint32    NdisCoMediaConnectStatus;
//
//
//
// Defines the state of the LAN media
//
//	typedef enum _NDIS_MEDIA_STATE
//	{
//		NdisMediaStateConnected,
//		NdisMediaStateDisconnected
//	} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad19c-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Vendor's Driver Version")]
class  MSNdis_CoVendorDriverVersion : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The vendor-assigned version number of the NIC driver."),
		WmiDataId(1)]    uint32    NdisCoVendorDriverVersion;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad19d-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Minimum Link Speed")]
class  MSNdis_CoMinimumLinkSpeed : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The maximum inbound and outbound speeds of the NIC (kbps)."),
		WmiDataId(1)]	MSNdis_NetworkLinkSpeed	NdisCoMinimumLinkSpeed;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{0a214805-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Transmits PDUs OK")]
class  MSNdis_CoTransmitPdusOk : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of PDUs transmitted without errors"),
		WmiDataId(1)]    uint32    NdisCoTransmitPdusOk;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{0a214806-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Receive PDUs OK")]
class  MSNdis_CoReceivePdusOk : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of PDUs the NIC receives without errors and indicates to bound protocols."),
		WmiDataId(1)]    uint32    NdisCoReceivePdusOk;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{0a214807-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Transmit PDU Errors")]
class  MSNdis_CoTransmitPduErrors : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of PDUs a NIC fails to transmit."),
		WmiDataId(1)]    uint32    NdisCoTransmitPduErrors;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{0a214808-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Receive PDU Errors")]
class  MSNdis_CoReceivePduErrors : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of PDUs a NIC receives but does not indicate to the protocols due to errors."),
		WmiDataId(1)]    uint32    NdisCoReceivePduErrors;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{0a214809-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("CoNDIS Receive PDUs No Buffer")]
class  MSNdis_CoReceivePdusNoBuffer : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of PDUs the NIC cannot receive due to lack of NIC receive buffer space."),
		WmiDataId(1)]    uint32    NdisCoReceivePdusNoBuffer;
};

///
///
///	ATM media specific GUIDs
///
///
[WMI, Dynamic, Provider("WMIProv"), guid("{791ad19e-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Supported VC Rates")]
class  MSNdis_AtmSupportedVcRates : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Minimum cell rate supported."),
		WmiDataId(1)]    uint32	MinCellRate;

	[read,
		Description("Maximum cell rate supported."),
		WmiDataId(2)]	uint32	MaxCellRate;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad19f-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Supported Service Category")]
class  MSNdis_AtmSupportedServiceCategory : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Bit mask defining the service categories supported by the hardware."),
		WmiDataId(1)]    uint32	NdisAtmSupportedServiceCategory;

//
//	This can be a combination of following defines:
//
//      #define ATM_SERVICE_CATEGORY_CBR    1   // Constant Bit Rate
//      #define ATM_SERVICE_CATEGORY_VBR    2   // Variable Bit Rate
//      #define ATM_SERVICE_CATEGORY_UBR    4   // Unspecified Bit Rate
//  	#define ATM_SERVICE_CATEGORY_ABR    8   // Available Bit Rate
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a0-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Supported AAL Types")]
class  MSNdis_AtmSupportedAalTypes : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Bit mask defining the AAL types supported by the hardware."),
		WmiDataId(1)]    uint32	NdisAtmSupportedAalTypes;
//
//	This can be a combination of the following defines:
//
//      #define AAL_TYPE_AAL0           1
//      #define AAL_TYPE_AAL1           2
//      #define AAL_TYPE_AAL34          4
//      #define AAL_TYPE_AAL5           8
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a1-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Hardware Current Address")]
class  MSNdis_AtmHardwareCurrentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The address of the NIC encoded in the hardware."),
		WmiDataId(1)]    MSNdis_NetworkAddress     NdisAtmHardwareCurrentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a2-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Maximum Active VCs")]
class  MSNdis_AtmMaxActiveVcs : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Maximum number of active VCs the adapter can support."),
		WmiDataId(1)]    uint32	NdisAtmMaxActiveVcs;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a3-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Maximum Active VCI Bits")]
class  MSNdis_AtmMaxActiveVciBits : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of bits controllable in the VCI field of the cell header."),
		WmiDataId(1)]    uint32	NdisAtmMaxActiveVciBits;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a4-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Maximum Active VPI Bits")]
class  MSNdis_AtmMaxActiveVpiBits : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of bits controllable in the VPI field of the cell header."),
		WmiDataId(1)]	uint32	NdisAtmMaxActiveVpiBits;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a5-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Maximum AAL0 Packet Size")]
class  MSNdis_AtmMaxAal0PacketSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Maximum supported size for AAL0 packets."),
		WmiDataId(1)]    uint32	NdisAtmMaxAal0PacketSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a6-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Maximum AAL1 Packet Size")]
class  MSNdis_AtmMaxAal1PacketSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Maximum supported size for AAL1 packets."),
		WmiDataId(1)]    uint32	NdisAtmMaxAal1PacketSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad1a7-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Maximum AAL3/4 Packet Size")]
class  MSNdis_AtmMaxAal34PacketSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Maximum supported size for AAL3/4 packets."),
		WmiDataId(1)]    uint32	NdisAtmMaxAal34PacketSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{791ad191-e35c-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Maximum AAL5 Packet Size")]
class  MSNdis_AtmMaxAal5PacketSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Maximum supported size for AAL5 packets."),
		WmiDataId(1)]    uint32	NdisAtmMaxAal5PacketSize;
};


[WMI, Dynamic, Provider("WMIProv"), guid("{0a21480a-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Receive Cells OK")]
class  MSNdis_AtmReceiveCellsOk : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of cells the NIC has received without errors."),
		WmiDataId(1)]    uint64	NdisAtmReceiveCellsOk;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{0a21480b-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Transmit Cells OK")]
class  MSNdis_AtmTransmitCellsOk : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of cells the NIC has transmitted without errors."),
		WmiDataId(1)]    uint64	NdisAtmTransmitCellsOk;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{0a21480c-e35f-11d0-9692-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS ATM Receive Cells Dropped")]
class  MSNdis_AtmReceiveCellsDropped : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of receive cells the NIC has dropped."),
		WmiDataId(1)]    uint64	NdisAtmReceiveCellsDropped;
};

///
///
/// 	Ethernet specific GUIDs
///	
///

[WMI, Dynamic, Provider("WMIProv"), guid("{447956ff-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Ethernet Permanent Address")]
class  MSNdis_EthernetPermanentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The address of the NIC encoded in the hardware."),
		WmiDataId(1)]    MSNdis_NetworkAddress     NdisPermanentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795700-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Ethernet Current Address")]
class  MSNdis_EthernetCurrentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The address the NIC is currently using."),
		WmiDataId(1)]    MSNdis_NetworkAddress     NdisCurrentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795701-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Ethernet Multicast List")]
class  MSNdis_EthernetMulticastList : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Number of multicast addresses enabled on the NIC."),
		WmiDataId(1)] uint32 NumberElements;

	[read,
     	Description("The multicast address list on the NIC enabled for packet reception."),
		WmiDataId(2),
		WmiSizeIs("NumberElements")]    MSNdis_NetworkAddress NdisMulticastList[];
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795702-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("Adpater Ethernet Maximum Multicast List Size")]
class  MSNdis_EthernetMaximumMulticastListSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The maximum number of multicast addresses the NIC driver can manage."),
		WmiDataId(1)]    uint32    NdisEthernetMaximumMulticastListSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795703-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Ethernet MAC Options")]
class  MSNdis_EthernetMacOptions : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("Features supported by the underlying driver, which could be emulating Ethernet."),
		WmiDataId(1)]    uint32    NdisEthernetMacOptions;

//
//	Supported values:
//
//		NDIS_802_3_MAC_OPTION_PRIORITY		0x00000001
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795704-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Ethernet Receive Error Alignment")]
class  MSNdis_EthernetReceiveErrorAlignment : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames received with alignment errors."),
		WmiDataId(1)]    uint32    NdisEthernetReceiveErrorAlignment;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795705-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Ethernet One Transmit collision")]
class    MSNdis_EthernetOneTransmitCollision : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames successfully transmitted after exactly one collision."),
		WmiDataId(1)]    uint32    NdisEthernetOneTransmitCollision;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795706-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Ethernet More Transmit collisions")]
class  MSNdis_EthernetMoreTransmitCollisions : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The number of frames successfully transmitted after more than one collision."),
		WmiDataId(1)]    uint32    NdisEthernetMoreTransmitCollisions;
};

///
///
/// 	Token Ring specific GUIDs
///
///
[WMI, Dynamic, Provider("WMIProv"), guid("{44795707-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Permanent Address")]
class  MSNdis_TokenRingPermanentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The address of the NIC encoded in the hardware."),
		WmiDataId(1)]    MSNdis_NetworkAddress  NdisPermanentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795708-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Current Address")]
class  MSNdis_TokenRingCurrentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The address the NIC is currently using."),
		WmiDataId(1)]    MSNdis_NetworkAddress     NdisCurrentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{44795709-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Current Functional Address")]
class  MSNdis_TokenRingCurrentFunctional : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
		Description("The functional address enabled on the NIC for packet reception."),
		WmiDataId(1)]    uint32    NdisTokenRingCurrentFunctional;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{4479570a-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Current Group Address")]
class  MSNdis_TokenRingCurrentGroup : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The group address enabled on the NIC for packet reception."),
		WmiDataId(1)]    uint32    NdisTokenRingCurrentGroup;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{4479570b-a61b-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Last Open Status")]
class  MSNdis_TokenRingLastOpenStatus : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
     	Description("The last open error status returned for a protocol's call to NdisOpenAdapter."),
		WmiDataId(1)]    uint32    NdisTokenRingLastOpenStatus;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{890a36ec-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Current Ring Status")]
class  MSNdis_TokenRingCurrentRingStatus : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
		Description("The last ring status indicated with an NDIS_RING_XXX status code."),
		WmiDataId(1)]    uint32    NdisTokenRingCurrentRingStatus;

//
//	This can be one of the following values:
//
//  NDIS_RING_SIGNAL_LOSS                   0x00008000
//  NDIS_RING_HARD_ERROR                    0x00004000
//  NDIS_RING_SOFT_ERROR                    0x00002000
//  NDIS_RING_TRANSMIT_BEACON               0x00001000
//  NDIS_RING_LOBE_WIRE_FAULT               0x00000800
//  NDIS_RING_AUTO_REMOVAL_ERROR            0x00000400
//  NDIS_RING_REMOVE_RECEIVED               0x00000200
//  NDIS_RING_COUNTER_OVERFLOW              0x00000100
//  NDIS_RING_SINGLE_STATION                0x00000080
//	NDIS_RING_RING_RECOVERY                 0x00000040
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14032-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Current Ring State.")]
class  MSNdis_TokenRingCurrentRingState : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
	[read,
		Description("The state of the NIC driver with repsect to entering the ring."),
                Values{"NdisRingStateOpened",
                        "NdisRingStateClosed",
                        "NdisRingStateOpening",
                        "NdisRingStateClosing",
                        "NdisRingStateOpenFailure",
                        "NdisRingStateRingFailure"},
                ValueMap{"1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6"},
		WmiDataId(1)]    uint32    NdisTokenRingCurrentRingState;

//
//	This is defined as follows:
//
//		typedef enum _NDIS_802_5_RING_STATE
//		{
//   		NdisRingStateOpened = 1,
//   		NdisRingStateClosed,
//   		NdisRingStateOpening,
//   		NdisRingStateClosing,
//   		NdisRingStateOpenFailure,
//   		NdisRingStateRingFailure
//		} NDIS_802_5_RING_STATE, *PNDIS_802_5_RING_STATE;
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14033-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Line Errors")]
class  MSNdis_TokenRingLineErrors : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("Number of frames with an invalid FCS or a code violation."),
		WmiDataId(1)]    uint32    NdisTokenRingLineErrors;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14034-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Token Ring Lost Frames")]
class  MSNdis_TokenRingLostFrames : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The number of frames transmitted that have not circled the ring within the maximum ring latency."),
		WmiDataId(1)]    uint32    NdisTokenRingLostFrames;
};

///
///
/// 	FDDI specific GUIDs
///
///

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14035-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Long Permanent Address")]
class  MSNdis_FddiLongPermanentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The long address of the NIC encoded in the hardware."),
		WmiDataId(1)]    MSNdis_NetworkAddress     NdisPermanentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14036-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Long Current Address")]
class  MSNdis_FddiLongCurrentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The long address the NIC is currently using."),
		WmiDataId(1)]    MSNdis_NetworkAddress     NdisCurrentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14037-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Long Multicast List")]
class  MSNdis_FddiLongMulticastList : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("Number of multicast addresses enabled on the NIC."),
		WmiDataId(1)] uint32 NumberElements;
    [read,
		Description("The multicast long address list on the NIC enabled for packet reception."),
		WmiDataId(2), WmiSizeIs("NumberElements")]
                MSNdis_NetworkAddress NdisMulticastList[];
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14038-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Long Maximum List Size")]
class  MSNdis_FddiLongMaximumListSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The maximum number of multicast long addresses the NIC driver can manage."),
		WmiDataId(1)]    uint32    NdisFddiLongMaximumListSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14039-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Short Permanent Address")]
class  MSNdis_FddiShortPermanentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The short address of the NIC encoded in the hardware."),
		WmiDataId(1)]    MSNdis_NetworkShortAddress     NdisPermanentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf1403a-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Short Current Address")]
class  MSNdis_FddiShortCurrentAddress : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The short address the NIC is currently using."),
		WmiDataId(1)]    MSNdis_NetworkShortAddress     NdisCurrentAddress;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf1403b-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Short Multicast List")]
class  MSNdis_FddiShortMulticastList : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("Number of multicast short addresses enabled on the NIC."),
		WmiDataId(1)] uint32 NumberElements;
    [read,
		Description("The multicast short address list on the NIC enabled for packet reception."),
		WmiDataId(2),
		WmiSizeIs("NumberElements")]    MSNdis_NetworkShortAddress NdisMulticastList[];
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf1403c-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Short Maximum List Size")]
class  MSNdis_FddiShortMaximumListSize : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The maximum number of multicast short addresses the NIC driver can manage."),
		WmiDataId(1)]    uint32    NdisFddiShortMaximumListSize;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf1403d-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Attachment Type")]
class  MSNdis_FddiAttachmentType : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("Defines the attachment of the NIC to the network."),
                Values{"NdisFddiTypeIsolated",
                        "NdisFddiTypeLocalA",
                        "NdisFddiTypeLocalB",
                        "NdisFddiTypeLocalAB",
                        "NdisFddiTypeLocalS",
                        "NdisFddiTypeWrapA",
                        "NdisFddiTypeWrapB",
                        "NdisFddiTypeWrapAB",
                        "NdisFddiTypeWrapS",
                        "NdisFddiTypeCWrapA",
                        "NdisFddiTypeCWrapB",
                        "NdisFddiTypeCWrapS",
                        "NdisFddiTypeThrough"},
                ValueMap{"1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6",
                        "7",
                        "8",
                        "9",
                        "10",
                        "11",
                        "12",
                        "13"},
		WmiDataId(1)]    uint32    NdisFddiAttachmentType;

//
//	This can be of the following type:
//
//		typedef enum _NDIS_FDDI_ATTACHMENT_TYPE
//	    {
//	        NdisFddiTypeIsolated = 1,
//	        NdisFddiTypeLocalA,
//	        NdisFddiTypeLocalB,
//	        NdisFddiTypeLocalAB,
//	        NdisFddiTypeLocalS,
//	        NdisFddiTypeWrapA,
//	        NdisFddiTypeWrapB,
//	        NdisFddiTypeWrapAB,
//	        NdisFddiTypeWrapS,
//	        NdisFddiTypeCWrapA,
//	        NdisFddiTypeCWrapB,
//	        NdisFddiTypeCWrapS,
//	        NdisFddiTypeThrough
//	    } NDIS_FDDI_ATTACHMENT_TYPE, *PNDIS_FDDI_ATTACHMENT_TYPE;
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf1403e-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Upstream Node Long")]
class  MSNdis_FddiUpstreamNodeLong : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The long address of the station above this NIC on the ring or zero if the address is unknown."),
		WmiDataId(1)]    MSNdis_NetworkAddress  NdisFddiUpstreamNodeLong;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf1403f-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Downstream Node Long")]
class  MSNdis_FddiDownstreamNodeLong : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The long address of the station below this NIC on the ring or zero if the address is unknown."),
		WmiDataId(1)]    MSNdis_NetworkAddress  NdisFddiDownstreamNodeLong;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14040-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Frame Errors")]
class  MSNdis_FddiFrameErrors : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The number of frames detected in error by this NIC that have not been detected in error by another device on the ring."),
		WmiDataId(1)]    uint32    NdisFddiFrameErrors;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14041-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Frames Lost")]
class  MSNdis_FddiFramesLost : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The number of times this NIC detected a format error during frame reception such that the frame was stripped."),
		WmiDataId(1)]    uint32    NdisFddiFramesLost;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14042-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI Ring Management State")]
class  MSNdis_FddiRingManagmentState : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("Defines the current state of the Ring Management state machine."),
                Values{"NdisFddiRingIsolated",
                        "NdisFddiRingNonOperational",
                        "NdisFddiRingOperational",
                        "NdisFddiRingDetect",
                        "NdisFddiRingNonOperationalDup",
                        "NdisFddiRingOperationalDup",
                        "NdisFddiRingDirected",
                        "NdisFddiRingTrac"},
                ValueMap{"1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6",
                        "7",
                        "8"},
		WmiDataId(1)]    uint32    NdisFddiRingManagmentState;

//
//	This can be of the following type:
//
//		typedef enum _NDIS_FDDI_RING_MGT_STATE
//      {
//          NdisFddiRingIsolated = 1,
//          NdisFddiRingNonOperational,
//          NdisFddiRingOperational,
//          NdisFddiRingDetect,
//          NdisFddiRingNonOperationalDup,
//          NdisFddiRingOperationalDup,
//          NdisFddiRingDirected,
//          NdisFddiRingTrace
//      } NDIS_FDDI_RING_MGT_STATE, *PNDIS_FDDI_RING_MGT_STATE;
//
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14043-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI LCT Failures")]
class  MSNdis_FddiLctFailures : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The count of the consecutive times the link confidence test (LCT) has failed during connection management."),
		WmiDataId(1)]    uint32    NdisFddiLctFailures;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14044-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI LEM Rejects")]
class  MSNdis_FddiLemRejects : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("The link error monitor (LEM) count of times that a link was rejected."),
		WmiDataId(1)]    uint32    NdisFddiLemRejects;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{acf14045-a61c-11d0-8dd4-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS FDDI LConnect State")]
class  MSNdis_FddiLConnectionState : MSNdis
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("Defines the state of this port's Physical Connection Management (PCM) state machine."),
                Values{"NdisFddiStateOff",
                        "NdisFddiStateBreak",
                        "NdisFddiStateTrace",
                        "NdisFddiStateConnect",
                        "NdisFddiStateNext",
                        "NdisFddiStateSignal",
                        "NdisFddiStateJoin",
                        "NdisFddiStateVerify",
                        "NdisFddiStateActive",
                        "NdisFddiStateMaintenance"},
                ValueMap{"1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6",
                        "7",
                        "8",
                        "9",
                        "10"},
		WmiDataId(1)]    uint32    NdisFddiLConnectionState;
//
//	This can be of the following type:
//
//		typedef enum _NDIS_FDDI_LCONNECTION_STATE
//      {
//          NdisFddiStateOff = 1,
//          NdisFddiStateBreak,
//          NdisFddiStateTrace,
//          NdisFddiStateConnect,
//          NdisFddiStateNext,
//          NdisFddiStateSignal,
//          NdisFddiStateJoin,
//          NdisFddiStateVerify,
//          NdisFddiStateActive,
//          NdisFddiStateMaintenance
//      } NDIS_FDDI_LCONNECTION_STATE, *PNDIS_FDDI_LCONNECTION_STATE;
//

};


///
///
/// 	NDIS status specific GUIDs
///
///


[WMI, Dynamic, Provider("WMIProv"), guid("{981f2d76-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Status Reset Start")]
class  MSNdis_StatusResetStart : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{981f2d77-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Status Reset End")]
class  MSNdis_StatusResetEnd  : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{981f2d7d-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Status Media Connect")]
class  MSNdis_StatusMediaConnect : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{981f2d7e-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Status Media Disconnect")]
class  MSNdis_StatusMediaDisconnect : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
};

[WMI, Dynamic, Provider("WMIProv"), guid("{981f2d84-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Status Media Specific Indication")]
class  MSNdis_StatusMediaSpecificIndication  : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("Number of bytes for media specific status indication"),
		WmiDataId(1)]    uint32    NumberElements;
    [read,
		Description("Media specific status information."),
		WmiDataId(2), WmiSizeIs("NumberElements")]    uint8    NdisStatusMediaSpecificIndication[];
};

[WMI, Dynamic, Provider("WMIProv"), guid("{981f2d85-b1f3-11d0-8dd7-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Status Link Speed Change")]
class  MSNdis_StatusLinkSpeedChange  : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
		Description("New inbound and outbound link speeds for the adapter."),
		WmiDataId(1)]    MSNdis_NetworkLinkSpeed	NdisStatusLinkSpeedChange;
};

[WMI, Dynamic, Provider("WMIProv"), 
 guid("{5413531c-b1f3-11d0-d78d-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Protocol Bind Notification")]
class  MSNdis_StatusProtocolBind  : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
     Description("Name of transport bound"),
     WmiDataId(1)]    string Transport;
};

[WMI, Dynamic, Provider("WMIProv"), 
 guid("{6e3ce1ec-b1f3-11d0-d78d-00c04fc3358c}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("NDIS Protocol Unbind Notification")]
class  MSNdis_StatusProtocolUnbind  : WMIEvent
{
	[key, read]
	string		InstanceName;
	
	[read]
	boolean		Active;
	
    [read,
     Description("Name of transport unbound"),
     WmiDataId(1)]    string Transport;
};

//
// Keyboard and Mouse

[abstract]
class MSKeyboard
{
};

class MSMouse
{
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("Keyboard port driver information"),
 guid("{4731F89A-71CB-11d1-A52C-00A0C9062910}"),
 GuidName1("KEYBOARD_PORT_WMI_STD_DATA_GUID"),
 HeaderName("KEYBOARD_PORT_WMI_STD_DATA"),
 locale("MS\\0x409")]
class MSKeyboard_PortInformation : MSKeyboard
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read,
     Values{"I8042 Connector"
             "Serial Connector",
             "USB Connector" },
     ValueMap{"0",
             "1",
             "2" },
     DefineValues{"KEYBOARD_PORT_WMI_STD_I8042",
                  "KEYBOARD_PORT_WMI_STD_SERIAL",
                  "KEYBOARD_PORT_WMI_STD_USB"},
     Description("How the keyboard is connected to the computer")]
    uint32 ConnectorType;

    [WmiDataId(2),
     read,
     Description("The DataQueueSize property indicates the size of the data queue.")]
    uint32   DataQueueSize;

    [WmiDataId(3),
     read,
     Description("Number of errors that occured on this device")]
    uint32 ErrorCount;

    [WmiDataId(4),
     read,
     Description("The NumberOfFunctionKeys property indicates the number of function keys on the keyboard.")]
    uint32   FunctionKeys;

    [WmiDataId(5),
     read,
     Description("The NumberOfIndicators property indicates the number of indicator leds on the keyboard.")]
    uint32   Indicators;
};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("Mouse port driver information"),
 guid("{4731F89C-71CB-11d1-A52C-00A0C9062910}"),
 GuidName1("POINTER_PORT_WMI_STD_DATA_GUID"),
 HeaderName("POINTER_PORT_WMI_STD_DATA"),
 locale("MS\\0x409")]
class MSMouse_PortInformation : MSMouse
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read,
     Values{"I8042 Connector"
             "Serial Connector",
             "USB Connector" },
     ValueMap{"0",
             "1",
             "2" },
     DefineValues{"POINTER_PORT_WMI_STD_I8042",
                  "POINTER_PORT_WMI_STD_SERIAL",
                  "POINTER_PORT_WMI_STD_USB"},
     Description("How the mouse is connected to the computer")]
    uint32 ConnectorType;

    [WmiDataId(2),
     read,
     Description("The DataQueueSize property indicates the size of the data queue.")]
    uint32   DataQueueSize;

    [WmiDataId(3),
     read,
     Description("Number of errors that occured on this device")]
    uint32   ErrorCount;

    [WmiDataId(4),
     read,
     Description("The NumberOfButtons property indicates the number of buttons on the pointing device.")]
    uint32   Buttons;

    [WmiDataId(5),
     read,
     Values{"Standard Mouse",
          "Standard Pointer",
          "Standard Absolute Pointer",
          "Tablet",
          "Touch Screen",
          "Pen",
          "Track Ball",
          "Other"},
     ValueMap{"0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "256"},
     DefineValues{"POINTER_PORT_WMI_STD_MOUSE",
                  "POINTER_PORT_WMI_STD_POINTER",
                  "POINTER_PORT_WMI_ABSOLUTE_POINTER",
                  "POINTER_PORT_WMI_TABLET",
                  "POINTER_PORT_WMI_TOUCH_SCRENE",
                  "POINTER_PORT_WMI_PEN",
                  "POINTER_PORT_WMI_TRACK_BALL",
                  "POINTER_PORT_WMI_OTHER"},
     Description("The HardwareType property indicates the hardware type of the pointing device.")]
    uint32 HardwareType;

};

[Dynamic, Provider("WMIProv"),
 WMI,
 Description("Mouse class driver information"),
 guid("{4731F89B-71CB-11d1-A52C-00A0C9062910}"),
 locale("MS\\0x409")]
class MSMouse_ClassInformation : MSMouse
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read,
     Description("An identification number for the device")]
    uint64   DeviceId;
};


[Dynamic, Provider("WMIProv"),
 WMI,
 Description("Keyboard class driver information"),
 guid("{4731F899-71CB-11d1-A52C-00A0C9062910}"),
 locale("MS\\0x409")]
class MSKeyboard_ClassInformation : MSKeyboard
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read,
     Description("An identification number for the device")]
    uint64   DeviceId;
};

//
// Thermal information via ACPI
[abstract]
class MSAcpi
{
}; 


[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("ThermalZone temperature information"),
 guid("{A1BC18C0-A7C8-11d1-BF3C-00A0C9062910}"),
 locale("MS\\0x409")]
class MSAcpi_ThermalZoneTemperature : MSAcpi
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     Description("Thermal information change stamp"),
     read] 
    uint32 ThermalStamp;

    [WmiDataId(2), 
     Description("First thermal constant"),
     read] 
    uint32 ThermalConstant1;

    [WmiDataId(3), 
     Description("Second thermal constant"),
     read] 
    uint32 ThermalConstant2;

    [WmiDataId(4), 
     Description("Reserved"),
     read] 
    uint32 Reserved;

    [WmiDataId(5), 
     Description("Sampling period"),
     read] 
    uint32 SamplingPeriod;

    [WmiDataId(6), 
     Description("Temperature at thermal zone in tenths of degrees Kelvin"),
     read] 
    uint32 CurrentTemperature;

    [WmiDataId(7), 
     Description("Temperature (in tenths of degrees Kelvin) at which the OS must activate CPU throttling (ie, enable passive cooling)"),
     read] 
    uint32 PassiveTripPoint;

    [WmiDataId(8), 
     Description("Temperature (in tenths of degrees Kelvin) at which the OS must shutdown the system (ie, critical temperature)"),
     read] 
    uint32 CriticalTripPoint;

    [WmiDataId(9), 
     Description("Count of active trip points"),
     read] 
    uint32 ActiveTripPointCount;

    [WmiDataId(10), 
     Description("Temperature levels (in tenths of degrees Kelvin) at which the OS must activate active cooling"),
     MissingValue(0),
     read] 
    uint32 ActiveTripPoint[10];

};

//
// Disk
[abstract]
class MSDiskDriver
{
}; 

[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("Disk Geometry"),
 guid("{25007F51-57C2-11d1-A528-00A0C9062910}"),
 HeaderName("WMI_DISK_GEOMETRY"),
 locale("MS\\0x409")]
class MSDiskDriver_Geometry : MSDiskDriver
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     read] 
    sint64 Cylinders;

    [WmiDataId(2), 
     Values{"Format is unknown",
             "5.25, 1.2MB,  512 bytes/sector",
             "3.5,  1.44MB, 512 bytes/sector",
             "3.5,  2.88MB, 512 bytes/sector",
             "3.5,  20.8MB, 512 bytes/sector",
             "3.5,  720KB,  512 bytes/sector",
             "5.25, 360KB,  512 bytes/sector",
             "5.25, 320KB,  512 bytes/sector",
             "5.25, 320KB,  1024 bytes/sector",
             "5.25, 180KB,  512 bytes/sector",
             "5.25, 160KB,  512 bytes/sector",
             "Removable media other than floppy",
             "Fixed hard disk media",
             "3.5, 120M Floppy",
             "3.5 ,  640KB,  512 bytes/sector",
             "5.25,  640KB,  512 bytes/sector",
             "5.25,  720KB,  512 bytes/sector",
             "3.5 ,  1.2Mb,  512 bytes/sector",
             "3.5 ,  1.23Mb, 1024 bytes/sector",
             "5.25,  1.23MB, 1024 bytes/sector",
             "3.5 MO 128Mb   512 bytes/sector",
             "3.5 MO 230Mb   512 bytes/sector",
             "8,     256KB,  128 bytes/sector"},
     ValueMap{"0",
             "1",
             "2",
             "3",
             "4",
             "5",
             "6",
             "7",
             "8",
             "9",
             "10",
             "11",
             "12",
             "13",
             "14",
             "15",
             "16",
             "17",
             "18",
             "19",
             "20",
             "21",
             "22"},
     read] 
    uint32 MediaType;

    [WmiDataId(3), 
     read] 
    uint32 TracksPerCylinder;

    [WmiDataId(4), 
     read] 
    uint32 SectorsPerTrack;

    [WmiDataId(5), 
     read] 
    uint32 BytesPerSector;

};

[
 WMI, 
 Description("Disk performance statistics"),
 guid("BDD865D2-D7C1-11d0-A501-00A0C9062910"),
 HeaderName("WMI_DISK_PERFORMANCE"),
 locale("MS\\0x409")]
class MSDiskDriver_PerformanceData : MSDiskDriver
{
    [WmiDataId(1),
     Description("Number of bytes read on disk"),
     read]
    sint64 BytesRead;

    [WmiDataId(2),
     Description("Number of bytes written on disk"),
     read]
    sint64 BytesWritten;

    [WmiDataId(3),
     Description("Amount off time spent reading from disk"),
     read]
    sint64 ReadTime;

    [WmiDataId(4),
     Description("Amount off time spent writing to disk"),
     read]
    sint64 WriteTime;

    [WmiDataId(5),
     Description("Amount off disk idle time"),
     read]
    sint64 IdleTime;

    [WmiDataId(6),
     Description("Number of read operations from disk"),
     read]
    uint32 ReadCount;

    [WmiDataId(7),
     Description("Number of write operations to disk"),
     read]
    uint32 WriteCount;

    [WmiDataId(8),
     Description("Number of requests waiting in the disk queue"),
     read]
    uint32 QueueDepth;

    [WmiDataId(9),
     Description("Number of split IO operations"),
     read]
    uint32 SplitCount;

    [WmiDataId(10),
     Description(""),
     read]
    sint64 QueryTime;

    [WmiDataId(11),
     Description(""),
     read]
    uint32 StorageDeviceNumber;

    [WmiDataId(12),
     Description(""),
     read]
    uint16 StorageManagerName[8];

};

[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("Disk performance statistics"),
 guid("BDD865D1-D7C1-11d0-A501-00A0C9062910"),
 locale("MS\\0x409")]
class MSDiskDriver_Performance : MSDiskDriver
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     Description("Performance Data Information"),
     read]
    MSDiskDriver_PerformanceData PerfData;

    [WmiDataId(2),
     Description("Internal device name"),
     read]
    string DeviceName;
};



//
// General storage
[abstract]
class MSStorageDriver
{
}; 


[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("Storage Device Failure Prediction Status"),
 guid("{78ebc102-4cf9-11d2-ba4a-00a0c9062910}"),
 HeaderName("STORAGE_FAILURE_PREDICT_STATUS"),
 GuidName1("WMI_STORAGE_FAILURE_PREDICT_STATUS_GUID"),
 locale("MS\\0x409")]
class MSStorageDriver_FailurePredictStatus : MSStorageDriver
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     ValueMap{"0", "255"},
     Values{"Unknown", "Test - Not a failure"},
     read] 
    uint32 Reason;


    [WmiDataId(2), 
     Description("TRUE if drive is predictiing failure. In this case it is critical that the disk is backed up immediately"),
     read]
    boolean PredictFailure;

};

[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("Storage Device Failure Prediction Data"),
 guid("{78ebc103-4cf9-11d2-ba4a-00a0c9062910}"),
 HeaderName("STORAGE_FAILURE_PREDICT_DATA"),
 GuidName1("WMI_STORAGE_FAILURE_PREDICT_DATA_GUID"),
 locale("MS\\0x409")]
class MSStorageDriver_FailurePredictData : MSStorageDriver
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     read] 
    uint32 Length;


    [WmiDataId(2), 
     Description("Vendor specific failure prediction data"),
     read]
    uint8 VendorSpecific[512];

};

[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("Storage Device Failure Prediction Event"),
 guid("{78ebc104-4cf9-11d2-ba4a-00a0c9062910}"),
 HeaderName("STORAGE_FAILURE_PREDICT_EVENT"),
 GuidName1("WMI_STORAGE_PREDICT_FAILURE_EVENT_GUID"),
 locale("MS\\0x409")]
class MSStorageDriver_FailurePredictEvent : WmiEvent
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     read] 
    uint32 Length;


    [WmiDataId(2), 
     Description("Vendor specific failure prediction data"),
     WmiSizeIs("Length"),
     read]
    uint8 VendorSpecific[];

};

[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("Storage Device Failure Prediction Functions"),
 guid("{78ebc105-4cf9-11d2-ba4a-00a0c9062910}"),
 HeaderName("STORAGE_FAILURE_PREDICT_FUNCTION"),
 GuidName1("WMI_STORAGE_FAILURE_PREDICT_FUNCTION_GUID"),
 locale("MS\\0x409")]
class MSStorageDriver_FailurePredictFunction : MSStorageDriver
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiMethodId(1), 
     Implemented,
     Description("Configures setting that specifies if additional failure prediction checking can cause a loss of performance")]
    void AllowPerformanceHit([in] boolean Allow);

    [WmiMethodId(2), 
     Implemented,
     Description("Enables or disables failure prediction checking at the hardware level")]
    void EnableDisableHardwareFailurePrediction([in] boolean Enable);

    [WmiMethodId(3), 
     Implemented,
     Description("Enables or disables polling for failure prediction status")]
    void EnableDisableFailurePredictionPolling(
                               [in, Description("Period in seconds to poll for failure prediction status")] 
                                uint32 Period,
                               [in] boolean Enable);
    [WmiMethodId(4), 
     Implemented,
     Description("Returns mechanism used to read failure prediction status ")]
    void GetFailurePredictionCapability([out, Values{"0", "1", "2", "3"},
                                         ValueMap{"Not Supported",
                                                  "Ioctl Based",
                                                  "IDE SMART",
                                                  "SCSI SMART"}
                                        ] uint32 Capability);

    [WmiMethodId(5), 
     Implemented,
     Description("Enables execution of offline diagnostics")]
    void EnableOfflineDiags([out] boolean Success);

};


[abstract]
class MSIde
{
}; 

[Dynamic, Provider("WMIProv"), WMI, 
 Description("Scsi Address"),
 guid("{53f5630f-b6bf-11d0-94f2-00a0c91efb8b}"),
 locale("MS\\0x409")]
class MSIde_PortDeviceInfo : MSIde
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     Description("Scsi Bus Number"),
     read] 
    uint8 Bus;
    
    [WmiDataId(2), 
     Description("Scsi Target ID"),
     read] 
    uint8 Target;

    [WmiDataId(3), 
     Description("Scsi Lun"),
     read] 
    uint8 Lun;
};



// Serial
[abstract]
class MSSerial
{
};


[WMI, Dynamic, Provider ("WMIProv"),
 guid("{A0EC11A8-B16C-11D1-BD98-00A0C906BE2D}"),
 GuidName1("SERIAL_PORT_WMI_NAME_GUID"),
 locale("MS\\0x409"),
 Description("Serial Port Name")
]
class MSSerial_PortName : MSSerial
{
    boolean Active;
    [key]
      string InstanceName;

    [WmiDataId(1),
     Description("Serial Port Name"),
     read]
      string PortName;
};


[WMI, Dynamic, Provider ("WMIProv"),
 guid("{EDB16A62-B16C-11D1-BD98-00A0C906BE2D}"),
 GuidName1("SERIAL_PORT_WMI_COMM_GUID"),
 HeaderName("SERIAL_WMI_COMM_DATA"),
 Description("Serial Communications Information")
]
class MSSerial_CommInfo : MSSerial
{
    boolean Active;
    [key]
      string InstanceName;

    [WmiDataId(1),
     Description("The BaudRate property indicates the baud rate for this serial port"),
     read]
      uint32 BaudRate;

    [WmiDataId(2),
     Description("The BitsPerByte property indicates the number of bits per byte for the serial port"),
     read]
      uint32 BitsPerByte;     

    [WmiDataId(3),
     read,
     Description("The Parity property indicates the type of parity used"),
     Values{"None",
             "Odd",
             "Even",
             "Space",
             "Mark"},
     ValueMap{"0",
             "1",
             "2",
             "3",
             "4"},
     DefineValues{"SERIAL_WMI_PARITY_NONE",
                  "SERIAL_WMI_PARITY_ODD",
                  "SERIAL_WMI_PARITY_EVEN",
                  "SERIAL_WMI_PARITY_SPACE",
                  "SERIAL_WMI_PARITY_MARK"}
      ]
      uint32 Parity;

    [WmiDataId(4),
     Description("The ParityCheckEnabled property determines whether parity checking is enabled"),
     read]
      boolean ParityCheckEnable;

    [WmiDataId(5),
     read,
     Description("The StopBits property indicates the number of stop bits for the serial port"),
     Values{"1",
             "1.5",
             "2"},
     ValueMap{"0",
             "1",
             "2"},
     DefineValues{"SERIAL_WMI_STOP_1",
                  "SERIAL_WMI_STOP_1_5",
                  "SERIAL_WMI_STOP_2"}]
      uint32 StopBits;

    [WmiDataId(6),
     Description("The XOffCharacter property indicates the XOff character for the serial port"),
     read]
      uint32 XoffCharacter;

    [WmiDataId(7),
     Description("The XOffXmitThreshold property indicates the XOff transmit threshold for the serial port"),
     read]
      uint32 XoffXmitThreshold;

    [WmiDataId(8),
     Description("The XOnCharacter property indicates the XOn character"),
     read]
      uint32 XonCharacter;

    [WmiDataId(9),
     Description("The XOnXMitThreshold property indicates the XOn transmit threshold"),
     read]
      uint32 XonXmitThreshold;
      
    [WmiDataId(10),
     Description("The MaximumBaudRate property indicates the maximum baud rate of the serial port"),
     read]
      uint32 MaximumBaudRate;

    [WmiDataId(11),
     Description("The MaximumOutputBufferSize property indicates the maximum output buffer size (in bytes)"),
     read]
      uint32 MaximumOutputBufferSize;

    [WmiDataId(12),
     Description("The MaximumInputBufferSize property indicates the maximum input buffer size (in bytes)"),
     read]
      uint32 MaximumInputBufferSize;

    [WmiDataId(13),
     Description("The Support16BitMode property determines whether 16-bit mode is supported on the Win32 serial port"),
     read]
      boolean Support16BitMode;

    [WmiDataId(14),
     Description("The SupportDTRDSR property determines whether Data Terminal Ready (DTR) and Data Set Ready (DSR) signals are supported on the Win32 serial port."),
     read]
      boolean SupportDTRDSR;

    [WmiDataId(15),
     Description("The SupportIntervalTimeouts property determines whether interval timeouts are supported on the serial port"),
     read]
      boolean SupportIntervalTimeouts;

    [WmiDataId(16),
     Description("The SupportParityCheck property determines whether parity checking is supported on the Win32 serial port"),
     read]
      boolean SupportParityCheck;

    [WmiDataId(17),
     Description("The SupportRTSCTS property determines whether Ready To Send (RTS) and Clear To Send (CTS) signals are supported on the serial port"),
     read]
      boolean SupportRTSCTS;

    [WmiDataId(18),
     Description("The SupportXOnXOff property determines whether software flow control is supported on the serial port"),
     read]
      boolean SupportXonXoff;

    [WmiDataId(19),
     Description("The SettableBaudRate property determines whether the baud rate can be set on the serial port"),
     read]
      boolean SettableBaudRate;

    [WmiDataId(20),
     Description("The SettableDataBits property determines whether the number of data bits can be set on the Win32 serial port"),
     read]
      boolean SettableDataBits;

    [WmiDataId(21),
     Description("The SettableFlowControl property determines whether the flow control can be set on the serial port"),
     read]
      boolean SettableFlowControl;

    [WmiDataId(22),
     Description("The SettableParity property determines whether the parity can be set on the serial port"),
     read]
      boolean SettableParity;

    [WmiDataId(23),
     Description("The SettableParityCheck property determines whether parity checking can be set on the serial port"),
     read]
      boolean SettableParityCheck;

    [WmiDataId(24),
     Description("The SettableStopBits property determines whether the number of stop bits can be set on the serial port"),
     read]
      boolean SettableStopBits;

    [WmiDataId(25),
     Description("The IsBusy property determines whether the serial port is busy"),
     read]
      boolean IsBusy;
};
[Dynamic, Provider("WMIProv"),
 WMI, 
 Description("Data for Scsi Info Exceptions Mode Page"),
 guid("{1101D829-167B-4ebf-ACAE-28CAB7C34802}"),
 HeaderName("STORAGE_SCSI_INFO_EXCEPTIONS"),
 GuidName1("WMI_STORAGE_SCSI_INFO_EXCEPTIONS_GUID"),
 locale("MS\\0x409")]
class MSStorageDriver_ScsiInfoExceptions : MSStorageDriver
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     Description("The returned Parameter Savable bit of 1 indicates that page parameter data is savable."),
     read]
     boolean PageSavable;
    
    [WmiDataId(2), 
     Description("Bit flags: "
                 "Perf set to zero indicates that informational exception operations that are the cause of delays are acceptable. "
         "DExcpt set to zero indicates information exception operations shall be enabled. "
                 "Test of one instructs the drive to create false drive failures. "
                 "LogErr bit of zero indicates that logging of informational exception conditions are vendor specific."),
     BitMap{"Perf", "DExcpt", "Test", "LogErr"},
     BitValues{"7", "3",      "2",     "0"},
     read, write]
     uint8 Flags;

    [WmiDataId(3), 
     Description("The Method of Reporting Informational Exceptions (MRIE) indicates the methods that shall be used by the target to report information exception conditions."),
     ValueMap{"0", "1", "2", "3", "4", "5", "6"},
     Values{"No Reporting", "Asynchronous Event Reporting", "Generate Unit Attention", "Conditionally Generate Recovered Error", "Unconditionally Generate Recovered Error", "Generate No Sense", "Report On Request"},
     read, write]
     uint8 MRIE;

    [WmiDataId(4), 
     Description("Buffer padding to 32 bits, do not use"),
     read]
     uint8 Padding;

    [WmiDataId(5), 
     Description("Period in 100ms increments for reproting that an information exception condition has occurred."),
     read, write]
     uint32 IntervalTimer;

    [WmiDataId(6), 
     Description("Indicates the number of times to report an informational exception condition to the application client. A value of zero indications there is no limit."),
     read, write]
     uint32 ReportCount;
};

[WMI, Dynamic, Provider ("WMIProv"),
 guid("{270B9B86-B16D-11D1-BD98-00A0C906BE2D}"),
 GuidName1("SERIAL_PORT_WMI_HW_GUID"),
 HeaderName("SERIAL_WMI_HW_DATA"),
 Description("Hardware configuration for serial port")
]
class MSSerial_HardwareConfiguration : MSSerial
{
    boolean Active;
    [key]
      string InstanceName;

    [WmiDataId(1),
     Description("The IRQNumber property indicates the number of the IRQ resource"),
     read]
      uint32 IrqNumber;

    [WmiDataId(2),
     Description("The Vector property indicates the vector of the IRQ resource"),
     read]
      uint32 IrqVector;

    [WmiDataId(3),
     Description("The IRQLevel property indicates the level of the IRQ resource"),
     read]
      uint32 IrqLevel;

    [WmiDataId(4),
     Description("The AffinityMask property indicates the affinity mask of the IRQ resource"),
     read]
      uint32 IrqAffinityMask;

    [WmiDataId(5),
     Description("The InterruptType property indicates the interrupt type of the IRQ resource"),
     Values{"Latched",
             "Level"},
     ValueMap{"0",
             "1"},
     DefineValues{"SERIAL_WMI_INTTYPE_LATCHED",
                  "SERIAL_WMI_INTTYPE_LEVEL"},
     read]
      uint32 InterruptType;

    [WmiDataId(6),
     Description("The BaseIOAddress is the base IO address for the serial port"),
     read]
      uint64 BaseIOAddress;
};

[WMI, Dynamic, Provider ("WMIProv"),
 guid("{56415ACC-B16D-11D1-BD98-00A0C906BE2D}"),
 GuidName1("SERIAL_PORT_WMI_PERF_GUID"),
 HeaderName("SERIAL_WMI_PERF_DATA"),
 Description("Performance information for serial port")
]
class MSSerial_PerformanceInformation : MSSerial
{
    boolean Active;
    [key]
      string InstanceName;

    [WmiDataId(1),
     Description("The ReceivedCount property indicates the number of bytes received in the current session"),
     read]
      uint32 ReceivedCount;
      
    [WmiDataId(2),
     Description("The TransmittedCount property indicates the number of bytes transmitted in the current session"),
     read]
      uint32 TransmittedCount;
      
    [WmiDataId(3),
     Description("The FrameErrorCount property indicates the number of framing errors that occurred in the current session"),
     read]
      uint32 FrameErrorCount;
      
    [WmiDataId(4),
     Description("The SerialOverrunCount property indicates the number of serial overrun errors that occurred in the current session"),
     read]
      uint32 SerialOverrunErrorCount;
      
    [WmiDataId(5),
     Description("The BufferOverrunCount property indicates the number of buffer overrun errors that occurred in the current session"),
     read]
      uint32 BufferOverrunErrorCount;
      
    [WmiDataId(6),
     Description("The ParityErrorCount property indicates the number of parity errors that occurred in the current session"),
     read]
      uint32 ParityErrorCount;
};

[WMI, Dynamic, Provider ("WMIProv"),
 guid("{8209EC2A-2D6B-11d2-BA49-00A0C9062910}"),
 GuidName1("SERIAL_PORT_WMI_PROPERTIES_GUID"),
 HeaderName("SERIAL_WMI_COMMPROP"),
 Description("Communication properties for serial port")
]
class MSSerial_CommProperties : MSSerial
{
    boolean Active;
    [key]
      string InstanceName;

    [read, WmiDataId(1),
     Description("Specifies the size, in bytes, of the entire data packet, regardless of the amount of data requested")]
    uint16  wPacketLength;       // packet size, in bytes 

    [read, WmiDataId(2),
     Description("Specifies the version of the structure")]
    uint16  wPacketVersion;      // packet version 

    [read, WmiDataId(3),
     BitMap{"SP_SERIALCOMM"},
     BitValues{"0"},
     Description("Specifies a bitmask indicating which services are implemented by this provider. The SP_SERIALCOMM value is always specified for communications providers, including modem providers.")]
    uint32 dwServiceMask;       // services implemented 

    [read, WmiDataId(4),
     Description("Reserved; do not use.")]
    uint32 dwReserved1;         // reserved 

    [read, WmiDataId(5),
     Description("Specifies the maximum size, in bytes, of the driver's internal output buffer. A value of zero indicates that no maximum value is imposed by the serial provider")]
    uint32 dwMaxTxQueue;        // max Tx bufsize, in bytes 

    [read, WmiDataId(6),
     Description("Specifies the maximum size, in bytes, of the driver's internal input buffer. A value of zero indicates that no maximum value is imposed by the serial provider")]
    uint32 dwMaxRxQueue;        // max Rx bufsize, in bytes 

    [read, WmiDataId(7),
     BitMap{"BAUD_075", "BAUD_110", "BAUD_134_5", "BAUD_150", "BAUD_300", 
            "BAUD_600", "BAUD_1200", "BAUD_1800", "BAUD_2400", "BAUD_4800", 
            "BAUD_7200", "BAUD_9600", "BAUD_14400", "BAUD_19200", "BAUD_38400",
            "BAUD_56K", "BAUD_128K", "BAUD_115200", "BAUD_57600", "BAUD_USER"},

     BitValues{"0", "1", "2", "3", "4", 
               "5", "6", "7", "8", "9", 
               "10", "11", "12", "13", "14", 
               "15", "16", "17", "18", "28" },
     Description("Specifies the maximum allowable baud rate, in bits per second (bps). This member can be one of the following values: Value Meaning")]
    uint32 dwMaxBaud;           // max baud rate, in bps 

    [read, WmiDataId(8),
     ValueMap{"0x00000000", "0x00000001", "0x00000002", 
              "0x00000003", "0x00000004", "0x00000005", "0x00000006", 
              "0x00000021", "0x00000022", "0x00000100", 
              "0x00000101", "0x00000102", "0x00000103"},

     Values{ "Unspecified", "RS-232 serial port",  "Parallel port", 
             "RS-422 port", "RS-423 port","RS-449 port", "Modem device",
             "FAX device", "Scanner device", "Unspecified network bridge",
             "LAT protocol", "TCP/IP Telnet protocol", "X.25 standards"},

     Description("Specifies the specific communications provider type")]
    uint32 dwProvSubType;       // specific provider type 

    [read, WmiDataId(9),
     BitMap{ "(data-terminal-ready)/DSR (data-set-ready) supported",
             "(request-to-send)/CTS (clear-to-send) supported",
             "(receive-line-signal-detect) supported",
             "Parity checking supported",
             "XON/XOFF flow control supported"
             "Settable XON/XOFF supported",
             "Total (elapsed) time-outs supported",
             "Interval time-outs supported",
             "Special character support provided",
             "Special 16-bit mode supported"},
     BitValues{"0", "1", "2", "3", "4", 
               "5", "6", "7", "8", "9"},
     Description("Specifies a bitmask indicating the capabilities offered by the provider. This member can be one of the following values")]
    uint32 dwProvCapabilities;  // capabilities supported 

    [read, WmiDataId(10),
     BitMap{"Parity checking",
            "Baud rate",
            "Data bits",
            "Stop bits",
            "Handshaking (flow control)",
            "Parity checking",
            "(receive-line-signal-detect)"},
     BitValues{"0", "1", "2", "3", "4", 
               "5", "6"},
     Description("Specifies a bitmask indicating the communications parameter that can be changed")]
    uint32 dwSettableParams;    // changable parameters 

    [read, WmiDataId(11),
     BitMap{"BAUD_075", "BAUD_110", "BAUD_134_5", "BAUD_150", "BAUD_300", 
            "BAUD_600", "BAUD_1200", "BAUD_1800", "BAUD_2400", "BAUD_4800", 
            "BAUD_7200", "BAUD_9600", "BAUD_14400", "BAUD_19200", "BAUD_38400",
            "BAUD_56K", "BAUD_128K", "BAUD_115200", "BAUD_57600", "BAUD_USER"},

     BitValues{"0", "1", "2", "3", "4", 
               "5", "6", "7", "8", "9", 
               "10", "11", "12", "13", "14", 
               "15", "16", "17", "18", "28" },
     Description("Specifies a bitmask indicating the baud rates that can be used")]
    uint32 dwSettableBaud;      // allowable baud rates 

    [read, WmiDataId(12),
     BitMap{"5 data bits",
            "6 data bits",
            "7 data bits",
            "8 data bits",
            "16 data bits",
            "Special wide path through serial hardware lines"},

     BitValues{"0", "1", "2", "3", "4", "5"},
     Description("Specifies a bitmask indicating the number of data bits that can be set")]
    uint16  wSettableData;       // allowable byte sizes 

    [read, WmiDataId(13),
     BitMap{"1 stop bit",
            "1.5 stop bits",
            "2 stop bits",
            "No parity",
            "Even parity",
            "Mark parity",
            "Space parity"},

     BitValues{"0", "1", "2", "8", "9", "10", "11", "12"},
     Description("Specifies a bitmask indicating the stop bit and parity settings that can be selected.")]
    uint16  wSettableStopParity; // stop bits/parity allowed 

    [read, WmiDataId(14),
     Description("Specifies the size, in bytes, of the driver's internal output buffer. A value of zero indicates that the value is unavailable.")]
    uint32 dwCurrentTxQueue;    // Tx buffer size, in bytes 

    [read, WmiDataId(15),
     Description("Specifies the size, in bytes, of the driver's internal input buffer. A value of zero indicates that the value is unavailable.")]
    uint32 dwCurrentRxQueue;    // Rx buffer size, in bytes 

    [read, WmiDataId(16),
     Description("Specifies provider-specific data.")]
     uint32 dwProvSpec1;         // provider-specific data 

    [read, WmiDataId(17),
     Description("Specifies provider-specific data.")]
    uint32 dwProvSpec2;         // provider-specific data 

    [read, WmiDataId(18),
     Description("Number of bytes of provider specific data")]
    uint32 dwProvCharSize;

    [read, WmiDataId(19),
     WmiSizeIs("dwProvCharSize"),
     Description("Specifies provider-specific data. Applications should ignore this member unless they have detailed information about the format of the data required by the provider.")]
    uint8 wcProvChar[];       // provider-specific data 


};

[abstract]
class MSParallel
{
}; 

[Dynamic, Provider("WMIProv"), WMI, 
 Description("The allocate and free counts track the port sharing of the parallel port. If the allocate count equals the free count then the port is idle. If the allocate count is greater than the free count (free count + 1) then some other driver in the system has acquired exclusive access to that port. If the allocate count stays constant at freecount+1 for an arbitrarily long period of time, then some driver may have illegally locked the port preventing other drivers from accessing the port."),
 guid("{4BBB69EA-6853-11d2-8ECE-00C04F8EF481}"),
 HeaderName("PARPORT_WMI_ALLOC_FREE_COUNTS"),
 GuidName1("PARPORT_WMI_ALLOCATE_FREE_COUNTS_GUID"),
 locale("MS\\0x409")]
class MSParallel_AllocFreeCounts : MSParallel
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     Description("Port allocation count"),
     read] 
    uint32 PortAllocates;
    
    [WmiDataId(2), 
     Description("Port free count"),
     read] 
    uint32 PortFrees;
    
};

[Dynamic, Provider("WMIProv"), WMI, 
 Description("Bytes transferred for each mode for the device"),
 guid("{89FEF2D6-654B-11d2-9E15-00C04F8EF481}"),
 GuidName1("PARALLEL_WMI_BYTES_TRANSFERRED_GUID"),
 HeaderName("PARALLEL_WMI_LOG_INFO"),
 locale("MS\\0x409")]
class MSParallel_DeviceBytesTransferred : MSParallel
{
    [key, read] 
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1), 
     Description("Reserved"),
     read] 
    uint32 Flags1;

    [WmiDataId(2), 
     Description("Reserved"),
     read] 
    uint32 Flags2;

    [WmiDataId(3), 
     Description("Reserved"),
     read] 
    uint32 spare[2];

    [WmiDataId(4), 
     Description("Bytes writtem using SPP mode"),
     read] 
    sint64 SppWriteCount;

    [WmiDataId(5), 
     Description("Bytes writtem using nibble mode"),
     read] 
    sint64 NibbleReadCount;

    [WmiDataId(6), 
     Description("Bytes writtem using bounded Ecp mode"),
     read] 
    sint64 BoundedEcpWriteCount;
    [WmiDataId(7), 
     Description("Bytes read using bounded Ecp mode"),
     read] 
    sint64 BoundedEcpReadCount;

    [WmiDataId(8), 
     Description("Bytes writtem using hardware Ecp mode"),
     read] 
    sint64 HwEcpWriteCount;
    [WmiDataId(9), 
     Description("Bytes read using hardware Ecp mode"),
     read] 
    sint64 HwEcpReadCount;

    [WmiDataId(10), 
     Description("Bytes writtem using software Ecp mode"),
     read] 
    sint64 SwEcpWriteCount;
    [WmiDataId(11), 
     Description("Bytes read using software Ecp mode"),
     read] 
    sint64 SwEcpReadCount;

    [WmiDataId(12), 
     Description("Bytes writtem using hardware Epp mode"),
     read] 
    sint64 HwEppWriteCount;
    [WmiDataId(13), 
     Description("Bytes read using hardware Epp mode"),
     read] 
    sint64 HwEppReadCount;

    [WmiDataId(14), 
     Description("Bytes writtem using software Epp mode"),
     read] 
    sint64 SwEppWriteCount;
    [WmiDataId(15), 
     Description("Bytes read using software Epp mode"),
     read] 
    sint64 SwEppReadCount;

    [WmiDataId(16), 
     Description("Bytes read using byte (bidirectional / PS/2) mode"),
     read] 
    sint64 ByteReadCount;
    [WmiDataId(17), 
     Description("Bytes read using channelized Nibble mode (IEEE 1284.3)"),
     read] 
    sint64 ChannelNibbleReadCount;
    
};


// #define MOFRESOURCENAME L"Redbook"

[abstract]
class MSRedbook
{
};


[Dynamic,
 Provider("WMIProv"),
 WMI,
 Description("Digital Audio Filter Driver Information (redbook)"),
 GuidName1("GUID_REDBOOK_WMI_STD_DATA"),
 GuidName2("MSRedbook_DriverInformationGuid"),
 HeaderName("REDBOOK_WMI_STD_DATA"),
 guid("{b90550e7-ae0a-11d1-a571-00c04fa34730}"),
 locale("MS\\0x409")
]

class MSRedbook_DriverInformation
{
        [key, read]
        string InstanceName;

        [read]
        boolean Active;

        [WmiDataId(1),
         DefineDataId("REDBOOK_WMI_NUMBER_OF_BUFFERS"),
         read,
         write,
         Description("NumberOfBuffers*SectorsPerRead*2352 is the amount of memory used to reduce skipping." )
        ]
        uint32 NumberOfBuffers;

        [WmiDataId(2),
         DefineDataId("REDBOOK_WMI_SECTORS_PER_READ"),
         read,
         write,
         Description("Sectors (2352 bytes each) per read.")
        ]
        uint32 SectorsPerRead;

        [WmiDataId(3),
         DefineDataId("REDBOOK_WMI_SECTORS_PER_READ_MASK"),
         read,
         write,
         Description("Bitwise mask of supported sectors per read for this drive.  The lowest bit is one sector reads.  If all bits are set, there are no restrictions.")
        ]
        uint32 SectorsPerReadMask;

        [WmiDataId(4),
         DefineDataId("REDBOOK_WMI_MAX_SECTORS_PER_READ"),
         read,
         write,
         Description("Maximum sectors per read (depends on both adapter and drive).")
        ]
        uint32 MaximumSectorsPerRead;

        [WmiDataId(5),
         DefineDataId("REDBOOK_WMI_PLAY_ENABLED"),
         read,
         write,
         Description("PlayEnabled indicates the drive is currently using the RedBook filter.")
        ]
        boolean PlayEnabled;

        [WmiDataId(6),
         DefineDataId("REDBOOK_WMI_CDDA_SUPPORTED"),
         read,
         write,
         Description("CDDASupported indicates the drive supports digital audio for some sector sizes.")
        ]
        boolean CDDASupported;

        [WmiDataId(7),
         DefineDataId("REDBOOK_WMI_CDDA_ACCURATE"),
         read,
         write,
         Description("CDDAAccurate indicates the drive acccurately reads digital audio.  This ensures the highest quality audio")
        ]
        boolean CDDAAccurate;

        [WmiDataId(8),
         read,
         Description("Reserved for future use")
        ]
        boolean Reserved1;

};


[Dynamic,
 Provider("WMIProv"),
 WMI,
 Description("Digital Audio Filter Driver Performance Data (redbook)"),
 GuidName1("GUID_REDBOOK_WMI_PERF_DATA"),
 GuidName2("MSRedbook_PerformanceGuid"),
 HeaderName("REDBOOK_WMI_PERF_DATA"),
 guid("{b90550e8-ae0a-11d1-a571-00c04fa34730}"),
 locale("MS\\0x409")
]

class MSRedbook_Performance
{
        [key, read]
        string InstanceName;

        [read]
        boolean Active;

        [WmiDataId(1),
         DefineDataId("REDBOOK_WMI_PERF_TIME_READING_DELAY"),
         read,
         Description("Seconds spent ready to read, but unused. (*1E-7)" )
        ]
        sint64 TimeReadDelay;

        [WmiDataId(2),
         DefineDataId("REDBOOK_WMI_PERF_TIME_READING"),
         read,
         Description("Seconds spent reading data from source. (*1E-7)")
        ]
        sint64 TimeReading;

        [WmiDataId(3),
         DefineDataId("REDBOOK_WMI_PERF_TIME_STREAMING_DELAY"),
         read,
         Description("Seconds spent ready to stream, but unused. (*1E-7)")
        ]
        sint64 TimeStreamDelay;

        [WmiDataId(4),
         DefineDataId("REDBOOK_WMI_PERF_TIME_STREAMING"),
         read,
         Description("Seconds spent streaming data. (*1E-7)")
        ]
        sint64 TimeStreaming;

        [WmiDataId(5),
         DefineDataId("REDBOOK_WMI_PERF_DATA_PROCESSED"),
         read,
         Description("Number of bytes of data read and streamed.")
        ]
        sint64 DataProcessed;

        [WmiDataId(6),
         DefineDataId("REDBOOK_WMI_PERF_STREAM_PAUSED_COUNT"),
         read,
         Description("Number of times the stream has paused due to insufficient stream buffers.")
        ]
        uint32 StreamPausedCount;

};


[WMI, Dynamic, Provider("WMIProv"),
 guid("{e3dff7bd-3915-11d2-9103-00c04fb998a2}"),
 locale("MS\\0x409"),
 WmiExpense(1),
 Description("Enumerates Guids registered with WMI. The InstanceName is the Guid.")]
class RegisteredGuids
{
    [key, read]
    string      InstanceName;

    [read]
    boolean     Active;

    [read,
     Description("Type of guid"),
     Values {0, 1, 2, 3},
     ValueMap{"Trace Control Guid", "Trace Guid", "Data Guid", "Event Guid"},
     WmiDataId(1)]    uint32     GuidType;

    [read,
    Description("If Trace guid and enabled, indicates the LoggerId to which this Guid is currently logging data"),
     WmiDataId(2)]    uint32      LoggerId;

    [read,
    Description("If trace guid and If enabled, indicates the level of logging"),
     WmiDataId(3)]    uint32      EnableLevel;

    [read,
    Description("If trace guid and enabled, indicates the flags currently used in logging"),
     WmiDataId(4)]    uint32      EnableFlags;

    [read,
    Description("Indicates whether this Guid is enabled currently. For data guids this means if collection is enabled, For event guids this means if events are enabled. For Trace control guids this means the trace logging is enabled."),
     WmiDataId(5)]    boolean     IsEnabled;

};


//*************************************************************
//***   Creates namespace for TRACE under \root\wmi
//***   EventTrace - is the root for all Trace Guids
//***   All Provider Control Guids will derive from EventTrace
//***   All Trace Data Guids will derive from their ControlGuid
//*************************************************************

[abstract]
class EventTrace
{
    [HeaderDataId(1),
     Description("Trace Event Size"),
     read]
    uint16 EventSize;

    [HeaderDataId(2),
     Description("Reserved"),
     read]
    uint16 ReservedHeaderField;

    [HeaderDataId(3),
     Description("Event Type"),
     read]
    uint8 EventType;

    [HeaderDataId(4),
     Description("Trace Level"),
     read]
    uint8 TraceLevel;

    [HeaderDataId(5),
     Description("Trace Version"),
     read]
    uint16 TraceVersion;

    [HeaderDataId(6),
     Description("Thread Id"),
     PointerType,
     read]
    uint64 ThreadId;

    [HeaderDataId(7),
     Description("TimeStamp"),
     read]
    uint64 TimeStamp;

    [HeaderDataId(8),
     Description("Event Guid"),
     read]
    uint8 EventGuid[16];

    [HeaderDataId(9),
     Description("Kernel Time"),
     read]
    uint32 KernelTime;

   [HeaderDataId(10),
    Description("User Time"),
    read]
   uint32 UserTime;

   [HeaderDataId(11),
    Description("Instance Id"),
    read]
   uint32 InstanceId;

   [HeaderDataId(12),
    Description("Parent Guid"),
    read]
    uint8 ParentGuid[16];

   [HeaderDataId(13),
    Description("Parent Instance Id"),
    read]
   uint32 ParentInstanceId;

   [HeaderDataId(14),
    Description("Pointer to Mof Data"),
    PointerType,
    read]
   uint32 MofData;

   [HeaderDataId(15),
    Description("Length of Mof Data"),
    read]
   uint32 MofLength;
};

[Dynamic, 
 Description("Windows2000 Kernel Trace Provider"),
 Guid("{9e814aad-3204-11d2-9a82-006008a86939}"),
 locale("MS\\0x409")
]
class MSNT_SystemTrace:EventTrace
{

};


[Dynamic, 
 Description("Thread Create/Exit Event"),
 Guid ("{3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c}"),
 locale("MS\\0x409")
]
class MSNT_ThreadInformation:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("Thread Id"),
     PointerType,
     read]  
     uint32  NewThreadId;

    [WmiDataId(2),
     Description("Process Id"),
     PointerType,
     read]  
     uint32  ProcessId; 
};

[Dynamic, 
 Description("Process Create/Exit Event"),
 Guid("{3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c}"),
 locale("MS\\0x409")
]
class MSNT_ProcessInformation:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("Process Id"),
     PointerType,
     read]  
    uint32 ProcessId;
    [WmiDataId(2),
     Description("Parent Id"),
     PointerType,
     read] 
     uint32 ParentId;
    [WmiDataId(3),
     Description("User SID"),
     read]  
     string UserSid;
    [WmiDataId(4),
     Description("Image FileName"),
     read]
     string ImageName; 
};

[Dynamic, 
 Description("I/O Read/Write Event"),
 Guid("{3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c}"),
 locale("MS\\0x409")
]
class MSNT_IoInformation:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("Disk Number"),
     read]
     uint32 DiskNumber;
    [WmiDataId(2),
     Description("Irp Flags"),
     read]
     uint32 IrpFlags;
    [WmiDataId(3),
     Description("Transfer Size"),
     read]
     uint32 TransferSize;
    [WmiDataId(4),
     Description("Response Time"),
     read]
     uint32 ResponseTime;
    [WmiDataId(5),
     Description("Byte Offset"),
     read]
     uint64 ByteOffset;
    [WmiDataId(6),
     Description("File Object"),
     PointerType,
     read]
     uint32 FileObject;
};

[Dynamic, 
 Description("Page Fault Event"),
 Guid("{3d6fa8d3-fe05-11d0-9dda-00c04fd7ba7c}"),
 locale("MS\\0x409")
]
class MSNT_PageFaultInformation:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("Virtual Address"),
     PointerType,
     read]
     uint32 VirtualAddress;
    [WmiDataId(2),
     Description("Program Counter"),
     PointerType,
     read]
     uint32 ProgramCounter;
};

[Dynamic, 
 Description("File Name"),
 Guid("{90cbdc39-4a3e-11d1-84f4-0000f80464e3}"),
 locale("MS\\0x409")
]
class MSNT_FileInformation:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("File Object"),
     PointerType,
     read]
     uint32 FileObject;
    [WmiDataId(2),
     Description("File Name"),
     read]
     string FileName;
};

[Dynamic, 
 Description("TcpIp Send/Receive"),
 Guid("{9a280ac0-c8e0-11d1-84e2-00c04fb998a2}"),
 locale("MS\\0x409")
]
class MSNT_TcpIpInformation:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("Source IPAddr"),
     read]
     uint32 saddr;
    [WmiDataId(2),
     Description("Destination IPAddr"),
     read]
     uint32 daddr;
    [WmiDataId(3),
     Description("Source Port"),
     read]
     uint16 sport;
    [WmiDataId(4),
     Description("Destination Port"),
     read]
     uint16 dport;
    [WmiDataId(5),
     Description("Transfer Size"),
     read]
     uint32 TransferSize;
    [WmiDataId(6),
     Description("Process Id"),
     PointerType,
     read]
     uint32 PID;
};

[Dynamic,
 Description("Image Load"),
 Guid("{2cb15d1d-5fc1-11d2-abe1-00a0c911f518}"),
 locale("MS\\0x409")
]
class MSNT_ImageLoad:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("ImageBase"),
     PointerType,
     read]
     uint32 ImageBase;
    [WmiDataId(2),
     Description("ImageSize"),
     PointerType,
     read]
     uint32 ImageSize;
    [WmiDataId(3),
     Description("Image Name"),
     read]
     string ImageName;
};

[Dynamic,
 Description("Registry"),
 Guid("{ae53722e-c863-11d2-8659-00c04fa321a1}"),
 locale("MS\\0x409")
]
class MSNT_Registry:MSNT_SystemTrace
{
    [WmiDataId(1),
     Description("Return Status"),
     PointerType,
     read]
     uint32 Status;
    [WmiDataId(2),
     Description("Key Handle"),
     PointerType,
     read]
     uint32 KeyHandle;
    [WmiDataId(3),
     Description("Elapsed Time"),
     read]
     uint64 ElapsedTime;
    [WmiDataId(4),
     Description("Registry Key Name"),
     read]
     string KeyName;
};

