<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-
1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Toaster</TITLE>
</HEAD>
<BODY LINK="#0000ff">

<FONT FACE="Verdana" SIZE=5><H2>Toaster</H2>
</FONT><FONT FACE="Verdana" SIZE=2>

<P>
<A HREF="#sum">Summary</A><BR>
<A HREF="#intro">Introduction to WDM Driver Model</A><BR>
<A HREF="#toast">Introduction to the Toaster Sample </A><BR>
<A HREF="#build">Building the sample</A><BR>
<A HREF="#install">Installation</A><BR>
<A HREF="#test">Testing</A><BR>
<A HREF="#filter">Filters</A><BR>
<A HREF="#params">Device Parameters Subkey</A><BR>
<A HREF="#power">Power Management</A><BR>
<A HREF="#wmi">WMI</A><BR>
<A HREF="#etw">Event Tracing</A><BR>
<A HREF="#tmon">Toastmon</A><BR>
<A HREF="toastpkg\toastpkg.htm">Toaster Installation Package</A><BR>
<A HREF="#notes">Notes</A><BR>
</PRE>
<P>
<H3><A NAME="sum"></A>Summary</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
The Toaster sample provides a starting point for Windows® 2000/XP/Server 2003 driver development. It contains annotated code to illustrate the functionality of bus driver, function driver, assorted class, device, and bus filter drivers, class-installer, and device-specific co-installer for a hypothetical Toaster bus and its devices. 

 
<H3><A NAME="intro"></A>Introduction to WDM Driver Model</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>
Every device driver stack for a Plug and Play (PnP) device under the Microsoft® Windows® 2000/XP/Server 2003 operating system typically comprises a bus driver, a function driver, and from zero to one or more filter drivers. These drivers must support Plug and Play, Power Management, and Windows Management Instrumentation (WMI) to provide a better user experience and greater satisfaction. 

 <p>

These buzzwords make sense if you have developed a driver for Windows 95 or Windows 98. But, a developer who has only worked on Windows NT® drivers might wonder: What are these things? Why do I need to worry about them? How do I implement them?

 <p>

Imagine a system with a new type of PnP I/O bus called a toaster bus. A controller chip on the motherboard initializes and manages the bus. The bus has a couple of ports jutting out of the box into which you can plug your toasters.
<p>
 

To provide support for this bus on Windows NT 4.0, you must modify the HAL (hardware abstraction layer) to recognize and initialize the I/O bus during system boot and you must provide a set of HAL functions for scanning the bus and accessing the configuration space of the devices by other drivers. Next, you must write drivers for every type of toaster device that load along with the system, and then use the exported HAL functions to scan the bus to detect the device, read the I/O resource requirements, and configure and initialize the device. These drivers are loaded regardless of whether or not a particular toaster is plugged in.  

 <p>

If another driver requires the I/O resources claimed by your driver, there is no resource distribution mechanism on Windows NT 4.0 to instruct the driver to relinquish them and use other resources if possible. If you want to expose instrumentation data or report some exceptional events to user mode, you must provide your own interface and custom applications. There is no generic interface like WMI and no power management.

 
<P>
To support this bus and its devices under Windows 2000/XP/Server 2003, however, you don’t have to modify the HAL or export a new set of functions. All you need to do is write a bus driver that has knowledge of bus architecture, identifies (enumerates) devices on the bus, reads their resource requirements, and configures them. This driver model also makes the operating system independent of its I/O bus. This means you don’t need help from Microsoft if you design a new I/O bus to modify the HAL. Then, you write function drivers to control individual devices connected to the bus. Later on, one can write one or more filter drivers to add or modify the features supported by bus, a specific device or class of devices. There can be any number of lower-level or upper-level filter drivers for a bus, a device, or a class of devices. 

 
<p>
The Windows 2000/XP/Server 2003 DDK documentation explains these new concepts and features by providing background information and describing how to implement them in your driver(s). This article and the accompanying sample drivers package provide annotated code samples that illustrate the functionality of various drivers without getting into detailed hardware specifics. These samples will help you start coding right away.

 <P>

To make the sample code closer to a real-world driver, I have defined a new class of devices called the TOASTER class and wrote a bus driver, function driver, and all possible class, device, and bus filter drivers for this hypothetical TOASTER bus and its devices. I have also provided a sample of coinstaller DLL to show how you can parse a custom section from an INF file and perform some special operations before and after the installation of a device, and how you can create FriendlyName for a device. The function and bus driver also show how you can provide power manager and WMI support.

 <P>

You can learn the implementation details of these sample drivers by looking at the code and reading the Windows 2000/XP/Server 2003 DDK documentation. The rest of this article discusses the contents of the package that accompanies this article and how to install, build, and test these drivers. This article also briefly examines the various registry entries created by the system to setup and load the drivers.  

 
<P>

<B>Note:</B>  This package is mostly intended to demonstrate WDM concepts for educational purposes. It is not to be used in a production environment in its entirety. One may not require all of the components of the package or all the features demonstrated in a single component to have a working driver. <P>


 
<H3><A NAME="toast"></A>Introduction to the Toaster Sample
</H3></FONT><FONT FACE="Verdana" SIZE=2><P>

This sample driver package contains <I>bus</I>, <I>func</I>, <I>filter</I>, <I>exe</I>, <I>inc</I>, <I>coinstaller</I>, <I>classinstaller</I>, <I>inf</I>, <I>toastmon</I>, and <I>toastpkg</I> directories. The following summary describes the directories and key files.

 <P>

<I>bus</I>

 <BLOCKQUOTE> This directory contains the source code of the toaster bus driver (Busenum.sys). The job of this driver is to service the TOASTER bus controller, enumerate devices that are plugged in, and perform bus-level power management. The bus driver supports D0 and D3 power states. It also has a WMI interface.</BLOCKQUOTE>

 <P>

<I>func</I>

 <BLOCKQUOTE> All the sub-directories under this one contain the source code of the function driver (Toaster.sys) for standard toaster devices. To be illustrative and useful learning sample for beginners to driver development, the sample has been built from almost nothing (skeletal) to fully functional, adding useful features at each step. When built, all the different versions produce toaster.sys file. You can use the standard toaster.inf or toastco.inf to install and test. You can either manually install the driver (root-enumerations) or bus enumerate the driver using the toaster bus driver. They all share one common header file present in the <I>shared</I> directory. Let us assume that the function driver owns the power policy of the toaster device and supports D0, D1 and D3 power states, and also the toaster device is capable of waking the system from D1 state. 
<OL>
<LI> <I>Incomplete1</I>: This is the simplest form of a WDM driver. It shows bare minimum functionality required to get installed and loaded in the system. You cannot open the device or talk to it. As the name suggests, this is not complete and safe enough to be used as a model for a production level driver.
<LI> <I>Incomplete2</I>: This version is slightly advanced than the incomplete1 version. This version shows how to track I/O IRPs and handle stop and remove PNP request safely with respect to driver unload. Instead of using remlocks, this sample implements its own locking scheme to be more general purpose and compatible with 9x systems. You can open the registered interface from usermode and send read, write and IOCTL requests. This is a still an incomplete sample because it doesn't handle power IRPs and do the necessary S to D power IRP conversion required by the bus driver.
<LI> <I>Featured1</I>: This is a complete version with full fledged power management and WMI support.
<LI> <I>Featured2</I>: This version contains Wait-wake support and Event Tracing support in addition to all the features supported by featured1.</BLOCKQUOTE>

 

<I>inc</I>

 <BLOCKQUOTE>This directory contains headers files that are shared among drivers and applications.
</BLOCKQUOTE>
 

<I>Disk</I>

 <BLOCKQUOTE>This directory is the build target path. All the toaster binaries are placed here during build under the respecive build_environment\target_OS sub-directories. For example, if you build under Windows Server 2003 x86 checked build environment, the target path will be disk\chk_wnet_x86\i386\. Since there are more than one version of toaster.sys, it is not placed in this directory to avoid overwriting one another. All the varoius versions of toaster.sys are built under their respective source directory.
</BLOCKQUOTE>
<I>exe </I>

 <BLOCKQUOTE>This directory contains three subdirectories <I>notify</I>, <I>enum</I>, and <I>toast</I>, with files to produce <I>notify.exe</I>, <I>enum.exe</I> and <I>toast.exe</I> (user-mode console applications):

 
<UL>
    

    <LI>
    <I>Enum.exe</I> is a user-mode enumerator, a simple console application. Because the toaster bus is not real, you need to have a mechanism to tell the bus driver when you plug in, unplug, and eject devices from the system. This application serves that purpose. Typically it’s written as a control panel applet for non-Plug and Play (legacy) devices. For example, <I>game.cpl</I>. 

 <p><PRE>

Usage: Enum [-a SerialNo] - Plugs in a device.  SerialNo. must be greater than zero.
            [-r SerialNo or 0] - Unplugs device(s). Specify 0 to unplug all the devices enumerated so far.
            [-e SerialNo or 0] - Ejects device(s). Specify 0 to eject all the devices enumerated so far.</PRE><p>
By design every toaster device will have a globally unique serial number.
<p>

     <LI>
   <I>Toast.exe</I>: This is a user-mode console application to control the toaster. <p>
   <LI>
   <I>Notify.exe</I>: This GUI application not only combines the functionality of Enum.exe and toast.exe but also shows how to handle PnP notification in user-mode. You should install the coinstaller for the toaster device by using toastco.inf to get meaninful display of PnP notification. Another cool feature of this exe is that you can specify some other HW ID (Instead of the default toaster device id) and cause other drivers to be loaded as a function driver. This is useful for testing prototype drivers to check whether the PnP code works. 

 </BLOCKQUOTE>

</UL>

<I>filter</I>
<p>
 This directory contains six different subdirectories, each producing one of the following drivers from a common source file (<I>filter.c</I>): <p>
<UL>
   
<LI>
        Class upper filter (<I>clsupper.sys</I>)

<LI>
        Class lower filter (<I>clslower.sys</I>)

<LI>
        Device upper filter (<I>devupper.sys</I>)

<LI>
        Device lower filter (<I>devlower.sys</I>)

<LI>
        Bus FDO upper filter (<I>bfdoupr.sys</I>) 

<LI>
         Bus FDO lower filter (<I>bfdolwr.sys</I>) 

 </UL>

<I>coinstaller</I>

 <BLOCKQUOTE>This directory contains source code of the device-specific coinstaller (<I>tostrco1.dll</I>). The DDK documentation has a good overview of coinstaller and its operation. The coinstaller demonstrates how to create a FriendlyName for a device based on its unique instance id. In this sample, during enumeration, the bus driver provides the serial number in the UINumber field of the device capabilities. The FriendlyName is required to uniquely identify multiple devices of the same interface class. The coinstaller also shows how to open an INF file and parse a custom section.
</BLOCKQUOTE>
 
<I>classinstaller</I>

 <BLOCKQUOTE>This directory contains source code of the class-installer (<I>tostrcls.dll</I>). The DDK documentation has a good overview of classinstaller and its operation. This dummy class-installer included to provide a class icon for all the TOASTER Class devices. It is copied to the system32 directory when the class is installed for the first time in the system.
</BLOCKQUOTE>

<I>inf </I>
<p>
 This directory contains 3 subdirectories (i386, amd64, & ia64) and each contains following files:
<p>
 
<UL>
  <LI>
       <I>bus.inf</I>: This .inf installs the <I>basenum.sys</I> and sets up the registry.

 
<LI>
       <I>simple.inf</I>: This .inf creates <B>Toaster</B> class, installs <I>toaster.sys</I> and sets up the registry.

<LI>
       <I>toaster.inf</I>: This .inf file is functionally similar to <I>simple.inf</I> but also installs the class-installer. The class-installer provides custom icon for the class and an advanced property page to change the friendlyname of the device in the device manager.

<LI>
       <I>toastco.inf</I>: This .inf file is functionally similar to toaster.inf but also installs the coinstaller. The co-installer is used to dynamically create a unique friendlyname of the device based on the serial number.
 

<LI>
       <I>busf.inf</I> and <I>toasterf.inf</I>: These two .inf files are functionally similar to the above INF files but also install all the previously mentioned filter drivers. 


<LI>
        <I>filter.inf</I>: This .inf installs just a device upper filter for the toaster device. Please read the Filter section in this article on how to use this .inf file.


<LI>
        <I>toaster.cat</I>: This is a dummy catalog file. 

</UL>

<p>


<I>toastmon </I>
<BLOCKQUOTE>
This has the source of a root-enumerated driver called <I>toastmon.sys</I>. More information on this is covered later in the <B>Toastmon</B> section. 
</BLOCKQUOTE> 

<I>toastpkg</I>
<BLOCKQUOTE>
This has the sources for an integrated device installation solution that illustrates how to provide support for the various user approaches to adding new hardware, while providing optional value-added software, etc.  More information is contained in the <A HREF="toastpkg\Toastpkg.htm">toastpkg.htm</A> file in the <I>toastpkg</I> directory.
</BLOCKQUOTE> 

<H3><A NAME="build"></A>Building the sample</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>
To build the sample drivers, you must first set up the DDK environment on your host machine. The “Installation and Release Notes” in the Windows 2000/XP/Server 2003 DDK has a complete description on how to do this.

 <OL>


 <LI>
     Run the build –ceZ command in the Toaster directory to build <I>busenum.sys</I>, <I>toaster.sys</I>, <I>enum.exe</I>, <I>toast.exe</I>, <I>tostrco1.dll</I>, <I>tostrcls.dll</I>, and the six filter drivers mentioned previously. 

 

 <LI>
     Copy all the .sys, .exe, .dll, a bus driver INF file (bus.inf), toaster.cat, and a toaster device INF file (toastco.inf) to a floppy disk or a temporary directory on the target system.
</OL>
  <P>


<H3><A NAME="install"></A>Installation</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>


First install the bus driver. To install the bus driver on Windows 2000: <p>

<OL>

<LI>
      Double-click the ‘Add/Remove Hardware’ wizard in Control Panel.
<LI>
      At the Add/Remove Hardware Wizard, click Next.
<LI>
      Choose the ‘Add/Troubleshoot a device’, then click Next.

<LI>
      Select ‘Add a new device’ from the list, then click Next.

<LI>
      Select ‘No, I Want to Select the Hardware from a list’ and then click Next.

<LI>
      Select ‘System Devices’ and then click Next. NOTE: This might take a few minutes.


<LI>  Click 'Have Disk', make sure that 'A:\' is in the "Copy manufacturer's files from:" box, and click OK.

<LI>  Click on the desired of the two entries, and then click Next.

<LI>  At 'Start Hardware Installation,' click Next.

<LI>  Click Finish at 'Completing the Add/Remove Hardware Wizard.'
  
 </OL>

To install the bus driver on Windows XP and Windows Server 2003: <p>

<OL>

<LI>
      Double-click the ‘Add Hardware’ wizard in Control Panel.

<LI>
      At the 'Welcome to the Add Hardware Wizard', click ‘Next’.

<LI>
      Select 'Yes, I have already connected the hardware', then click Next.
<LI>
      Select ‘Add a new hardware device’ from the list, then click Next.

<LI>
      Select ‘Install the hardware that I manually select from a list(Advanced),' and then click next.

<LI>
      Select ‘System Devices’, then click Next. 

<LI>  Click 'Have Disk', make sure that 'A:\' is in the "Copy manufacturer's files from:" box, and click OK.

<LI>  Click on the desired entry, and then click Next.

<LI>  At 'The wizard is ready to install your hardware', click Next.

<LI>  Click Finish at 'Completing the Add/Remove Hardware Wizard.'
 </OL>
<p>
The system copies the <I>busenum.sys</I> file to the <I>%Systemroot%\system32\drivers</I> directory and sets up the following registry keys to represent the bus driver to the PnP manager:
<p>

 

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E97D-E325-11CE-BFC1-08002BE10318}\nnnn 
<br>
  // nnnn is the instance number of this System Class driver on the system.
<p>
 

It copies the INF file as OEM.n.INF, where n is a zero-based number, to the system INF directory. It also creates the standard Services keys to load the driver:
<p>
 

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\busenum. 
<p>
 

 

Once installed the system creates device registry keys (Hardware keys) under:

 <p>

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\Root\SYSTEM\nnnn
<br>
  // nnnn is the instance number of this System Class driver on the system.
<p>
 

Another quick way to install the bus driver without going through so many mouse clicks would be to use the Installer sample application present in the <I>ntddk\src\general\devcon</I> directory. This sample allows you to root-enumerate a driver with one simple command. Please read the help file included in the sample on how to build and use the application to install this driver. To install the bus driver using devcon.exe:

<BLOCKQUOTE> <PRE>
c:\>devcon.exe  install  bus.inf  "root\busenum"
</PRE></BLOCKQUOTE>

<p>


<H3><A NAME="test"></A>Testing</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>

Once the Toaster bus driver is installed and started by the PnP Manager, you can run the <I>enum.exe</I> or Notify.exe application from the command prompt to simulate plug in, unplug or ejection of toaster devices on the system. Both these applications basically send an I/O control (IOCTL) to the bus driver with the user provided globally unique serial number and Hardware ID of the device, and trigger the entire enumeration process. The PnP manager takes the ID information provided by the bus driver and searches the system INF directory to find a matching INF file. If it doesn't find a suitable INF file (that would be the case when you install for the first time) it prompts the user to specify an INF file. At this point, you can pick one of the three INF files (toaster.inf, toastco.inf or toasterf.inf) to be the device INF file. If you are testing this sample for the first time, you should choose toastco.inf. 
<P>
You can remove/eject a single device by giving its serial number or remove/eject all the devices by specifying 0 (zero) as the serial number of the device. 

 <p>

<B>To plug in a device (or rather simulate a device arrival):
</B>
 
<BLOCKQUOTE>
C:\>enum -p 1
</BLOCKQUOTE>
 

<B>To unplug a device:
</B>
 

<BLOCKQUOTE>C:\>enum -u 1
</BLOCKQUOTE>
 

<B>To eject a device:
</B>
 

<BLOCKQUOTE>C:\>enum -e 1
</BLOCKQUOTE>
 

To test a plugged in device, you can use the <I>toast.exe</I> application. This application basically enumerates all the toaster class devices, displays its properties such as FriendlyName, InstanceId, and opens the last enumerated device to perform a read operation and send a DeviceIoControl to the device depending on the user command line option. 

 <p>

If you invoke without any option it basically opens the last enumerated interface and prompts you to initiate a Read operation in a loop. You press any key to continue the read loop or press ‘q’ to break out of the loop. If you use the –h option it opens the last enumerated interface and sends a DeviceIoControl to hide the device from the Device Manager before performing read.

 <p>

Usage: Toast <–h> {-h option causes the device to hide from Device Manager UI}

 <p>

Both these applications use the SetupDi functions to enumerate and open the device interfaces. These functions are documented in the Windows 2000/XP/Server 2003 DDK documentation.


<p>

<H3><A NAME="filter"></A>Filters</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>

You can install device filter drivers by specifying LowerFilters or UpperFilters to the Hardware registry key (HKLM\ \SYSTEM\CurrentControlSet\Enum) for the device; and class filters by specifying them to the Software registry key (HKLM\SYSTEM\CurrentControlSet\Control\Class\<GUID>) for the device class. 
<p>
Because this is an MULTI_SZ string, you can specify more than one filter for the device or class. If you specify more than one, the load order is in the order they are listed – the filter at the end of list is the topmost driver in the stack, and so on. However filter drivers should not be written to rely on this order, because the load order can change and other filter drivers may or may not be there in the group. You can install device specific filters by using a [.HW] section that specifies AddReg section, and class specific filters by specifying AddReg section from the base install section in your INF file. The <I>busf.inf</I> and <I>toasterf.inf</I> show how to do that. 
<p>
 

The <I>filter.inf</I> file is a special .inf file that enables you to install a filter driver for the toaster device after it has been installed and enumerated. To install an upper device filter for a toaster device on Windows 2000: 

 <OL>
  
<LI>
      Enumerate a toaster device.

<LI>
      Open the Device Manager. 

<LI>
      Open the Properties of the Toaster device for which you want to install filter.

<LI>
       Click the Driver tab, and then click Update Driver. 

<LI>
      Follow the wizard's prompts, and when prompted, select the Display a list of the known drivers option. 

<LI>
      Click Have Disk and point to the location of the filter.inf file. 

<LI>
      Proceed through the rest of the install. 
</OL>

 <p>


<H3><A NAME="params"></A>Device Parameters Subkey</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>


Currently the sample doesn’t show how to read Device Parameters value from the registry. This feature will be added in the future updates of this driver.
<P>
Under Windows 2000/XP/Server 2003, the configuration information is not stored under the Services key of the driver. It is stored in three different places, depending on whether it’s device instance specific, driver specific or interface specific. 

 <P>

You can store device-specific configuration information under the Hardware key of that particular device instance (HKLM\SYSTEM\CCS\Enum\&lt;DeviceId&gt;\&lt;VendorId&gt;\&lt;InstanceId&gt;\Device Parameters) and driver-specific information under the Software key (HKLM\SYSTEM\CCS\Control\Class\&lt;GUID&gt;\&lt;driver-instance-id&gt;\ Device Parameters) of the driver by using <B>IoOpenDeviceRegistryKey</B> function. 

 <P>

You can store interface-specific information under the device-interface key (HKLM\SYSTEM\CurrentControlSet\Control\DeviceClasses\{GUID}\&lt;SymbolicLinkName&gt;\Device Parameters) by calling <B>IopenDeviceInterfaceRegistryKey</B> with the symbolic link name of the device interface. Both of these functions return the handle to the <B>Device Parameters</B> subkey. For legacy support, you can continue to store information under the Services key.

<P>
<H3><A NAME="power"></A>Power Management</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>


In this example, the function driver acts as a power policy owner for the toaster device and supports DO and D3 power mode. You can use the same power logic to implement power policy in the bus driver. You need a system with an ACPI-compatible BIOS in order to test the power management code. If you have an ACPI compatible system, you will see a Standby option in the Shutdown submenu.
<H5>Code Walkthrough</H5>Following paragraphs illustrate how the funcion 
driver handles various power requests (power.c). The graph below shows the order in 
which various functions are called in each case. For clarity, the word Toaster has
been removed from all the function names.
<P>
<B>Query Power Request (IRP_MN_QUERY_POWER):</B>The function driver first sends the 
system query power IRP (S-IRP) down to the bus 
driver and when the IRP gets completed, it generates a device query power IRP (D-IRP)
 in the completion routine. The S-IRP is marked pending and saved in the FDO device-extension. The 
function driver then receives the newly generated D-IRP as it gets sent from 
the top of the stack by the power manager. If the device is going into a low 
power state, it marks the queue state to hold any incoming requests, waits 
for the all the pending I/Os to complete, and forwards the D-IRP down to the 
bus driver. When the bus driver completes the IRP, the power manager calls 
the power IRP completion routine. Here, in the power IRP completion routine, 
the function driver completes the S-IRP.</P>
<PRE>
    DispathPower (S-IRP)
    |
    |---->DispatchQueryPowerState
               |
               |---->DispatchSystemPowerIrp
                           |
                           |---->PoCallDriver to Busdriver
                                        |
          CompletionSystemPowerIrp*<----|
          |
          |---->QueueCorrespondingDeviceIrp (1)
                      |
                      |---->DispathPower (D-IRP)
                                 |
                                 |---->DispatchQueryPowerState
                                            |
                                            |---->DispatchDeviceQueryPower (2)
                                                       |
                                                       |---->FinalizeDevicePowerIrp
                                                                  |
                                                                  |---->PoCallDriver to Busdriver
                                                                              |
                                         CompletionOnFinalizedDeviceIrp**<----|
                                         |                        
                                         |---->IoCompleteRequest (S-IRP)

</PRE>
<B>Set Power Request to Power-Down(IRP_MN_SET_POWER):</B> The function driver first sends the S-IRP 
down to the bus driver and when it completes, it generates a D-IRP in the
completion routine. The S-IRP is marked pending and saved in the FDO device-extension. The function driver then receives the newly generated D-IRP as 
it gets sent from the top of the stack. If the device is going into low power 
state, it saves the device context, powers down the device and 
then forwards the D-IRP down to the bus driver. When the bus driver 
completes the IRP, the power manager calls the power IRP completion 
routine. Here the function driver completes the S-IRP.
<PRE>
    DispathPower (SIRP)
    |
    |---->DispatchSetPowerState
           |
           |---->DispatchSystemPowerIrp
                       |
                       |---->PoCallDriver to Busdriver
                                    |
      CompletionSystemPowerIrp*<----|
      |
      |---->QueueCorrespondingDeviceIrp (call PoRequestPowerIrp to generate D-IRP)
                  |
                  |---->DispathPower (D-IRP)
                             |
                             |---->DispatchSetPowerState (D-IRP)
                                        |
                                        |---->DispatchDeviceSetPower
                                                   |
                                                   |---->CallbackHandleDeviceSetPower (3) 
                                                              |
                                                              |---->FinalizeDevicePowerIrp
                                                                          |
                                                                          |---->PoCallDriver to Busdriver
                                                                                      |
                                                 CompletionOnFinalizedDeviceIrp**<----|
                                                 |  
                                                 |--->IoCompleteRequest (S-IRP)
</PRE>
<B>Set Power Request to Power-Up(IRP_MN_SET_POWER):</B>  The function driver first sends the S-IRP down
to the bus driver and when it completes it generates a D-IRP in the completion 
routine. The S-IRP is marked pending and saved in the device extension. The function
driver then receives the newly generated D-IRP as it gets sent from the top of the 
stack. If the pending S-IRP is for restoring the power state of the system to S0, the 
driver first completes the S-IRP and then if the device is in a low power state, it powers up the device, restores 
the device context and processes any pending IRPs waiting  in the queue. The reason the S-IRP is 
completed before the D-IRP during power-up is to speed-up the system resume as restoring the device to 
Do usually takes longer. One thing to note here is that to avoid receiving remove IRP from
PNP manager, you must first request D-IRP and then complete the S-IRP, You shouldn't do that in 
reverse order because the PNP manager guarantees that as long as an S-IRP is pending, it will
not send a remove request. Then the function driver forwards the D-IRP down to the bus driver. When the bus driver 
completes the IRP, the power manager calls the power IRP completion 
routine. Here the function driver completes the S-IRP.
<PRE>
    DispathPower (SIRP)
    |
    |---->DispatchSetPowerState
           |
           |---->DispatchSystemPowerIrp
                       |
                       |---->PoCallDriver to Busdriver
                                    |
      CompletionSystemPowerIrp*<----|
      |
      |---->QueueCorrespondingDeviceIrp (call PoRequestPowerIrp to generate D-IRP)
                  |
                  |---->DispathPower (D-IRP)
                             |
                             |---->DispatchSetPowerState (D-IRP)
                                        |
                                        |---->DispatchDeviceSetPower (Complete S-IRP)
                                                   |
                                                   |---->PoCallDriver to Busdriver
                                                                 |
                                    CompletionDevicePowerUp*<----|
                                     |                          
                                     |---->CallbackHandleDeviceSetPower (4)
                                                |
                                                |---->FinalizeDevicePowerIrp 
                                                           |
                                                           |---->IoCompleteRequest (D-IRP) 
                                                                       |
                                                                       |---->CompletionOnFinalizedDeviceIrp**
                                                                     
</PRE>                                                             
                            
* - This is an IRP completion routine set using IoSetCompletionRoutine.<P>
** - This is a Power IRP completion routine specified in PoRequestPowerIrp when we generate D-IRP. 
<P>
The difference is that the IRP completion routine is called by the I/O manager
when the lower driver calls IoCompleteRequest but the 
power IRP completion routine is called by Power manager, 
just before freeing the IRP memory, when the IRP finally returns back to it.
<OL>
<LI>Calls PoRequestPowerIrp to generate D-IRP and sets 
   CompletionOnFinalizedDeviceIrp as the power IRP completion routine.
<LI>If the system is going to lower power state, start queuing requests. 
<LI>This is a worker thread spawned to run at PASSIVE_LEVEL. 
    Here, save the device-context and power-down the devie.

<LI>This is a worker thread spawned to run at PASSIVE_LEVEL. 
    Here, power-up the device and restore device context. 
    If there are IRPs pending in the queue process them.


</OL>
<P>

<H3><A NAME="wmi"></A>WMI</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>

A WMI interface is provided to both the function and bus driver. The WMI library is used to handle WMI IRPs. The MOF files, which define WMI data and event blocks, are compiled along with the driver and included in the driver’s binary image. 

 <P>

To test the WMI interface, first install the WMI SDK on your system. Then, use either <I>wbemtest.exe</I> or CIM Studio to enumerate the instances registered by these drivers. 

 <P>

For example, to see the data exported by the Toaster driver:  <P>


<OL>
 
 <LI>
     Run <I>wbemtest.exe</I>. 

 <LI>
      Connect to “root\WMI” class. 

 <LI>
      Click Enum Instances. 

 <LI>
     Type ToasterDeviceInformation and press Enter. 

 </OL>

You should see the toaster device instances. The DebugPrintLevel data in both the drivers have been made read/write, so that it is possible to dynamically change the value of these variables with the WMI application and control the driver debug trace seen on Windbg.

<p>
You can also generate a HTML script using the bmf file (wmimofck -whtml toaster.bmf) and test both the data and event blocks exported by the driver. The toaster driver fires a ToasterNotifyDeviceArrival event every time a device is plugged in and started successfully. For more information on WMI testing, check http://support.microsoft.com/support/kb/articles/q252/6/79.asp. The function driver's WMI handler also responds to WMI queries from Device Manager to provide Power Manangement tab in the device properties dialog.

 <P>

<H3><A NAME="etw"></A>Event Tracing (ETW)</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>
Event tracing in Windows (aka software tracing) allows drivers to log debug trace messages efficiently without affecting system performance. You can selectively enable tracing on your target machine and log messages. You can do the tracing both on free and checked build system without requiring a kernel-debugger or serial connection. You can watch the traces simultaneously in the target machine and also in the kernel-debugger. The steps required to provide software tracing is fairly easy and documented in the DDK "WPP Software Tracing" section. These are the following things I did to get tracing support in toaster function driver.
<OL>
<LI>Generated a GUID (C56386BD-7C67-4264-B8D9-C4A53B93CBEB) using GUIDGEN. This GUID will be used as the control Guid (provider guid) for toaster.
<LI>Defined the debug flags and GUID in a header file (toaster.h). Look for WPP_CONTROL_GUIDS.
<LI>Included a file called xyz.tmh, where xyz is name of the source file, in every source file after all other includes files and before any WPP macros are called.
<LI>Registered for tracing in DriverEntry by calling WPP_INIT_TRACING(DriverObject, RegistryPath).
<LI>Deregistered for tracing in ToasterUnload by calling WPP_CLEANUP(DriverObject).
<LI>Added RUN_WPP=$(SOURCES) line to "sources" file to pre-process the WPP macro and generate xyz.tmh files.
<LI>Informed RUN_WPP to map all my ToasterDebugPrint calls to native DoTraceMessage function by using the <I>func:</I> option in RUN_WPP preprocessor directive.
</OL>
<P>Through out the code, you will see different implementation for enabling tracing on Windows 2000. This is due to the fact that tracing enable/disable is handled via IRP_MJ_SYSTEM_CONTROL dispatch handler in Win2K and via an explicit callback in XP and beyond. So if you have your own WMI handler, you have to add few extra WPP macros to workaround the issue. This also has an unavoidable side-effect that drivers on Win2K can be traced only if they have a device object. So, for WDM drivers that typically create their deviceobject in AddDevice, it's not possible to trace DriverEntry calls.
<P>

<P>
<B>Logging the traces in a file:</B>
<OL>
<LI>Generate Trace message format (.TMF) files from the toaster.pdb file. You can do that by calling "tracepdb -f toaster.pdb" in the DDK build environment. This command will produce two files, C56386BD-7C67-4264-B8D9-C4A53B93CBEB.tmc and yyy.tmf, where yyy is some guid, for every source file that makes the ToasterDebugPrint tracing call.
<LI>Copy all the tmf files to the target machine in a temporary directory, say c:\temp.
<LI>Install the toaster driver. 
<LI>Copy all the tracing tools from %DDKROOT%\tools\tracing directory to your target machine's temp directory.
<LI>Create a text file called toaster.ctl, and add the following line, "C56386BD-7C67-4264-B8D9-C4A53B93CBEB toaster".
<LI>Set TRACE_FORMAT_SEARCH_PATH environment variable to point to the directory where the TMF files are present. In our case, it is c:\temp.
<LI>Enable debug tracing by calling "tracelog -start -guid toaster.ctl -f toaster.bin -flags 0x1"
<LI>Force the driver to do something. You can either disable/enable or run toast.exe and send read requests. All the debug messages will be logged in toaster.bin file in a binary form. 	
<LI>Stop the logger by calling "tracelog -stop toaster"
<LI>Finally, format the binary log file to get human readable text file by calling "tracefmt -nosummary toaster.txt toaster.bin". </OL><P>

Note that you can also get realtime traces by using the -rt option of tracelog at the time you enable the tracing. You can also use the TRACEVIEW (src\tools\traceview) utility from the DDK to get the traces easily. This GUI tool has been built around the other tracing utilities mentioned above to make the task of getting traces a lot easier.
<P>
<B>Getting the traces in realtime on the host machine and in kernel debugger:</B>
<OL>
<LI>Enable realtime tracing on the target machine with -kd option.
<PRE>c:\temp>tracelog -start toaster -rt -kd -ft 1 -guid toaster.ctl -flags 0xff</PRE>
<LI>On the host-side, in the kernel debugger, turn on dynamic printing by using !WMITRACE debugger extension.
<PRE>kd>!wmitrace.dynamicprint 1</PRE>
<LI>Then, set the WMI trace search path to the directory that contains all the TMF files generated earlier.
<PRE>kd>!wmitrace.searchpath path_of_TMF_files</PRE>
<LI>Also make sure that !wmitrace.guidfile is set to default.tmf or system.tmf depending on where you have that file in relation to the debugger.<P>
<LI>If the tracing is enabled, you should see a 'toaster' session entry listed when you dump the event trace structures. For example:
<PRE>
0: kd> !wmitrace.strdump
(WmiTracing)StrDump Generic
  LoggerContext Array @ 0x80BF1760 [64 Elements]
    Logger Id  2 @ 0x820C5000 Named 'MSDTC_TRACE_SESSION'
    Logger Id  3 @ 0x81AAF000 Named 'toaster'
</PRE>
<LI>You can view the traces in realtime on the target machine by running: <pre>tracefmt.exe -rt toaster -p path_of_TMF_files -display</pre>
</OL>
<P>Please note that !wmitrace debugger extension is not supported on Win2K. So you wouldn't able to see the traces of a Win2K  system in a kernel debugger.
<P>
<H3><A NAME="tmon"></A>Toastmon</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>

This driver demonstrates how to handle PnP notification in kernel-mode. Using the toastmon.inf file you can install this driver with Add Hardware wizard. This driver gets root-enumerated and in it's AddDevice it registers for device arrival notification on the Toaster interface class. When you plugin a toaster device, the system calls the notification handler and the driver opens the associated device and registers for Device Change notification. When you disable/unplug/eject the toaster device the driver notification handler is called to close handle to the device. The technique demonstrated in this sample is useful when you write a driver that wants to talk to a device that your driver is not controlling.
 

<P>
<H3><A NAME="notes"></A>Notes</H3></FONT><FONT FACE="Verdana" SIZE=2><P>

None of the drivers or applications in this sample package has been made compatible or tested on Windows 9x systems. So they are not "WDM" drivers - in that they are not source compatible with Windows 9x. These code samples are primarily geared towards Windows 2000 and future releases of OS. However they can be easily adapted to work on Windows 9x systems by following the compatibily notes in the code and as well as Walter Oney's "Programming Windows Driver Model" book. 

<P>
</FONT><P ALIGN="CENTER"><A HREF="#top"><FONT FACE="Verdana" SIZE=2>Top of page</FONT></A><FONT FACE="Verdana" SIZE=2> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff" HEIGHT=2>
<P></TD>
</TR>
</TABLE>

<FONT FACE="MS Sans Serif" SIZE=1><P>&copy; Microsoft Corporation 2002</FONT><FONT FACE="Verdana" SIZE=2> </P></FONT></BODY>
</HTML>

