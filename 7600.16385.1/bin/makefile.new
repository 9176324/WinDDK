
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    makefile.def

Abstract:

    This is the standard makefile for the components of the NT project.
    It includes the following files:

        .\sources.      - developer supplies this file.  It defines the
                          required TARGETNAME, TARGETTYPE and
                          SOURCES as well as optional macros that control
                          the behavior of the compiler and linker:

        $(OBJ_PATH)\$O\_objects.mac  - built by BUILD.EXE from .\sources.


Targets:

    all       - Builds all targets in this make file


Useful Variables Set:

    CPUTYPE={I386|IA64|AMD64|ARM}

Optional Controls Variables (partial list), these are environment variables,
remember they can be set with env=value on the command line as well:

NOTE:  xxx_... is {MSC|386|ia64|amd64} where MSC_ applies to the C compiler
       independent of the cpu type.  Specific cpu_ will take precedence
       over the equivalent MSC_ variable.

    NTKERNEL=filename

    UMAPPL=filename

    NT_UP
            Define as 0 in environment to turn on MP.
            If undefined or equal to 1, you get UP.

    xxx_warning_level

    xxx_optimization

    xxx_STDCALL = 1 use _stdcall calling convention
                  0 use _cdecl calling convention

    NTDEBUG

    BROWSER_INFO

    NT_INST - set to turn on instrumentation

    BASEDIR - \nt or \ntrel (default \nt)

    PRECOMPILED_CXX=1 - do precompiled headers for CXX instead of C files
                        note: precompiled headers can not be used on both
                        c and cxx files in a single directory.
!ENDIF


#
# Managed code is x86 and is very slow on IA64, doubling build times.
# Turn off some of the build tools that use managed code.
# More critical x86 tools remain -- csc.exe, managed C++ cl.exe.
#
!if "$(HOST_PROCESSOR_ARCHITECTURE)" == "ia64" || "$(PROCESSOR_ARCHITECTURE)" == "IA64"

DISABLE_CV=1
!undef DO_LSBUILD

!endif

# Store away the original value of %_NTTREE% so we can use it later
# for things like LCG creation that binplace extra generated files
# to a different root under %_NTTREE% with %_ALT_TARGET_PATH% (if set)
# appended after that.
!if [set NTTREE_ORIG=$(_NTTREE)]
!endif

!ifdef BINPLACE_LOG
BUILD_LOGS=$(BINPLACE_LOG)\..
!if !exist($(BUILD_LOGS)\sidebyside)
!if [mkdir $(BUILD_LOGS)\sidebyside 2>nul]
!endif
!endif
!endif

# See if the user wants BROWSER_INFO.
!ifdef BROWSER_INFO
USER_ENV_BROWSER_INFO=1
!endif

!ifndef MUI
MUI=1
!endif

#
# Select build target and set platform specific variables.
#

!ifdef BUILD_ALLOW_ALL_WARNINGS
BUILD_ALLOW_LINKER_WARNINGS=1
BUILD_ALLOW_COMPILER_WARNINGS=1
!endif
BUILD_ALLOW_MIDL_WARNINGS=1

!ifndef BUILD_ALLOW_LINKER_WARNINGS
LINKER_WX_SWITCH=/WX
!else
LINKER_WX_SWITCH=
!endif

!ifndef BUILD_ALLOW_COMPILER_WARNINGS
COMPILER_WX_SWITCH=/WX
!else
COMPILER_WX_SWITCH=
!endif

!ifndef BUILD_ALLOW_MIDL_WARNINGS
MIDL_WX_SWITCH=/WX
!else
MIDL_WX_SWITCH=
!endif

!include $(NTMAKEENV)\makefile.plt

!ifndef MASTER_VERSION_FILE
!if "$(POCKETPC)" == ""
MASTER_VERSION_FILE = $(SDK_INC_PATH)\ntverp.h
!endif
DEFAULT_VERSION_FILE=1
!endif

!if exist($(OBJECT_ROOT)\$O\ntverpmk.inc)
!include $(OBJECT_ROOT)\$O\ntverpmk.inc
!endif

!ifdef OFFICIAL_BUILD_MACHINE
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES) /DOFFICIAL_BUILD=1
BBT_BINPLACE_PREBBT=1
!endif

BINPLACE_INSTRUMENTED_BINARIES=1

#
# Optionally include version and public key information from generated file.
# The file is large and slow to be processed by nmake so we only use it if
# it is asked for.
#
!if defined(USE_VERSIONS)
!if "$(USE_VERSIONS)" != "1"
!error The only legal value for USE_VERSIONS is 1.
!endif
!if exist($(OBJECT_ROOT)\$O\versionsmk.inc)
!include $(OBJECT_ROOT)\$O\versionsmk.inc
!endif
!endif

!ifndef LANGUAGE
LANGUAGE=usa
!endif

#
# Include the developer supplied file that defines the TARGETNAME,
# TARGETTYPE and SOURCES macros.  Make sure it defines them.
#

!ifdef USE_CAPK
# Kernel profiling - icecap api's come from the kernel or from rtl\icecap.c when building the kernel/hal/ntdll
USE_ICECAP4=1
PERFLIBS=
!endif

!if defined(USE_ICECAP) || defined(USE_ICECAP4) || defined(USE_DLP)
! ifdef USE_ICECAP
PERFFLAGS=-Gh
PERFLIBS=$(SDK_LIB_PATH)\icap.lib
! else
!  ifdef USE_ICECAP4
PERFFLAGS=/fastcap
!  else # USE_DLP
PERFFLAGS=/dlp
!  endif
!  ifndef PERFLIBS
PERFLIBS=$(SDK_LIB_PATH)\icecap.lib
!  endif
! endif
! if $(FREEBUILD)
NTDEBUG=ntsdnodbg
! else
NTDEBUG=ntsd
! endif
NTDEBUGTYPE=windbg
!endif

#
# If you want to run on an older version of the OS, then set
# _NT_TARGET_VERSION to one of the below in your sources file
#

_NT_TARGET_VERSION_LATEST   =$(__LATEST_NT_TARGET_VERSION)
_NT_TARGET_VERSION_WIN7     =0x601
_NT_TARGET_VERSION_VISTA    =0x600
_NT_TARGET_VERSION_LONGHORN =0x600
_NT_TARGET_VERSION_WS03     =0x502
_NT_TARGET_VERSION_WINXP    =0x501
_NT_TARGET_VERSION_WIN2K    =0x500
_NT_TARGET_VERSION_NT4      =0x400

#
# Most current defaults for version info, can be overridden explicitly or
# by setting _NT_TARGET_VERSION in your sources file
#

LATEST_NTDDI_VERSION        =0x06010000

LATEST_WIN32_IE_VERSION     =0x0800
LATEST_WIN32_WINNT_VERSION  =0x0601

LATEST_WIN32_WIN95_VERSION  =0x0400
LATEST_WIN32_WCE_VERSION    =0x0300
LATEST_SUBSYSTEM_VERSION    =6.01

#
# Run miscfiles rules during both compile and link phases.  Sources file
# can override by setting this a value other than 0
#

MISCFILES_DURING_LINK=0

# Validate INTL_DEPOT if it's set
!if defined (INTL_DEPOT)
! if "$(INTL_DEPOT)" != "1"
!  error INTL_DEPOT can only be set to 1
! endif
!endif

#
# Special macros used to point to things in %_NTTREE%\loc\src.
# Can be used throughout this makefile and in sources files.
#
LOC_DIR=loc
LOC_SRC=$(LOC_DIR)\src
LOC_BIN=$(LOC_SRC)\bin
LOC_MULTI=$(LOC_SRC)\multi
LOC_LCG=$(LOC_SRC)\LCG
!if "$(INTL_DEPOT)" == "1"
LOC_PRELOC=$(LOC_DIR)\bindrop
!else
LOC_PRELOC=$(LOC_SRC)\preloc
!endif

#
# Set LOC_UA properly so it can be used in sources files. NOTE: This is _not_
# for use in the rest of this makefile. We do this here to allow PRELOC_LANG
# or PRELOC_BASE_LANG to be set in project.mk and have that affect what LOC_UA
# is set to in their sources files. This is how the UA bits in the Intl depots work.
#
!if defined(PRELOC_LANG)
LOC_UA=$(LOC_PRELOC)\$(PRELOC_LANG)\UA
LOC_EULA=$(LOC_PRELOC)\$(PRELOC_LANG)
!else
# This covers the case of PRELOC_BASE_LANG=1 and of neither PRELOC_BASE_LANG
# or PRELOC_LANG being set - we default to the same location in both cases.
LOC_UA=$(LOC_BIN)\UA
LOC_EULA=$(LOC_BIN)
!endif



!INCLUDE .\sources
SOURCES_USED=$(SOURCES_USED) .\sources

#
# Attempt to include the sources file from the target subdirectory.
#
!IF EXIST(.\$(TARGET_DIRECTORY)\sources)
!message BUILDMSG: $(MAKEDIR): this directory includes .\$(TARGET_DIRECTORY)\sources.  This may override macros specificed in $(MAKEDIR)\sources.
! INCLUDE .\$(TARGET_DIRECTORY)\sources
SOURCES_USED=$(SOURCES_USED) .\$(TARGET_DIRECTORY)\sources
!ENDIF

#
# Attempt to include the sources file from the parent target subdirectory.
#

!IF EXIST(..\$(TARGET_DIRECTORY)\sources)
!message BUILDMSG: $(MAKEDIR): this directory includes ..\$(TARGET_DIRECTORY)\sources.  This may override macros specificed in $(MAKEDIR)\sources.
! INCLUDE ..\$(TARGET_DIRECTORY)\sources
SOURCES_USED=$(SOURCES_USED) ..\$(TARGET_DIRECTORY)\sources
!ENDIF


# move into build.exe for perf

#
# People tend to think that just because their C++ code #includes some midl output, they need BUILD_PASS0_CONSUMES, or
# that all managed code needs BUILD_PASS0_CONSUMES or BUILD_CONSUMES. These are false.
#
!if defined(BUILD_PASS0_CONSUMES)
# net\peernet\collabspaces\src\collabhookhost uses $(TARGET_DIRECTORY)_SOURCES
# some directories do use capital .IDL
# CONSIDER: move this into build.exe.
!if !defined(NTTARGETFILE0) \
    && "$(SOURCES:.idl=)"       == "$(SOURCES)"       && "$(SOURCES:.odl=)"       == "$(SOURCES)"       \
    && "$(SOURCES:.IDL=)"       == "$(SOURCES)"       && "$(SOURCES:.ODL=)"       == "$(SOURCES)"       \
    && "$(I386_SOURCES:.idl=)"  == "$(I386_SOURCES)"  && "$(I386_SOURCES:.odl=)"  == "$(I386_SOURCES)"  \
    && "$(I386_SOURCES:.IDL=)"  == "$(I386_SOURCES)"  && "$(I386_SOURCES:.ODL=)"  == "$(I386_SOURCES)"  \
    && "$(AMD64_SOURCES:.IDL=)" == "$(AMD64_SOURCES)" && "$(AMD64_SOURCES:.ODL=)" == "$(AMD64_SOURCES)" \
    && "$(AMD64_SOURCES:.idl=)" == "$(AMD64_SOURCES)" && "$(AMD64_SOURCES:.odl=)" == "$(AMD64_SOURCES)" \
    && "$(IA64_SOURCES:.idl=)"  == "$(IA64_SOURCES)"  && "$(IA64_SOURCES:.odl=)"  == "$(IA64_SOURCES)"  \
    && "$(IA64_SOURCES:.IDL=)"  == "$(IA64_SOURCES)"  && "$(IA64_SOURCES:.ODL=)"  == "$(IA64_SOURCES)"
!message $(MAKEDIR) BUILD_PASS0_CONSUMES is not needed here and is counterproductive; remove it.
!endif
!endif

!if defined(BUILD_PASS0_PRODUCES)
!if !defined(NTTARGETFILE0) && "$(SOURCES:.idl=)" == "$(SOURCES)" && "$(SOURCES:.mc=)" == "$(SOURCES)" && "$(SOURCES:.odl=)" == "$(SOURCES)" \
    && "$(SOURCES:.IDL=)" == "$(SOURCES)" && "$(SOURCES:.MC=)" == "$(SOURCES)" && "$(SOURCES:.ODL=)" == "$(SOURCES)" \
    && !defined(EVENTS_MANIFEST) && !defined(SLS_LICENSING_MANIFEST) && !defined(PASS0_PUBLISH)
!message $(MAKEDIR) BUILD_PASS0_PRODUCES is not needed here and is counterproductive; remove it.
!endif
!endif

!if (defined(BUILD_CONSUMES) || defined(BUILD_PRODUCES)) && ("$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "DRIVER")
!message BUILDMSG: $(MAKEDIR): BUILD_CONSUMES/PRODUCES is unnecessary, remove it.
!endif

#
# move into build.exe for perf and then write result into _objects.mac
#
!if !defined(USE_DLLDEF_OBJECTS) && defined(DLLDEF_OBJECTS)
USE_DLLDEF_OBJECTS=1
!elseif !defined(USE_DLLDEF_OBJECTS)
USE_DLLDEF_OBJECTS=0
!elseif "$(USE_DLLDEF_OBJECTS)" != "0" && "$(USE_DLLDEF_OBJECTS)" != "1"
!  error USE_DLLDEF_OBJECTS may only be 0 or 1 or not defined.
USE_DLLDEF_OBJECTS=0
!endif

!if defined(MCPP_TYPE) && "$(MCPP_TYPE)" != "pure" && "$(MCPP_TYPE)" != "safe"
!error $(MAKEDIR) MCPP_TYPE must be pure or safe or not defined, but it is $(MCPP_TYPE).
!endif

!if defined(INLCUDES)
!error $(MAKEDIR): INLCUDES does nothing. Remove it.
!endif

!if defined(PRECOMPILED_CXX) && "$(PRECOMPILED_CXX)" != "" && "$(PRECOMPILED_CXX)" != "1"
!error $(MAKEDIR): PRECOMPILED_CXX has an invalid value, change it to 1.
!endif

!if defined(USE_NATIVE_EH) && "$(USE_NATIVE_EH)" != "1" && "$(USE_NATIVE_EH)" != "ASYNC" && "$(USE_NATIVE_EH)" != "CTHROW"
!error $(MAKEDIR): USE_NATIVE_EH has an invalid value, change it to 1.
!endif


!if defined(NTTEST)
!error $(MAKEDIR): NTTEST does nothing. Remove it.
!endif

#
# Link binaries instrumented with IceCAP to NTOSKRNl.EXE or NTDLL.DLL to
# obtain __CAP imports. Do not set C_DEFINES for catalogs.
#
!if defined(USE_CAPK)
! if "$(TARGETTYPE)" != "CATALOG"
C_DEFINES=$(C_DEFINES) /D_CAPKERN=1
ASM_DEFINES=$(ASM_DEFINES) /D_CAPKERN=1
! endif
! if defined(MANAGED_CXX)
PERFFLAGS=$(PERFFLAGS:/fastcap=)
! endif
! if defined(USE_ICECAP4)
!  if "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "DYNLINK"
!   if "$(TARGETLIBS)" == "$(TARGETLIBS:ntdll.lib=)"
TARGETLIBS=$(SDK_LIB_PATH)\ntdll.lib $(TARGETLIBS)
!   endif
!  endif
!  if "$(TARGETTYPE)" == "DRIVER" || "$(TARGETTYPE)" == "GDI_DRIVER" || "$(TARGETTYPE)" == "MINIPORT"
!   if "$(TARGETLIBS)" == "$(TARGETLIBS:ntoskrnl.lib=)"
TARGETLIBS=$(DDK_LIB_PATH)\ntoskrnl.lib $(TARGETLIBS)
!   endif
!  endif
! endif
!endif

!if "$(USE_RUNTIME_CHECKS)" == "1" && !defined(RESOURCE_ONLY_DLL)
! if !defined(MANAGED_CXX)
USER_C_FLAGS=$(USER_C_FLAGS) /RTCcsu /wd4748 /DMSC_NOOPT
MSC_OPTIMIZATION=/Oi
DEFAULT_MSC_OPT=/Oi
386_OPTIMIZATION=/Oi
! endif
! if !defined(MCPP_TYPE) && "$(TARGETTYPE)" != "CATALOG"
!  if defined(NTKERNEL)
KERNEL_LIBS=$(KERNEL_LIBS) $(MINWIN_PRIV_SDK_LIB_PATH)\RuntimeChecks.lib
!  elseif ("$(TARGETNAME)" == "ntdll" && "$(TARGETTYPE)" == "DYNLINK" && !defined(TEST_CODE))
TARGETLIBS=$(TARGETLIBS) $(MINWIN_PRIV_SDK_LIB_PATH)\RuntimeChecks.lib
!  elseif defined(BOOTAPPNAME)
TARGETLIBS=$(TARGETLIBS) $(MINWIN_PRIV_SDK_LIB_PATH)\RuntimeChecks.lib
!  elseif "$(TARGETTYPE)" == "DRIVER" \
       || "$(TARGETTYPE)" == "MINIPORT" \
       || "$(TARGETTYPE)" == "GDI_DRIVER" \
       || "$(TARGETTYPE)" == "EXPORT_DRIVER"
TARGETLIBS=$(TARGETLIBS) $(MINWIN_PRIV_SDK_LIB_PATH)\RuntimeChecks.lib $(DDK_LIB_PATH)\ntoskrnl_dbgprintex.lib
!  else
TARGETLIBS=$(TARGETLIBS) $(MINWIN_PRIV_SDK_LIB_PATH)\RuntimeChecks.lib $(SDK_LIB_PATH)\ntdll.lib
!  endif
! endif
!endif

!if defined(PASS_INDEPENDENT_TARGETS)
!undef SOURCES
!undef LANGUAGE_NEUTRAL_MANAGED_RESOURCES
!undef LANGUAGE_SPECIFIC_MANAGED_RESOURCES
!endif

#
# _EVENTS_MANIFEST is passed on the nmake command line by build.exe to indicate
# if believes EVENTS_MANIFEST is defined, even if it was in !if $(386) or such.
#
!if (  defined(EVENTS_MANIFEST) \
    || defined(_EVENTS_MANIFEST) \
    || defined(SLS_LICENSING_MANIFEST) \
    || defined(_SLS_LICENSING_MANIFEST) \
    ) && !defined(MANIFESTONLY)

!undef BUILD_PASS_INDEPENDENT

!endif

#
# move into build.exe for perf
#
!if defined(TARGET_DESTINATION)
_TARGET_DESTINATION_WITHOUT_QUOTES=$(TARGET_DESTINATION:"=)
!endif

!ifndef PASS_INDEPENDENT_TARGETS
! if  !exist($(OBJ_PATH)\$O\_objects.mac)
!  if [-build /O]
!  endif
! endif
! include $(OBJ_PATH)\$O\_objects.mac
!endif

# CONFIG_CONCURRENCY_MIDL is from the config file -- true or false
# CONCURRENT_MIDL is an override in the source file -- 0 or 1

!if ("$(CONFIG_CONCURRENCY_MIDL)" == "true") \
    && ("$(CONCURRENT_MIDL)" != "0") \
    && !defined(SYNCHRONIZE_PASS0_BLOCK) \
    && defined(_CONCURRENT_MIDL_UUID) \
    && defined(_CONCURRENT_MIDL_LOCKDIR) \

!  if [mkdir $(_CONCURRENT_MIDL_LOCKDIR)]
!  endif

_CONCURRENT_MIDL_RUN=run_concurrent $(_CONCURRENT_MIDL_LOCKDIR)
_CONCURRENT_MIDL_JOIN=join_concurrent $(_CONCURRENT_MIDL_LOCKDIR)

!endif


#
# Translate old redundant public symbols to new internal somewhat redundant symbols.
#
!if defined(MANAGED_CODE)
_C_SHARP=1
!endif
!if defined(MANAGED_VB)
_VB=1
!endif

!if "$(TARGETTYPE)" == "CATALOG" || \
    "$(TARGETTYPE)" == "MSI"

!  if defined(C_DEFINES)
!     error C_DEFINES may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(INCLUDES)
!     error INCLUDES may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(TARGETEXT)
!     error TARGETEXT may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(DLLDEF_OBJECTS)
!     error DLLDEF_OBJECTS may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(LINKLIBS)
!     error LINKLIBS may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(TARGETLIBS)
!     error TARGETLIBS may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(_C_SHARP)
!     error TARGETTYPE == $(TARGETTYPE) may not include SOURCES=*.cs.
!  endif
!  if defined(MANAGED_CXX)
!     error MANAGED_CXX may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(_VB)
!     error TARGETTYPE == $(TARGETTYPE) may not include SOURCES=*.vb.
!  endif
!  if defined(_TLBIMP)
!     error SOURCES=*.tlb may not used with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(UMLIBS)
!     error UMLIBS may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
!  if defined(USE_MSVCRT)
!     error USE_MSVCRT may not be defined with TARGETTYPE == $(TARGETTYPE).
!  endif
#...
!else

!if defined(COMBOX_SANDBOX)
C_DEFINES = $(C_DEFINES) /DCOMBOX_SANDBOX
!endif


!endif


!ifndef PASS_INDEPENDENT_TARGETS

!if defined(TARGETPATH)
! message $(MAKEDIR): TARGETPATH is $(TARGETPATH)
!endif

!if defined(TARGETPATHLIB)
! message $(MAKEDIR): TARGETPATHLIB is $(TARGETPATHLIB)
!endif

!if defined(MANAGED_RESOURCES) && defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)
!  error $(MAKEDIR) MANAGED_RESOURCES and LANGUAGE_SPECIFIC_MANAGED_RESOURCES may not both be defined.
!endif

!if defined(MANAGED_RESOURCES) && defined(LANGUAGE_NEUTRAL_MANAGED_RESOURCES)
!  error $(MAKEDIR) MANAGED_RESOURCES and LANGUAGE_NEUTRAL_MANAGED_RESOURCES may not both be defined.
!endif

!if defined(MANAGED_WIN32_RESOURCE_FILE)
#!  error $(MAKEDIR) MANAGED_WIN32_RESOURCE_FILE in use.
!  message JKSEP2005MARK $(MAKEDIR) MANAGED_WIN32_RESOURCE_FILE in use.
!endif


!if defined(_C_SHARP) || defined(MANAGED_CXX) || defined(_VB) || defined(_TLBIMP)
_PROJECT_BUILDS_MANAGED_CODE=1
!else

# set USE_PHOENIX_GLOBAL=1 (env) to turn on phoenix for everything otherwise default to UTC
!if "$(USE_PHOENIX_GLOBAL)" == "1" && "$(USE_PHOENIX)" == ""
USE_PHOENIX=1
!endif

! if "$(USE_PHOENIX)" == "1"
!  error $(MAKEDIR): Phoenix compiler is no longer supported. Please do not specify USE_PHOENIX.
! endif

!endif

!if defined(MSBUILD_XAMLFILES) || defined(MSBUILD_APPDEFFILE) || defined(MSBUILD_RESOURCE) || defined(MSBUILD_TARGETTYPE)
XAML_COMPILATION=1

#
# If there is no msbuild project available in current directory, it will compile xaml files to
# the corresponding .g.cs (or .g.vb) and .baml files, all those baml files and the related
# resource files will be embedded into a single targetname.g.resources file.
#
# This .g.resources could be language netrual or language specific, depends on user's setting.
# by default, it is language specific.

!  if defined(MSBUILD_XAMLFILES) || defined(MSBUILD_RESOURCE)

!   if "$(GENERATE_TEMP_TARGET_FOR_LOCAL_TYPE_REF)" != "true"
MSBUILD_GENERATED_RESOURCE_FILE=$(OBJ_PATH)\$(O)\$(TARGETNAME).g.resources
!    if "$(MSBUILD_GENERATE_LANGUAGE_NEUTRAL_RESOURCE)" == "true"
!     if "$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES)" == ""
LANGUAGE_NEUTRAL_MANAGED_RESOURCES=$(MSBUILD_GENERATED_RESOURCE_FILE)
!     else
LANGUAGE_NEUTRAL_MANAGED_RESOURCES=$(MSBUILD_GENERATED_RESOURCE_FILE);$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES)
!     endif
!    else

!     if "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)" == ""
LANGUAGE_SPECIFIC_MANAGED_RESOURCES=$(MSBUILD_GENERATED_RESOURCE_FILE)
!     else
LANGUAGE_SPECIFIC_MANAGED_RESOURCES=$(MSBUILD_GENERATED_RESOURCE_FILE);$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)
!     endif
!    endif
!   endif   # Not for Local Reference
MSBUILD_GENERATED_FILE_TARGET=$(MSBUILD_GENERATED_RESOURCE_FILE)

!  else if defined(MSBUILD_APPDEFFILE)
MSBUILD_GENERATED_FILE_TARGET=$(MSBUILD_APPDEFFILE:.xaml=.g.cs)
!  endif
!endif


#
# LOCALIZE_NO_MUI is the preferred way to tell the build process that you do
# not want to MUI split something, but that you do want to localize it. This should
# only be used for projects targeting pre-Vista platforms - anything on Vista or
# above should be MUI split and the resulting MUI file is what should be localized.
#
!if defined(LOCALIZE_NO_MUI)
!message LCG: LOCALIZE_NO_MUI: $(LOCALIZE_NO_MUI)
! if "$(LOCALIZE_NO_MUI)" != "1" && "$(LOCALIZE_NO_MUI)" != "0"
!  error LOCALIZE_NO_MUI must be empty, 1, or 0
! endif
! if "$(LOCALIZE_NO_MUI)" == "1"
# NOTE: We can't do this because $(MUI) is set to 1 automatically before the sources file is included, and people test
# for the value of $(MUI) in their sources files. If they set LOCALIZE_NO_MUI=1, we have to assume they wanted no MUI
# and just turn it off - we have no way to distinguish between what was automatically set above vs. what people set
# in their sources file.
#!  if "$(MUI)" == "1"
#!    error LOCALIZE_NO_MUI=1 and MUI=1 are mutally exclusive
#!  endif
BUILD_LCG=1
MUI=0
!  if defined(MUI_COMMENT)
MUI_COMMENT=MUI splitting turned off by LOCALIZE_NO_MUI : $(MUI_COMMENT)
!  else
MUI_COMMENT=MUI splitting turned off by LOCALIZE_NO_MUI
!  endif
! endif
# See above notes about $(MUI) and sources files
#!else
#! ifndef MUI
#MUI=1
#! endif
!endif



#
# LOCALIZE_NO_MUI_MULTI is the preferred way to tell the build process that you do
# not want to MUI split something, but that you do want to localize it as multilingual.
# This should only be used for projects targeting pre-Vista platforms - anything on Vista
# or above should be MUI split and the resulting MUI file is what should be localized.
#
!if defined(LOCALIZE_NO_MUI_MULTI)
!message LCG: LOCALIZE_NO_MUI_MULTI: $(LOCALIZE_NO_MUI_MULTI)
! if "$(LOCALIZE_NO_MUI_MULTI)" != "1" && "$(LOCALIZE_NO_MUI_MULTI)" != "0"
!  error LOCALIZE_NO_MUI_MULTI must be empty, 1, or 0
! endif
! if "$(LOCALIZE_NO_MUI_MULTI)" == "1"
!  if "$(LOCALIZE_NO_MUI)" == "1"
!   error LOCALIZE_NO_MUI_MULTI=1 and LOCALIZE_NO_MUI=1 are mutally exclusive
!  endif
BUILD_LCG=1
MUI=0
!  if defined(MUI_COMMENT)
MUI_COMMENT=MUI splitting turned off by LOCALIZE_NO_MUI_MULTI : $(MUI_COMMENT)
!  else
MUI_COMMENT=MUI splitting turned off by LOCALIZE_NO_MUI_MULTI
!  endif
! endif
!endif


#
# LOCALIZE_MUI_MULTI is the preferred way to tell the build process that you want
# to localize your .mui files as multilingual.
#
!if defined(LOCALIZE_MUI_MULTI)
!message LCG: LOCALIZE_MUI_MULTI: $(LOCALIZE_MUI_MULTI)
! if "$(LOCALIZE_MUI_MULTI)" != "1" && "$(LOCALIZE_MUI_MULTI)" != "0"
!  error LOCALIZE_MUI_MULTI must be empty, 1, or 0
! endif
! if "$(LOCALIZE_MUI_MULTI)" == "1"
!  if "$(LOCALIZE_NO_MUI)" == "1"
!   error LOCALIZE_MUI_MULTI=1 and LOCALIZE_NO_MUI=1 are mutally exclusive
!  endif
!  if "$(LOCALIZE_NO_MUI_MULTI)" == "1"
!   error LOCALIZE_MUI_MULTI=1 and LOCALIZE_NO_MUI_MULTI=1 are mutally exclusive
!  endif
BUILD_LCG=1
MUI=1
BINPLACE_FLAGS=$(BINPLACE_FLAGS) /G5 $(LOC_MULTI)
! endif
!endif




#
# Ban LINKER_FLAGS containing managed resource stuff unless it is test code or language neutral.
# Ban USER_CS_FLAGS <ditto>.
#
!if !defined(TEST_CODE) && "$(MUI)" != "0" && "$(LANGUAGE_NEUTRAL)" != "0" # { {

!if "$(LINKER_FLAGS)" != "" # { {

_LINKER_FLAGS_LOWERCASE=$(LINKER_FLAGS)

_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:A=a)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:B=b)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:C=c)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:D=d)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:E=e)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:F=f)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:G=g)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:H=h)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:I=i)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:J=j)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:K=k)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:L=l)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:M=m)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:N=n)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:O=o)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:P=p)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:Q=q)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:R=r)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:S=s)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:T=t)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:U=u)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:V=v)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:W=w)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:X=x)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:Y=y)
_LINKER_FLAGS_LOWERCASE=$(_LINKER_FLAGS_LOWERCASE:Z=z)

_LINKER_FLAGS_LOWERCASE_SLASH=$(_LINKER_FLAGS_LOWERCASE:-=/)

!if "$(_LINKER_FLAGS_LOWERCASE_SLASH:/assemblyresource=)" != "$(_LINKER_FLAGS_LOWERCASE_SLASH)"
! error $(MAKEDIR) LINKER_FLAGS may not contain /assemblyresource. Use LANGUAGE_NEUTRAL_MANAGED_RESOURCES instead.
!endif

!if "$(_LINKER_FLAGS_LOWERCASE_SLASH:/assemblylinkresource=)" != "$(_LINKER_FLAGS_LOWERCASE_SLASH)"
! error $(MAKEDIR) LINKER_FLAGS may not contain /assemblylinkresource. Use embedded resources instead, via LANGUAGE_NEUTRAL_MANAGED_RESOURCES.
!endif

!endif # } }

!if "$(USER_CS_FLAGS)" != "" # { {

_USER_CS_FLAGS_LOWERCASE=$(USER_CS_FLAGS)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:A=a)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:B=b)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:C=c)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:D=d)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:E=e)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:F=f)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:G=g)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:H=h)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:I=i)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:J=j)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:K=k)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:L=l)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:M=m)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:N=n)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:O=o)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:P=p)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:Q=q)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:R=r)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:S=s)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:T=t)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:U=u)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:V=v)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:W=w)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:X=x)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:Y=y)
_USER_CS_FLAGS_LOWERCASE=$(_USER_CS_FLAGS_LOWERCASE:Z=z)

_USER_CS_FLAGS_LOWERCASE_SLASH=$(_USER_CS_FLAGS_LOWERCASE:-=/)

!if "$(_USER_CS_FLAGS_LOWERCASE_SLASH:/res=)" != "$(_USER_CS_FLAGS_LOWERCASE_SLASH)"
! message $(MAKEDIR) USER_CS_FLAGS may not contain /resources, use LANGUAGE_NEUTRAL_MANAGED_RESOURCES or LANGUAGE_SPECIFIC_MANAGED_RESOURCES instead.
!endif

!if "$(_USER_CS_FLAGS_LOWERCASE_SLASH:/linkres=)" != "$(_USER_CS_FLAGS_LOWERCASE_SLASH)"
! message $(MAKEDIR) USER_CS_FLAGS may not contain /linkresource. Use embedded resources instead, via and LANGUAGE_NEUTRAL_MANAGED_RESOURCES, or embed resources into a satellite assembly using LANGUAGE_SPECIFIC_MANAGED_RESOURCES.
!endif

!if "$(_USER_CS_FLAGS_LOWERCASE_SLASH:/win32res=)" != "$(_USER_CS_FLAGS_LOWERCASE_SLASH)"
! message $(MAKEDIR) USER_CS_FLAGS may not contain /win32res. Use LANGUAGE_SPECIFIC_MANAGED_WIN32_RESOURCE_FILE or LANGUAGE_NEUTRAL_MANAGED_WIN32_RESOURCE_FILE.
!endif

!endif # } }

!endif # } }


!if defined(LANGUAGE_NEUTRAL_MANAGED_RESOURCES)

! if "$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES)" == ""
!  error LANGUAGE_NEUTRAL_MANAGED_RESOURCES may not be empty.
! endif

! if !defined(_PROJECT_BUILDS_MANAGED_CODE)
!  error LANGUAGE_NEUTRAL_MANAGED_RESOURCES may not be defined without MANAGED_CXX | SOURCES=*.cs | SOURCES=*.vb.
! endif
! if "$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES: -=)" != "$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES)" \
        || "$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES:/=)" != "$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES)"
!   error LANGUAGE_NEUTRAL_MANAGED_RESOURCES may not contain switches (no dash or forward slash).
! endif

! if defined(MANAGED_CXX)
_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_LINKER_FLAGS=$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES: =)
_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_LINKER_FLAGS=/assemblyresource:$(_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_LINKER_FLAGS:;= /assemblyresource:)
LINKER_FLAGS=$(LINKER_FLAGS) $(_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_LINKER_FLAGS) # TBD remove this line
! else
_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS=$(LANGUAGE_NEUTRAL_MANAGED_RESOURCES: =)
_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS=/resource:$(_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS:;= /resource:)
! endif

!endif

!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)

! if "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)" == ""
!  error LANGUAGE_SPECIFIC_MANAGED_RESOURCES may not be empty.
! endif

! if !defined(_PROJECT_BUILDS_MANAGED_CODE)
!  error LANGUAGE_SPECIFIC_MANAGED_RESOURCES may not be defined without MANAGED_CXX | SOURCES=*.cs | SOURCES=*.vb.
! endif
! if "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES: -=)" != "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)" \
        || "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES:/=)" != "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)"
!   error LANGUAGE_SPECIFIC_MANAGED_RESOURCES may not contain switches (no dash or forward slash).
! endif

_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_AL_FLAGS=$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES: =)
_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_AL_FLAGS=/embedresource:$(_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_AL_FLAGS:;= /embedresource:)

! if defined(MANAGED_CXX)
_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_LINKER_FLAGS=$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES: =)
_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_LINKER_FLAGS=/assemblyresource:$(_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_LINKER_FLAGS:;= /assemblyresource:)
LINKER_FLAGS=$(LINKER_FLAGS) $(_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_LINKER_FLAGS) # TBD remove this line
! else
_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS=$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES: =)
_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS=/resource:$(_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS:;= /resource:)
! endif

! if "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES:,=)" != "$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)"
!  message JKSEP2005MARK $(MAKEDIR) unable to state _MANAGED_RESOURCES_SATELLITE_ASSEMBLY_DEPENDENCIES.
_MANAGED_RESOURCES_SATELLITE_ASSEMBLY_DEPENDENCIES=$(SOURCES_USED) $(SOURCES)
! else
_MANAGED_RESOURCES_SATELLITE_ASSEMBLY_DEPENDENCIES=$(LANGUAGE_SPECIFIC_MANAGED_RESOURCES:;= )
! endif

!endif

!if defined(USE_STL) && !defined(STL_VER)
STL_VER=70
!endif

#
# SUPPRESS_STL_WARNINGS should be cleaned out of the tree in
# deference to specific uses of MSC_WARNING_LEVEL.
#
!if defined(SUPPRESS_STL_WARNINGS) && "$(SUPPRESS_STL_WARNINGS)" != "1"
!  error $(MAKEDIR) SUPPRESS_STL_WARNINGS must be 1 or not defined.
!endif

!if defined(SUPPRESS_STL_WARNINGS) && "$(STL_VER)" != "70"
!  error $(MAKEDIR) SUPPRESS_STL_WARNINGS is only valid when STL_VER == 70.
!endif

!if defined(SUPPRESS_STL_WARNINGS)
#
# 4018 signed/unsigned mismatch
# 4114 same type qualifier used more than once
# 4146 unary minus operator applied to unsigned type, result still unsigned
# 4244 conversion, possible loss of data
# 4245 combination of 4018 and 4244
# 4290 C++ exception specification ignored except to indicate a function is not __declspec(nothrow)
#
# /D_STL70_ at end seems wrong but there is some problem with precompiled headers otherwise.
#
_STL70_WARNINGS=/wd4018 /wd4144 /wd4146 /wd4244 /wd4245 /wd4290 /D_STL70_
!endif

!if defined(OLD_AUTO_PTR) && defined(USE_STL) && "$(STL_VER)" == "70"
_STL70_WARNINGS=$(_STL70_WARNINGS) /D_OLD_AUTO_PTR
!endif

!if defined(_AUTO_PTR_HAZARD) && defined(USE_STL) && "$(STL_VER)" == "70"
_STL70_WARNINGS=$(_STL70_WARNINGS) /D_AUTO_PTR_HAZARD
!endif

!if defined(_STREAM_WCHAR_T_HAZARD) && defined(USE_STL)
_STL70_WARNINGS=$(_STL70_WARNINGS) /D_STREAM_WCHAR_T_HAZARD
!endif

!ifdef PASS1_LINK
MAKEDLL=1
!undef NOLINK
!endif
!if defined(_C_SHARP) || defined(_VB) || defined(_TLBIMP)
MAKEDLL=1
!undef NOLINK
!undef PASS1_NOLIB
!endif

!if defined(MCPP_TYPE) && !defined(MANAGED_CXX)
!  error MCPP_TYPE cannot be defined without MANAGED_CXX.
!endif
!if defined(MCPP_TYPE) && "$(URT_VER)" < "2."
!  error MCPP_TYPE cannot be defined for URT_VER < 2.
!endif
!if defined(MANAGED_CXX) && defined(USE_STL) && "$(STL_VER)" != "70"
!  error If managed C++ uses STL, it must use the default STL -- remove STL_VER.
!endif

!if defined(MANAGED_CXX) && "$(URT_VER)" >= "2.0"
_USE_LIBCMMT=1
!endif

!endif # PASS_INDEPENDENT_TARGETS

!if "$(URT_VER)" != "2.0"
_URTRUN_20=$(_PERL) $(RAZZLETOOLPATH)\urtrun.pl 2.0
!else
_URTRUN_20=
!endif

!if $(USE_OBJECT_ROOT) # { {

!if "$(DLLDEF)" == "$O\$(TARGETNAME).def"
DLLDEF=$(OBJ_PATH)\$O\$(TARGETNAME).def
!elseif "$(DLLDEF)" == "$O\$(TARGETNAME).DEF"
DLLDEF=$(OBJ_PATH)\$O\$(TARGETNAME).DEF
!endif

!if "$(TARGETPATH)" == "" || "$(TARGETPATH)" == "obj" || "$(TARGETPATH)" == "OBJ" || "$(TARGETPATH)" == "$(_OBJ_DIR)"
TARGETPATH=$(OBJ_PATH)\$(_OBJ_DIR)
!endif

!if "$(TARGETPATHLIB)" == "obj" || "$(TARGETPATHLIB)" == "OBJ" || "$(TARGETPATHLIB)" == "$(_OBJ_DIR)"
TARGETPATHLIB=$(OBJ_PATH)\$(_OBJ_DIR)
!endif

!if "$(TARGETPATH)" == "..\$(_OBJ_DIR)"
TARGETPATH=$(OBJ_PATH)\..\$(_OBJ_DIR)
!endif

!if "$(TARGETPATHLIB)" == "..\$(_OBJ_DIR)"
TARGETPATHLIB=$(OBJ_PATH)\..\$(_OBJ_DIR)
!endif

!if "$(MC_SOURCEDIR)" == "$O"
MC_SOURCEDIR=$(OBJ_PATH)\$(O)
!endif

!if "$(PASS0_HEADERDIR)" == "$O"
PASS0_HEADERDIR=$(OBJ_PATH)\$(O)
!endif

!if "$(PASS0_CLIENTDIR)" == "$O"
PASS0_CLIENTDIR=$(OBJ_PATH)\$(O)
!endif

!if "$(PASS0_SERVERDIR)" == "$O"
PASS0_SERVERDIR=$(OBJ_PATH)\$(O)
!endif

!if "$(PASS0_SOURCEDIR)" == "$O"
PASS0_SOURCEDIR=$(OBJ_PATH)\$(O)
!endif

!if "$(MIDL_TLBDIR)" == "$O"
MIDL_TLBDIR=$(OBJ_PATH)\$O
!endif

!if "$(MIDL_UUIDDIR)" == "$O"
MIDL_UUIDDIR=$(OBJ_PATH)\$O
!endif

!else  # } {

OBJ_PATH=$(MAKEDIR)

!if "$(TARGETPATH)" == "" || "$(TARGETPATH)" == "obj" || "$(TARGETPATH)" == "OBJ"
TARGETPATH=$(_OBJ_DIR)
!endif

!if "$(TARGETPATHLIB)" == "obj" || "$(TARGETPATHLIB)" == "OBJ"
TARGETPATHLIB=$(_OBJ_DIR)
!endif

!endif # } }

!if defined(ALT_PROJECT_TARGET)
ALT_PROJECT_TARGET_OBJ=$(OBJ_PATH)\$(ALT_PROJECT_TARGET)
!endif

!if "$(TARGETPATH)" != ""
! if !exist($(TARGETPATH)\$(TARGET_DIRECTORY))
!  if [mkdir $(TARGETPATH)\$(TARGET_DIRECTORY) 2>nul]
!  endif
! endif
!endif

!if "$(TARGETPATHLIB)" != ""
! if !exist($(TARGETPATHLIB)\$(TARGET_DIRECTORY))
!  if [mkdir $(TARGETPATHLIB)\$(TARGET_DIRECTORY) 2>nul]
!  endif
! endif
!endif

!if !$(WIN64)
SUBSYSTEM_400 = 4.00
SUBSYSTEM_410 = 4.10
SUBSYSTEM_500 = 5.00
SUBSYSTEM_501 = 5.01
!else
SUBSYSTEM_400 = 5.02
SUBSYSTEM_410 = 5.02
SUBSYSTEM_500 = 5.02
SUBSYSTEM_501 = 5.02
!endif
SUBSYSTEM_502 = 5.02
SUBSYSTEM_600 = 6.00
SUBSYSTEM_601 = 6.01

LINKER_APP_VERSION          =6.1
LINKER_OS_VERSION           =6.1


!if defined(_NT_TARGET_VERSION)
_CHECK_NT_TARGET_VERSION=$(_NT_TARGET_VERSION)
_CHECK_NT_TARGET_VERSION=$(_CHECK_NT_TARGET_VERSION: =)
_CHECK_NT_TARGET_VERSION=$(_CHECK_NT_TARGET_VERSION:0x0=0x)
!if "$(_CHECK_NT_TARGET_VERSION)" != "$(_NT_TARGET_VERSION_WINXP)" \
    && "$(_CHECK_NT_TARGET_VERSION)" != "$(_NT_TARGET_VERSION_WS03)" \
    && "$(_CHECK_NT_TARGET_VERSION)" != "$(_NT_TARGET_VERSION_VISTA)" \
    && "$(_CHECK_NT_TARGET_VERSION)" != "$(_NT_TARGET_VERSION_WIN7)" \
    && "$(_CHECK_NT_TARGET_VERSION)" != "$(_NT_TARGET_VERSION_LATEST)"
# multi line errors require the older !message style
!message NMAKE : _NT_TARGET_VERSION value is unknown.
!message NMAKE : _NT_TARGET_VERSION is misspecified.
!message NMAKE : The valid values are:
!message NMAKE : $$(_NT_TARGET_VERSION_WINXP)
!message NMAKE : $$(_NT_TARGET_VERSION_WS03)
!message NMAKE : $$(_NT_TARGET_VERSION_VISTA)
!message NMAKE : $$(_NT_TARGET_VERSION_WIN7)
!message NMAKE : $$(_NT_TARGET_VERSION_LATEST)
# This is usually defaulted in makefile.plt and the default is not exposed.
# If we don't change the value here, we get a nonsensical error message.
_NT_TARGET_VERSION=$(__LATEST_NT_TARGET_VERSION)
!endif
!else
_NT_TARGET_VERSION=$(__LATEST_NT_TARGET_VERSION)
!endif


LIB_WLH=1

#
# Set versions correctly for NT4/2000/XP/Longhorn
#


!if $(WIN64) && \
     (($(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_WINXP)) || \
      ($(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_WIN2K)) || \
      ($(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_NT4)))
# Lowest NT_TARGET_VERSION for Win64 is WS03
_NT_TARGET_VERSION=$(_NT_TARGET_VERSION_WS03)
LIB_WLH=0
!endif


!if $(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_WIN7)         ## Windows "7" ##
CURRENT_NTDDI_VERSION       =$(LATEST_NTDDI_VERSION)
CURRENT_WIN32_IE_VERSION    =$(LATEST_WIN32_IE_VERSION)
CURRENT_WIN32_WINNT_VERSION =$(LATEST_WIN32_WINNT_VERSION)
SUBSYSTEM_VERSION_LATEST    =6.01
SUBSYSTEM_VERSION_CURRENT   =$(SUBSYSTEM_VERSION_LATEST)
CATALOG_OS_VERSION          =2:6.1

!elseif $(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_VISTA)    ## Windows Vista ##
CURRENT_NTDDI_VERSION       =0x06000100
CURRENT_WIN32_IE_VERSION    =0x0700
CURRENT_WIN32_WINNT_VERSION =0x0600
SUBSYSTEM_VERSION_LATEST    =6.00
CATALOG_OS_VERSION          =2:6.0

!elseif $(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_WS03)     ## Windows Server 2003 ##
CURRENT_NTDDI_VERSION       =0x05020100
# Server 2003 gold has _WIN32_IE=0x0602, and Server 2003 SP1 has _WIN32_IE=0x0603
CURRENT_WIN32_IE_VERSION    =0x0603
CURRENT_WIN32_WINNT_VERSION =0x0502
SUBSYSTEM_VERSION_LATEST    =5.02
CATALOG_OS_VERSION          =2:5.2


!message BUILDMSG: _NT_TARGET_VERSION SET TO WS03
SDK_LIB_DEST=$(BASEDIR)\lib\wnet
DDK_LIB_DEST=$(SDK_LIB_DEST)
IFSKIT_LIB_DEST=$(SDK_LIB_DEST)
SDK_LIB_PATH=$(BASEDIR)\lib\wnet\*
DDK_LIB_PATH=$(SDK_LIB_PATH)
HALKIT_LIB_PATH=$(SDK_LIB_PATH)
IFSKIT_LIB_PATH=$(SDK_LIB_PATH)
LIB_WLH=0


!elseif $(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_WINXP)    ## Windows XP ##
# XP gold has _WIN32_IE=0x0600, XP SP1 has _WIN32_IE=0x0601, and XPSP2 _WIN32_IE=0x0603
CURRENT_NTDDI_VERSION       =0x05010200
CURRENT_WIN32_IE_VERSION    =0x0603
CURRENT_WIN32_WINNT_VERSION =0x0501
SUBSYSTEM_VERSION_LATEST    =$(SUBSYSTEM_501)
CATALOG_OS_VERSION          =2:5.1



!message BUILDMSG: _NT_TARGET_VERSION SET TO WINXP
SDK_LIB_DEST=$(BASEDIR)\lib\wxp
DDK_LIB_DEST=$(SDK_LIB_DEST)
IFSKIT_LIB_DEST=$(SDK_LIB_DEST)
SDK_LIB_PATH=$(BASEDIR)\lib\wxp\*
DDK_LIB_PATH=$(SDK_LIB_PATH)
HALKIT_LIB_PATH=$(SDK_LIB_PATH)
IFSKIT_LIB_PATH=$(SDK_LIB_PATH)
LIB_WLH=0


!elseif $(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_WIN2K)    ## Windows 2000 ##
CURRENT_NTDDI_VERSION      =0x05000400
CURRENT_WIN32_IE_VERSION   =0x0501
CURRENT_WIN32_WINNT_VERSION=0x0500
SUBSYSTEM_VERSION_LATEST   =$(SUBSYSTEM_500)
CATALOG_OS_VERSION          =2:5.0

!elseif $(_NT_TARGET_VERSION) == $(_NT_TARGET_VERSION_NT4)      ## Windows NT 4 ##
CURRENT_NTDDI_VERSION      =0x04000600
CURRENT_WIN32_IE_VERSION   =0x0200
CURRENT_WIN32_WINNT_VERSION=0x0400
SUBSYSTEM_VERSION_LATEST   =$(SUBSYSTEM_400)
!else
!message NMAKE : Uxxxx: _NT_TARGET_VERSION value is unknown.  Update Makefile.def to understand the new version.
!endif # _NT_TARGET_VERSION


!if "$(POCKETPC)" != ""
! if "$(POCKETPC_EMULATION)" != ""
WINCE_IMAGE = -WINDOWSCE:EMULATION
! else
WINCE_IMAGE = -WINDOWSCE
! endif
CVTRES_PLATFORM_FLAGS = $(WINCE_IMAGE)
!endif

!if defined(TEST_CODE)
C_DEFINES=$(C_DEFINES) /DTEST_CODE
!else if $(WIN64) && !defined(NTTESTENV)
LINK_TIME_CODE_GENERATION=1
!endif

#
# move into build.exe for perf
#
!if defined(TEST_CODE) && "$(MAKEDIR_LOWERCASE:\testsrc\=)" == "$(MAKEDIR_LOWERCASE)"
!  message $(MAKEDIR) building test code in dev tree
!endif

BINPLACE_FLAGS=$(BINPLACE_FLAGS) /:CVTCIL

!if (defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)) && \
    (defined(LTCG_NTNOPCH) || \
    (defined(PASS1_PUBLISH) && \
    "$(BUILD_PASS)" != "PASS0" && \
    "$(BUILD_PASS)" != "PASS2" && \
    !defined(NOLIB) && \
    "$(TARGETTYPE)" != "DYNLINK" && \
    "$(TARGETTYPE)" != "PROGLIB" && \
    "$(TARGETTYPE)" != "EXPORT_DRIVER"))
# LTCG with PCH encodes a hardcoded path to the PCH file - disable pch if publishing.
NTNOPCH=1
!endif

!if "$(_TARGET_DESTINATION_WITHOUT_QUOTES)" != ""
BINPLACE_TARGET_FLAGS= /:DEST $(TARGET_DESTINATION)
!endif

# Support to compile licensing manifest
!if defined(SLS_LICENSING_MANIFEST)
!    include $(RAZZLETOOLPATH)\licensing.inc
!endif

#
# LocStudio-related settings that have to be set very early
#


# The parser LSBuild uses can be specified on a per-project
# basis by defining LSBUILD_PARSER_ID in the sources file.
!if defined(LSBUILD_PARSER_ID)
LSBUILD_PARSER_ID_OPTION=/p:$(LSBUILD_PARSER_ID)
!else
LSBUILD_PARSER_ID_OPTION=
!endif

# We need to use a specific parser for files we know are managed code.
!if defined(LSBUILD_PARSER_ID_MANAGED)
LSBUILD_PARSER_ID_OPTION_MANAGED=/p:$(LSBUILD_PARSER_ID_MANAGED)
!else
LSBUILD_PARSER_ID_OPTION_MANAGED=/p:211
!endif

# The alternate LCI directory can be specified on a per-project
# basis by defining ALT_LCI_DIR in the sources file.
!if defined(ALT_LCI_DIR)
ALT_LCI_DIR_OPTION=/d:$(ALT_LCI_DIR)
!else
ALT_LCI_DIR_OPTION=
!endif

# LSBUILD generated LCG files binplace to $(_NTTREE)\$(LCG_BINPLACE_ROOT)
!if "$(LCG_BINPLACE_ROOT: =)" == ""
LCG_BINPLACE_ROOT=$(LOC_LCG)
LCG_BINPLACE_ROOT_MANAGED=$(LCG_BINPLACE_ROOT)\managed
!endif

# Adjust the LCG binplace root as needed...
!if "$(ALT_PROJECT_TARGET)" == ""
LCG_BINPLACE_TARGET=$(LCG_BINPLACE_ROOT)
LCG_BINPLACE_TARGET_MANAGED=$(LCG_BINPLACE_ROOT_MANAGED)
!else
LCG_BINPLACE_TARGET=$(LCG_BINPLACE_ROOT)\$(ALT_PROJECT_TARGET)
LCG_BINPLACE_TARGET_MANAGED=$(LCG_BINPLACE_ROOT_MANAGED)\$(ALT_PROJECT_TARGET)
!endif

# Define the right binplace locations for the localizable and neutral perf counters
PERF_INI_DIR_LS=perfINI_LS
PERF_INI_DIR_LN=perfINI_LN
LOC_PERF_COUNTERS_TARGET_DESTINATION=$(LOC_BIN)\$(PERF_INI_DIR_LS)
PERF_COUNTERS_TARGET_DESTINATION=$(PERF_INI_DIR_LN)
! if "$(_TARGET_DESTINATION_WITHOUT_QUOTES)" != "" && "$(_TARGET_DESTINATION_WITHOUT_QUOTES)" != "retail"
LOC_PERF_COUNTERS_TARGET_DESTINATION=$(LOC_PERF_COUNTERS_TARGET_DESTINATION)\$(TARGET_DESTINATION)
PERF_COUNTERS_TARGET_DESTINATION=$(PERF_COUNTERS_TARGET_DESTINATION)\$(TARGET_DESTINATION)
! endif

# Define the right binplace locations for the localizable and neutral msc files
MSC_FILES_DIR_LS=MSCFiles_LS
MSC_FILES_DIR_LN=MSCFiles_LN
LOC_MSC_FILES_TARGET_DESTINATION=$(LOC_BIN)\$(MSC_FILES_DIR_LS)
MSC_FILES_TARGET_DESTINATION=$(MSC_FILES_DIR_LN)
! if "$(_TARGET_DESTINATION_WITHOUT_QUOTES)" != "" && "$(_TARGET_DESTINATION_WITHOUT_QUOTES)" != "retail"
LOC_MSC_FILES_TARGET_DESTINATION=$(LOC_MSC_FILES_TARGET_DESTINATION)\$(TARGET_DESTINATION)
MSC_FILES_TARGET_DESTINATION=$(MSC_FILES_TARGET_DESTINATION)\$(TARGET_DESTINATION)
! endif

#
# Decide if we should build LCG files for CMI_MANIFESTS.
# This is similar to setting BUILD_LCG.
#
# We will create LCG files if:
#
# - one of the following is true:
#   - The developer specifies BUILD_CMI_LCG=1 in their sources file
#   - We are NOT building test code
#
!if "$(BUILD_CMI_LCG)" != ""
!message LCG: BUILD_CMI_LCG: $(BUILD_CMI_LCG)
! if "$(BUILD_CMI_LCG)" != "1" && "$(BUILD_CMI_LCG)" != "0"
!  error BUILD_CMI_LCG must be empty, 1, or 0
! endif

!elseif defined(TEST_CODE)
BUILD_CMI_LCG=0

!else
BUILD_CMI_LCG=1
!endif

#
# LOCALIZE_BASE_FILE is for forcing the base file (after MUI splitting)
# to get localized as a multilingual file. It is expected to be used with
# "driver" or "kernel" style MUI splitting where a copy of the resources
# is left in the "base" DLL/EXE/etc. as well as a copy being placed into
# the .MUI file. This is needed for printer drivers that need to be
# localized because in that case we need to localize both the base DLL
# _and_ the MUI file. Setting this will cause an LCG file to get created
# for the base file and cause the base file to be binplaced to such that
# it passes through the multi-lingual localization process. The binplacing
# of the .mui file and it's associated LCG is not affected.
#
!if defined(LOCALIZE_BASE_FILE)
!message LCG: LOCALIZE_BASE_FILE: $(LOCALIZE_BASE_FILE)
! if "$(LOCALIZE_BASE_FILE)" != "1" && "$(LOCALIZE_BASE_FILE)" != "0"
!  error LOCALIZE_BASE_FILE must be empty, 1, or 0
! endif
! if "$(LOCALIZE_NO_MUI)" == "1"
!  error LOCALIZE_BASE_FILE cannot be used if LOCALIZE_NO_MUI is turned on (LOCALIZE_NO_MUI=1)
! endif
! if "$(MUI)" != "1"
!  error LOCALIZE_BASE_FILE cannot be used if MUI splitting is turned off (MUI=0)
! endif
!endif

# Make sure we don't use LOCALIZE_BASE_FILE when it should not be used
!if "$(LOCALIZE_BASE_FILE)" == "1"
! if ("$(TARGET_DESTINATION::=)" != "$(TARGET_DESTINATION)")
!  error LOCALIZE_BASE_FILE can not be used with multiple target destinations
! endif
!endif

# Make sure no older/unsupported macros get used
!if defined(LANG_MISCFILES)
! error LANG_MISCFILES has been deprecated. Use the proper PASSx_LANG_MISCFILES version instead.
!endif

!if defined(LOC_MISCFILES) || defined(I386_LOC_MISCFILES) || defined(IA64_LOC_MISCFILES) || defined(AMD64_LOC_MISCFILES)
! error LOC_MISCFILES has been deprecated. Use the proper PASSx_LOC_MISCFILES version instead.
!endif

!if defined(MULTI_MISCFILES)
! error MULTI_MISCFILES has been deprecated. Use the proper PASSx_MULTI_MISCFILES version instead.
!endif

#
# These are very special macros that are created based on the pass currently running
# based on the content of the PASS# variants of each macro. The code block we run
# in each pass is identical and they never run at the same time, so this enables us
# to re-use and not duplicate as much of the infrastructure as possible. It reduces
# the per-pass differences to these specific if blocks that _are_ pass specific.
#
!if "$(BUILD_PASS)" == "PASS0"
! if defined(PASS0_LANG_MISCFILES)
LANG_MISCFILES=$(PASS0_LANG_MISCFILES)
LANG_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_lang_miscfiles.log
! endif
! if defined(PASS0_LOC_MISCFILES)
LOC_MISCFILES=$(PASS0_LOC_MISCFILES)
LOC_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_loc_miscfiles.log
LOC_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass0_loc_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS0_LOC_MUI_MISCFILES)
LOC_MUI_MISCFILES=$(PASS0_LOC_MUI_MISCFILES)
LOC_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_loc_mui_miscfiles.log
LOC_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass0_loc_mui_miscfiles_neutral.lst
LOC_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass0_loc_mui_miscfiles_resource.lst
LOC_MUI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass0_loc_mui_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS0_PRELOC_MISCFILES)
PRELOC_MISCFILES=$(PASS0_PRELOC_MISCFILES)
PRELOC_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_preloc_miscfiles.log
! endif
! if defined(PASS0_PRELOC_MUI_MISCFILES)
PRELOC_MUI_MISCFILES=$(PASS0_PRELOC_MUI_MISCFILES)
PRELOC_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_preloc_mui_miscfiles.log
PRELOC_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass0_preloc_mui_miscfiles_neutral.lst
PRELOC_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass0_preloc_mui_miscfiles_resource.lst
! endif
! if defined(PASS0_PRELOC_MUI_ONLY_MISCFILES)
PRELOC_MUI_ONLY_MISCFILES=$(PASS0_PRELOC_MUI_ONLY_MISCFILES)
PRELOC_MUI_ONLY_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_preloc_mui_only_miscfiles.log
PRELOC_MUI_ONLY_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass0_loc_mui_only_miscfiles_neutral.lst
PRELOC_MUI_ONLY_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass0_loc_mui_only_miscfiles_resource.lst
! endif
! if defined(PASS0_MULTI_MISCFILES)
MULTI_MISCFILES=$(PASS0_MULTI_MISCFILES)
MULTI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_multi_miscfiles.log
MULTI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass0_multi_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS0_MULTI_MUI_MISCFILES)
MULTI_MUI_MISCFILES=$(PASS0_MULTI_MUI_MISCFILES)
MULTI_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass0_multi_mui_miscfiles.log
MULTI_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass0_multi_mui_miscfiles_neutral.lst
MULTI_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass0_multi_mui_miscfiles_resource.lst
MULTI_MUI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass0_multi_mui_miscfiles.lcg.binplace.txt
! endif
!endif


!if "$(BUILD_PASS)" == "PASS1"
! if defined(PASS1_LANG_MISCFILES)
LANG_MISCFILES=$(PASS1_LANG_MISCFILES)
LANG_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_lang_miscfiles.log
! endif
! if defined(PASS1_LOC_MISCFILES)
LOC_MISCFILES=$(PASS1_LOC_MISCFILES)
LOC_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_loc_miscfiles.log
LOC_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass1_loc_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS1_LOC_MUI_MISCFILES)
LOC_MUI_MISCFILES=$(PASS1_LOC_MUI_MISCFILES)
LOC_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_loc_mui_miscfiles.log
LOC_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass1_loc_mui_miscfiles_neutral.lst
LOC_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass1_loc_mui_miscfiles_resource.lst
LOC_MUI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass1_loc_mui_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS1_PRELOC_MISCFILES)
PRELOC_MISCFILES=$(PASS1_PRELOC_MISCFILES)
PRELOC_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_preloc_miscfiles.log
! endif
! if defined(PASS1_PRELOC_MUI_MISCFILES)
PRELOC_MUI_MISCFILES=$(PASS1_PRELOC_MUI_MISCFILES)
PRELOC_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_preloc_mui_miscfiles.log
PRELOC_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass1_preloc_mui_miscfiles_neutral.lst
PRELOC_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass1_preloc_mui_miscfiles_resource.lst
! endif
! if defined(PASS1_PRELOC_MUI_ONLY_MISCFILES)
PRELOC_MUI_ONLY_MISCFILES=$(PASS1_PRELOC_MUI_ONLY_MISCFILES)
PRELOC_MUI_ONLY_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_preloc_mui_only_miscfiles.log
PRELOC_MUI_ONLY_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass1_loc_mui_only_miscfiles_neutral.lst
PRELOC_MUI_ONLY_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass1_loc_mui_only_miscfiles_resource.lst
! endif
! if defined(PASS1_MULTI_MISCFILES)
MULTI_MISCFILES=$(PASS1_MULTI_MISCFILES)
MULTI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_multi_miscfiles.log
MULTI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass1_multi_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS1_MULTI_MUI_MISCFILES)
MULTI_MUI_MISCFILES=$(PASS1_MULTI_MUI_MISCFILES)
MULTI_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass1_multi_mui_miscfiles.log
MULTI_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass1_multi_mui_miscfiles_neutral.lst
MULTI_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass1_multi_mui_miscfiles_resource.lst
MULTI_MUI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass1_multi_mui_miscfiles.lcg.binplace.txt
! endif
!endif

!if "$(BUILD_PASS)" == "PASS2"
! if defined(PASS2_LANG_MISCFILES)
LANG_MISCFILES=$(PASS2_LANG_MISCFILES)
LANG_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_lang_miscfiles.log
! endif
! if defined(PASS2_LOC_MISCFILES)
LOC_MISCFILES=$(PASS2_LOC_MISCFILES)
LOC_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_loc_miscfiles.log
LOC_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass2_loc_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS2_LOC_MUI_MISCFILES)
LOC_MUI_MISCFILES=$(PASS2_LOC_MUI_MISCFILES)
LOC_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_loc_mui_miscfiles.log
LOC_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass2_loc_mui_miscfiles_neutral.lst
LOC_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass2_loc_mui_miscfiles_resource.lst
LOC_MUI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass2_loc_mui_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS2_PRELOC_MISCFILES)
PRELOC_MISCFILES=$(PASS2_PRELOC_MISCFILES)
PRELOC_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_preloc_miscfiles.log
! endif
! if defined(PASS2_PRELOC_MUI_MISCFILES)
PRELOC_MUI_MISCFILES=$(PASS2_PRELOC_MUI_MISCFILES)
PRELOC_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_preloc_mui_miscfiles.log
PRELOC_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass2_preloc_mui_miscfiles_neutral.lst
PRELOC_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass2_preloc_mui_miscfiles_resource.lst
! endif
! if defined(PASS2_PRELOC_MUI_ONLY_MISCFILES)
PRELOC_MUI_ONLY_MISCFILES=$(PASS2_PRELOC_MUI_ONLY_MISCFILES)
PRELOC_MUI_ONLY_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_preloc_mui_only_miscfiles.log
PRELOC_MUI_ONLY_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass2_loc_mui_only_miscfiles_neutral.lst
PRELOC_MUI_ONLY_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass2_loc_mui_only_miscfiles_resource.lst
! endif
! if defined(PASS2_MULTI_MISCFILES)
MULTI_MISCFILES=$(PASS2_MULTI_MISCFILES)
MULTI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_multi_miscfiles.log
MULTI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass2_multi_miscfiles.lcg.binplace.txt
! endif
! if defined(PASS2_MULTI_MUI_MISCFILES)
MULTI_MUI_MISCFILES=$(PASS2_MULTI_MUI_MISCFILES)
MULTI_MUI_MISCFILES_LOG=$(OBJ_PATH)\$O\pass2_multi_mui_miscfiles.log
MULTI_MUI_MISCFILES_NEUTRAL_LIST=$(OBJ_PATH)\$O\pass2_multi_mui_miscfiles_neutral.lst
MULTI_MUI_MISCFILES_RESOURCE_LIST=$(OBJ_PATH)\$O\pass2_multi_mui_miscfiles_resource.lst
MULTI_MUI_MISCFILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\pass2_multi_mui_miscfiles.lcg.binplace.txt
! endif
!endif

# For prelocalized files, we need to know what language they are. Note that this is
# intentionally different from the somewhat ambigiously used $(LANG) variable...
!if defined(PRELOC_MISCFILES)          || \
    defined(PRELOC_MUI_MISCFILES)      || \
    defined(PRELOC_MUI_ONLY_MISCFILES) || \
    defined(PRELOC_PRINTER_INFS)       || \
    "$(TARGETTYPE)" == "USER_ASSISTANCE"

# Validate PRELOC_BASE_LANG if it's set
!if defined (PRELOC_BASE_LANG)
! if "$(PRELOC_BASE_LANG)" != "1" && "$(PRELOC_BASE_LANG)" != "0"
!  error PRELOC_BASE_LANG can only be set to 1 or 0
! endif
!endif

# Validate we have something for the language for prelocalized files
! if "$(PRELOC_LANG: =)" == "" && "$(PRELOC_BASE_LANG)" != "1"
# multi line errors require the older !message style
!  message error : If using any of the PASSx_PRELOC_MISCFILES, PASSx_PRELOC_MUI_MISCFILES,
!  message error : PASSx_PRELOC_MUI_ONLY_MISCFILES, or PRELOC_PRINTER_INFS macros, or
!  message error : TARGETTYPE=USER_ASSISTANCE, you must do one of the following in your
!  message error : sources file:
!  message error :  - Set PRELOC_LANG to a valid language
!          error :  - Set PRELOC_BASE_LANG=1
! endif

# Validate things are not in conflict
! if defined(PRELOC_LANG) && "$(PRELOC_BASE_LANG)" == "1"
!  error You cannot set PRELOC_BASE_LANG=1 and set PRELOC_LANG.
! endif

# Make sure we set the right binplace directory for prelocalized files
# NOTE: Rebuild these values from scratch and do not re-use $(LOC_UA)
!if defined(PRELOC_LANG)
PRELOC_BINPLACE_DIR=$(LOC_PRELOC)\$(PRELOC_LANG)
UA_BINPLACE_DIR=$(LOC_PRELOC)\$(PRELOC_LANG)\UA
!else
PRELOC_BINPLACE_DIR=$(LOC_BIN)
UA_BINPLACE_DIR=$(LOC_BIN)\UA
!endif

# For UA files, check for obvious errors and get them binplacing correctly
!if "$(TARGETTYPE)" == "USER_ASSISTANCE"
! if "$(ALT_PROJECT_TARGET)" != "" && "$(ALT_PROJECT_TARGET)" != "."
!  error Must not define ALT_PROJECT_TARGET with TARGETYPE=USER_ASSISTANCE.
! else
ALT_PROJECT_TARGET=$(UA_BINPLACE_DIR)
! endif
!endif

!endif # PRELOC_*

!if defined(LOC_PLA_XML_FILES)
LOC_PLA_XML_FILES_LOG=$(OBJ_PATH)\$O\loc_pla_xml_files.log
LOC_PLA_XML_FILES_RESOURCE_LIST=$(OBJ_PATH)\$O\loc_pla_xml_files_resource.lst
LOC_PLA_XML_FILES_LCG_BINPLACE_TXT=$(OBJ_PATH)\$(O)\loc_pla_xml_files.lcg.binplace.txt
!endif

# Validate that there is no conflict between the *_MUI_MISCFILES macros and the MUI macro.
!if defined(LOC_MUI_MISCFILES) || \
    defined(MULTI_MUI_MISCFILES) || \
    defined(PRELOC_MUI_MISCFILES) || \
    defined(PRELOC_MUI_ONLY_MISCFILES)
! if "$(MUI)" == "0"
!  error You cannot set MUI=0 if you are using any of the *_MUI_MISCFILE macros.
! endif # MUI==0
!endif # defined(*_MUI_MISCFILES)


# Support to compile CMI manifests
!if (    defined(CMI_MANIFESTS) \
      || defined(CMI_WOW64_MANIFESTS) \
      || defined(CMI_MULTI_MANIFESTS) \
      || defined(CMI_MULTI_WOW64_MANIFESTS) \
      || defined(EVENTS_MANIFEST) \
      || defined(CMI_PROD_MANIFESTS) \
      || defined(CMI_WOW64_PROD_MANIFESTS) \
      || defined(CMI_EDITION_MANIFESTS) \
    ) && !defined(MANIFEST_COMPILER_CMD)
MANIFEST_COMPILER_CMD=cscript //nologo $(RAZZLETOOLPATH)\ManifestCompiler.vbs $(RAZZLETOOLPATH)\ManifestCompiler.xsl
!endif


# Support for components that use manifest-generated events or direct calls
# to ETW APIs that aren't defined in ntetw.h, but want to use the Etw*
# routines in ntdll.dll rather than the Win32 forwarders in advapi32.dll.

!IF "$(MANPP_USE_NTDLL_EVENT_FUNCTIONS)" == "1"
C_DEFINES=$(C_DEFINES) \
    -DEventActivityIdControl=EtwEventActivityIdControl \
    -DEventEnabled=EtwEventEnabled \
    -DEventProviderEnabled=EtwEventProviderEnabled \
    -DEventRegister=EtwEventRegister \
    -DEventUnregister=EtwEventUnregister \
    -DEventWrite=EtwEventWrite \
    -DEventWriteEx=EtwEventWriteEx \
    -DEventWriteEndScenario=EtwEventWriteEndScenario \
    -DEventWriteStartScenario=EtwEventWriteStartScenario \
    -DEventWriteString=EtwEventWriteString \
    -DEventWriteTransfer=EtwEventWriteTransfer \
    -DGetTraceLoggerHandle=EtwGetTraceLoggerHandle \
    -DGetTraceEnableLevel=EtwGetTraceEnableLevel \
    -DGetTraceEnableFlags=EtwGetTraceEnableFlags \
    -DRegisterTraceGuidsA=EtwRegisterTraceGuidsA \
    -DRegisterTraceGuidsW=EtwRegisterTraceGuidsW \
    -DTraceEvent=EtwLogTraceEvent \
    -DTraceMessage=EtwTraceMessage \
    -DUnregisterTraceGuids=EtwUnregisterTraceGuids
!ENDIF

!IF defined(CMI_MANIFESTS)
SOURCE_MANIFEST = $(OBJ_PATH)\$O\source_manifest.log
!ENDIF

!IF $(386) && defined(CMI_WOW64_MANIFESTS)
WOW64_SOURCE_MANIFEST = $(OBJ_PATH)\$O\wow64_source_manifest.log
!ENDIF

!IF defined(CMI_MULTI_MANIFESTS)
MULTI_SOURCE_MANIFEST = $(OBJ_PATH)\$O\multi_source_manifest.log
!ENDIF

!IF $(386) && defined(CMI_MULTI_WOW64_MANIFESTS)
MULTI_WOW64_SOURCE_MANIFEST = $(OBJ_PATH)\$O\multi_wow64_source_manifest.log
!ENDIF

!IF defined(CMI_PROD_MANIFESTS)
PROD_SOURCE_MANIFEST = $(OBJ_PATH)\$O\prod_source_manifest.log
INTERNAL_SOURCE_MANIFEST = $(OBJ_PATH)\$O\internal_source_manifest.log
!ENDIF

!IF $(386) && defined(CMI_WOW64_PROD_MANIFESTS)
PROD_WOW64_SOURCE_MANIFEST = $(OBJ_PATH)\$O\prod_wow64_source_manifest.log
INTERNAL_WOW64_SOURCE_MANIFEST = $(OBJ_PATH)\$O\internal_wow64_source_manifest.log
!ENDIF

!IF defined(CMI_EDITION_MANIFESTS)
EDITION_SOURCE_MANIFEST = $(OBJ_PATH)\$O\edition_source_manifest.log
!ENDIF

!IF defined(CMI_WINPE_MANIFESTS)
WINPE_SOURCE_MANIFEST = $(OBJ_PATH)\$O\winpe_source_manifest.log
!ENDIF

!ifndef MANIFEST_COMPILER_CMD
MANIFEST_COMPILER_CMD=cscript //nologo $(RAZZLETOOLPATH)\ManifestCompiler.vbs $(RAZZLETOOLPATH)\ManifestCompiler.xsl
!endif

!ifndef MANIFEST_RCPARSER_CMD
MANIFEST_RCPARSER_CMD=rcmanparse
!endif

!if defined(MT_SKIP_MANIFEST_VALIDATION)
!else
MT_OPTIONS=$(MT_OPTIONS) -validate_manifest
!endif

MT_FIXUP_LIST=FixDefWildcardAttributes,FixSystem32Path,FixBuildAssemblyPath,CorralRegistryData,FixResourceStrings,ConvertNegativeRegDwordValues,MapDirIdToDirectoryName,CanonicalizeRegistryKeyNames,AddMissingManifestVersionAttribute,AddMissingPublicKeyTokenToDefId,ExpandShortRootKeyNames,MergeDuplicateRegistryKeys,RemoveDuplicateComClasses,RemoveDuplicateProgIds,RemoveDuplicateDependencies,RemoveDuplicateRegistryValues,FixResourceStrings,IgnoreDrivers,AddMissingSecurityDescriptors,RemoveFileDependencies,RemovePrerequisiteDependencies,RemoveRedirectInfo

!ifndef MT_NO_COPYRIGHT_FIXUP
MT_FIXUP_LIST=$(MT_FIXUP_LIST),ForceMicrosoftCopyright
!endif

!if defined(MT_SKIP_MANIFEST_FIXUPS)
!else
MT_OPTIONS=$(MT_OPTIONS) -fix_bogus_manifests:$(MT_FIXUP_LIST)
!endif

!ifndef PASS_INDEPENDENT_TARGETS
! ifdef _PROJECT_BUILDS_MANAGED_CODE
!  ifdef MANAGED_CXX
!   if "$(TARGETTYPE)" == "LIBRARY" || "$(TARGETTYPE)" == "NOTARGET"
_MANAGED_CXX_LIBRARY=1
!   endif
!   if "$(MANAGED_TARGET_TYPE)" == "module"
!    if "$(URT_VER)" >= "2.0"
USER_C_FLAGS=$(USER_C_FLAGS) /LN
!    endif # } }
LINKER_FLAGS=$(LINKER_FLAGS) /NoAssembly
!   endif
!  endif


! endif
!endif  # PASS_INDEPENDENT_TARGETS


#
# set up NO_BINPLACE early so everyone that wants to check this can check it
# Two reasons not to binplace:
# 1) since we're generating binary drops of this source there's no need to
# binplace the files.  The files should be binplaced from the binary_release
# directory.
# 2) there's nowhere to move the files to
#
!if defined(BINARY_PUBLISH) || \
    defined(BINARY_PUBLISH_DIR) || \
    !defined(_NTTREE) || \
    (defined(TEST_CODE) && defined(NO_TEST_BINPLACE))
NO_BINPLACE=1
!endif

!ifndef PASS_INDEPENDENT_TARGETS

!if defined(MANIFESTS) && "$(MANIFESTS: =)" == ""
!  error error If MANIFESTS is defined, it must not be empty.
# And just containing spaces is the same as empty.
!endif

!if ((defined(_PROJECT_BUILDS_MANAGED_CODE) && ("$(BUILD_PRODUCT)" == "NT")) \
    || defined(MANIFESTS) \
    || defined(ASSEMBLY_IDENTITY_NAME)) \
  && !defined(_MAKING_ASMID_INC) \
  && !defined(_MANAGED_CXX_LIBRARY) \
  && "$(MANAGED_TARGET_TYPE)" != "module"

!if defined(MANAGED_PLATFORM_SPECIFIC) && "$(MANAGED_PLATFORM_SPECIFIC)" != "1"
!error MANAGED_PLATFORM_SPECIFIC must be set to 1 or not defined
!endif

WINDOWS_ASSEMBLY_VERSION=$(WINDOWS_VERSION)
!  include $(OBJECT_ROOT)\$O\translate_asmid.inc

#
# Run idtool.
#
!  if [nmake.exe /nologo /f $(NTMAKEENV)\makefile.def _ASSEMBLY_IDENTITY=$(_ASSEMBLY_IDENTITY) _MAKING_ASMID_INC=1 $(OBJ_PATH)\$O\_asmid.inc]
!  endif
!  include $(OBJ_PATH)\$O\_asmid.inc
!endif

!if defined(COM_VISIBLE) && "$(COM_VISIBLE)" != "0" && "$(COM_VISIBLE)" != "1"
!  error COM_VISIBLE must be 0 or 1 or not defined.
!endif

!if defined(COM_VISIBLE) && !defined(_PROJECT_BUILDS_MANAGED_CODE)
!  error COM_VISIBLE can only be defined for managed code.
# Review -- just ignore it?
!endif

# SXS_NO_BINPLACE will be deprecated.
# It will be replaced by reversing the default and introducing a new macro for the other case:
#  ASSEMBLY_IS_SXS=1
# which defaults to 1 for managed code and it set explicitly for comctl32.dll, etc.
!if defined(SXS_NO_BINPLACE) && "$(SXS_NO_BINPLACE)" != "1"
! error SXS_NO_BINPLACE must be 1 or not defined.
!endif

#
# TARGEXT is .lib in pass1 building PROGLIB, DYNLINK
# but LINK_TARGETEXT is not.
#
# TBD: The logic for TARGETEXT should move up to here and provide this.
# This is just a small subset.
#
# EXPORT_DRIVER DRIVER MINIPORT DYNLINK LIBRARY DRIVER_LIBRARY..
#
!if "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "PROGLIB"
LINK_TARGETEXT=exe
!else
LINK_TARGETEXT=dll
!endif

!if defined(NTKERNEL)
__TARGETNAME=$(NTKERNEL)
__TARGETEXT=exe
!else
__TARGETNAME=$(TARGETNAME)
__TARGETEXT=$(TARGETEXT)
!endif

#
# Deal with referencing public keys from the global build initialization data
# generated from the rather misnamed "versions.xml" into various includable forms
!if "$(BUILD_PRODUCT)" == "NT"
!  ifdef USE_PUBLIC_KEY_REFERENCES
!    ifdef _PROJECT_BUILDS_MANAGED_CODE
REFERENCES=$(REFERENCES);$(SDK_REF_PATH)\Microsoft.Windows.Identity.dll
!    else
!      error USE_PUBLIC_KEY_REFERENCES only supports managed code
!    endif
!  endif
!endif


#
# Where did the name ".asmmeta" come from?
#   ".asm" == "assembly source code", not just x86, ia64, amd64, etc., but also il.
#   ".meta" == "metadata only .dll"
#     => ".asmmeta" == "assembly source code to metadata only .dll"
#
# ".meta" is also sometimes known as "dehydrated .dll" or "dehydrated assembly".
# (assembly has another meaning -- "unit of deployment", ".dll", "self described .dll", ".dll + .xml manifest")
#
# For our purposes, we drop the term ".meta" and instead refer to "metadata only .dlls" (or .exes).
#
# Asmmeta.exe is basically a stripped down ildasm.
# It removes all code (leaving "ret" instructions) but leaves in all the declarations, all the metadata.
#
# Asmmeta.exe's output includes version numbers.
#
# Version numbers must be changable fairly rapidly, must be changed rapidly, else the ability
#   to change them will greatly decrease.
#
# So version numbers must be removed from asmmeta.exe's output, and put back in right before running ilasm.
#
# o\foo.asmmeta_ver_pass0 has versions; it is input to ilasm in pass0.
# o\foo.asmmeta_ver_pass2 has versions; it is the output of asmmeta.exe in pass2.
# Given a steady state of no code changes, the above two files are identical.
# .\foo.asmmeta lacks versions; it is the checked in textual "source" file (though not hand written and not very readable).
#
# foo.cs => o\foo.dll => o\asmmeta_ver_pass2 => comparison/copy => .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#
# as long as foo.cs is unchanged:
#   pass0: .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#   pass2: foo.cs => o\foo.dll => o\asmmeta_ver_pass2 => comparison/(no)copy => stop
#
# if foo.cs is changed, then:
#   pass0: .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#   pass2: foo.cs => o\foo.dll => o\asmmeta_ver_pass2 => comparison/copy => developer must build again
#   next pass0 => .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#

# detect .asmmetas that are no longer needed
!if defined(_PROJECT_BUILDS_MANAGED_CODE) \
    && "$(TARGETTYPE)" == "PROGRAM" \
    && !defined(USE_ASMMETA) \
    && !defined(ASMMETA_INPUT) \
    && exist($(TARGETNAME).asmmeta)
! error delete $(MAKEDIR)\$(TARGETNAME).asmmeta
!endif

!if defined(_PROJECT_BUILDS_MANAGED_CODE)
!  if defined(USE_ASMMETA)
!    if "$(TARGETTYPE)" == "DYNLINK"
!      message $(MAKEDIR) USE_ASMMETA=1 does nothing when TARGETTYPE == DYNLINK, remove it.
!    else
!      if "$(USE_ASMMETA)" != "1"
!        error $(MAKEDIR) USE_ASMMETA must be 1 or not defined, change it to 1.
!      endif
!    endif
!  endif
!else

#
# This if needs some work, it lets too much through.
#
!  if defined(USE_ASMMETA) \
    && !(defined(ASSEMBLY_IDENTITY_VERSION_NAME) || defined(URT_VER))
!    error $(MAKEDIR) USE_ASMMETA does nothing for native code; remove it.
!  endif

!endif

!if \
    ( \
        (defined(_PROJECT_BUILDS_MANAGED_CODE) && ("$(BUILD_PRODUCT)" == "NT") && ("$(TARGETTYPE)" != "PROGRAM")) \
            || defined(USE_ASMMETA) \
            || defined(ASMMETA_INPUT) \
    ) \
  && !defined(_MANAGED_CXX_LIBRARY) \
  && ("$(MANAGED_TARGET_TYPE)" != "module" || defined(ASMMETA_INPUT)) \
  && "$(TARGETEXT)" != "lib"

! if exist($(TARGETNAME).asmmeta) && exist($(TARGET_DIRECTORY)\$(TARGETNAME).asmmeta)
!  message warning : delete $(MAKEDIR)\$(TARGETNAME).asmmeta or $(MAKEDIR)\$(TARGET_DIRECTORY)\$(TARGETNAME).asmmeta
! endif

! ifndef SOURCE_ASMMETA
!  if exist($(TARGET_DIRECTORY)\$(TARGETNAME).asmmeta)
SOURCE_ASMMETA=$(TARGET_DIRECTORY)\$(TARGETNAME).asmmeta
!  else
SOURCE_ASMMETA=$(TARGETNAME).asmmeta
!  endif
! endif

! if exist($(SOURCE_ASMMETA))
_O_BINARY_METADATA=$(OBJ_PATH)\$O\$(TARGETNAME).metadata_$(LINK_TARGETEXT)
! endif
_O_ASMMETA_OUTPUT=$(OBJ_PATH)\$O\$(TARGETNAME).asmmeta_ver_pass2
_O_ASMMETA=$(OBJ_PATH)\$O\$(TARGETNAME).asmmeta

! ifndef ASMMETA_INPUT
# TBD -- why isn't it always defined?
!  ifdef TARGET
ASMMETA_INPUT=$(TARGET)
!  else
ASMMETA_INPUT=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT:.=)
!  endif
! endif

!endif

#
# SXS_LOCALIZE is going away.
#
#
# This would be the default but so far everyone is an exception.
#  Comctl32.dll has multiple languages in the code .dll.
#  Gdiplus.dll has no resources.
#  Rtc is using system32 fallback + explicit satellite dependency.
#
# Besides that, nobody yet needs this.
#

!if defined(SXS_LOCALIZE_ASSEMBLY_MUI) && "$(SXS_LOCALIZE_ASSEMBLY_MUI)" != "1"
!  error SXS_LOCALIZE_ASSEMBLY_MUI can only be set to 1.
!endif

!if defined(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY) && "$(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY)" != "1"
!  error SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY can only be set to 1.
!endif

!if defined(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY) && !defined(SXS_LANGUAGE)
!  error If you set SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY, you must also set SXS_LANGUAGE, and use SXS_LANGUAGE in your assembly identity.
!endif


#
# SideBySide (SXS) Build
#
# Step by Step instructions
#
# For building a monolithic application, foo.ext (where .ext is usually .exe but for example .scr).
# For building an application that hosts arbitrary (3rd party) code.
# For building a single file component like comctl32.dll.
# For building a multiple file component.
#
# Reference
#
# An assembly contains a manifest and one or more files, usually .dlls.
# The manifest can be in a resource in one of the files, or it can be in a seperate
#   .manifest file. For purposes of fitting on an 8.3 CD, .man is allowed.
# Build.exe is generally limited to building one .dll per directory, so
#   you can be building files for an assembly without building a manifest.
#
# To build/binplace a manifest:
#
#  SXS_MANIFEST required
#    This is the source file that contains your manifest.
#    It must end in .manifest.
#    It is always preprocessed. Available macros include:
#      SXS_ASSEMBLY_NAME
#      SXS_ASSEMBLY_VERSION
#      SXS_ASSEMBLY_LANGUAGE
#      SXS_PROCESSOR_ARCHITECTURE
#
#  SXS_MANIFEST_IN_RESOURCES optional
#    This is defined or not, so you just say
#      SXS_MANIFEST_IN_RESOURCES=
#    or don't say anything.
#
#  SXS_ASSEMBLY_NAME and/or SXS_SHORT_ASSEMBLY_NAME required
#    One can be generated from the other.
#    SXS_SHORT_ASSEMBLY_NAME is used where 8.3 limits apply, like on the product CD.
#    Both of these macros can be hierarchical, using dot, dash, or underscore to seperate
#    elements. SXS_SHORT_ASSEMBLY_NAME should actually only contain 8 character elements.
#
#  SXS_ASSEMBLY_VERSION optional, defaults to 5.1.
#
#  SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT required
#    SXS_ASSEMBLY_LANGUAGE_INDEPENDENT is defined or not.
#    SXS_ASSEMBLY_LANGUAGE is four digits like
#      0409 for English US
#      0009 for English
#      0000 for language independent
#    We should make this easier as is done for resources (LANGUAGE => RCCODEPAGE), but for now we don't.
#
# To build/binplace a file into an assembly, a subset of the information
# needed for manifests is needed:
#
#  SXS_ASSEMBLY_NAME and/or SXS_SHORT_ASSEMBLY_NAME
#  SXS_ASSEMBLY_VERSION
#  SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT
#
# There are restrictions on the values of these macros and not all restrictions
# are currently enforced by the build. Enforcement is in verify.src.
#

!if "$(ALT_PROJECT)" == "WOW6432" || "$(ALT_PROJECT_TARGET)" == "WOW6432"
SXS_PDB_WOW6432_W_PREFIX=w
SXS_LOG_WOWBINS_W_ASMS_PREFIX=w
SXS_LOG_BINPLACE_WOW6432_PREFIX=wow6432^\
SXS_WOW6432=1
!endif

#
# There's two meta-modes of operation in SXS - Application manifest mode and component manifest mode.
# Depending on what you have defined in your sources file, you can simplify all of the build process
# down to a very minimal set of commands in your sources files and still get Fusionization goodness.
#
# Example:
#
# SXS_APPLICATION_MANIFEST=MyAppManifest.manifest
#
# (or)
#
# SXS_COMPONENT_MANIFEST=MyComponentManifest.manifest
#
# See the code below for what gets defined based on each - it's more or less the defaults, but
# explicitly spelled out.
#

# No fair using either app and component manifest, and specifying sxs_manifest, or using both by accident
!if defined(SXS_APPLICATION_MANIFEST) && defined(SXS_COMPONENT_MANIFEST)
! error You can have only one of SXS_APPLICATION_MANIFEST or SXS_COMPONENT_MANIFEST, not both
!elseif defined(SXS_MANIFEST) && ( defined(SXS_APPLICATION_MANIFEST) || defined(SXS_COMPONENT_MANIFEST) )
! error When using SXS_APPLICATION_MANIFEST or SXS_COMPONENT_MANIFEST, do not specify SXS_MANIFEST
!endif

# Applications get the following defaults that are not defaulted later:
# - SXS_ASSEMBLY_LANGUAGE=SXS_ASSEMBLY_LANGUAGE_INDEPENDENT
# - SXS_ASSEMBLY_NAME=Microsoft.Windows.$(PROJECT).$(TARGETNAME)
# - Manifest in resources
!ifdef SXS_APPLICATION_MANIFEST
SXS_MANIFEST=$(SXS_APPLICATION_MANIFEST)
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
!ifndef SXS_ASSEMBLY_NAME
SXS_ASSEMBLY_NAME=Microsoft.Windows.$(_PROJECT_:\=.).$(TARGETNAME:_=-)
!endif
!ifndef SXS_ASSEMBLY_LANGUAGE
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!endif

# Components get the following defaulted:
# - SXS_ASSEMBLY_NAME=Microsoft.Windows.$(PROJECT).$(TARGETNAME)
# - Language independent
!elseif defined(SXS_COMPONENT_MANIFEST)
SXS_MANIFEST=$(SXS_COMPONENT_MANIFEST)
!ifndef SXS_ASSEMBLY_NAME
SXS_ASSEMBLY_NAME=Microsoft.Windows.$(_PROJECT_\=.).$(TARGETNAME)
!endif
!ifndef SXS_ASSEMBLY_LANGUAGE
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!endif

!endif

!include $(NTMAKEENV)\verify.src

!ifdef ISOLATION_AWARE_ENABLED
C_DEFINES=$(C_DEFINES) /DISOLATION_AWARE_ENABLED=1
!endif

#
# NO_BINPLACE implies SXS_NO_BINPLACE
#
!ifdef NO_BINPLACE
SXS_NO_BINPLACE=1
!endif

#
# Building an .exe implies SXS_NO_BINPLACE, no publishing
#
!if "$(TARGETTYPE)" == "PROGRAM"
SXS_NO_BINPLACE=1
! if ((defined(PASS0_PUBLISH))  || (defined(PASS1_PUBLISH))) && !defined(PUBLISH_EXE_ALLOWED)
!  error $(MAKEDIR) directories where TARGETTYPE is set to "PROGRAM" may not publish files
! endif
!endif


#
# We can build SXS_ASSEMBLY_NAME out of SXS_SHORT_ASSEMBLY_NAME
# and vice versa.
#

!if !defined(SXS_ASSEMBLY_NAME) && defined(SXS_SHORT_ASSEMBLY_NAME)
SXS_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME)
!endif

!if !defined(SXS_SHORT_ASSEMBLY_NAME) && defined(SXS_ASSEMBLY_NAME)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_ASSEMBLY_NAME)
!endif

#
# Support the idea of a hierarchical 8.3 name, besides that this
# transform might be applied after the preceding assignment.
#
# eg: msft-vcrtl => msft\vcrtl
#

# Turn hierarchical names using [-._ ] as the element divider
# into hierarchical file system names. (Note that _ and . are not
# currently allowed in assembly names.)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:-=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:_=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:.=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME: =\)

# Shorten one special name that is likely to appear in long assembly names.
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:Microsoft=Msft)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:microsoft=msft)

!if defined(SXS_MANIFEST_IN_RESOURCES) && !defined(SXS_MANIFEST)
! error You must specify SXS_MANIFEST if you specify SXS_MANIFEST_IN_RESOURCES.
!endif

!if defined(SXS_ASSEMBLY_VERSION) && !defined(SXS_ASSEMBLY_NAME)
! error You may not specify SXS_ASSEMBLY_VERSION without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if (defined(SXS_ASSEMBLY_LANGUAGE) || defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT)) && !defined(SXS_ASSEMBLY_NAME)
! error You may not specify SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if defined(SXS_BINPLACE_ALSO_ROOT) && !defined(SXS_ASSEMBLY_NAME)
! error You may not specify SXS_BINPLACE_ALSO_ROOT without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if defined(_ASSEMBLY_IDENTITY) && !defined(SXS_NO_BINPLACE) # {
# nothing
!elseif defined(SXS_ASSEMBLY_NAME) # } {
#
# SXS_ASSEMBLY_VERSION may only contain dots and digits.
# Removing them should leave nothing.
#
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_ASSEMBLY_VERSION)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:.=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:0=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:1=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:2=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:3=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:4=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:5=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:6=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:7=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:8=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:9=)
!if "$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS)" != ""
! error SXS_ASSEMBLY_VERSION ($(SXS_ASSEMBLY_VERSION)) may only contain dots and digits.
!endif

#
# ASSERT(SXS_ASSEMBLY_LANGUAGE xor SXS_ASSEMBLY_LANGUAGE_INDEPENDENT)
#
!if    (!defined(SXS_ASSEMBLY_LANGUAGE) && !defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT))
! error Must specify SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT.
!endif

!if ( defined(SXS_ASSEMBLY_LANGUAGE) &&  defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT))
! error Must not specify both SXS_ASSEMBLY_LANGUAGE and SXS_ASSEMBLY_LANGUAGE_INDEPENDENT.
! error ( SXS_ASSEMBLY_LANGUAGE=$(SXS_ASSEMBLY_LANGUAGE), SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=$(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) )
!endif

#
# Derive from SXS_ASSEMBLY_LANGUAGE from SXS_ASSEMBLY_LANGUAGE_INDEPENDENT.
#
!if defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) && !defined(SXS_ASSEMBLY_LANGUAGE)
SXS_ASSEMBLY_LANGUAGE=x-ww
!endif

#
# This is for Fusion stuff only. It does not need to match the nt subsystem version.
#
!ifndef SXS_ASSEMBLY_VERSION
SXS_ASSEMBLY_VERSION=5.1
!endif

#
# SxS Versions are Major.Minor.Release.Revision
#
!ifdef SXS_ASSEMBLY_VERSION # {

!ifndef SXS_ASSEMBLY_VERSION_PART_3
SXS_ASSEMBLY_VERSION_PART_3=0
!endif

!ifndef SXS_ASSEMBLY_VERSION_PART_4
SXS_ASSEMBLY_VERSION_PART_4=0
!endif

#
# If this is more than eight characters or not adequately unique, the user must specify it in their sources file.
#
!if "$(SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER)" == ""
!ifndef SXS_AUTO_VERSION
!if "$(SXS_ASSEMBLY_VERSION_PART_4)" != "0"
SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER=$(SXS_ASSEMBLY_VERSION:.=)$(SXS_ASSEMBLY_VERSION_PART_3)
!else
SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER=$(SXS_ASSEMBLY_VERSION:.=)$(SXS_ASSEMBLY_VERSION_PART_3)$(SXS_ASSEMBLY_VERSION_PART_4)
!endif
!else
SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER=$(SXS_ASSEMBLY_VERSION:.=)
!endif
!endif

SXS_ASSEMBLY_FULL_VERSION=$(SXS_ASSEMBLY_VERSION).$(SXS_ASSEMBLY_VERSION_PART_3).$(SXS_ASSEMBLY_VERSION_PART_4)

!endif # }

!ifndef SXS_NO_BINPLACE # {
#
# We might need SXS_ASSEMBLY_LANGUAGE and even SXS_ASSEMBLY_PROCESSOR_ARCHITECTURE
# in SXS_BINPLACE_DIR, esp. for example if we have any data only assemblies with
# the same name/version as code containing assemblies.
#
# Eventually the mapping from assembly metadata to run-time paths and
# build-time paths will be exposed by sxs.dll/sxs.lib consumed
# by build tools written in C/C++ (possibly just binplace).
# Build/Make are too constraining for our needs.
# For now we get by.
#
# "asms" is very special, it is the root of where assemblies are binplaced
# and it is the root of where they appear on the XP CD, in XP service packs,
# and QFEs. "asms" was replaced by asms01.cab in Server 2003.
# This string appears in a number of places:
#   \nt\tools\PostBuildScripts
#   \nt\admin\ntsetup\inf\win4\inf\dosnet.inx
#   \nt\admin\ntsetup\inf\win4\inf\syssetup.inx
#
# We place version in front of name due to restrictions on how the manifest
# file name related to the name of leaf directory it is in.
SXS_BINPLACE_DIR2=$(SXS_EIGHT_CHARACTER_VERSION_DIRECTORY_NAME_UNIQUIFIER)\$(SXS_SHORT_ASSEMBLY_NAME)
SXS_BINPLACE_DIR3=asms\$(SXS_BINPLACE_DIR2)
SXS_BINPLACE_RESOURCES_DIR=$(SXS_BINPLACE_DIR3).Resources

#
# create msms destination directory
#
!ifdef SXS_GENERATE_MERGE_MODULE # {

#
# if the generate mode is not defined, set it default : 0
#
!ifndef SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP
SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP=0
!else
SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP=1
!endif

!if "$(SXS_MERGE_MODULE_GUID)" == "" || "$(SXS_MERGE_MODULE_COMPONENT_GUID)" == ""  # {
!error MergeModule GUID and MergeModule Component must be specified
!endif # }

!ifndef SXS_MERGE_MODULE # { use the manifest basename as the msm basename
SXS_MERGE_MODULE=$(SXS_MANIFEST_BASENAME).msm
!endif #}

!ifndef SXS_MERGE_MODULE_LOCATION
SXS_MERGE_MODULE_DESTINATION=asm_msm\$(SXS_BINPLACE_DIR2)
!else
#
#parse this string to generate the real path
#
SXS_MERGE_MODULE_LOCATION=$(SXS_ASSEMBLY_FULL_VERSION:.=)\$(SXS_MERGE_MODULE_LOCATION)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:-=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:_=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:.=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION: =\)
SXS_MERGE_MODULE_LOCATION=asm_msm\$(SXS_MERGE_MODULE_LOCATION)
!endif
!endif # }

BINPLACE_GENERATE_PLACEFILE=1
!if "$(BINPLACE_DESTINATIONS)" == ""
BINPLACE_DESTINATIONS=$(SXS_BINPLACE_DIR3)
!else
BINPLACE_DESTINATIONS=$(BINPLACE_DESTINATIONS):$(SXS_BINPLACE_DIR3)
!endif
BINPLACE_DESTINATIONS_NORETAIL=$(BINPLACE_DESTINATIONS)
!ifdef SXS_BINPLACE_ALSO_ROOT
BINPLACE_DESTINATIONS=$(BINPLACE_DESTINATIONS):retail
!endif

!endif # !SXS_NO_BINPLACE }

#
# Optionally uniquize the .pdb names, so they can go in a flat directory (%_nttree%\symbols.pri\retail\dll)
#
!ifndef SXS_LONG_PDB_NAME
SXS_LONG_PDB_NAME=$(SXS_PDB_WOW6432_W_PREFIX)$(SXS_ASSEMBLY_NAME:.=)-$(SXS_ASSEMBLY_FULL_VERSION:.=)-$(TARGETNAME:.=)
!endif
!ifndef SXS_NO_BINPLACE #{
!if !defined(TARGETPDB) && "$(SXS_USE_LONG_PDB_NAME)" == "1" && !defined(SXS_AUTO_VERSION)
LINKER_FLAGS=$(LINKER_FLAGS) /pdb:$(TARGETPATH)\$(TARGET_DIRECTORY)\$(SXS_LONG_PDB_NAME).pdb
!endif
SXS_BINPLACE_FLAGS=/ChangeAsmsToRetailForSymbols
!endif #}

!endif # !SXS_ASSEMBLY_NAME }

!if defined(BINPLACE_LOG) && !defined(NO_SXS_LOG)
!if !defined(NO_BINPLACE) && ("$(TARGETTYPE)" == "NOTARGET" || "$(MAKEDLL)" != "" || "$(BUILD_PASS)" == "PASS2")
SXS_LOG_PASS=1
SXS_LOG_CMD= ( echo. )
!endif
!endif

!if defined(SXS_LOG_PASS) && !defined(APPEND_TOOL)
APPEND_TOOL=appendtool
!endif

!ifdef SXS_MANIFEST # {

#
# If removing .manifest or .Manifest from SXS_MANIFEST leaves it unchanged,
# it doesn't contain either one and is invalid.
#
!if "$(SXS_MANIFEST:.Manifest=)" == "$(SXS_MANIFEST)" \
    && "$(SXS_MANIFEST:.manifest=)" == "$(SXS_MANIFEST)"
! error SXS_MANIFEST ($(SXS_MANIFEST)) must contain ".Manifest", it must end in ".Manifest"
!endif

SXS_MANIFEST_SOURCE_FILENAME=$(SXS_MANIFEST:..\=)

SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_SOURCE_FILENAME)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.manifest=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Manifest=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.man=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Man=)

#
# Always make .man file in the obj directory.
#
SXS_MANIFEST_OBJ1=$(OBJ_PATH)\$O\$(SXS_MANIFEST_BASENAME).o_manifest

#
# If TARGETPDB is defined, we'll use the linker's default PDB name.
# if SXS_AUTO_VERSION is on, derive the PDB name from ntverp.h & sxsmanifest.h
# by preprocessing a .lnk file to provide the right /pdb flag to LINKER
#
!if defined(SXS_AUTO_VERSION) && !defined(TARGETPDB) && "$(SXS_USE_LONG_PDB_NAME)" == "1" && !defined(RESOURCE_ONLY_DLL)
SXS_PDB_NAMER=$(OBJ_PATH)\$O\$(SXS_MANIFEST_BASENAME)_pdb.lnk
!endif

!ifndef SXS_MANIFEST_IN_RESOURCES # {

#
# OBJ is files in obj\i386.
# BIN is binplaced files, possibly also in obj\i386.
#
# The binplaced file must be 8.3 in XP.
# The obj\i386 file
#  - should allow .exes to be run from obj\i386 that don't have manifest-in-resources
#  - not override manifest-in-resources
#
SXS_MANIFEST_BIN_FILENAME=$(SXS_MANIFEST_BASENAME).man

!if !defined(NO_BINPLACE) && !defined(SXS_NO_BINPLACE) && ("$(BUILD_PASS)" == "PASS1" || "$(BUILD_PASS)" == "PASSALL")
SXS_MISCFILES=$(SXS_MISCFILES) $(OBJ_PATH)\$O\$(SXS_MANIFEST_BASENAME).man
!endif

# Make a .manifest file identical to the .man file (we just copy it).
!if "$(TARGETTYPE)" != "NOTARGET" && ("$(MAKEDLL)" != "" || "$(BUILD_PASS)" == "PASS2")

SXS_MANIFEST_OBJ2=$(OBJ_PATH)\$O\$(TARGETNAME).$(TARGETEXT).manifest

!endif

!else # } SXS_MANIFEST_IN_RESOURCES { #

SXS_MANIFEST_BIN_FILENAME=$(TARGETNAME).$(TARGETEXT)

!ifndef SXS_MANIFEST_RESOURCE_ID # {
!if defined(ISOLATION_AWARE_ENABLED) || "$(TARGETTYPE)" == "DYNLINK"
SXS_MANIFEST_RESOURCE_ID=ISOLATIONAWARE_MANIFEST_RESOURCE_ID
!elseif "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "PROGLIB" || "$(TARGETTYPE)" == "UMAPPL_NOLIB"
SXS_MANIFEST_RESOURCE_ID=CREATEPROCESS_MANIFEST_RESOURCE_ID
!endif
!endif # }

# Enforce icon sizes and bit depths by turning on "audit" mode
# Only x86 for now because icocomp, which fixes audit violations, is only checked in for x86
!ifndef NO_RC_AUDIT
!if $(386)
RCOPTIONS=/a $(RCOPTIONS)
!endif
!endif

#
# Putting manifests in resources requires no editing of the .rc file.
# We can do this via forceinclude-file or forceinclude-string.
# I thought rc.exe had a forceinclude-file feature like the C++ compiler.
# By the time I realized that it doesn't, it seemed better to press ahead
# with simulating it than not depend on it. There is unlikely any other way
# to support SXS_MANIFEST_IN_RESOURCES without requiring "nonlocal" .rc file
# edits (ie: without further fanning out how many files need to touched in how
# many places by clients who want to build sxs assemblies).
#
RCOPTIONS=-DSXS_MANIFEST_OBJ1="\"$(SXS_MANIFEST_OBJ1:\=/)\"" $(RCOPTIONS)
INCPATHRC=$(INCPATHRC)
RC_FORCE_INCLUDE_STRING=$(RC_FORCE_INCLUDE_STRING)^
^#include "windows.h"^
^/* RT_MANIFEST is in winuser.h and winuser.rh */^
$(SXS_MANIFEST_RESOURCE_ID) RT_MANIFEST SXS_MANIFEST_OBJ1
#RC_FORCE_INCLUDE_FILES=$(RC_FORCE_INCLUDE_FILES);$(BASE_INC_PATH)\SxsManifestInResource.rc2
#RC_FORCE_INCLUDE_STRING=

!endif # } SXS_MANIFEST_IN_RESOURCES

!ifdef SXS_LOG_PASS # {
#
# data for PostBuild/ManifestMangler
#

SXS_BINPLACE_LOG=$(BINPLACE_LOG)-sxs

!ifndef APPEND_CMD
APPEND_CMD=$(APPEND_TOOL) -file $(SXS_BINPLACE_LOG) -
!endif
_RUN_SXS_LOG_CMD=1
SXS_LOG_CMD= ( $(SXS_LOG_CMD) ) &                                          \
        ( echo                                                             \
        SXS_ASSEMBLY_NAME="$(SXS_ASSEMBLY_NAME)"                           \
        SXS_ASSEMBLY_VERSION="$(SXS_ASSEMBLY_FULL_VERSION)"                \
        SXS_ASSEMBLY_LANGUAGE="$(SXS_ASSEMBLY_LANGUAGE)"                   \
        SXS_MANIFEST="$(SXS_LOG_BINPLACE_WOW6432_PREFIX)$(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BIN_FILENAME)"  \
!ifdef SXS_LOCALIZE_ASSEMBLY_MUI
        SXS_LOCALIZE_ASSEMBLY_MUI=$(SXS_LOCALIZE_ASSEMBLY_MUI) \
!endif
!ifdef SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY
        SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY=$(SXS_LOCALIZE_ASSEMBLY_SATELLITE_WITH_EXPLICIT_DEPENDENCY) \
!endif
        | $(APPEND_TOOL) -file $(BUILD_LOGS)\sidebyside\binplace_$(COMPUTERNAME).log-sxs - )


#
# Produce manifest-related, including
#       Required: catalog,
#       Optional: merge module
#
!ifndef SXS_NO_BINPLACE # {

!ifdef SXS_GENERATE_MERGE_MODULE   # { begin create log-file-entry for Assembly MergeModule

#
# the msm-log lsitfile is in the format of
#   SourceFileDirectory | Destination-MSM-Filename | MergeModuleID | MergeModuleComponent ID
#
!ifndef SXS_MERGE_MODULE_TXT_DATA   #{
SXS_MERGE_MODULE_TXT_DATA=\
 $(SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP),\
 $(SXS_MERGE_MODULE_GUID),\
 ..\$(SXS_MERGE_MODULE_LOCATION)\$(SXS_MERGE_MODULE),\
 ..\$(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BASENAME).man,\
 $(SXS_MERGE_MODULE_COMPONENT_GUID)

!endif # }

!endif # } end create log-file-entry for Assembly MergeModule

!endif # SXS_NO_BINPLACE }

!endif # SXS_LOG_PASS }

!endif # SXS_MANIFEST }

!if defined(SXS_LOG_PASS) && defined(SXS_MERGE_MODULE_TXT_DATA) # {
SXS_MERGEMODULE_LIST_TXT=$(BUILD_LOGS)\sxsMsmList_$(COMPUTERNAME).txt
!if defined(SXS_MERGE_MODULE_TXT_DATA)
_RUN_SXS_LOG_CMD=1
SXS_LOG_CMD=( $(SXS_LOG_CMD) ) & ( echo $(SXS_MERGE_MODULE_TXT_DATA) | $(APPEND_TOOL) -file $(SXS_MERGEMODULE_LIST_TXT) - )
!endif

!endif # }

!endif # PASS_INDEPENDENT_TARGETS

#
# Do this independently of the presence of any other SXS options
# to aid .manifest preprocessing in the absense of any other sxs build support,
# like for users of CreateActCtx. The MultiRes test case uses this.
#
!ifndef SXS_PROCESSOR_ARCHITECTURE
!ifdef SXS_WOW6432
SXS_PROCESSOR_ARCHITECTURE=wow64
!elseif defined(_BUILDARCH)
SXS_PROCESSOR_ARCHITECTURE=$(_BUILDARCH)
!elseif $(386)
SXS_PROCESSOR_ARCHITECTURE=x86
!elseif $(IA64)
SXS_PROCESSOR_ARCHITECTURE=ia64
!else
! error Cannot determine processorArchitecture.
!endif
!endif

!ifndef PASS_INDEPENDENT_TARGETS

!if defined(LOCALIZED_RESOURCES) && !defined(RCCODEPAGE)
! if "$(LANGUAGE)" == "JPN" || "$(LANGUAGE)" == "jpn"
RCCODEPAGE=932
! elseif "$(LANGUAGE)" == "KOR" || "$(LANGUAGE)" == "kor"
RCCODEPAGE=949
! elseif "$(LANGUAGE)" == "CHS" || "$(LANGUAGE)" == "chs"
RCCODEPAGE=936
! elseif "$(LANGUAGE)" == "CHP" || "$(LANGUAGE)" == "chp"
RCCODEPAGE=936
! elseif "$(LANGUAGE)" == "CHT" || "$(LANGUAGE)" == "cht"
RCCODEPAGE=950
! endif
!endif

#
# Set far east specific defines based on the project
#
DO_FE_SB=0

!endif # PASS_INDEPENDENT_TARGETS

!if "$(ALT_PROJECT_TARGET)" == ""
ALT_PROJECT_TARGET=.
!endif

!if 1 # PASS_INDEPENDENT_TARGETS

!if "$(ALT_PROJECT)" == "FE"  || \
    "$(ALT_PROJECT)" == "CHT" || \
    "$(ALT_PROJECT)" == "CHS" || \
    "$(ALT_PROJECT)" == "CHP" || \
    "$(ALT_PROJECT)" == "JPN" || \
    "$(ALT_PROJECT)" == "KOR" || \
    "$(ALT_PROJECT)" == "NEC_98"
C_DEFINES=$(C_DEFINES) /DDBCS /DKKBUGFIX
ASM_DEFINES=$(ASM_DEFINES) /DDBCS /DKKBUGFIX
DO_FE_SB=1
!endif

!if "$(ALT_PROJECT)" == "CHT"
C_DEFINES=$(C_DEFINES) /DTAIWAN
ASM_DEFINES=$(ASM_DEFINES) /DTAIWAN
!elseif "$(ALT_PROJECT)" == "CHS" || "$(ALT_PROJECT)" == "CHP"
C_DEFINES=$(C_DEFINES) /DPRC
ASM_DEFINES=$(ASM_DEFINES) /DPRC
!elseif "$(ALT_PROJECT)" == "JPN"
C_DEFINES=$(C_DEFINES) /DJAPAN
ASM_DEFINES=$(ASM_DEFINES) /DJAPAN
!elseif "$(ALT_PROJECT)" == "KOR"
C_DEFINES=$(C_DEFINES) /DKOREA
ASM_DEFINES=$(ASM_DEFINES) /DKOREA
!elseif "$(ALT_PROJECT)" == "NEC_98"
C_DEFINES=$(C_DEFINES) /DJAPAN /DNEC_98
ASM_DEFINES=$(ASM_DEFINES) /DJAPAN /DNEC_98
!elseif "$(ALT_PROJECT)" != ""
C_DEFINES=$(C_DEFINES) /D_$(ALT_PROJECT)_
!endif

!IF "$(ALT_PROJECT)" == "HYDRA"
ASM_DEFINES=$(ASM_DEFINES) /D_HYDRA_
HYDRA=1
!ENDIF

!IF "$(ALT_PROJECT)" == "JANUS"
ASM_DEFINES=$(ASM_DEFINES) /D_JANUS_
C_DEFINES=$(C_DEFINES) /D_JANUS_
JANUS=1
!ENDIF

!IF ("$(NO_W32_SB)" == "" && "$(W32_SB)" == "1")
DO_FE_SB=1
! ENDIF

!IF "$(DO_FE_SB)" == "1"
C_DEFINES=$(C_DEFINES) /DFE_SB /DFE_IME
ASM_DEFINES=$(ASM_DEFINES) /DFE_SB
!ENDIF

!IF "$(ALT_PROJECT)" == "DS"
# Nothing, just /D_DS_ from above
!ENDIF

!ifdef RESOURCE_ONLY_DLL
# Resource only DLL's have no exports, no entrypoint, no code, no data, no debug symbolic.
LINKER_FORCE_NO_DBG_SECTION=1
NO_DLL_EXPORTS=1
!undef DLLENTRY
!undef NOLINK
!undef USE_MSVCRT
!undef USE_LIBCMT
!undef USE_LIBCNTPR
NO_BROWSER_FILE=1
LINK_NO_RELEASE=1
MAKEDLL=1
TARGETLIBS=
LINKLIBS=
DLLDEF_OBJECTS=
USE_NOLIBS=1
NO_NTDLL=1
AFX_FORCE_STDAFX=
AFX_FORCE_USRDLL=
MFC_LIBS=
! ifndef SUBSYSTEM_VERSION
SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSION_LATEST)
! endif
!else
! ifdef USE_INCREMENTAL_LINKING
LINKER_DBG_SECTION=/debug /debugtype:cv,pdata
! else
LINKER_DBG_SECTION=/debug /debugtype:cv,fixup,pdata
! endif
AFX_FORCE_STDAFX=/include:__afxForceSTDAFX
AFX_FORCE_USRDLL=/include:__afxForceUSRDLL
!endif

!ifdef LINKER_FORCE_NO_DBG_SECTION
LINKER_DBG_SECTION=/debug:NONE
!endif

!ifdef PURE_FORWARDER_DLL
BUFFER_OVERFLOW_CHECKS=0
USE_NOLIBS=1
NO_NTDLL=1
TARGETLIBS=
! ifndef SUBSYSTEM_VERSION
SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSION_LATEST)
! endif
!endif

# File System drivers have different deprecation rules from regular drivers
!if defined(DEPRECATE_DDK_FUNCTIONS) && ("$(DRIVERTYPE)" != "FS") && ("$(DRIVERTYPE)" != "fs")
C_DEFINES=$(C_DEFINES) /DDEPRECATE_DDK_FUNCTIONS=1
!endif

!if defined(TARGETPATHLIB)
! if ("$(TARGETTYPE)" == "DYNLINK") || ("$(TARGETTYPE)" == "EXPORT_DRIVER")
!  if "$(MAKEDLL)" == ""
# Pass 1 of a two pass build.  Make sure TargetPath is the same as targetpathlib.
NO_BROWSER_FILE=1
TARGETPATH=$(TARGETPATHLIB)
!  endif
! endif
!else
TARGETPATHLIB=$(TARGETPATH)
!endif

!if ("$(TARGETPATH)" == "$(BASEDIR)\lib") || ("$(TARGETPATH)" == "$(BASEDIR)\LIB")
!  error Setting TARGETPATH=$(BASEDIR)\lib in sources is not valid -- please remove TARGETPATH.
!endif

!if !defined(TARGETTYPE)
!  error Your .\sources file must define the TARGETTYPE macro.
!endif

!if "$(TARGETTYPE)" != "NOTARGET" # { {

!  if !defined(TARGETNAME) # { {
!    error Your sources. file must define the TARGETNAME macro.
!  endif # } }

!  if !defined(SOURCES) && !defined(PASS_INDEPENDENT_TARGETS) # { {
!    error Your sources. file must define the SOURCES macro.
!  endif # } }

!else # } { TARGETTYPE == NOTARGET

!  if defined(SOURCES) && "$(SOURCES: =)" == "" # { {
#!    error $(MAKEDIR) Remove empty SOURCES macro.
!  endif # } }

!  if defined(TARGETNAME) && "$(TARGETNAME: =)" == "" # { {
#!    error $(MAKEDIR) Remove empty TARGETNAME macro.
!  endif # } }

!  if !defined(TARGETNAME) # { {
TARGETNAME=
!  endif # } }

!endif # } } TARGETTYPE == NOTARGET

#!if defined(SOURCES) && "$(SOURCES: =)" == "" && "$(TARGETTYPE)" == "NOTARGET"
#! error $(MAKEDIR) Remove empty SOURCES macro.
#!endif

!if defined(MC_FLAGS)
! if   "$(MC_FLAGS:-z=)" != "$(MC_FLAGS)" \
    || "$(MC_FLAGS:/z=)" != "$(MC_FLAGS)" \
    || "$(MC_FLAGS:/Z=)" != "$(MC_FLAGS)" \
    || "$(MC_FLAGS:-Z=)" != "$(MC_FLAGS)"
!  error MC_FLAGS must not contain /z.
! endif
!endif

!if defined(FORCENATIVEOBJECT)
!  if "$(FORCENATIVEOBJECT)" != "1"
!    error FORCENATIVEOBJECT must be 1 or not defined.
!  endif
!endif

!if defined(TEST_CODE)
!  if "$(TEST_CODE)" != "1"
!    error TEST_CODE must be 1 or not defined.
!  endif
!endif

!if "$(MSC_OPTIMIZATION)" != "$(MSC_OPTIMIZATION:Od=)"
# FORCENATIVEOBJECT=1
# Define MSC_NOOPT if optimizations are disabled.
C_DEFINES=$(C_DEFINES) /DMSC_NOOPT
!endif

!ifndef COFFBASE_TXT_FILE
COFFBASE_TXT_FILE = $(NTMAKEENV)\coffbase.txt
!endif

!IFNDEF UMBASE
! IFDEF COFFBASE
UMBASE=@$(COFFBASE_TXT_FILE),$(COFFBASE)
! ELSE
!  if $(WIN64)
!    if $(AMD64)
UMBASE=@$(COFFBASE_TXT_FILE),usermode64
!    else
#     Enable this for IA64 too
UMBASE=@$(COFFBASE_TXT_FILE),usermode
!    endif
!  else
UMBASE=@$(COFFBASE_TXT_FILE),usermode
!  endif
! ENDIF
!ENDIF

LINKLIBS=$(LINKLIBS) $(PERFLIBS)

!if !defined(ATL_VER)
ATL_VER=71
!endif

!if ("$(ATL_VER)" == "70" || "$(ATL_VER)" == "71" || "$(ATL_VER)" == "80") && \
    (defined(USE_ATL) || defined(USE_STATIC_ATL))

ATL_INCLUDES=$(ATL_INC_ROOT)\atl71

ATL_DEFINES=/D_ATL_STATIC_REGISTRY
! ifdef DEBUG_CRTS
ATL_STATIC_LIBS=$(ATL_LIB_PATH)\atlsd.lib
ATL_LIBS=
! else
ATL_STATIC_LIBS=$(ATL_LIB_PATH)\atls.lib
ATL_LIBS=
! endif
ATL_LIBS=$(ATL_LIBS) $(ADDITIONAL_ATL_LIBS)
! if !defined(BUFFER_OVERFLOW_CHECKS)
BUFFER_OVERFLOW_CHECKS=1
! endif
!else
! ifdef USE_ATL
ATL_INCLUDES=$(ATL_INC_ROOT)\atl$(ATL_VER)
ATL_DEFINES=/D_ATL_DLL
ATL_LIBS=$(ATL_LIB_PATH)\atl.lib $(ADDITIONAL_ATL_LIBS)
! elseif defined(USE_STATIC_ATL)
ATL_INCLUDES=$(ATL_INC_ROOT)\atl$(ATL_VER)
ATL_LIBS=$(ADDITIONAL_ATL_LIBS)
ATL_DEFINES=/D_ATL_STATIC_REGISTRY
! endif
!endif

!ifdef USE_WTL
!ifdef WTL_INC_PATH
WTL_INCLUDES=$(WTL_INC_PATH)\wtl
!else
WTL_INCLUDES=$(SDK_INC_PATH)\wtl
!endif
!endif

!ifdef USE_TEST_LOGGING
INCLUDES=$(INCLUDES);$(SDKTOOLS_INC_PATH)
TARGETLIBS=$(SDKTOOLS_LIB_PATH)\wttlog.lib $(TARGETLIBS)
!endif

!if defined(USE_MSVCRT20)
! error $(MAKEDIR): USE_MSVCRT20 does nothing. Remove it or change to USE_MSVCRT=1
!endif

!if defined(USE_MSVCRT40)
! error $(MAKEDIR): USE_MSVCRT40 does nothing. Remove it or change to USE_MSVCRT=1
!endif

!if defined(USE_CRTDLL)
! error $(MAKEDIR): USE_CRTDLL does nothing. Remove it or change to USE_MSVCRT=1
!endif

!if defined(CRTDLL)
! error $(MAKEDIR): CRTDLL does nothing. Remove it or change to USE_MSVCRT=1
!endif

!if defined(USE_IERT)
! error USE_IERT is not supported.
!endif

!IF DEFINED(USE_MFC) || DEFINED(USE_MFCUNICODE)

!if "$(PLATFORM_MFC_VER)" != "0x0600"
# MFC versions before 6.0 need NT4/Win95 values. Override at your own risk.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0400
!endif
!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0300
!endif
!else   # MFC post 6x defaults to the current version of IE/Win2k.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=$(CURRENT_WIN32_WINNT_VERSION)
!endif
!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=$(CURRENT_WIN32_IE_VERSION)
!endif
!endif

!ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=$(LATEST_WIN32_WIN95_VERSION)
!endif

!ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=$(LATEST_WIN32_WCE_VERSION)
!endif

#---------------------------------------------------------#
# this set of defines establishes the "correct" build     #
# environment for an app that needs to use MFC.  the      #
# app's sources file only needs to specify USE_MFC=1      #
# and this makefile will set the enviroment up correctly. #
#---------------------------------------------------------#

! ifndef UMENTRY
!  ifdef USE_MFCUNICODE
UMENTRY=wwinmain
!  else
UMENTRY=winmain
!  endif
! endif

! if "$(TARGETTYPE)" == "DYNLINK" && !defined(RESOURCE_ONLY_DLL)
!  ifndef DLLENTRY
DLLENTRY=_DllMainCRTStartup
!  endif
! endif

! ifndef UMTYPE
UMTYPE=windows
! endif

UMENTRYABS=

# Allow other MFC's.
#  To do so, you need to:
#    1. Define MFC_INCLUDES to point to your MFC headers.
#    2. Define MFC_LIBS to point to your MFC libraries (specifically, the dll
#       library)
#    3. Define USE_MSVCRT=1 if you don't want to link with the NT CRT DLL.
#
#  Note:
#     There is only one type of build (_AFXDLL or MFC in a DLL linking to the
#     CRT in a dll).
#     You should disable the alternate MFC's if compiling for RISC platforms.
#     You need to handle specifying the correct libs for Check/Free and
#     Ansi/Unicode.

! if !defined(USE_MSVCRT) && !defined(USE_NOLIBS)
!  ifdef USE_STATIC_MFC
USE_LIBCMT=1
!  else
USE_MSVCRT=1
!  endif
! endif

# Add MFC_FLAGS in just in case there's old sources files that use it.

MFC_DEFINES=$(MFC_DEFINES) $(MFC_FLAGS) /D_AFX_NOFORCE_LIBS /D_MFC_VER=$(PLATFORM_MFC_VER)

! ifdef DEBUG_CRTS
MFC_DEFINES=$(MFC_DEFINES) /D_AFX_ENABLE_INLINES
! endif

! IFDEF USE_MFCUNICODE
MFC_DEFINES=$(MFC_DEFINES) /DUNICODE /D_UNICODE
! ENDIF

# Assume Latest MFC (4.0 for now)

! ifndef USE_STATIC_MFC
MFC_DEFINES=$(MFC_DEFINES) /D_AFXDLL
LINKER_FLAGS = $(LINKER_FLAGS) $(AFX_FORCE_STDAFX)
! endif
! ifdef MFC_USRDLL
MFC_DEFINES=$(MFC_DEFINES) /D_USRDLL
LINKER_FLAGS = $(LINKER_FLAGS) $(AFX_FORCE_USRDLL)
! endif

# MFC 4 uses Native EH only

!ifndef USE_NATIVE_EH
USE_NATIVE_EH=1
!endif
USE_RTTI=1

# UNICODE must use the UNICODE entrypoint

! ifdef USE_MFCUNICODE
!  if "$(UMENTRY)" == "winmain"
UMENTRY = wwinmain
!  else if "$(UMENTRY)" == "main"
UMENTRY = wmain
!  endif
! endif

! ifndef MFC_VER
MFC_VER=42
! else if "$(MFC_VER)" == "40" && !defined(USE_STATIC_MFC)
!error $(MAKEDIR) MFC_VER=40 is not supported.
! endif

!ifndef MFC_INC_PATH
MFC_INC_PATH=$(MFC_INC_ROOT)\mfc$(MFC_VER)
!endif

! ifndef MFC_DAO_INC
MFC_DAO_INC=$(MFC_INC_ROOT)\dao350
! endif

! ifndef MFC_INCLUDES
MFC_INCLUDES=$(MFC_INC_PATH);$(MFC_DAO_INC)
!  ifdef MFC_LANGUAGE
MFC_INCLUDES=$(MFC_INC_PATH)\l.$(MFC_LANGUAGE);$(MFC_INCLUDES)
!  endif
! endif

! ifndef MFC_LIBS
!  ifdef USE_STATIC_MFC

!   ifdef DEBUG_CRTS
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\uafxcwd.lib
!    else
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\nafxcwd.lib
!    endif
!   else
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\uafxcw.lib
!    else
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\nafxcw.lib
!    endif
!   endif

!  else                # USE_STATIC_MFC

!   ifdef DEBUG_CRTS
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)ud.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)ud.lib  \
         $(MFC_LIB_PATH)\mfcd$(MFC_VER)ud.lib \
         $(MFC_LIB_PATH)\mfcn$(MFC_VER)ud.lib \
         $(MFC_LIB_PATH)\mfco$(MFC_VER)ud.lib
!    else
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)d.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)d.lib  \
         $(MFC_LIB_PATH)\mfcd$(MFC_VER)d.lib \
         $(MFC_LIB_PATH)\mfcn$(MFC_VER)d.lib \
         $(MFC_LIB_PATH)\mfco$(MFC_VER)d.lib
!    endif
!   else
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)u.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)u.lib
!    else
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER).lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER).lib
!    endif
!   endif
MFC_LIBS=$(MFC_STATIC_LIB) $(MFC_LIBS)
# SUBSYSTEM_VERSIONX isn't available yet.
# Communicate to when it is available that MFC_LIBS comes
# from makefile.def and is not user-specified.
_PROVIDE_MFC_LIBS=1
!  endif               # USE_STATIC_MFC
! endif                # MFC_LIBS
!endif                 # USE_MFC

!IFNDEF UMTYPE
!if "$(TARGETTYPE)" == "DYNLINK" || \
    "$(TARGETTYPE)" == "LIBRARY" || \
    "$(TARGETTYPE)" == "USER_ASSISTANCE" || \
    "$(TARGETTYPE)" == "NOTARGET"
UMTYPE=console
!elseif (defined(_C_SHARP) || defined(_VB) || defined(_TLBIMP)) && "$(TARGETTYPE)" == "PROGRAM"
UMTYPE=windows
!else
UMTYPE=nt
!endif
!ENDIF

!ifdef USE_MFC30
! error USE_MFC30 is not supported.
!else
! ifdef DEBUG_CRTS
DCRT=d
LIBC_DEFINES = /D_DEBUG /D_SYSCRT_DEBUG
! else
!  if $(FREEBUILD)
DCRT=
LIBC_DEFINES = /DNDEBUG
!  else
DCRT=
LIBC_DEFINES =
!  endif
! endif
!endif

!if defined(_USE_LIBCMMT)
C_DEFINES=$(C_DEFINES) /D_STATIC_MGDLIB
!endif

!if defined(USE_NTDLL)
! if defined(USE_LIBCMT)
!error USE_NTDLL defined with USE_LIBCMT
! elseif defined(USE_MSVCRT)
!error USE_NTDLL defined with USE_MSVCRT
! elseif defined(USE_LIBCNTPR)
!error USE_NTDLL defined with USE_LIBCNTPR
! endif
!endif

!if defined(USE_MSVCRT)
! if "$(UMTYPE)" == "nt" || "$(UMTYPE)" == "ntss"
! error USE_MSVCRT not compatible with UMTYPE=nt or ntss
! endif

!  ifdef MANAGED_CXX
!   if "$(MCPP_TYPE)" == "safe"
!   elseif "$(MCPP_TYPE)" == "pure"
!    ifdef USE_PTRUST
LIBC_LIB=$(CRT_LIB_PATH)\ptrustu.lib
!    endif
FORCENATIVEOBJECT=1
NO_NTDLL=1
!   else
!    if "$(URT_VER)" >= "2.0"
LIBC_LIB=$(CRT_LIB_PATH)\msvcrt$(DCRT).lib
!     if !defined(USE_NOUUIDLIB)
LIBC_LIB=$(LIBC_LIB) $(SDK_LIB_PATH)\uuid.lib
!     endif
!    else
LIBC_LIB=$(CRT_LIB_PATH)\msvcrt$(DCRT).lib
!    endif
!   endif
!   if !defined(DLLENTRY) && "$(URT_VER)" >= "2.0" && "$(TARGETTYPE)" == "DYNLINK"
DLLENTRY=_DllMainCRTStartup
!   endif

LIBC_LIB=\
    $(LIBC_LIB) \
    $(SDK_LIB_PATH)\mscoree.lib \
    $(SDK_LIB_PATH)\ole32.lib

!  else
!   if !defined(USE_NOCRTLIBS)
LIBC_LIB=$(CRT_LIB_PATH)\msvcrt$(DCRT).lib
!   endif
!  endif

!  ifdef USE_IOSTREAM
LIBC_LIB=$(LIBC_LIB) $(CRT_LIB_PATH)\msvcirt$(DCRT).lib
!  endif
!  ifdef USE_STL
!   if "$(STL_VER)" == "70"
!    if (!defined(_USE_LIBCMMT) && !defined(MCPP_TYPE)) || "$(URT_VER)" == "1.1"
LIBC_LIB=$(SDK_LIB_PATH)\ntstc_msvcrt.lib $(LIBC_LIB)
!    endif
LIBC_DEFINES=$(LIBC_DEFINES) /D_STATIC_CPPLIB /D_STL70_
!   else
!    if !defined(MCPP_TYPE)
LIBC_LIB=$(CRT_LIB_PATH)\msvcprt$(DCRT).lib $(LIBC_LIB)
!    endif
!   endif
!  endif
LIBC_DEFINES=$(LIBC_DEFINES) /D_DLL=1 /D_MT=1

!elseif defined(USE_LIBCMT)

LIBC_LIB=$(CRT_LIB_PATH)\libcmt$(DCRT).lib
! ifdef MANAGED_CXX
LIBC_LIB=$(LIBC_LIB) $(SDK_LIB_PATH)\mscoree.lib
! endif
! ifdef USE_IOSTREAM
LIBC_LIB=$(CRT_LIB_PATH)\libcimt$(DCRT).lib $(LIBC_LIB)
! endif
! ifdef USE_STL
!  if "$(STL_VER)" == "70"
!    if !defined(_USE_LIBCMMT) || "$(URT_VER)" == "1.1"
LIBC_LIB=$(SDK_LIB_PATH)\ntstc_libcmt.lib $(LIBC_LIB)
!    endif
LIBC_DEFINES=$(LIBC_DEFINES) /D_STATIC_CPPLIB /D_STL70_
!  else
!    if !defined(_USE_LIBCMMT)
LIBC_LIB=$(CRT_LIB_PATH)\libcpmt$(DCRT).lib $(LIBC_LIB)
!    endif
!  endif
! endif
LIBC_DEFINES=$(LIBC_DEFINES) /D_MT=1

!elseif defined(USE_LIBCNTPR)

LIBC_LIB=$(SDK_LIB_PATH)\libcntpr.lib
LIBC_LIB=$(CRT_LIB_PATH)\safecrtnt.lib $(LIBC_LIB)
CRT_BUILD_FLAGS=/MT /U_MT

!elseif (defined(USE_NTDLL) || \
       "$(TARGETTYPE)" == "DRIVER" || \
       "$(TARGETTYPE)" == "EXPORT_DRIVER")

LIBC_DEFINES=$(LIBC_DEFINES) /D_DLL=1 /DNDEBUG
LIBC_LIB=

!elseif defined(USE_NOLIBS) || \
       "$(TARGETTYPE)" == "HAL" || \
       "$(TARGETTYPE)" == "GDI_DRIVER"

LIBC_DEFINES=$(LIBC_DEFINES) /DNDEBUG
NO_NTDLL=1

!else
LIBC_LIB=
CRT_BUILD_FLAGS=/MT /U_MT
! ifdef USE_STL
!   error "single thread CRT with STL not supported - add USE_LIBCMT=1 or USE_MSVCRT=1"
! endif
! ifdef USE_IOSTREAM
!   error "single thread CRT with IOSTREAM not supported - add USE_LIBCMT=1 or USE_MSVCRT=1"
! endif

!endif

!ifdef USE_SAFECRTNT
LIBC_LIB =  $(CRT_LIB_PATH)\safecrtnt.lib $(LIBC_LIB)
!endif

!ifdef USE_VCCOM
LIBC_LIB = $(SDK_LIB_PATH)\vccomsup.lib $(LIBC_LIB)
!endif

!ifdef _USE_LIBCMMT
!  if "$(MCPP_TYPE)" == "pure"
LIBC_LIB=$(CRT_LIB_PATH)\libcummt$(DCRT).lib $(LIBC_LIB)
!  elseif !defined(MCPP_TYPE)
!    if "$(URT_VER)" != "1.1"
LIBC_LIB=$(CRT_LIB_PATH)\libcmmt$(DCRT).lib $(LIBC_LIB)
!    endif
!  endif
!endif

!if defined(USE_MSVCRT) \
    && !defined(USE_LIBCMT) \
    && defined(MANAGED_CXX) \
    && "$(URT_VER)" == "1.1"
LIBC_LIB=$(CRT_LIB_PATH)\libcmmt11.lib $(LIBC_LIB)
!endif

!IFNDEF GPSIZE
GPSIZE= 0
!ENDIF

LIBRARY_PATH=$(SDK_LIB_PATH)

!if defined(USE_MFC) ||  defined(USE_MFCUNICODE)
LIBC_LIB = $(MFC_LIBS) $(LIBC_LIB)
!endif

!if defined(USE_ATL) || defined(USE_STATIC_ATL)
LIBC_LIB = $(ATL_STATIC_LIBS) $(LIBC_LIB) $(ATL_LIBS)
# Piggy back on MFC_DEFINES for now.
MFC_DEFINES = $(MFC_DEFINES) $(ATL_DEFINES)
!endif

!if $(386) && defined(USE_MSLU)
# MSLU goes after MFC/ATL/CRT but before everything else
LIBC_LIB = $(LIBC_LIB) $(SDK_LIB_PATH)\unicows.lib
!endif

!if $(LIB_WLH)
!  if $(_NT_TARGET_VERSION) >= $(_NT_TARGET_VERSION_WIN7)
NTDLL_CRT=$(SDK_LIB_PATH)\ntdllp.lib
!  else
NTDLL_CRT=$(CRT_LIB_PATH)\safecrtnt.lib $(SDK_LIB_PATH)\ntdllp.lib
!  endif
!else
NTDLL_CRT=$(CRT_LIB_PATH)\safecrtnt.lib $(SDK_LIB_PATH)\ntdll.lib
!endif

NT_LIBS=$(NTDLL_CRT) $(MINWIN_SDK_LIB_PATH)\nt.lib

!IF "$(BUILD_MINWIN)" == "1"
GUI32_LIBS=
!ELSE
GUI32_LIBS=$(SDK_LIB_PATH)\gdi32.lib \
           $(SDK_LIB_PATH)\user32.lib

WIN32_LIBS=$(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\kernel32.lib
!ENDIF

!IF "$(USE_DEFAULT_WIN32_LIBS)" == "1" || "$(USE_DEFAULT_WIN32_LIBS)" == ""
# Allow the default setting determined above to be used
!ELSEIF "$(USE_DEFAULT_WIN32_LIBS)" == "0"
WIN32_LIBS=
!ELSE
!ERROR USE_DEFAULT_WIN32_LIBS must be either 1 or 0
!ENDIF

!IF "$(USE_DEFAULT_GUI32_LIBS)" == "1" || "$(USE_DEFAULT_GUI32_LIBS)" == ""
# Allow the default setting determined above to be used
!ELSEIF "$(USE_DEFAULT_GUI32_LIBS)" == "0"
GUI32_LIBS=
!ELSE
!ERROR USE_DEFAULT_GUI32_LIBS must be either 1 or 0
!ENDIF

NTSS_LIBS=$(NT_LIBS) $(BASE_LIB_PATH)\smdll.lib

!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
# Building a WDM driver.  Default the subsystem version to the DDK version # (currently 1.0)
! ifndef SUBSYSTEM_VERSION
SUBSYSTEM_VERSION=1.10
! endif
!endif

!ifndef SUBSYSTEM_VERSION
SUBSYSTEM_WINVER   =$(SUBSYSTEM_VERSION_LATEST)
SUBSYSTEM_CONVER   =$(SUBSYSTEM_VERSION_LATEST)
SUBSYSTEM_NATVER   =$(SUBSYSTEM_VERSION_LATEST)
!else
SUBSYSTEM_WINVER   =$(SUBSYSTEM_VERSION)
SUBSYSTEM_CONVER   =$(SUBSYSTEM_VERSION)
SUBSYSTEM_NATVER   =$(SUBSYSTEM_VERSION)
!endif

#
# Set NTDDI_VERSION
#

!if "$(NTDDI_VERSION)" == ""

# Default
C_DEFINES=$(C_DEFINES) /DNTDDI_VERSION=$(CURRENT_NTDDI_VERSION)
!else

# User specified
C_DEFINES=$(C_DEFINES) /DNTDDI_VERSION=$(NTDDI_VERSION)
!endif

!if "$(TARGETTYPE)" == "DYNLINK" || \
    "$(TARGETTYPE)" == "LIBRARY" || \
    "$(TARGETTYPE)" == "PROGRAM" || \
    "$(TARGETTYPE)" == "PROGLIB"
!  if "$(_NT_TARGET_VERSION)" < "$(_NT_TARGET_VERSION_WIN7)" || \
      ("$(SUBSYSTEM_VERSION)" != "" && \
       "$(SUBSYSTEM_VERSION)" < "$(SUBSYSTEM_601)")
!    ifndef PRECOMPILED_INCLUDE
# downlevel psapi uses version 1 of the psapi header
C_DEFINES=$(C_DEFINES) /DPSAPI_VERSION=1
!    endif
!  endif
!endif

CRT_INCLUDES=$(CRT_INC_PATH)
!ifdef USE_IOSTREAM
CRT_INCLUDES=$(CRT_INCLUDES);$(IOSTREAMS_INC_PATH)
!endif
!ifdef USE_STL
! if "$(STL_VER)" == "70"
CRT_INCLUDES=$(CRT_INCLUDES);$(STL7_INC_PATH)
! else
CRT_INCLUDES=$(CRT_INCLUDES);$(STL6_INC_PATH)
! endif
!endif

!IF "$(UMTYPE)" == "nt"

SUBSYSTEM_VERSIONX=$(SUBSYSTEM_NATVER)
SUBSYSTEM=native,$(SUBSYSTEM_NATVER)
UMINCL=$(CRT_INCLUDES)

#
#  Setup the program entry and libs if its native
#

!if !defined(NO_NATIVE_LIBS)

STD_CALL_ENTRY=1

! IF "$(UMENTRY)" == "wmain"
UMENTRY=/entry:NtProcessStartupW
! ELSE
UMENTRY=/entry:NtProcessStartup
! ENDIF

UMLIBS=$(UMLIBS) $(NT_LIBS)
!endif

NOT_TERMINAL_SERVER_AWARE=1

!ELSEIF "$(UMTYPE)" == "windows"

SUBSYSTEM_VERSIONX=$(SUBSYSTEM_WINVER)
SUBSYSTEM=windows,$(SUBSYSTEM_WINVER)
UMINCL=$(CRT_INCLUDES)

! IF "$(UMENTRY)" == "winmain"
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
!   error managed code should use unicode, specify UMENTRY=wwinmain
!  else
UMENTRY=/entry:WinMainCRTStartup
!  endif
! ELSEIF "$(UMENTRY)" == "wwinmain"
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
UMENTRY=/entry:?wWinMainCRTStartup@@$$$$FYMHXZ
!  else
UMENTRY=/entry:wWinMainCRTStartup
!  endif
! ELSEIF "$(UMENTRY)" == "wmain"
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
UMENTRY=/entry:?wmainCRTStartup@@$$$$FYMHXZ
!  else
UMENTRY=/entry:wmainCRTStartup
!  endif
! ELSEIF "$(UMENTRYABS)" == ""
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
!   error managed code should use unicode, specify UMENTRY=wmain
!  else
UMENTRY=/entry:mainCRTStartup
!  endif
! ELSE
UMENTRY=/entry:$(UMENTRYABS)
! ENDIF

UMLIBS=$(UMLIBS) $(WIN32_LIBS) $(GUI32_LIBS)

!ELSEIF "$(UMTYPE)" == "console"

SUBSYSTEM_VERSIONX=$(SUBSYSTEM_CONVER)
SUBSYSTEM=console,$(SUBSYSTEM_CONVER)
UMINCL=$(CRT_INCLUDES)

! IF "$(UMENTRY)" == "winmain"
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
!   error managed code should use unicode, specify UMENTRY=wwinmain
!  else
UMENTRY=/entry:WinMainCRTStartup
!  endif
! ELSEIF "$(UMENTRY)" == "wwinmain"
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
UMENTRY=/entry:?wWinMainCRTStartup@@$$$$FYMHXZ
!  else
UMENTRY=/entry:wWinMainCRTStartup
!  endif
! ELSEIF "$(UMENTRY)" == "wmain"
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
UMENTRY=/entry:?wmainCRTStartup@@$$$$FYMHXZ
!  else
UMENTRY=/entry:wmainCRTStartup
!  endif
! ELSEIF "$(UMENTRYABS)" == ""
!  if "$(MCPP_TYPE)" == "pure" && "$(TARGETTYPE)" == "PROGRAM"
!   error managed code should use unicode, specify UMENTRY=wmain
!  else
UMENTRY=/entry:mainCRTStartup
!  endif
! ELSE
UMENTRY=/entry:$(UMENTRYABS)
! ENDIF

UMLIBS=$(UMLIBS) $(WIN32_LIBS)

!ELSEIF "$(UMTYPE)" == "ntss"

SUBSYSTEM_VERSIONX=$(SUBSYSTEM_NATVER)
SUBSYSTEM=native,$(SUBSYSTEM_NATVER)
UMINCL=$(CRT_INCLUDES)

STD_CALL_ENTRY=1

! IF "$(UMENTRY)" == "wmain"
UMENTRY=/entry:NtProcessStartupW
! ELSE
UMENTRY=/entry:NtProcessStartup
! ENDIF

NOT_TERMINAL_SERVER_AWARE=1

UMLIBS=$(UMLIBS) $(NTSS_LIBS)

!ELSEIF "$(UMTYPE)" == "posix"

#
# This is only for base\sfu.
#
!  if "$(MAKEDIR_RELATIVE_TO_BASEDIR:base\sfu\=)" == "$(MAKEDIR_RELATIVE_TO_BASEDIR)"
!    error $(MAKEDIR) UMTYPE == posix is only supported in $(BASEDIR)\base\sfu.
!  endif

SUBSYSTEM=posix$(SUBSYSTEM_POSIXVER)
UMINCL=$(SDK_INC_PATH)\posix;$(CRT_INC_PATH)

UMENTRY=-entry:__PosixProcessStartup

UMLIBS=$(UMLIBS) $(POSIX_LIBS)

!ELSE
! ERROR Invalid UMTYPE value - $(UMTYPE)
!ENDIF  # UMTYPE tests


NTINCLUDES=$(OAK_INC_PATH);$(SDK_INC_PATH);$(MINWIN_SDK_INC_PATH)

#
# Let drivers include files such as ntddk.h.
# WDM drivers\libs can only include wdm.h type of files though ...
# DDK_INC_PATH must be first for precedence.
#
!IF "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
NTINCLUDES=$(NTINCLUDES);$(WDM_INC_PATH)
!ELSEIF "$(DRIVERTYPE)" == "fs" || "$(DRIVERTYPE)" == "FS"
NTINCLUDES=$(NTINCLUDES);$(DDK_INC_PATH);$(IFSKIT_INC_PATH)
!ELSEIF "$(TARGETTYPE)" == "DRIVER"        || \
        "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
        "$(TARGETTYPE)" == "MINIPORT"      || \
        "$(TARGETTYPE)" == "DRIVER_LIBRARY"
NTINCLUDES=$(NTINCLUDES);$(DDK_INC_PATH);$(WDM_INC_PATH)
!ENDIF

!IF "$(BUILD_MINWIN)" == "1" && "$(MINWIN_INC_PATH)" != ""
NTINCLUDES=$(NTINCLUDES);$(MINWIN_INC_PATH);$(MINWIN_PRIV_SDK_INC_PATH)
C_DEFINES=$(C_DEFINES) -DBUILD_MINWIN
!ENDIF

#
# User mode scheduling (UMS) build options.
#

!if "$(ENABLE_UMS)" == "1"
!    if $(386)
BUILD_UMS_ENABLED=0
!    elseif $(AMD64)
BUILD_UMS_ENABLED=1
!    elseif $(IA64)
BUILD_UMS_ENABLED=1
!    elseif $(ARM)
BUILD_UMS_ENABLED=0
!    else
!error Unsupported architecture.
!endif
C_DEFINES=$(C_DEFINES) /DBUILD_UMS_ENABLED=$(BUILD_UMS_ENABLED)
!endif


#
# Temporarily enable the deprecated macros KMDF_VERSION and UMDF_VERSION for the WDK
#

!   if DEFINED(KMDF_VERSION)
!      message warning : The directive KMDF_VERSION has been replaced by KMDF_VERSION_MAJOR and will be removed in the next version of the WDK. Please update your scripts accordingly.
KMDF_VERSION_MAJOR = $(KMDF_VERSION)
!   endif

!   if DEFINED(UMDF_VERSION)
!      message warning : The directive UMDF_VERSION has been replaced by UMDF_VERSION_MAJOR and will be removed in the next version of the WDK. Please update your scripts accordingly.
UMDF_VERSION_MAJOR = $(UMDF_VERSION)
!   endif


!IF DEFINED(KMDF_VERSION_MAJOR)
!   if ("$(KMDF_VERSION_MAJOR)" == "1" || "$(KMDF_VERSION_MAJOR)" == "01")
KMDF_VERSION_MAJOR = 1
!       IF !DEFINED(KMDF_VERSION_MINOR)
KMDF_VERSION_MINOR = $(KMDF_VERSION_MINOR_LATEST)
!       ENDIF
KMDF_VER_PATH = $(KMDF_VERSION_MAJOR).$(KMDF_VERSION_MINOR)
!   else
!       error using incorrect KMDF major version number $(KMDF_VERSION_MAJOR).
!   endif
NTINCLUDES=$(NTINCLUDES);$(KMDF_INC_PATH)\$(KMDF_VER_PATH)

#
# Add Windows Driver Framework inc if it is a WDF driver.
#

#
# KMDF_MAJOR_VERSION and KMDF_MINOR_VERSION are C flags and can be used by
# the C preprocessor, in order to find the version of KMDF
#
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MAJOR_VERSION=$(KMDF_VERSION_MAJOR)
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MINOR_VERSION=$(KMDF_VERSION_MINOR)

#
# KMDF_MAJOR_VERSION_STRING and KMDF_MINOR_VERSION_STRING are C flags and
# can be used by scripts and applications to build KMDF filenames
# dynamically (e.g. the nonpnpapp uses it to build the name of the
# coinstaller)
#
!   if $(KMDF_VERSION_MAJOR) < 10
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MAJOR_VERSION_STRING=0$(KMDF_VERSION_MAJOR)
!   else if $(KMDF_VERSION_MAJOR) < 100
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MAJOR_VERSION_STRING=$(KMDF_VERSION_MAJOR)
!   else
!       error using incorrect KMDF major version number $(KMDF_VERSION_MAJOR).
!   endif

!   if $(KMDF_VERSION_MINOR) < 10
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MINOR_VERSION_STRING=00$(KMDF_VERSION_MINOR)
!   else if $(KMDF_VERSION_MINOR) < 100
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MINOR_VERSION_STRING=0$(KMDF_VERSION_MINOR)
!   else if $(KMDF_VERSION_MINOR) < 1000
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MINOR_VERSION_STRING=$(KMDF_VERSION_MINOR)
!   else
!       error using incorrect KMDF minor version number $(KMDF_VERSION_MINOR).
!   endif
!ELSE
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MAJOR_VERSION_STRING=01
USER_C_FLAGS=$(USER_C_FLAGS) /DKMDF_MINOR_VERSION_STRING=00$(KMDF_VERSION_MINOR_LATEST)
!ENDIF

!IF DEFINED(UMDF_VERSION_MAJOR)
!   if ("$(UMDF_VERSION_MAJOR)" == "1" || "$(UMDF_VERSION_MAJOR)" == "01")
UMDF_VERSION_MAJOR = 1
!       IF !DEFINED(UMDF_VERSION_MINOR)
UMDF_VERSION_MINOR = $(UMDF_VERSION_MINOR_LATEST)
!       ENDIF
UMDF_VER_PATH = $(UMDF_VERSION_MAJOR).$(UMDF_VERSION_MINOR)
!   else
!       error using incorrect UMDF major version number $(UMDF_VERSION_MAJOR).
!   endif
NTINCLUDES=$(NTINCLUDES);$(UMDF_INC_PATH)\$(UMDF_VER_PATH)
!ENDIF


!IFNDEF CBSTRING
! IF "$(MAJORCOMP)" == "ntos" || \
     "$(MAJORCOMP)" == "NTOS" || \
     "$(TARGETTYPE)" == "DRIVER"         || \
     "$(TARGETTYPE)" == "DRIVER_LIBRARY" || \
     "$(TARGETTYPE)" == "GDI_DRIVER"     || \
     "$(TARGETTYPE)" == "HAL"            || \
     "$(TARGETTYPE)" == "EXPORT_DRIVER"  || \
     "$(TARGETTYPE)" == "MINIPORT"
!    IF "$(DRIVERTYPE)" != "VXD"
CBSTRING= -cbstring
!    ENDIF
! ELSE
CBSTRING=
! ENDIF
!ENDIF


!if "$(TARGETTYPE)" == "DRIVER_LIBRARY"
TARGETTYPE=LIBRARY
!endif

#
#  Add PROJECT_INC_PATH to NTINCLUDES, if NO_PRIVATE_INC is not set
#
!IFDEF PROJECT_INC_PATH
! IFNDEF NO_PRIVATE_INC
NTINCLUDES=$(PROJECT_ROOT)\inc;$(PROJECT_OBJ_ROOT)\inc\$O;$(PROJECT_INC_PATH);$(NTINCLUDES)
! ENDIF
!ENDIF

NTINCLUDES=$(OBJ_PATH)\$O;$(NTINCLUDES)

!if "$(POCKETPC)" == ""
!IFNDEF COMPILER_WARNINGS
COMPILER_WARNINGS=/FI$(SDK_INC_PATH)\warning.h $(PROJECT_COMPILER_WARNINGS)
!ifdef USE_LINT
LINT_FORCEDINCS=$(LINT_FORCEDINCS) -header($(SDK_INC_PATH)\warning.h)
!endif
!ENDIF

#
# Warnings that should not be over-ridden by individual projects.
#
#
# tag test code so static analysis tools can distinguish product code and test code
#
!ifdef TEST_CODE

!  if "$(URT_VER)" < "2.0"
TEST_CODE_MANAGED_RES=$(SDKTOOLS_REF_PATH)\__testcode11__.resources
!  else # URT_VER >= 2.0
TEST_CODE_MANAGED_RES=$(SDKTOOLS_REF_PATH)\__testcode20__.resources
!  endif

!  if defined(_C_SHARP)
USER_CS_FLAGS=$(USER_CS_FLAGS) /res:$(TEST_CODE_MANAGED_RES)
!  elseif defined(_VB)
USER_VB_NET_FLAGS=$(USER_VB_NET_FLAGS) /res:$(TEST_CODE_MANAGED_RES) /win32manifest:$(RAZZLETOOLPATH)\managed\v2.0\test.win32manifest
!  elseif defined(MANAGED_CXX) # managed C++
LINKER_FLAGS=$(LINKER_FLAGS) /ASSEMBLYRESOURCE:$(TEST_CODE_MANAGED_RES)
!  else                        # native C++
COMPILER_WARNINGS=$(COMPILER_WARNINGS) /FI$(SDKTOOLS_INC_PATH)\testcode.h
!  endif

!endif # TEST_CODE

!endif

!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=$(CURRENT_WIN32_WINNT_VERSION)
!endif

!ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=$(LATEST_WIN32_WIN95_VERSION)
!endif

!ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=$(LATEST_WIN32_WCE_VERSION)
!endif

!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=$(CURRENT_WIN32_IE_VERSION)
!endif

!ifndef WINVER_VERSION
!ifdef CHICAGO_PRODUCT
WINVER_VERSION=$(WIN32_WIN95_VERSION)
!elseif defined(POCKETPC)
WINVER_VERSION=$(WIN32_WCE_VERSION)
!else
WINVER_VERSION=$(WIN32_WINNT_VERSION)
!endif
!endif

!ifdef UNDEF_WINVER
_WINVER_VERSION=/UWINVER
!else
_WINVER_VERSION=/DWINVER=$(WINVER_VERSION)
!endif

!ifdef POCKETPC

NO_NTDLL=1
! IFNDEF WIN32_DEFINE
WIN32_DEFINE=/DWIN32=300 /D_WIN32_WCE=$(WIN32_WCE_VERSION) $(_WINVER_VERSION)
!  if "$(POCKETPC_EMULATION)" != ""
WIN32_DEFINE = $(WIN32_DEFINE) /D_WIN32_WCE_EMULATION
!  endif
! ENDIF

!ELSEIF defined(CHICAGO_PRODUCT)

NO_NTDLL=1
! IFNDEF WIN32_DEFINE
WIN32_DEFINE=/DWIN32=200 /D_CHICAGO_=200 /D_WIN32_WINDOWS=$(WIN32_WIN95_VERSION) $(_WINVER_VERSION)
! ENDIF

!ELSE

WIN32_DEFINE=/DWIN32=100 /D_NT1X_=100 /DWINNT=1 /D_WIN32_WINNT=$(WIN32_WINNT_VERSION) $(_WINVER_VERSION)

!ENDIF

WIN32_DEFINE=$(WIN32_DEFINE) /D_WIN32_IE=$(WIN32_IE_VERSION)

INCLUDES     = $(INCLUDES: =)
NTINCLUDES   = $(NTINCLUDES: =)
UMINCL       = $(UMINCL: =)
MFC_INCLUDES = $(MFC_INCLUDES: =)
USER_INCLUDES =$(USER_INCLUDES: =)
ATL_INCLUDES = $(ATL_INCLUDES: =)
WTL_INCLUDES = $(WTL_INCLUDES: =)

# MFC, ATL, WTL, and USER first

INCPATH0=/I$(MFC_INCLUDES:;= /I) /I$(ATL_INCLUDES:;= /I) /I$(WTL_INCLUDES:;= /I) /I$(USER_INCLUDES:;= /I)
INCPATH1=/I$(MFC_INCLUDES:;= /I) /I$(ATL_INCLUDES:;= /I) /I$(WTL_INCLUDES:;= /I) /I$(USER_INCLUDES:;= /I)

# INCLUDES if set

!ifdef INCLUDES
INCPATH0 = $(INCPATH0) /I$(INCLUDES:;= /I)
INCPATH1 = $(INCPATH1) /I$(INCLUDES:;= /I)
!endif

# Finally NT and UM

INCPATH0=$(INCPATH0) /I$(NTINCLUDES:;= /I) /I$(UMINCL:;= /I)
INCPATH1=$(INCPATH1) /I$(NTINCLUDES:;= /I) /I$(UMINCL:;= /I)

# Remove empty "/I " settings (INCL/NTINCLUDES/UMINCL/MFC_INCLUDES macros may be empty above)

INCPATH0=$(INCPATH0:-I =)
INCPATH0=$(INCPATH0:/I =)
INCPATH1=$(INCPATH1:-I =)
INCPATH1=$(INCPATH1:/I =)
!ifdef USE_LINT
LINT_INCLUDES=-i$(TARGET_DIRECTORY)\ -i. $(LINT_PRECOMPPATH) $(INCPATH1:/I=-i)
!endif

!IF !defined(DLLENTRY) || defined(NO_DLLENTRY)
DLLENTRY=/noentry
!ELSE
! if "$(DLLENTRY:-entry:=)" == "$(DLLENTRY)" && "$(DLLENTRY:/entry:=)" == "$(DLLENTRY)"
DLLENTRY=/entry:$(DLLENTRY)
! endif
!ENDIF

!IFNDEF DLLBASE
! IFDEF COFFBASE
DLLBASE=@$(COFFBASE_TXT_FILE),$(COFFBASE)
! ELSE
DLLBASE=@$(COFFBASE_TXT_FILE),$(TARGETNAME)
! ENDIF
!ENDIF

!if !defined(MCPP_TYPE)
!IFNDEF DLLDEF
DLLDEF=$(@B).def
!ENDIF
!endif

!IFNDEF BOOTBASE
! IFDEF FRAZZLE
BOOTBASE=0xd0100000,0xd0104000
! ELSE
BOOTBASE=0xd0ff0000,0xd0ff4000
! ENDIF
!ENDIF

!IFNDEF DRIVERBASE
DRIVERBASE=0x10000
!ENDIF

!IFNDEF HALBASE
HALBASE=0x80010000
!ENDIF

!endif # } }

COMPLUS_INSTALLROOT=$(RAZZLETOOLPATH)\managed

!if (defined(URT_VER) || defined(_PROJECT_BUILDS_MANAGED_CODE))

! if "$(URT_VER)" == "1.1"
!  if defined(_PROJECT_BUILDS_MANAGED_CODE) && !$(386)
!   error URT_VER=1.1 is not supported for $(_BUILDARCH) (try 2.0)
!  endif
!  ifdef MCPP_TYPE
!   error MCPP_TYPE is not supported for URT_VER=1.1 (try 2.0)
!  endif
!  if defined(_PROJECT_BUILDS_MANAGED_CODE)
_NT_TOOLS_VERSION=0x700
!  endif
! elseif "$(URT_VER)" == "2.0"
! else
!   error URT_VER must be specified as 1.1 or 2.0
! endif

COMPLUS_VERSION=v$(URT_VER)
CLR_REF_PATH=$(SDK_REF_PATH)\clr$(URT_VER:.=)
URTTARGET=$(CLR_REF_PATH)

! ifdef BUILD_PATH
BUILD_PATH=$(COMPLUS_INSTALLROOT)\$(COMPLUS_VERSION);$(BUILD_PATH)
PATH=$(BUILD_PATH)
! else
PATH=$(COMPLUS_INSTALLROOT)\$(COMPLUS_VERSION);$(PATH)
! endif

! if [set COMPLUS_INSTALLROOT=$(COMPLUS_INSTALLROOT)]
! endif
! if [set COMPLUS_VERSION=$(COMPLUS_VERSION)]
! endif

! ifdef MANAGED_CXX
LINK_NAME=$(COMPLUS_INSTALLROOT)\$(COMPLUS_VERSION)\$(_BUILDARCH)\link
CC_NAME=$(COMPLUS_INSTALLROOT)\$(COMPLUS_VERSION)\$(_BUILDARCH)\cl

!  ifdef BUILD_PATH
BUILD_PATH=$(COMPLUS_INSTALLROOT)\$(COMPLUS_VERSION)\$(_BUILDARCH);$(BUILD_PATH)
PATH=$(BUILD_PATH)
!  else
PATH=$(COMPLUS_INSTALLROOT)\$(COMPLUS_VERSION)\$(_BUILDARCH);$(PATH)
!  endif

# Managed CXX implies /EHa
USE_NATIVE_EH=ASYNC

!  if !$(FREEBUILD) && !defined(NO_DEBUG_ASSEMBLY)
LINKER_FLAGS=$(LINKER_FLAGS) /AssemblyDebug
!  endif

!  if "$(URT_VER)" >= "2.0"
MANAGED_CXX_FLAGS=$(MANAGED_CXX_FLAGS) /d1clr:nostdlib /d1clr:nomscorlib $(USECXX_FLAG)
!  else
LINKER_FLAGS=$(LINKER_FLAGS) $(SDK_LIB_PATH)\nochkclr.obj
!  endif

!  ifdef MCPP_TYPE
MANAGED_CXX_FLAGS=$(MANAGED_CXX_FLAGS) /clr:$(MCPP_TYPE)
LINKER_FLAGS=$(LINKER_FLAGS) /clrimagetype:$(MCPP_TYPE)
!  else
MANAGED_CXX_FLAGS=$(MANAGED_CXX_FLAGS) /clr
!  endif

! endif

#
# Enable FxCop in-source suppression for managed code
#

# 1. For C# projects

! if defined(_C_SHARP)
!  if defined(VERIFY_BUILD) || defined(BUILD_OACR)
USER_CS_FLAGS=$(USER_CS_FLAGS) /d:CODE_ANALYSIS
!   if "$(URT_VER)" < "2.0"
REFERENCES = $(REFERENCES);$(SDKTOOLS_REF_PATH)\SuppressMessage11.metadata_dll
!   endif
!  endif

# 2. For managed C++ projects

! elseif defined(MANAGED_CXX)
!  if defined(VERIFY_BUILD) || defined(BUILD_OACR)
USER_C_FLAGS=$(USER_C_FLAGS) /DCODE_ANALYSIS=1
!   if "$(URT_VER)" < "2.0"
REFERENCES = $(REFERENCES);$(SDKTOOLS_REF_PATH)\SuppressMessage11.metadata_dll
!   endif
!  endif

# 3. For managed VB projects

!elseif defined(MANAGED_VB)

! if defined(VERIFY_BUILD) || defined(BUILD_OACR)

# Define CODE_ANALYSIS iff running 'timebuild /verify'
USER_VB_NET_FLAGS=$(USER_VB_NET_FLAGS) /define:CODE_ANALYSIS=1

!  if "$(URT_VER)" < "2.0"
REFERENCES = $(REFERENCES);$(SDKTOOLS_REF_PATH)\SuppressMessage11.metadata_dll
!  endif

! endif # VERIFY_BUILD

!endif

#
# Handle REFERENCES.
#
# C# accepts
#  /r:foo1.dll /r:foo2.dll
#  /r:foo1.dll,foo2.dll
#
# C++ accepts
#  /FUfoo1.dll /FUfoo2.dll
#
# (minor bug -- build.exe splits on , and ; even for C++, it should do only ;)
#
!if defined(REFERENCES) && defined(_PROJECT_BUILDS_MANAGED_CODE)

_REFERENCES=$(REFERENCES: =)

# Convert double semicolons to single semicolons, to handle appending ";foo" to REFERENCES that
# is already semicolon terminated.
_REFERENCES=$(_REFERENCES:;;=;)

# get rid of the leading ; if there is one
_REFERENCES=; $(_REFERENCES)
_REFERENCES=$(_REFERENCES:; ;=)
_REFERENCES=$(_REFERENCES:; =)

# get rid of the trailing ; if there is one
_REFERENCES=$(_REFERENCES) ;
_REFERENCES=$(_REFERENCES:; ;=)
_REFERENCES=$(_REFERENCES: ;=)

!  if "$(BUILD_PRODUCT)" == "NT"
!   if "$(_REFERENCES)" == ""
!   error REFERENCES is empty.
!   else

#
# Adding '*' at the end so we can detect correctly case when reference 
# is last one without anything appended (we detect only when .dll or 
# .exe is put at the end of reference, removing false negative 
# like Wtt.ExecutionLayer.meatadata_dll
# 
_REFERENCES_CHECK=$(REFERENCES)*
_REFERENCES_CHECK=$(_REFERENCES_CHECK:B=b)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:C=c)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:D=d)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:E=e)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:I=i)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:L=l)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:M=m)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:O=o)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:R=r)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:S=s)
_REFERENCES_CHECK=$(_REFERENCES_CHECK:X=x)

!    if "$(_REFERENCES_CHECK:\mscorlib.dll=)" != "$(_REFERENCES_CHECK)" \
    || "$(_REFERENCES_CHECK:\mscorlib.metadata_dll=)" != "$(_REFERENCES_CHECK)"

!    error Do not put mscorlib.dll or mcorlib.metadata_dll in REFERENCES.
!    error Just let the build system provide you mscorlib.dll in whatever way it automatically does.

!    elseif "$(_REFERENCES_CHECK:.dll*=)" != "$(_REFERENCES_CHECK)" \
         || "$(_REFERENCES_CHECK:.dll,=)" != "$(_REFERENCES_CHECK)" \
         || "$(_REFERENCES_CHECK:.dll;=)" != "$(_REFERENCES_CHECK)" \
         || "$(_REFERENCES_CHECK:.dll =)" != "$(_REFERENCES_CHECK)"
!    error REFERENCES must use .metadata_dll instead of .dll.

!    elseif "$(_REFERENCES_CHECK:.exe*=)" != "$(_REFERENCES_CHECK)" \
         || "$(_REFERENCES_CHECK:.exe,=)" != "$(_REFERENCES_CHECK)" \
         || "$(_REFERENCES_CHECK:.exe;=)" != "$(_REFERENCES_CHECK)" \
         || "$(_REFERENCES_CHECK:.exe =)" != "$(_REFERENCES_CHECK)"
!    error REFERENCES must use .metadata_exe instead of .exe.

!    endif

# Note this is checking all the references at once, so REFERENCES=.\foo.metadata_dll bar.metadata_dll bogusly
#   accepts bar.metadata_dll.
!    if "$(_REFERENCES_CHECK:\=)" == "$(_REFERENCES_CHECK)"
!    error REFERENCES must contain only full paths or relative paths, it cannot contain leaf-only elements. (For example, use $$(CLR_REF_PATH)\System.metadata_dll instead of System.metadata_dll.)
!    endif
!   endif
!  endif

!  ifdef MANAGED_CXX
MANAGED_CXX_FLAGS=$(MANAGED_CXX_FLAGS) /FU$(_REFERENCES:;= /FU)
!  elseif (defined(_C_SHARP) || defined(_VB) || defined(_TLBIMP))
MANAGED_REFERENCES=/r:$(_REFERENCES:;= /r:)
!  else
!  error REFERENCES defined but not any of MANAGED_CXX, sources=*.cs, *vb, *.tlb.
!  endif
! endif

#
# These references are not optional for Managed C++, and the compiler does not like
#  it if you specify .metadata_dll. /FU is order dependent, you must put these at the start.
#
! ifdef MANAGED_CXX
MANAGED_CXX_FLAGS=/FU$(CLR_REF_PATH)\Microsoft.VisualC.dll $(MANAGED_CXX_FLAGS)
!  if "$(URT_VER)" < "2.0"
MANAGED_CXX_FLAGS=/FI$(OBJECT_ROOT)\$O\_using_mscorlib.h $(MANAGED_CXX_FLAGS)
!  else
MANAGED_CXX_FLAGS=/FU$(CLR_REF_PATH)\mscorlib.dll $(MANAGED_CXX_FLAGS)
!  endif
! endif

! if (defined(_C_SHARP) || defined(_VB) || defined(_TLBIMP))
!  ifndef MANAGED_TARGET_TYPE
!   if "$(TARGETTYPE)" == "PROGRAM"
!    if "$(UMTYPE)" != "console"
MANAGED_TARGET_TYPE=winexe
!    else
MANAGED_TARGET_TYPE=exe
!    endif
!   elseif "$(TARGETTYPE)" == "DYNLINK"
MANAGED_TARGET_TYPE=library
!   endif
!  endif

!  ifdef MANAGED_PLATFORM_SPECIFIC
!   if "$(URT_VER)" < "2.0"
!   error MANAGED_PLATFORM_SPECIFIC cannot be used with URT_VER < 2.0
!   endif

!   if "$(_BUILDARCH)" == "ia64"
USER_CS_FLAGS=$(USER_CS_FLAGS) /platform:itanium
!   else if "$(_BUILDARCH)" == "amd64"
USER_CS_FLAGS=$(USER_CS_FLAGS) /platform:x64
!   else if "$(_BUILDARCH)" == "x86"
USER_CS_FLAGS=$(USER_CS_FLAGS) /platform:x86
!   else
!    error Using MANAGED_PLATFORM_SPECIFIC with unsupported build architecture
!   endif
!  else
!   if "$(URT_VER)" >= "2.0"
USER_CS_FLAGS=$(USER_CS_FLAGS) /platform:anycpu
!   endif
!  endif

!  ifndef GENBASEMAC_CMD
GENBASEMAC_CMD=$(RAZZLETOOLPATH)\genbasemac.pl
!  endif
!  if "$(GENBASEMAC_CMD)"!=""
!   if !exist($(GENBASEMAC_CMD))
!     message NMAKE : Uxxxx: unable to find $(GENBASEMAC_CMD)
!   endif
!   message BUILD: $(GENBASEMAC_CMD) $(OBJ_PATH)\$O $(TARGETNAME) $(COFFBASE_TXT_FILE)
!   IF [$(_PERL) $(GENBASEMAC_CMD) $(OBJ_PATH)\$O $(TARGETNAME) $(COFFBASE_TXT_FILE)]
!   ENDIF
!   IF EXIST( $(OBJ_PATH)\$O\coffbase.mac )
!    INCLUDE $(OBJ_PATH)\$O\coffbase.mac
!   ELSE
MANAGED_COFFBASE=0x400000
!   ENDIF
!  endif

!  if $(FREEBUILD)
MANAGED_DBG_FLAGS=/optimize+ /debug:pdbonly
!  else
!   if defined(_VB)
MANAGED_DBG_FLAGS=/debug:full /define:DEBUG=1
!   else
MANAGED_DBG_FLAGS=/debug:full /define:DEBUG
!   endif
!  endif

#
# Tlbimp.cmd is still used for 1.1 for its error filtering.
#
MANAGED_CODE_BUILD_TOOL= \
!  if defined(_VB)
    $(VB_NET_COMPILER_NAME)
!  elseif defined(_TLBIMP)
!   if "$(URT_VER)" < "2.0"
    tlbimp.cmd /strictref $(_TLBIMP_FLAGS) /noenv
!   else
    tlbimp.exe $(TLBIMP_MACHINE) /strictref:nopia $(_TLBIMP_FLAGS)
!   endif
!  else
    $(CS_COMPILER_NAME)
!  endif

MANAGED_CODE_BUILD_SWITCHES1= \
    /out:$(TARGET) \

!  if defined(_VB) || defined(_C_SHARP)
!   if !defined(_MANAGED_SOURCES)
_MANAGED_SOURCES=$(SOURCES)
!   endif

# make sure csc.rsp is never used
MANAGED_CODE_BUILD_TOOL=$(MANAGED_CODE_BUILD_TOOL) /noconfig

MANAGED_CODE_BUILD_SWITCHES2= \
    $(MANAGED_CODE_BUILD_SWITCH_CUSTOM) \
    /target:$(MANAGED_TARGET_TYPE) \
    /baseaddress:$(MANAGED_COFFBASE) \
    $(MANAGED_STD_FLAGS) \
    $(_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS) \
    $(_LANGUAGE_NEUTRAL_MANAGED_RESOURCES_CSC_OR_VBC_FLAGS)

!  endif

MANAGED_CODE_BUILD_SWITCHES2= \
    $(MANAGED_CODE_BUILD_SWITCHES2) \
    $(MANAGED_REFERENCES) \

!if defined(_RES_FILE)
!if defined(_C_SHARP)
MANAGED_CODE_BUILD_SWITCHES2=$(MANAGED_CODE_BUILD_SWITCHES2) /win32res:$(_RES_FILE)
!endif
!if defined(_VB)
MANAGED_CODE_BUILD_SWITCHES2=$(MANAGED_CODE_BUILD_SWITCHES2) /win32resource:$(_RES_FILE)
!endif
!endif

MANAGED_CODE_BUILD_SWITCHES=\
 $(MANAGED_CODE_BUILD_SWITCHES1) \
 $(MANAGED_CODE_BUILD_SWITCHES2)

# This split is related to changing spaces to newlines in the output.
# We change only the newlines in "2" and leave them in "1", so build.exe
# can sniff the command correctly.
MANAGED_CODE_BUILD_CMD1 = \
    $(MANAGED_CODE_BUILD_TOOL) \
    $(MANAGED_CODE_BUILD_SWITCHES1) \

MANAGED_CODE_BUILD_CMD1=$(MANAGED_CODE_BUILD_CMD1:  = )

MANAGED_CODE_BUILD_CMD2= \
    $(MANAGED_CODE_BUILD_SWITCHES2) \
    $(_MANAGED_SOURCES)

MANAGED_CODE_BUILD_CMD=\
 $(MANAGED_CODE_BUILD_CMD1) \
 $(MANAGED_CODE_BUILD_CMD2)

# Managed code always defines MAKEDLL (it's a single pass build after all).

MAKEDLL=1

! endif # _C_SHARP || _VB || _TLBIMP
!endif # URT_VER || _PROJECT_BUILDS_MANAGED_CODE


# Variable to hold default value to w2k razzle builds
WIN2K_DDK_REPLACEMENT=win2000.obj

WIN2K_DDK_REPLACEMENT=winxp.obj

!if    defined(USE_MSVCRT) \
    && ("$(SUBSYSTEM_VERSIONX)" < "6.00")

!if defined(MANAGED_CXX) && "$(URT_VER)" == "1.1" && $(386) && !defined(MCPP_TYPE)

!if ("$(SUBSYSTEM_VERSIONX)" < "5.00")
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt11_winnt4.obj $(SDK_LIB_PATH)\msvcrt_winnt4.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.00")
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt11_$(WIN2K_DDK_REPLACEMENT) $(SDK_LIB_PATH)\msvcrt_$(WIN2K_DDK_REPLACEMENT) $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.01")
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt11_winxp.obj $(SDK_LIB_PATH)\msvcrt_winxp.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.02")
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt11_win2003.obj $(SDK_LIB_PATH)\msvcrt_win2003.obj $(LIBC_LIB)
!else
!error SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSIONX) is invalid for x86 and URT_VER=1.1.
!endif

!elseif defined(MANAGED_CXX) && "$(URT_VER)" == "2.0" && "$(MCPP_TYPE)" == "pure"

!if ("$(SUBSYSTEM_VERSIONX)" < "5.00") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\libcummt_winnt4.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.00") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\libcummt_$(WIN2K_DDK_REPLACEMENT) $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.01") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\libcummt_winxp.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.02")
LIBC_LIB=$(SDK_LIB_PATH)\libcummt_win2003.obj $(LIBC_LIB)
!else
!error SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSIONX) is invalid for URT_VER=2.0 and MCPP_TYPE=PURE.
!endif

!elseif defined(MANAGED_CXX) && "$(URT_VER)" == "2.0" && !defined(MCPP_TYPE)

!if ("$(SUBSYSTEM_VERSIONX)" < "5.00") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt_winnt4.obj $(SDK_LIB_PATH)\msvcrt_winnt4.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.00") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt_$(WIN2K_DDK_REPLACEMENT) $(SDK_LIB_PATH)\msvcrt_$(WIN2K_DDK_REPLACEMENT) $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.01") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt_winxp.obj $(SDK_LIB_PATH)\msvcrt_winxp.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.02")
LIBC_LIB=$(SDK_LIB_PATH)\libcmmt_win2003.obj $(SDK_LIB_PATH)\msvcrt_win2003.obj $(LIBC_LIB)
!else
!error SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSIONX) is invalid for URT_VER=2.0.
!endif

!elseif !defined(MANAGED_CXX) && !defined(MCPP_TYPE)

!if !defined(DEBUG_CRTS)

!if ("$(SUBSYSTEM_VERSIONX)" < "5.00") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\msvcrt_winnt4.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.00") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\msvcrt_$(WIN2K_DDK_REPLACEMENT) $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.01") && $(386)
LIBC_LIB=$(SDK_LIB_PATH)\msvcrt_winxp.obj $(LIBC_LIB)
!elseif ("$(SUBSYSTEM_VERSIONX)" == "5.02")
LIBC_LIB=$(SDK_LIB_PATH)\msvcrt_win2003.obj $(LIBC_LIB)
!else
!error SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSIONX) is invalid for $(_BUILDARCH).
!endif

!if defined(USE_STL) && "$(STL_VER)" == "70"
LIBC_LIB=$(CRT_LIB_PATH)\msvcprt_btowc.lib $(LIBC_LIB)
!endif

#
# temporary workaround umlibs bug
#
!if defined(UMAPPL)
_UMAPPL_LINK_LIB_IGNORE_DUPLICATE_DOWNLEVEL_LIBC_OBJ_SPECIFIED_MORE_THAN_ONCE=1
!endif

!endif
!endif
!endif

!if defined(DOWNLEVEL_BTOWC)
!  error $(MAKEDIR) DOWNLEVEL_BTOWC is no longer used, use _NT_TARGET_VERSION or SUBSYSTEM_VERSION instead.
!endif

!if (defined(USE_MFC) || defined(USE_MFCUNICODE)) \
    && !defined(USE_STATIC_MFC) \
    && "$(MFC_VER)" == "42" \
    && ("$(SUBSYSTEM_VERSIONX)" <= "5.00") \
    && $(386) \
    && defined(_PROVIDE_MFC_LIBS)
MFC_LIBS=$(SDK_LIB_PATH)\mfc42_downlevel.obj $(MFC_LIBS)
!endif

!ifndef PASS_INDEPENDENT_TARGETS

!IFDEF makedll
!error use MAKEDLL instead of makedll.
!ENDIF

!IF $(386)
OBJECTS=$(386_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(386_DLLLIBOBJECTS)
!ELSEIF $(IA64)
OBJECTS=$(IA64_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(IA64_DLLLIBOBJECTS)
!ELSEIF $(AMD64)
OBJECTS=$(AMD64_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(AMD64_DLLLIBOBJECTS)
!ELSEIF $(ARM)
OBJECTS=$(ARM_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(ARM_DLLLIBOBJECTS)
!ENDIF

!if defined(_RES_FILE) \
        && (   ("$(TARGETTYPE)" == "PROGRAM") \
            || ("$(TARGETTYPE)" == "DRIVER") \
            || ("$(BUILD_PASS)" == "PASS2") \
            || ("$(BUILD_PASS)" == "PASSALL") \
            || ("$(MAKEDLL)" == "1") \
            || defined(_C_SHARP) \
            || defined(_VB) \
            || defined(RESOURCE_ONLY_DLL) \
            || defined(COMPILE_RESOURCES_IN_PASS1) \
            )
MYMUILINK=$(_RES_FILE)
!endif

!if !defined(TARGETTYPE) || "$(TARGETTYPE)" ==  "NOTARGET"
MYMUILINK=
!endif

#
# BUILD.EXE defines the NOLINK variable to disable the building of any
# test executables when it is recursing on a dirs. file to build components
# in subdirectories.
#

!IF "$(BUILDMSG)" != "Stop."
! IFDEF NOLINK
!  UNDEF NTKERNEL
!  UNDEF MAKEDLL
! ELSE
!  IFDEF nolink
!   UNDEF NTKERNEL
!   UNDEF MAKEDLL
!  ENDIF
! ENDIF # DEF NOLINK
!ENDIF # BUILDMSG != "Stop."

!IF (!defined(_C_SHARP) && !defined(_VB))
DYNLINK_LIB=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
DYNLINK_LIBDIR=$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
!ENDIF

!IF "$(TARGETNAMEP)" != ""
DYNLINK_LIBP=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAMEP).lib
DYNLINK_LIBPDIR=$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\$(TARGETNAMEP).lib
!ENDIF

!if !defined(MCPP_TYPE)
DYNLINK_EXP=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp
!endif

#
# Determine type of target link we are doing
#
!IF "$(TARGETTYPE)" == "PROGLIB"
!  IF "$(TARGETEXT)" == ""
TARGETEXT=exe
!endif
! if defined(USE_NTDLL)
TARGETLIB=$(NTDLL_CRT)
! else
TARGETLIB=$(LIBC_LIB)
! endif
!ELSEIF "$(TARGETTYPE)" == "CATALOG"
TARGETEXT=cat
!ELSEIF "$(TARGETTYPE)" == "MSI"
TARGETEXT=msi
!ELSEIF "$(TARGETTYPE)" == "PROGRAM"
! IF "$(TARGETEXT)" == ""
TARGETEXT=exe
! endif
! if defined(USE_NTDLL)
TARGETLIB=$(NTDLL_CRT)
! else
TARGETLIB=$(LIBC_LIB)
! endif
!ELSEIF "$(TARGETTYPE)" == "DYNLINK"
! IF "$(MAKEDLL)" != ""
!  IF "$(TARGETNAME)" == "ntdll"
TARGETLIB=
!  ELSEIF defined (USE_NTDLL)           # USE_NTDLL never links with LIBC_LIB
TARGETLIB=$(WIN32DLL_LIBS) $(NTDLL_CRT)

!  ELSEIF defined (USE_SYSDLL)          # USE_SYSDLL uses either kernel32 (Win95) or ntdll (NT) for CRT support
!error $(MAKEDIR) - USE_SYSDLL no longer supported
!  ELSEIF defined (NO_NTDLL)            # NO_NTDLL never links with ntdll
TARGETLIB=$(WIN32DLL_LIBS) $(LIBC_LIB)
!  ELSE                                 # Everything else uses ntdll after libc.
TARGETLIB=$(WIN32DLL_LIBS) $(LIBC_LIB)
!  ENDIF
!  IF "$(TARGETEXT)" == ""
TARGETEXT=dll
!  ENDIF
! ELSE
TARGETEXT=lib
TARGETLIB=
! ENDIF

!ELSEIF "$(TARGETTYPE)" == "LIBRARY"
TARGETEXT=lib
TARGETLIB=

!ELSEIF "$(TARGETTYPE)" == "DRIVER"
!  IF "$(TARGETEXT)" == ""
TARGETEXT=sys
!  ENDIF
!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
TARGETLIB=$(DDK_LIB_PATH)\wdm.lib
!ELSEIF "$(DRIVERTYPE)" == "VXD"
TARGETEXT=vxd
!ELSE
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
!  IF defined(SUBSYSTEM_VERSION) && "$(SUBSYSTEM_VERSION)" < "$(SUBSYSTEM_601)"
TARGETLIB=$(CRT_LIB_PATH)\safecrtnt.lib $(SDK_LIB_PATH)\libcntpr.lib $(TARGETLIB)
!  ENDIF
!ENDIF

#
# Add Windows Driver Framework lib if it is a WDF driver
#
!IF DEFINED(KMDF_VERSION_MAJOR)
TARGETLIB=$(TARGETLIB) \
          $(KMDF_LIB_PATH)\$(KMDF_VER_PATH)\WdfLdr.lib \
          $(KMDF_LIB_PATH)\$(KMDF_VER_PATH)\WdfDriverEntry.lib
!ENDIF

!ELSEIF "$(TARGETTYPE)" == "EXPORT_DRIVER"
! IF "$(MAKEDLL)" != ""
TARGETEXT=sys
!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
TARGETLIB=$(DDK_LIB_PATH)\wdm.lib
!ELSE
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
!  IF defined (SUBSYSTEM_VERSION) && "$(SUBSYSTEM_VERSION)" < "$(SUBSYSTEM_601)"
TARGETLIB=$(CRT_LIB_PATH)\safecrtnt.lib $(SDK_LIB_PATH)\libcntpr.lib $(TARGETLIB)
!  ENDIF
!ENDIF

#
# Add Windows Driver Framework lib if it is a WDF export driver
#
!IF DEFINED(KMDF_VERSION_MAJOR)
TARGETLIB=$(TARGETLIB) \
          $(KMDF_LIB_PATH)\$(KMDF_VER_PATH)\WdfLdr.lib \
          $(KMDF_LIB_PATH)\$(KMDF_VER_PATH)\WdfDriverEntry.lib

!ENDIF

! ELSE
TARGETEXT=lib
TARGETLIB=
! ENDIF

!ELSEIF "$(TARGETTYPE)" == "HAL"
! IF "$(MAKEDLL)" != ""
TARGETEXT=dll
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib
! ELSE
TARGETEXT=lib
TARGETLIB=
! ENDIF

!ELSEIF "$(TARGETTYPE)" == "MINIPORT"
TARGETEXT=sys

!ELSEIF "$(TARGETTYPE)" == "GDI_DRIVER"

TARGETEXT=dll
TARGETLIB=$(DDK_LIB_PATH)\win32k.lib
!ifdef USE_LIBCNTPR_FOR_GDI_DRIVER_CRTS
TARGETLIB=$(SDK_LIB_PATH)\libcntpr.lib $(TARGETLIB)
!endif
!ENDIF # TARGETTYPE


!if !defined(INSTRUMENT_FOR_COVERAGE)
INSTRUMENT_FOR_COVERAGE=0
!endif


!if defined(BUILD_DEBUG)
!message MAKEDIR=$(MAKEDIR)
!message TARGETNAME=$(TARGETNAME)
!message TARGET_DESTINATION=$(TARGET_DESTINATION)
!message TEST_CODE=$(TEST_CODE)
!message TARGETEXT=$(TARGETEXT)
!message TARGETNAME=$(TARGETNAME)
!endif


_BINPLACE_LINK_RESULT = $@
_PRE_BBT_TARGET_DESTINATION=$(_TARGET_DESTINATION_WITHOUT_QUOTES)


!if $(FREEBUILD) \
    && defined(_NTTREE) \
    && defined(TARGET_DESTINATION) \
    && "$(IBC)" != "0" \
    && ("$(_TARGET_DESTINATION_WITHOUT_QUOTES::=)" == "$(_TARGET_DESTINATION_WITHOUT_QUOTES)") \
    && (exist($(BASEDIR)\bbt\$(_BUILDARCH)fre\ibc\$(TARGET_DESTINATION:retail=)\$(TARGETNAME).$(TARGETEXT)))

IBC_CMD= $(_PERL) $(BASEDIR)\bbt\bbtcountsgen\ibc.pl \
! if "$(_TARGET_DESTINATION_WITHOUT_QUOTES)" != "retail"
        /Destination:$(TARGET_DESTINATION) \
! endif
        /File:$@
!else
IBC_CMD=
!endif

TARGET=

!ifdef PASS1_NOLIB
!ifdef NTTARGETFILE1
USE_MAKEFILE_INC=1
!undef NTTARGETFILE1
!endif
!ifdef NTTARGETFILE2
USE_MAKEFILE_INC=1
!undef NTTARGETFILE2
!endif
!ifdef NTTARGETFILES
USE_MAKEFILE_INC=1
!undef NTTARGETFILES
!endif
!undef TARGETEXEFILES
!undef MISCFILES
!endif

!IF ("$(TARGETTYPE)" != "UMAPPL_NOLIB" && !defined(PASS1_NOLIB)) \
    && (("$(TARGETTYPE)" == "CATALOG") \
    || ("$(TARGETTYPE)" == "MSI") \
    || ("$(OBJECTS)" != "") \
    || (defined(_RES_FILE) && (("$(TARGETTYPE)" == "DRIVER") || ("$(TARGETTYPE)" == "PROGRAM") || ("$(TARGETTYPE)" == "DYNLINK") || ("$(TARGETTYPE)" == "EXPORT_DRIVER") || ("$(TARGETTYPE)" == "PROGLIB"))) \
    || defined(_TLBIMP) \
    || defined(NTKERNEL) \
    || (defined(_C_SHARP) && ("$(_MANAGED_SOURCES:.cs=)" != "$(_MANAGED_SOURCES)")) \
    || (defined(_VB) && ("$(_MANAGED_SOURCES:.vb=)" != "$(_MANAGED_SOURCES)")) \
    || ("$(OBJLIBFILES)" != "" && (("$(TARGETTYPE)" == "LIBRARY") || ("$(TARGETTYPE)" == "DRIVER_LIBRARY")))) \

TARGET=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)

!ELSE

!if !defined(PASS1_NOLIB) && "$(BUILD_PASS)" == "PASS1" && (("$(TARGETTYPE)" == "LIBRARY") || ("$(TARGETTYPE)" == "DRIVER_LIBRARY"))
!message error : No .lib/.dll/.exe/.sys is produced, at least for $(_BUILDARCH). Change TARGETTYPE to NOTARGET. Or possibly tag the directory not to build for $(_BUILDARCH).
!if "$(SOURCES: =)" == ""
!message error : You can probably also remove SOURCES=<empty> (try it).
!endif
!if defined(TARGETNAME) && !defined(SLS_LICENSING_MANIFEST)
!message error : You can often but not always also remove TARGETNAME (try it).
!endif
!error
!endif

!ENDIF

!if defined(SLS_LICENSING_MANIFEST) && !defined(TARGETNAME)
!error SLS_LICENSING_MANIFEST requires TARGETNAME.
!endif

!IFDEF NOTARGETLIB
TARGETLIB=
!ENDIF

!IFNDEF MACHINE_TARGETLIBS
MACHINE_TARGETLIBS=$(TARGETLIB) $(TARGETLIBS)
!ENDIF

!if (!defined(_C_SHARP) && !defined(_VB))
TARGETOBJFILES=$(TARGETOBJFILES) $(OBJECTS)
!ENDIF

# This allows us to call packthem /s to "sign" MST files
# after they're built and before they're binplaced
SIGN_THEME_FILE_CMD=
!if "$(SIGN_THEME_FILE)" == "1"
SIGN_THEME_FILE_CMD=SignTheme.cmd $(OBJ_PATH)\$(O) $@
!endif

#
# MUI LANGUAGE_NEUTRAL
#

!ifdef LANGUAGE_NEUTRAL


MUI = $(LANGUAGE_NEUTRAL)
MUI_COMMENT = LN_TEMPSUPPORT, LANGUAGE_NEUTRAL value being used to set MUI - this support will be removed soon
!endif

#
# Undefine these flags in case user has defined them accidentially. These flags are for internal use only in this file.
# They will be defined in this file.
#
!undef DO_LANGUAGE_NEUTRAL
!undef DO_LANGUAGE_NEUTRAL_DRV
!undef LANGUAGE_NEUTRAL_STS

!if "$(TARGETTYPE)" == "DRIVER"  || "$(TARGETTYPE)" == "DRIVER_LIBRARY" || "$(TARGETTYPE)" == "GDI_DRIVER"  || \
    "$(TARGETTYPE)" == "HAL"     || "$(TARGETTYPE)" == "EXPORT_DRIVER"  || "$(TARGETTYPE)" == "MINIPORT" || \
    (  ("$(MAJORCOMP)" == "ntos" || "$(MAJORCOMP)"  == "NTOS")  &&  "$(TARGETTYPE)" != "LIBRARY"  )
DO_LANGUAGE_NEUTRAL_DRV=1
!endif

#
# MUI_DRV is for forcing a user mode project to be treated as a driver.
# For example a printer notification dll shipped with printer driver.
#
!ifdef MUI_DRV
DO_LANGUAGE_NEUTRAL_DRV=1
!endif

#
# Now that we know how we'll be MUI splitting, do an extra check on LOCALIZE_BASE_FILE to be sure it's not being abused
#
!if "$(LOCALIZE_BASE_FILE)" == "1"
! if "$(DO_LANGUAGE_NEUTRAL_DRV)" == "1"
!message BUILDMSG: Warning: LOCALIZE_BASE_FILE should only be used if you are doing kernel-mode style MUI splitting : $(MAKEDIR)
! endif
!endif

#
# If user explicitely disables MUI then they must also define MUI_COMMENT
# and put justification as why he disabled MUI, otherwise we'll output error.
#
!if  "$(MUI)" != "1"
!  if "$(MUI)" == "0"
!    ifdef MUI_COMMENT
LANGUAGE_NEUTRAL_STS=LGNSTS_MUIOFF
!    else
!      ERROR MUI split disabling by setting MUI=0 requires a detailed explanation justifying this decision.  Please add one in the form "MUI_COMMENT=" to your sources file.
!    endif
!  else
!    ERROR MUI=$(MUI); MUI must be set to 1 or 0.
!  endif
!endif #MUI != "1"

#
# If MUI is enabled we still check if the project is of valid type for MUIzation.
# The project must be UNMANAGED code.
#
!if  "$(MUI)" == "1"
! if ( defined(DO_LANGUAGE_NEUTRAL_DRV) || "$(TARGETTYPE)" == "PROGRAM" || \
       "$(TARGETTYPE)" == "PROGLIB"     || "$(TARGETTYPE)" == "DYNLINK" || \
     ( "$(TARGETTYPE)" == "NOTARGET" && \
        ( defined(MISCFILES)                 || defined(LANG_MISCFILES)       || \
          defined(MULTI_MISCFILES)           || defined(MULTI_MUI_MISCFILES)  || \
          defined(LOC_MISCFILES)             || defined(LOC_MUI_MISCFILES)    || \
          defined(PRELOC_MISCFILES)          || defined(PRELOC_MUI_MISCFILES) || \
          defined(PRELOC_MUI_ONLY_MISCFILES) || defined(PASS0_BINPLACE)       || \
          defined(PASS1_BINPLACE)            || defined(PASS2_BINPLACE) ) ) ) && \
     ( !defined(_C_SHARP) && !defined(_VB) )
DO_LANGUAGE_NEUTRAL=1
LANGUAGE_NEUTRAL_STS=LGNSTS_UNKNOWN
!  ELSE
!      if  "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "DYNLINK"
LANGUAGE_NEUTRAL_STS=LGNSTS_MANAGED
!      endif
!      if  "$(TARGETTYPE)" == "DRIVER" || "$(TARGETTYPE)" == "GDI_DRIVER" || "$(TARGETTYPE)" == "EXPORT_DRIVER"  || "$(TARGETTYPE)" == "HAL" || "$(TARGETTYPE)" == "MINIPORT"
LANGUAGE_NEUTRAL_STS=LGNSTS_KERNEL
!      endif
!  ENDIF
!ENDIF  #MUI == "1"

LANGUAGE_NEUTRAL_RESDIR=$(LOC_BIN)

#
# MUI Manifest
#
!ifdef DO_LANGUAGE_NEUTRAL
! ifndef DO_LANGUAGE_NEUTRAL_DRV
RC_CONFIG_ROOT_SOURCE=$(NTMAKEENV)\MUI.RCConfig
! else
RC_CONFIG_ROOT_SOURCE=$(NTMAKEENV)\MUI_DRV.RCConfig
! endif

RC_CONFIG_ROOT=$(NTMAKEENV)
! ifndef RC_CONFIG
!  ifndef DO_LANGUAGE_NEUTRAL_DRV
!   ifndef MUI_BIDI_IMG
RC_CONFIG=MUI.RCConfig
!   else
RC_CONFIG=MUI_BIDI_IMG.RCConfig
!   endif
!  else
!   ifndef MUI_BIDI_IMG
RC_CONFIG=MUI_DRV.RCConfig
!   else
RC_CONFIG=MUI_DRV_BIDI_IMG.RCConfig
!   endif
!  endif
! endif #ndef RC_CONFIG


# Lowercase the name
RC_CONFIG_LOWERCASE=$(RC_CONFIG)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:A=a)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:B=b)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:C=c)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:D=d)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:E=e)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:F=f)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:G=g)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:H=h)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:I=i)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:J=j)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:K=k)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:L=l)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:M=m)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:N=n)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:O=o)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:P=p)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:Q=q)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:R=r)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:S=s)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:T=t)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:U=u)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:V=v)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:W=w)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:X=x)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:Y=y)
RC_CONFIG_LOWERCASE=$(RC_CONFIG_LOWERCASE:Z=z)

# Create the variants we need
RC_CONFIG_SOURCE_FILENAME=$(RC_CONFIG_LOWERCASE:..\=)
RC_CONFIG_BASENAME=$(RC_CONFIG_SOURCE_FILENAME)
RC_CONFIG_BASENAME=$(RC_CONFIG_BASENAME:.muimanifest=)
RC_CONFIG_BASENAME=$(RC_CONFIG_BASENAME:.rcconfig=)


!ifdef DELTA_RC_CONFIG
DELTA_RC_CONFIG_BASENAME=$(DELTA_RC_CONFIG:.muimanifest=)
DELTA_RC_CONFIG_BASENAME=$(DELTA_RC_CONFIG:.rcconfig=)
RC_CONFIG_OBJ2=$(OBJ_PATH)\$O\$(DELTA_RC_CONFIG_BASENAME).drcc
!endif
RC_CONFIG_OBJ1=$(OBJ_PATH)\$O\$(RC_CONFIG_BASENAME).rcc

MAKE_RC_CONFIG_CMD=nmake.exe /nologo /f $(NTMAKEENV)\makefile.def $(RC_CONFIG_OBJ1)
MAKE_DELTA_RC_CONFIG_CMD=nmake.exe /nologo /f $(NTMAKEENV)\makefile.def $(RC_CONFIG_OBJ2)
RC_CONFIG_DEFINES=
RC_CONFIG_PREPROCESSOR_NAME=preprocessor
! if "$(TARGETTYPE)" != "NOTARGET"
LANGUAGE_NEUTRAL_RESOURCE = -q $(RC_CONFIG_OBJ1)
!     ifdef MUI_ALWAYS_SPLIT_VERSION
LANGUAGE_NEUTRAL_RESOURCE = $(LANGUAGE_NEUTRAL_RESOURCE) -g1
!     endif
!     ifdef DELTA_RC_CONFIG
LANGUAGE_NEUTRAL_RESOURCE = $(LANGUAGE_NEUTRAL_RESOURCE) -qq $(RC_CONFIG_OBJ2)
!     endif
! else
LANGUAGE_NEUTRAL_RESOURCE=
! endif

LANGUAGE_NEUTRAL_RESOURCE_MUIRCT = /q $(RC_CONFIG_OBJ1)
!    ifdef MUI_ALWAYS_SPLIT_VERSION
LANGUAGE_NEUTRAL_RESOURCE_MUIRCT = $(LANGUAGE_NEUTRAL_RESOURCE_MUIRCT) /f
!    endif

!else

MAKE_RC_CONFIG_CMD=
MAKE_DELTA_RC_CONFIG_CMD=
LANGUAGE_NEUTRAL_RESOURCE=
LANGUAGE_NEUTRAL_RESOURCE_MUIRCT=
!endif #defined DO_LANGUAGE_NEUTRAL


#
# Lsbuild.exe section
#

#
# Decide if we need to extract resource comments while compiling the resources.
# This is similar to setting BUILD_LCG.
#
# We will create LCE files if:
#
# - one of the following is true:
#   - The developer specifies BUILD_LCE_FILE=1 in their sources file
#   - We are NOT building test code
# - DO_LSBUILD=1
#
LCE_FILE=$(OBJ_PATH)\$O\$(TARGETNAME).lce
!if "$(BUILD_LCE_FILE)" != ""
!message LCG: BUILD_LCE_FILE: $(BUILD_LCE_FILE)
! if "$(BUILD_LCE_FILE)" != "1" && "$(BUILD_LCE_FILE)" != "0"
!  error BUILD_LCE_FILE must be empty, 1, or 0
! endif

!elseif defined(TEST_CODE)
BUILD_LCE_FILE=0

!else
BUILD_LCE_FILE=1

!endif

# If DO_LSBUILD is turned off, don't create LCE files
!if "$(DO_LSBUILD)" != "1"
BUILD_LCE_FILE=0
!endif




#
# Only perform LSBUILD-related operations if the LS option is passed to Razzle
#
!if "$(DO_LSBUILD)" == "1"

# If they did not supply an LCI file, look for one in the default place/name
!if defined(LCI_FILE)
! if !exist($(LCI_FILE))
!  error LCI_DEPEND does not exist : $(LCI_DEPEND)
! else
LCI_DEPEND=$(LCI_FILE)
! endif
!else
LCI_DEPEND=$(TARGETNAME).$(TARGETEXT).lci
!endif

# Stuff we use in multiple places
LCG_DEPEND=
MUIRES_DEPEND=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).muires



# We will create LCG files if:
#
# - We are in PASS2 or PASSALL and have a target
#    or PASS1 and building a RESOURCE_ONLY_DLL
# - one of the following is true:
#   - The developer specifies BUILD_LCG=1 in their sources file
#   - The developer specifies LCG_SOURCE=foo.bar in their sources file
#   - We are NOT building test code
#   - MUI splitting is being done
#     - A .muires file was created
#     - We can find the .res file(s) specified by MYMUILINK
#   - There is an developer-supplied LCI file present
#   - An LCE file was created by the resource compiler
#
!if ("$(BUILD_PASS)" == "PASS2" \
        || "$(BUILD_PASS)" == "PASSALL" \
        || ("$(BUILD_PASS)" == "PASS1" && defined(RESOURCE_ONLY_DLL)) \
        ) \
    && "$(TARGETTYPE)" != "NOTARGET" && "$(TARGETNAME)" != ""

! if "$(BUILD_LCG)" != ""
!message LCG: BUILD_LCG: $(BUILD_LCG)
!  if "$(BUILD_LCG)" != "1" && "$(BUILD_LCG)" != "0"
!    error BUILD_LCG must be empty, 1, or 0
!  endif
! endif

! if "$(BUILD_LCG)" == "0"
# Nothing to do except prevent entering the if/else chain below

! elseif "$(BUILD_LCG)" == "1"

# It was set forcibly by the user, make sure we set MUI_DEPEND correctly
!  if defined(DO_LANGUAGE_NEUTRAL)

# MUI dependancies must be the first ones we look for so that we set MUI_DEPEND
# properly - the LCI and LCE dependancies will get added automatically later on.
!   if exist($(MUIRES_DEPEND))
MUI_DEPEND=$(MUIRES_DEPEND)

# Note that we do not check for existance - this could be multiple files.
# We rely on the MUI code to create the *.notloc file if needed and we
# explicitly look for it in CreateLCGFile.pl.
!   elseif "$(MYMUILINK)" != ""
MUI_DEPEND=$(MYMUILINK)

!   endif # MUIRES_DEPEND
!  endif # DO_LANGUAGE_NEUTRAL

! elseif "$(LCG_SOURCE)" != ""
BUILD_LCG=1

! elseif defined(TEST_CODE)
BUILD_LCG=0

! elseif defined(DO_LANGUAGE_NEUTRAL)

# MUI dependancies must be the first ones we look for so that we set MUI_DEPEND
# properly - the LCI and LCE dependancies will get added automatically later on.
!  if exist($(MUIRES_DEPEND))
MUI_DEPEND=$(MUIRES_DEPEND)
BUILD_LCG=1

# Note that we do not check for existance - this could be multiple files.
# We rely on the MUI code to create the *.notloc file if needed and we
# explicitly look for it in CreateLCGFile.pl.
!  elseif "$(MYMUILINK)" != ""
MUI_DEPEND=$(MYMUILINK)
BUILD_LCG=1

!  elseif exist($(LCI_DEPEND))
BUILD_LCG=1

!  elseif exist($(LCE_FILE))
BUILD_LCG=1

!  else
BUILD_LCG=0

!  endif

! else
BUILD_LCG=0

! endif # DO_LANGUAGE_NEUTRAL

!else
BUILD_LCG=0

!endif


#
# If we are supposed to create an LCG, decide what we depend on for makefile rules and what our source/input file is
#
!if "$(BUILD_LCG)" == "1"

# If they set LCG_SOURCE, we use that for both LCG_DEPEND and LCG_SOURCE.
!if "$(LCG_SOURCE)" != ""
!message LCG: Using LCG_SOURCE to set LCG_TARGET and LCG_DEPEND
LCG_DEPEND=$(LCG_SOURCE)
LCG_TARGET=$(LCG_SOURCE).lcg


# If MUI splitting is being done (the normal case for non-managed code with win32 resources),
# we use the same file as MUI for LCG_DEPEND and the .MUI file for LCG_SOURCE.
!elseif "$(MUI_DEPEND)" != ""
!message LCG: Using MUI_DEPEND to set LCG_TARGET and LCG_DEPEND
LCG_DEPEND=$(MUI_DEPEND)
LCG_SOURCE=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT).mui
LCG_TARGET=$(OBJ_PATH)\$O\$(TARGETNAME).$(TARGETEXT).mui.lcg

# Use the non-MUI stuff if it is defined and depend on $(TARGET) as well as using it for the source.
!elseif "$(TARGET)" != ""
!message LCG: Using TARGET to set LCG_TARGET and LCG_DEPEND
LCG_DEPEND=$(TARGET)
LCG_SOURCE=$(TARGET)
LCG_TARGET=$(OBJ_PATH)\$O\$(TARGETNAME).$(TARGETEXT).lcg

!endif


# If we have an LCG_SOURCE, add in any extra dependancies we can find
!if "$(LCG_SOURCE)" != ""

# If it exists, we have a dependency on the lci (dev supplied comments) file
!if exist($(LCI_DEPEND))
!message LCG: Adding LCI dependency: $(LCI_DEPEND)
LCG_DEPEND=$(LCG_DEPEND) $(LCI_DEPEND)
!endif

# If we are creating an LCE file, add a dependency on the lce (resource compiler extracted comments) file
!if "$(BUILD_LCE_FILE)" == "1"
!message LCG: Adding LCE dependency: $(LCE_FILE)
LCG_DEPEND=$(LCG_DEPEND) $(LCE_FILE)
LSBUILD_LCE_OPTION=/e:$(LCE_FILE)
!else
LSBUILD_LCE_OPTION=
!endif

!endif # LCG_SOURCE

!message LCG_SOURCE: $(LCG_SOURCE)
!message LCG_DEPEND: $(LCG_DEPEND)
!message LCG_TARGET: $(LCG_TARGET)

!endif # BUILD_LCG

!endif # DO_LSBUILD


# Support for localizing the file we just linked
LOCALIZE_BASE_FILE_CMD=

!if "$(LOCALIZE_BASE_FILE)" == "1"
! if defined(DO_LSBUILD)

LOCALIZE_BASE_FILE_CMD=\
    $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /g:$@.lcg \
        /f:$@ \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!  ifndef NO_BINPLACE
        /b:$@.binplace.txt \
        /r:$(LCG_BINPLACE_TARGET) \
!  endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
! endif # DO_LSBUILD

!endif # LOCALIZE_BASE_FILE


#
# End of Lsbuild.exe rules/definitions
#




!IF "$(NOLINK)" == "" ||                                     \
    ("$(NOLINK)" != "" && !defined(PASS1_NOLIB) && ("$(TARGETTYPE)" == "LIBRARY" ||     \
                        (   ("$(TARGETTYPE)" == "DYNLINK" ||   \
                         "$(TARGETTYPE)" == "PROGLIB" || \
                         "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
                         "$(TARGETTYPE)" == "HAL")    &&       \
                            "$(MAKEDLL)" == "")              \
                           )                                 \
    )


! IF "$(NOLINK)" != "" && "$(TARGET)" != ""
!  ifndef NO_DLL_EXPORTS
TARGETLIBFILES=$(TARGETLIBFILES) $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
!  endif
! ELSE
TARGETEXEFILES=$(TARGETEXEFILES) $(TARGET)
! ENDIF

!ENDIF # NOLINK == "" || building .lib file for dll

!if "$(UMAPPL)" == ""
# Turn off UMEXEFILES/UMOBJFILES (handles case where it's conditional in sources file
# and build doesn't realize it when generating _objects.mac).
UMEXEFILES=
UMOBJFILES=
!endif

!IF defined(NTKERNEL)

TARGETOBJFILES=$(TARGETOBJFILES) $(OBJ_PATH)\$O\$(NTKERNEL).obj

! IFNDEF NOLINK

TARGETEXEFILES=$(TARGETEXEFILES) $(OBJ_PATH)\$O\$(NTKERNEL).exe

! ENDIF # NDEF NOLINK
!ENDIF # NTKERNEL

!IFDEF USE_LINT
! IFNDEF LINT_OUTPUT
LINT_OUTPUT=$(TARGETNAME)
! ENDIF
! IFNDEF LINT_EXT
LINT_EXT=tmp
! ENDIF
! IF "$(LINT_TYPE)" == "all"
TARGETLOBFILES1=
TARGETLOBFILES2=$(OBJ_PATH)\$O\$(LINT_OUTPUT).$(LINT_EXT)
! ELSEIF "$(LINT_TYPE)" == "lob"
TARGETLOBFILES1=$(TARGETOBJFILES:.obj=.lob)
TARGETLOBFILES2=
! ELSE
TARGETLOBFILES1=
TARGETLOBFILES2=$(TARGETOBJFILES:.obj=.lob)
! ENDIF
!ELSE
TARGETLOBFILES1=
TARGETLOBFILES2=
!ENDIF

#
# Define NT_UP as 0 in environment to turn on MP.
# If undefined or equal to 1, you get UP.
#

!IFNDEF NT_UP
NT_UP=1
!ENDIF

!IF "$(NT_UP)" == "0"
NT_UP_DEFINES=
!ELSE
NT_UP_DEFINES=/DNT_UP=1
!ENDIF

!IFNDEF NT_INST
NT_INST=0
!ENDIF

#
# User defined variables (environment variables or command line).
# A cpu specific definition will take precedence over the MSC definition.
#
# xxx_WARNING_LEVEL
# xxx_OPTIMIZATION
# xxx_CPPFLAGS
#

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF

#
# End of user defined variables.
#

STD_DEFINES=/DCONDITION_HANDLING=1 $(NT_UP_DEFINES) \
            /DNT_INST=$(NT_INST) $(WIN32_DEFINE) $(NT_PNP_POWER_DEFINES) \
            $(NT_PNP_STUB_DEFINES)

!IFNDEF NOT_LEAN_AND_MEAN
STD_DEFINES = $(STD_DEFINES) /DWIN32_LEAN_AND_MEAN=1
!ENDIF

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) /DDEVL=1 /DDBG=1
!else
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) /DDEVL=1
!endif

!if !defined(RESOURCE_ONLY_DLL) || \
    ("$(NTDEBUG)" == "ntsd") || \
    ("$(NTDEBUG)" == "ntsdnodbg") || \
    ("$(NTDEBUG)" == "cvp") || \
    ("$(NTDEBUG)" == "sym")
DBGFLAGS=/Zi
!else
DBGFLAGS=
!endif

!ifndef __BUILDMACHINE__
__BUILDMACHINE__=$(USERNAME: =)
!endif
!if exist ($(OBJECT_ROOT)\$O\__blddate__)
!include $(OBJECT_ROOT)\$O\__blddate__
!endif
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES)\
!ifdef BUILDDATE
    /D__BUILDDATE__=$(BUILDDATE)\
!endif
    /D__BUILDMACHINE__=$(__BUILDMACHINE__)

!IF "$(PRECOMPILED_OPTION)" == ""
! IF "$(PRECOMPILED_INCLUDE)" != ""
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.hxx=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.hpp=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.cxx=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.cpp=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_PCH)" == ""
PRECOMPILED_PCH=$(PRECOMPILED_INCLUDE_BASENAME:.hxx=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.hpp=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.h=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.cxx=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.cpp=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.c=.pch)
!  ENDIF
!  IF "$(PRECOMPILED_OBJ)" == ""
PRECOMPILED_OBJ=$(PRECOMPILED_PCH:.pch=.obj)
!  ENDIF
! ENDIF
!ENDIF

!IF "$(PRECOMPILED_OPTION)" == ""
! IF "$(PRECOMPILED_INCLUDE)" != ""
!  IF "$(PRECOMPILED_PCH)" != ""
!    if $(USE_OBJECT_ROOT)
HEADERFILE=/Fp$(OBJ_PATH)\$O\$(PRECOMPILED_PCH)
!    else
HEADERFILE=/Fp$O\$(PRECOMPILED_PCH)
!    endif
!  ENDIF
!  IF "$(PRECOMPILED_OBJ)" != ""
!    if $(USE_OBJECT_ROOT)
HEADEROBJNAME=$(OBJ_PATH)\$O\$(PRECOMPILED_OBJ)
!    else
HEADEROBJNAME=$O\$(PRECOMPILED_OBJ)
!    endif
HEADEROBJ=/Fo"$(HEADEROBJNAME)"
!  ENDIF

!   IF "$(PRECOMPILED_CXX)" == ""
PRECOMPILED=/Yu$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE)
PRECOMPILED_CXX=
!   ELSE
PRECOMPILED=
PRECOMPILED_CXX=/Yu$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE)
!   ENDIF
!   if $(USE_OBJECT_ROOT)
PRECOMPILED_TARGET=$(OBJ_PATH)\$O\$(PRECOMPILED_PCH)
!   else
PRECOMPILED_TARGET=$O\$(PRECOMPILED_PCH)
!   endif
! ELSE
PRECOMPILED=
PRECOMPILED_CXX=
! ENDIF
!ELSE
! IF "$(PRECOMPILED_CXX)" == ""
PRECOMPILED=$(PRECOMPILED_OPTION)
PRECOMPILED_CXX=
! ELSE
PRECOMPILED=
PRECOMPILED_CXX=$(PRECOMPILED_OPTION)
! ENDIF
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET)
! IF "$(PRECOMPILED_TARGET)" != ""
HEADERFILE=/Fp$(PRECOMPILED_TARGET)
! ENDIF
! IF "$(PRECOMPILED_OBJ)" != ""
HEADEROBJNAME=$(PRECOMPILED_OBJ)
HEADEROBJ=/Fo$(HEADEROBJNAME)
! ENDIF
!ENDIF

!IF "$(NTNOPCH)" != ""
# Need to do this conditionally.  If the pch obj exists, it's likely existing files
# reference it (ie: this isn't a clean build).  Keep the file ref but delete the
# pch stuff so links will work.
!ifdef HEADEROBJNAME
!if !exist($(HEADEROBJNAME))
HEADEROBJNAME=
HEADEROBJ=
PRECOMPILED_OBJ=
!if [del $(OBJ_PATH)\$O\_headerobjname.inc 2>nul]
!endif
!else
#
# Clearing PRECOMPILED_PCH below makes the delayed evaluation of HEADEROBJNAME
# be just objfre\i386\, which nmake complains it does not know how to make,
# and which causes stdinc.obj to not be put in the .lib.
#
# Force the evaluation of HEADEROBJNAME.
#
!if [-mkdir $(OBJ_PATH)\$O >nul 2>&1] && [echo HEADEROBJNAME=$(HEADEROBJNAME) > $(OBJ_PATH)\$O\_headerobjname.inc]
!endif
!endif
!endif
PRECOMPILED=
PRECOMPILED_CXX=
PRECOMPILED_INCLUDE=
PRECOMPILED_TARGET=
PRECOMPILED_PCH=
!if defined(HEADEROBJNAME) && exist($(OBJ_PATH)\$O\_headerobjname.inc)
!include $(OBJ_PATH)\$O\_headerobjname.inc
!endif
!ENDIF

!ifdef USECXX_FLAG
USECXX_FLAG=/TP
#!if "$(URT_VER)" >= "2"
# Why doesn't this work here?
# Every assignment to MANAGED_CXX_FLAGS precedes here (if that even matters).
#C_COMPILER_FLAGS_NOPCH=$(C_COMPILER_FLAGS_NOPCH) $(MANAGED_CXX_FLAGS)
#!endif
!endif

!IF ("$(PRECOMPILED_CXX)" == "") && ("$(USECXX_FLAG)" == "")
PRECOMPILED_FLAG=$(PRECOMPILED_FLAG) /Tc
!ELSE
PRECOMPILED_FLAG=$(PRECOMPILED_FLAG) /Tp
!ENDIF


#
# Set linker options
#

#
# Merge _PAGE with PAGE, _TEXT with .text, and make sure
# INIT sections are discardable
#

!ifdef LINKER_NOREF
LINK_REF_FLAG=/OPT:NOREF /OPT:NOICF
!else
! ifdef LINKER_NOICF
LINK_REF_FLAG=/OPT:REF /OPT:NOICF
! else
LINK_REF_FLAG=/OPT:REF /OPT:ICF
! endif
!endif

!ifdef NOT_TERMINAL_SERVER_AWARE
TSLINKER_FLAG=
!else
!       if $(_NT_TOOLS_VERSION) >= 0x700
TSLINKER_FLAG=/tsaware
!       else
TSLINKER_FLAG=
!       endif
!endif

!if $(_NT_TOOLS_VERSION) >= 0x800
DYNAMICBASE_FLAG=/dynamicbase
!else
DYNAMICBASE_FLAG=
!endif

#
# warning LNK4010: invalid subsystem version number 4.00; default subsystem version assumed (\nt\sdktools\build)
# warning LNK4039: section 'INIT' specified with /SECTION option does not exist (\nt\sdktools\build)
# warning LNK4078: multiple 'INIT' sections found with different attributes (E2000020) (\nt\base\boot\bldr\daytona)
# warning LNK4070: /OUT: directive in .EXP differs from output filename ignoring directive (\nt\base\ntos\init\mp)
# warning LNK4221: no public symbols found; archive member will be inaccessible
#
DEFAULT_LINK_LIB_IGNORE=4010,4037,4039,4065,4070,4078,4087,4089,4221
!if "$(BUILD_PRODUCT)" == "NT" || defined(LINK_ALLOW_MISSING_BASE_ADDRESS)
# Missing base address not interesting for OS (entire product rebased at postbuild time)
DEFAULT_LINK_LIB_IGNORE=$(DEFAULT_LINK_LIB_IGNORE),4198
!endif

!ifdef LINK_LIB_IGNORE
LINK_LIB_IGNORE_FLAG=/IGNORE:$(LINK_LIB_IGNORE),$(DEFAULT_LINK_LIB_IGNORE)
!else
LINK_LIB_IGNORE_FLAG=/IGNORE:$(DEFAULT_LINK_LIB_IGNORE)
!endif

!IF $(IA64) || $(AMD64)
LINK_LIB_IGNORE_FLAG= $(LINK_LIB_IGNORE_FLAG),4108,4088,4218
!ENDIF

!if "$(TARGETTYPE)" == "DYNLINK" && defined(RESOURCE_ONLY_DLL)
# LNK6036, LNK1263, LNK1264 - Don't do LTCG or POGO on resource only dll.
FORCENATIVEOBJECT=1
!endif

!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# 4218: non-native module found; restarting link with /LTCG
# 4235: /LTCG specified but no code generation required; remove /LTCG from the link command line to improve linker performance
LINK_LIB_IGNORE_FLAG= $(LINK_LIB_IGNORE_FLAG),4218,4235
!endif

!ifdef _UMAPPL_LINK_LIB_IGNORE_DUPLICATE_DOWNLEVEL_LIBC_OBJ_SPECIFIED_MORE_THAN_ONCE
LINK_LIB_IGNORE_FLAG=$(LINK_LIB_IGNORE_FLAG),4042
!endif

!ifdef LINK_NO_RELEASE
LINK_RELEASE=
!else
LINK_RELEASE=/release
!endif

!ifdef LARGE_ADDRESS_AWARE
LINKER_FLAGS = $(LINKER_FLAGS) /LARGEADDRESSAWARE
!endif

!ifdef DISABLE_HEAP_TERMINATE
! if ("$(SUBSYSTEM_VERSIONX)" < "6.00")
!error DISABLE_HEAP_TERMINATE only relevent for V6 or higher apps
! else
LINKER_FLAGS = $(LINKER_FLAGS) $(BASE_LIB_PATH)\HeapTerminateDisableV6.obj
! endif
!endif

!ifdef USE_INCREMENTAL_LINKING
LINK_INCREMENTAL_FLAG = /OPT:NOREF \
                        $(LINK_LIB_IGNORE_FLAG)
!else
LINK_INCREMENTAL_FLAG = $(LINK_REF_FLAG) \
                        $(LINK_LIB_IGNORE_FLAG) \
                        /INCREMENTAL:NO \
                        $(LINK_RELEASE)
!endif

LINKER_FLAGS =  $(LINKER_FLAGS) \
                /MERGE:_PAGE=PAGE \
                /MERGE:_TEXT=.text \
                /SECTION:INIT,d \
                $(LINK_INCREMENTAL_FLAG) \
                /NODEFAULTLIB

LINKER_FLAGS=$(LINKER_FLAGS) $(LINKER_WX_SWITCH)

!ifdef LINK_DEBUG
!if "$(LINK_DEBUG)" == ""
LINK_DEBUG=/VERBOSE
!endif
LINKER_FLAGS=$(LINKER_FLAGS) $(LINK_DEBUG)
!endif


LINK_OS_VERSIONS = /version:$(LINKER_APP_VERSION) /osversion:$(LINKER_OS_VERSION)
LINKER_FLAGS = $(LINKER_FLAGS) $(LINKER_DBG_SECTION) $(LINK_OS_VERSIONS)
LIBRARIAN_FLAGS = $(LINK_LIB_IGNORE_FLAG) $(LIBRARIAN_FLAGS) $(LINKER_WX_SWITCH) /nodefaultlib
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) /machine:$(MACHINE_TYPE)

LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS =
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS = /ltcg
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) $(LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS)
!endif

!ifdef DO_LANGUAGE_NEUTRAL
LANGUAGE_NEUTRAL_LINK_FLAG= /WX /noentry /NXCOMPAT /DYNAMICBASE /dll /nodefaultlib $(LINK_OS_VERSIONS) /machine:$(MACHINE_TYPE)
!    ifdef LARGE_ADDRESS_AWARE
LANGUAGE_NEUTRAL_LINK_FLAG = $(LANGUAGE_NEUTRAL_LINK_FLAG) /LARGEADDRESSAWARE
!    endif
!else
LANGUAGE_NEUTRAL_LINK_FLAG=
!endif

!ifndef LIB_NAME
LIB_NAME=$(LINK_NAME) /lib
!endif

LIBRARIAN=$(LIB_NAME) /out:$@ $(LIBRARIAN_FLAGS)

!ifndef LINK_NAME
! ifdef SUBSTITUTE_LINK
LINK_NAME=$(SUBSTITUTE_LINK)
! else
LINK_NAME=link.exe
! endif
!endif

LINKER=$(LINK_NAME) /out:$@ /machine:$(MACHINE_TYPE)

#
# SXS_PDB_NAMER is a file built in the obj directory, containing a /pdb flag for LINKER
#     eg: /pdb:obj\i386\MicrosoftWindowsGdiPlus-1.0.3790.127-gdiplus.pdb
# The pdb file name is derived from ntverp.h, $O, $(SXS_PDB_WOW6432_W_PREFIX)
# $(SXS_ASSEMBLY_NAME) and $(TARGETNAME)
# SXS_PDB_NAMER is not always used, but is always built if SXS_MANIFEST_OBJ1 is built.
#
_LINKER=$(LINK_NAME) /out:$@ \
!ifdef SXS_PDB_NAMER
    @$(SXS_PDB_NAMER) \
!endif
    /machine:$(MACHINE_TYPE)

!if defined(NTPROFILEINPUT) && ("$(TARGETTYPE)" == "LIBRARY")
! message NTPROFILEINPUT should be removed in: $(MAKEDIR).
!endif

!IF defined(NTPROFILEINPUT) || defined(EXEPROFILEINPUT)
ORDER=-order:@$(@B).prf
!ENDIF

!IFDEF DLLORDER
ORDER=-order:@$(DLLORDER)
!ENDIF

!if "$(SUBSYSTEM_NATVER)" < "5.02"
! ifndef DRIVER_ALIGNMENT
DRIVER_ALIGNMENT=0x80
! endif
! ifndef HAL_ALIGNMENT
HAL_ALIGNMENT=0x80
! endif
! ifndef KERNEL_ALIGNMENT
KERNEL_ALIGNMENT=0x80
! endif
!endif

!if $(AMD64)
!ifdef DRIVER_ALIGNMENT
DRIVER_ALIGN_SWITCH=/align:$(DRIVER_ALIGNMENT)
!endif
!ifdef HAL_ALIGNMENT
HAL_ALIGN_SWITCH=/align:$(HAL_ALIGNMENT)
!endif
!ifdef KERNEL_ALIGNMENT
KERNEL_ALIGN_SWITCH=/align:$(KERNEL_ALIGNMENT)
!endif
!else
!ifdef DRIVER_ALIGNMENT
DRIVER_ALIGN_SWITCH=/align:$(DRIVER_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!ifdef HAL_ALIGNMENT
HAL_ALIGN_SWITCH=/align:$(HAL_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!ifdef KERNEL_ALIGNMENT
KERNEL_ALIGN_SWITCH=/align:$(KERNEL_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!endif

#
# [GorN] 3/30/2000
#
#    WPP section (WMI tracing preprocessor)
#
#    env. vars:
#
#    RUN_WPP=list of files to run wpp on
#    WPP_REVISION=override default revision
#


!ifndef WPP_REVISION
WPP_REVISION=rev1
!endif

!ifndef WPP_NAME
WPP_NAME=tracewpp
!endif

!if $(ANSI_ANNOTATION)
WPP_MAKEFILE_FLAGS=/DWPP_ANSI_ANNOTATION
!endif

!ifdef RUN_WPP
RUN_WPP=$(WPP_MAKEFILE_FLAGS) -cfgdir:$(WPP_CONFIG_PATH)\$(WPP_REVISION) -odir:$(OBJ_PATH)\$O $(RUN_WPP)


#  execute wpp now

!  if [-$(WPP_NAME) $(RUN_WPP)]
!  endif

!  if exist(obj\_tracewpp.mac)
!     include obj\_tracewpp.mac
WPP_TARGETS=$(WPP_EXTRA_TARGETS)
!  endif
BINPLACE_FLAGS = $(BINPLACE_FLAGS) /:TMF
C_DEFINES=$(C_DEFINES) /DRUN_WPP
!else
WPP_TARGETS=
!endif

!ifdef USE_LINT
LINT_DEFS=$(CDEFINES:-D=-d)
LINT_DEFINES=$(LINT_DEFS:/D=-d)
! ifndef LINT_PATH
LINT_PATH=$(BASEDIR)\lint
! endif
! ifndef LINT_APP
LINT_APP=$(LINT_PATH)\lint-nt
! endif
!ifndef LINT_OPTS
LINT_OPTS=+v -zero
!endif
! if "$(LINT_TYPE)" == "all"
!  ifndef LINT_ALL_CMD
LINT_ALL_CMD=$(LINT_APP) $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt -os($(OBJ_PATH)\$O\$(LINT_OUTPUT).$(LINT_EXT))
!  endif
! else
!  if "$(LINT_TYPE)" == "lob"
!   ifndef LINT_CMD
LINT_CMD=$(LINT_APP) -u $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt +os($(OBJ_PATH)\$O\$(LINT_OUTPUT).$(LINT_EXT)) -oo($@)
!   endif
!   ifndef LINT_CMD2
LINT_CMD2=$(LINT_APP) $(LINT_OPTS) -i$(LINT_PATH)\ std.lnt +os($(OBJ_PATH)\$O\$(LINT_OUTPUT).$(LINT_EXT)) $(OBJ_PATH)\$O\*.lob
!   endif
!  else
!   ifndef LINT_CMD
LINT_CMD=$(LINT_APP) $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt +os($(OBJ_PATH)\$O\$(LINT_OUTPUT).$(LINT_EXT))
!   endif
!  endif
! endif
!else
LINT_CMD2=
!endif

!ifndef LINT_CMD2
LINT_CMD2=
!endif

#
# Standard inference rules for C files that produce object files.
#

.SUFFIXES:
.SUFFIXES: .asm .asmx .c .class .cs .cpp .cxx .exe .f .java .obj .odl .p .rc .rcpp .res .resx .resz .resources .s .sdl .tdl .thk .txt .vb

#
# Processor specific control and options.
#

#
# cl.exe now defaults to /GS, so BO_FLAGS must explicitly default to /GS-
#
BO_FLAGS=/GS-

DRIVER_ENTRY=DriverEntry
GDI_DRIVER_ENTRY=DrvEnableDriver

!if defined(KMDF_VERSION_MAJOR)
BUFFER_OVERFLOW_CHECKS=1
!endif


!if ("$(TARGETPATH)" == "obj" \
    || "$(TARGETPATH)" == "$(_OBJ_DIR)" \
    || "$(TARGETPATH)" == "$(OBJ_PATH)\$(_OBJ_DIR)" \
    ) \
    && "$(TARGETTYPE)" != "LIBRARY" \
    && "$(TARGETTYPE)" != "NOTARGET" \
    && !defined(PASS1_PUBLISH) \
    && !defined(PRECOMPILED_OPTION) \
    && !defined(USE_PDB_TO_COMPILE) \
    && "$(POGO_INSTRUMENT)" != "1"
USE_PDB_TO_COMPILE=1
!endif

!if defined(USE_PDB_TO_COMPILE) && "$(USE_PDB_TO_COMPILE)" != "0" && "$(USE_PDB_TO_COMPILE)" != "1"
! error USE_PDB_TO_COMPILE must be 0 or 1 or not defined.
!endif

!endif # PASS_INDEPENDENT_TARGETS

!include $(NTMAKEENV)\$(TARGET_DIRECTORY)mk.inc

!ifndef PASS_INDEPENDENT_TARGETS

#
# Make nmake output much more readable.
# Convert runs of spaces to a single space and then spaces to space-newline-space.
# Build.exe needs a space after a tool name in its filtering.
#

MANAGED_CODE_BUILD_CMD2=$(MANAGED_CODE_BUILD_CMD2:    = )
MANAGED_CODE_BUILD_CMD2=$(MANAGED_CODE_BUILD_CMD2:   = )
MANAGED_CODE_BUILD_CMD2=$(MANAGED_CODE_BUILD_CMD2:  = )
MANAGED_CODE_BUILD_CMD2=$(MANAGED_CODE_BUILD_CMD2: = ^
 )
ECHO_PRECOMPILED_MSG1=$(ECHO_PRECOMPILED_MSG1:    = )
ECHO_PRECOMPILED_MSG1=$(ECHO_PRECOMPILED_MSG1:   = )
ECHO_PRECOMPILED_MSG1=$(ECHO_PRECOMPILED_MSG1:  = )
ECHO_PRECOMPILED_MSG2=$(ECHO_PRECOMPILED_MSG2:    = )
ECHO_PRECOMPILED_MSG2=$(ECHO_PRECOMPILED_MSG2:   = )
ECHO_PRECOMPILED_MSG2=$(ECHO_PRECOMPILED_MSG2:  = )
ECHO_CXX_MSG=$(ECHO_CXX_MSG:    = )
ECHO_CXX_MSG=$(ECHO_CXX_MSG:   = )
ECHO_CXX_MSG=$(ECHO_CXX_MSG:  = )
ECHO_CXX_MSG=$(ECHO_CXX_MSG: = ^
 )
ECHO_MSG=$(ECHO_MSG:    = )
ECHO_MSG=$(ECHO_MSG:   = )
ECHO_MSG=$(ECHO_MSG:  = )
ECHO_MSG=$(ECHO_MSG: = ^
 )

#
# This is a little inelegant but it saves us from having to duplicate logic over and over in *mk.inc.
# The one downside is that the user cannot write a pure function named _DllMainCRTStartupForGS
# and use that as the entry point.
#
# One advantage is that, for example, we don't have to be embedded in all the UMTYPE checking.
# We handle all UMTYPEs.
#
# TBD -- unfactor *mk.inc into common code in makefile.def.
#
! ifdef MANAGED_CXX

!  ifdef MCPP_TYPE
!    undef BO_LIB
!    if  "$(DLLENTRY)" == "-entry:_DllMainCRTStartupForGS" \
      || "$(DLLENTRY)" == "/entry:_DllMainCRTStartupForGS" \
      || "$(DLLENTRY)" == "-entry:_DllMainCRTStartupForGS@12" \
      || "$(DLLENTRY)" == "/entry:_DllMainCRTStartupForGS@12" \
      || "$(DLLENTRY)" == "/entry:_DllMainCRTStartup" \
      || "$(DLLENTRY)" == "-entry:_DllMainCRTStartup" \
      || "$(DLLENTRY)" == "/entry:_DllMainCRTStartup@12" \
      || "$(DLLENTRY)" == "-entry:_DllMainCRTStartup@12"
DLLENTRY=/noentry
!    endif
!  endif # MCPP_TYPE

!  if "$(URT_VER)" < "2.0"
#
# linker warning -- "DLL containing objects compiled with /clr is not linked with /NOENTRY; image may not run correctly"
#
!    if  "$(DLLENTRY)" == "-entry:_DllMainCRTStartupForGS@12" \
      || "$(DLLENTRY)" == "/entry:_DllMainCRTStartupForGS@12"
DLLENTRY=/noentry
!    else
#
# TBD -- is there a better fix? Investigate Server SP1.
#
LINKER_FLAGS=$(LINKER_FLAGS) /ignore:4243
!    endif
USER_C_FLAGS=$(USER_C_FLAGS) /d1PrivateNativeTypes
!  endif # 1.1
! endif # MANAGED_CXX


# SUBSTITUTE_CS_COMPILER_NAME is currently used by OACR via razzle.cmd
CS_COMPILER_NAME=\
!ifdef SUBSTITUTE_CS_COMPILER_NAME
$(SUBSTITUTE_CS_COMPILER_NAME) \
!else
csc.exe \
!endif
/nologo /nostdlib /r:$(CLR_REF_PATH)\mscorlib.dll

# provide for future use of an alternate VB compiler location
VB_NET_COMPILER_NAME=\
!ifdef SUBSTITUTE_VB_COMPILER_NAME
    $(SUBSTITUTE_VB_COMPILER_NAME) \
!else
    vbc.exe \
!endif
    /nologo

# UNDONE -- need to see what mscorlib.dll vbc uses, probably the wrong one, and fix it

! if "$(UNSAFE_CODE_SWITCH)" == ""
!  if defined(_VB)
UNSAFE_CODE_SWITCH=
!  else
!   if "$(UNSAFE_CODE)" == "1"
UNSAFE_CODE_SWITCH=/unsafe+
!   else
UNSAFE_CODE_SWITCH=/unsafe-
!   endif
!  endif
! endif

MANAGED_STD_FLAGS        = $(MANAGED_DBG_FLAGS) /warnaserror+ $(UNSAFE_CODE_SWITCH)

! if defined(_VB)
MANAGED_STD_FLAGS        = $(MANAGED_STD_FLAGS) $(USER_VB_NET_FLAGS)
! else
MANAGED_STD_FLAGS        = $(MANAGED_STD_FLAGS) $(USER_CS_FLAGS)
! endif

! ifdef PERF_INSTRUMENTATION
MANAGED_STD_FLAGS=$(MANAGED_STD_FLAGS) /define:PROFILE
! endif


! ifndef LINKER_STACKSIZE
!  ifdef LINKER_STACKCOMMITSIZE
LINKER_STACKSIZE = /STACK:$(DEFAULT_STACKRESERVE),$(LINKER_STACKCOMMITSIZE)
!  else
LINKER_STACKSIZE = /STACK:$(DEFAULT_STACKRESERVE),$(DEFAULT_STACKCOMMIT)
!  endif
! endif

! if defined(KMDF_VERSION_MAJOR)
DRIVER_ENTRY=FxDriverEntry
! endif


LINKER_STACKSIZE_DLL=/STACK:0x40000,0x1000


LIBRARY_OBJS=$(IMPLIB_OBJS) $(MFC_STATIC_LIB) \
!if $(USE_DLLDEF_OBJECTS)
    $(DLLDEF_OBJECTS) \
!else
    $(LINKLIBS) \
!endif
    $(OBJECTS)

! if "$(TARGETTYPE)" != "DRIVER" && \
     "$(TARGETTYPE)" != "EXPORT_DRIVER" && \
     "$(TARGETTYPE)" != "MINIPORT" && \
     "$(TARGETTYPE)" != "GDI_DRIVER" && \
     !defined(NO_RDATA_MERGE)
LINKER_FLAGS = $(LINKER_FLAGS) /merge:.rdata=.text
! endif

LINKER_FLAGS=$(LINKER_FLAGS) /pdbcompress

!if "$(DELAYLOAD)" != ""

#
# Temporary change to remap API sets that they can be delay loaded using a friendly name.
#

DELAYLOAD=$(DELAYLOAD:L=l)
DELAYLOAD=$(DELAYLOAD:S=s)
DELAYLOAD=$(DELAYLOAD:A=a)
DELAYLOAD=$(DELAYLOAD:O=o)
DELAYLOAD=$(DELAYLOAD:K=k)
DELAYLOAD=$(DELAYLOAD:U=u)
DELAYLOAD=$(DELAYLOAD:P=p)

DELAYLOAD=$(DELAYLOAD:D=d)
DELAYLOAD=$(DELAYLOAD:B=b)
DELAYLOAD=$(DELAYLOAD:E=e)

DELAYLOAD=$(DELAYLOAD:W=w)
DELAYLOAD=$(DELAYLOAD:I=i)
DELAYLOAD=$(DELAYLOAD:N=n)
DELAYLOAD=$(DELAYLOAD:V=v)
DELAYLOAD=$(DELAYLOAD:C=c)

DELAYLOAD=$(DELAYLOAD:G=g)
DELAYLOAD=$(DELAYLOAD:M=m)
DELAYLOAD=$(DELAYLOAD:R=r)
DELAYLOAD=$(DELAYLOAD:T=t)
DELAYLOAD=$(DELAYLOAD:Y=y)

!  if    ("$(DELAYLOAD:lsalookup=)" != "$(DELAYLOAD)") \
         || ("$(DELAYLOAD:sddlbase=)" != "$(DELAYLOAD)") \
         || ("$(DELAYLOAD:api-ms-win-service-winsvc=)" != "$(DELAYLOAD)") \
         || ("$(DELAYLOAD:api-ms-win-service-core=)" != "$(DELAYLOAD)") \
         || ("$(DELAYLOAD:api-ms-win-service-management=)" != "$(DELAYLOAD)") \

DELAYLOAD=$(DELAYLOAD:lsalookup=api-ms-win-security-lsalookup-l1-1-0)
DELAYLOAD=$(DELAYLOAD:sddlbase=api-ms-win-security-sddl-l1-1-0)
DELAYLOAD=$(DELAYLOAD:api-ms-win-service-core-l1.=api-ms-win-service-core-l1-1-0.)
DELAYLOAD=$(DELAYLOAD:api-ms-win-service-management-l1.=api-ms-win-service-management-l1-1-0.)
DELAYLOAD=$(DELAYLOAD:api-ms-win-service-management-l2.=api-ms-win-service-management-l2-1-0.)
DELAYLOAD=$(DELAYLOAD:api-ms-win-service-winsvc-l1.=api-ms-win-service-winsvc-l1-1-0.)

!  endif
!endif

!   if "$(DELAYLOAD)" != ""
!       if "$(DLOAD_ERROR_HANDLER)" != ""
!           if "$(DLOAD_ERROR_HANDLER)" == "kernelbase" || \
               "$(DLOAD_ERROR_HANDLER)" == "kernelbase.dll" || \
               "$(DLOAD_ERROR_HANDLER)" == "kernel32" || \
               "$(DLOAD_ERROR_HANDLER)" == "kernel32.dll" || \
               "$(DLOAD_ERROR_HANDLER)" == "kernel32pub"
CRTLIBS=$(CRTLIBS) $(MINWIN_PRIV_SDK_LIB_PATH)\kernelbasedloadhandler.lib
!               if "$(DLOAD_ERROR_HANDLER)" == "kernelbase" || \
                   "$(DLOAD_ERROR_HANDLER)" == "kernelbase.dll"
TARGETLIBS = $(TARGETLIBS) $(MINWIN_PRIV_SDK_LIB_PATH)\api-ms-win-core-delayload-l1.lib
!               elseif "$(DLOAD_ERROR_HANDLER)" == "kernel32pub"
TARGETLIBS = $(TARGETLIBS) $(SDK_LIB_PATH)\kernel32.lib
!               else
TARGETLIBS = $(TARGETLIBS) $(SDK_LIB_PATH)\kernl32p.lib
!               endif
!               if "$(BUILD_MINWIN)" == "1"
_CHECK_DELAYLOAD_COMMAND=-check_delayload $@ minwin
!               else
_CHECK_DELAYLOAD_COMMAND=-check_delayload $@
!               endif
!           else
CRTLIBS=$(CRTLIBS) $(CRT_LIB_PATH)\delayimp.lib
!               if "$(DLOAD_FORCE_ERROR_CHECK)" != ""
_CHECK_DELAYLOAD_COMMAND=-check_delayload $@
!               endif
!           endif
!           if "$(_BUILDOPT)" == "no opt"
_CHECK_DELAYLOAD_COMMAND=@echo skipping check_delayload $(@F) due to no_opt.
!           endif
!       else
!           message BUILDMSG: Warning: DLOAD_ERROR_HANDLER not specified in $(MAKEDIR)
!       endif
DELAYLOAD = $(DELAYLOAD: =)
DELAYLOAD_FLAGS = /delayload:$(DELAYLOAD:;= /delayload:)
!       ifdef DELAYLOAD_UNLOAD_SUPPORT
DELAYLOAD_FLAGS = $(DELAYLOAD_FLAGS) /delay:unload
!       endif
LINKER_FLAGS = $(LINKER_FLAGS) $(DELAYLOAD_FLAGS)
!   endif

#
# Clear the suffixes list so we can ensure only pass zero stuff will be built
#
! IFDEF PASS0ONLY
.SUFFIXES:
! ENDIF


DRIVER_SWITCH = /driver

! if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
DRIVER_SWITCH = $(DRIVER_SWITCH) /driver:wdm
! else if "$(DRIVERTYPE)" == "VXD"
DRIVER_SWITCH = /vxd $(SDK_LIB_DEST)\i386\vxdwraps.clb
! endif

! ifdef BINARY_PUBLISH_DIR
!  ifndef BINARY_PUBLISH_FILES
!   error Must define BINARY_PUBLISH_FILES if defining BINARY_PUBLISH_DIR
!  endif
BINARY_PUBLISH_ROOT=$(BASEDIR)\$(_PROJECT_)\$(PROJECT_BINDROP_DIR)
BINARY_PUBLISH_ROOT=$(BINARY_PUBLISH_ROOT)\$(BINARY_PUBLISH_DIR)
BINARY_PUBLISH_ROOT=$(BINARY_PUBLISH_ROOT)\$(TARGET_DIRECTORY)\$(BUILD_TYPE)
! endif

!endif # PASS_INDEPENDENT_TARGETS

!if defined(BINARY_PUBLISH) || defined(BINARY_PUBLISH_DIR) || !defined(_NTTREE)

#
# since we're generating binary drops of this source there's no need to
# binplace the files.  The files should be binplaced from the binary_release
# directory.
#

NO_BINPLACE=1

!endif

!ifdef NO_BINPLACE

BINPLACE_CMD=@echo Skip Binplace:
BINPLACE_TOOL=$(BINPLACE_CMD)
BINPLACE_FLAGS=

!else


! ifndef BINPLACE_PLACEFILE
!  ifdef BINPLACE_GENERATE_PLACEFILE
BINPLACE_PLACEFILE = $(OBJ_PATH)\$O\placefil.txt
!  elseif "$(BUILD_PRODUCT)" == "IE"
BINPLACE_PLACEFILE = $(BINPLACE_PLACEFILE_DIR)\ieplace.txt
!  endif
! endif

#
# Sidebyside binplacing can be made simpler.
# In particular, move the code into build.exe and have it output what is necessary to _objects.mac.
# Idtool.exe may also suffice.
# No generated placefile is necessary.
# When this was originally written, /:DEST was not known and modifying build.exe was avoided.
#
! ifdef BINPLACE_GENERATE_PLACEFILE
MAKE_PLACEFILE_CMD=for %i in ($(SXS_MISCFILES) $(TARGET)) do echo %~nxi $(BINPLACE_DESTINATIONS) >> $(BINPLACE_PLACEFILE)
!  if defined(SXS_LOG_PASS) && defined(SXS_ASSEMBLY_NAME) && "$(TARGETTYPE)" != "NOTARGET"
MAKE_PLACEFILE_CMD=( $(MAKE_PLACEFILE_CMD) ) && ( for /f "delims=:" %i in ('echo $(BINPLACE_DESTINATIONS_NORETAIL)') do for %j in ($(TARGET))  do echo %i\%~nxj | $(APPEND_TOOL) -file $(BINPLACE_LOG)\..\symbolcd_cablists_asms_$(COMPUTERNAME).lst - )
!  endif
!  ifdef BINPLACE_ADDITIONAL_PLACEFILES
#
# BINPLACE_ADDITIONAL_PLACEFILES is a semicolon delimited list of additional placefiles.
# The last parameter is the output (which we also use as an input, so we repeat it).
#
MAKE_PLACEFILE_CMD=( $(MAKE_PLACEFILE_CMD) ) && ( merge_placefiles.exe $(BINPLACE_ADDITIONAL_PLACEFILES:;= ) $(BINPLACE_PLACEFILE) $(BINPLACE_PLACEFILE) )
!  endif
! endif

BINPLACE_FLAGS = /:NOCV $(BINPLACE_FLAGS) $(SXS_BINPLACE_FLAGS)

!ifdef BINPLACE_PLACEFILE
BINPLACE_FLAGS = /P $(BINPLACE_PLACEFILE) $(BINPLACE_FLAGS)
!endif

!ifdef BUILD_NO_SYMCHK
# BUILD_NO_SYMCHK is the older version of BINPLACE_NO_SYMCHK.
# Do a mapping of the old to the new until all of the SOURCES
# files are converted.
BINPLACE_NO_SYMCHK=1
!endif

!ifndef BINPLACE_NO_SYMCHK
!  ifndef BINPLACE_ALLOW_DBG
BINPLACE_FLAGS = /:DBG $(BINPLACE_FLAGS)
!  endif
BINPLACE_FLAGS = /j $(BINPLACE_FLAGS)
!else
# BINPLACE_NO_SYMCHK implies BINPLACE_ALLOW_DBG. This shouldn't really
# be needed, but guard against future changes which may explicitly check
# for BINPLACE_ALLOW_DBG.
BINPLACE_ALLOW_DBG=1
!endif

# If NTDBGFILES is defined then use binplace to split the symbols.
# Define BINPLACE flags as needed if separate .DBG file requested.

! IFDEF NTDBGFILES
!  ifdef NTDBGFILES_PRIVATE
BINPLACE_DBGFLAGS_NT = $(BINPLACE_DBGFLAGS_NT) /s $(_NTTREE)\Symbols.pri\$(ALT_PROJECT_TARGET)
!  endif
! else
BINPLACE_DBGFLAGS_NT=
! ENDIF

! if "$(VERIFY_LC)" == "1"
!  ifndef LC_PATH
LC_PATH=.
!  endif
BINPLACE_LC_FLAGS = /G $(LC_PATH)\$(@F).lc
BINPLACE_LC_MISCFLAGS = /G $(LC_PATH)\$(**F).lc
! else
BINPLACE_LC_FLAGS=
BINPLACE_LC_MISCFLAGS=
! endif

BINPLACE_FLAGS=/R $(_NTTREE)\$(ALT_PROJECT_TARGET) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS)

! ifdef LANGUAGE_NEUTRAL_STS
!  if "$(LANGUAGE_NEUTRAL_STS)" == "LGNSTS_MUIOFF"
LANGUAGE_NEUTRAL_STATUS_CMD=\
            if not exist $@.mui ( \
                if not exist $@.mui.notloc ( \
                   echo Build_Status  LN_MUI_STS: $(LANGUAGE_NEUTRAL_STS) $(@F) && \
                   echo Build_Status  MUI_COMMENT: $(MUI_COMMENT) $(@F) \
                ) \
            )
!  else
LANGUAGE_NEUTRAL_STATUS_CMD=\
            if not exist $@.mui ( \
                if not exist $@.mui.notloc ( \
                   echo Build_Status  LN_MUI_STS: $(LANGUAGE_NEUTRAL_STS) $(@F) \
                ) \
            )
!  endif
! else
LANGUAGE_NEUTRAL_STATUS_CMD=
! endif

BINPLACE_TOOL=$(NOECHO)binplace

BINPLACE_CMD = $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_FLAGS) $@

! if "$(LOCALIZE_BASE_FILE)" == "1" || "$(LOCALIZE_NO_MUI_MULTI)" == "1"
_BINPLACE_FLAGS_LOCALIZE = /R $(_NTTREE)\$(LOC_MULTI)
! elseif "$(LOCALIZE_NO_MUI)" == "1"
_BINPLACE_FLAGS_LOCALIZE = /R $(_NTTREE)\$(LOC_BIN)
! else
_BINPLACE_FLAGS_LOCALIZE =
! endif

!if defined(_BINPLACE_LINK_RESULT)
_BINPLACE_TARGET_COMMAND = \
    $(BINPLACE_TOOL) \
        $(BINPLACE_FLAGS) \
	$(BINPLACE_TARGET_FLAGS) \
        $(BINPLACE_LC_FLAGS) \
        $(_BINPLACE_FLAGS_LOCALIZE) \
        $(_BINPLACE_LINK_RESULT) \
!endif

_BBT_BINPLACE_COMMAND = \
    $(BINPLACE_TOOL) \
        $(BINPLACE_FLAGS) \
	$(BINPLACE_TARGET_FLAGS) \
        $(BINPLACE_LC_FLAGS) \
        $(_BINPLACE_FLAGS_LOCALIZE) \
        $@ \

_BBINSTR_BINPLACE_COMMAND = \
    $(BINPLACE_TOOL) \
        $(BINPLACE_FLAGS) \
	$(BINPLACE_TARGET_FLAGS) \
        $(BINPLACE_LC_FLAGS) \
        $(_BINPLACE_FLAGS_LOCALIZE) \
        $(_BINPLACE_BBT_INSTR) \

_BINPLACE_COVERAGE_COMMAND = \
    $(BINPLACE_TOOL) \
        $(BINPLACE_FLAGS) \
	$(BINPLACE_TARGET_FLAGS) \
        $(BINPLACE_LC_FLAGS) \
        $(_BINPLACE_FLAGS_LOCALIZE) \

! if "$(INSTRUMENT_FOR_COVERAGE)" == "1"

_COVERAGE_RESPONSE_FILE_CONTENTS=$(_COVERAGE_RESPONSE_FILE_CONTENTS)^
/BinplaceCommand $(_BINPLACE_COVERAGE_COMMAND)^
/BinplaceFlagsLocalize $(_BINPLACE_FLAGS_LOCALIZE)

! endif

!endif # NO_BINPLACE

BINPLACE_CMD_NO_BBT=$(BINPLACE_CMD)
BINPLACE_CMD_NT=$(BINPLACE_CMD)


!if 1 # PASS_INDEPENDENT_TARGETS

!ifdef NTDUMPAMAP
MAPDUMP_CMD = link /dump /map $@ | sort /R /+62 > $(_NTDUMPAMAP)\$(@B).srt
!else
MAPDUMP_CMD =
!endif


# Define this macro so including make files can supply a yes prompt
# as appropriate.  Put the "yes." file in a visible place for OEM's
# so they can make too.

!IFNDEF NOPASS0

# Pass Zero Inference Rules: IDL files (MIDL) and MC files

.SUFFIXES: .h .idl .mc .odl .tdl .asn .thk .mof

PASS0_OBJECTS=
! IF $(386)
PASS0_OBJECTS=$(PASS0_OBJECTS) $(PASS0_386_OBJECTS)
! ENDIF
! IF $(IA64)
PASS0_OBJECTS=$(PASS0_OBJECTS) $(PASS0_IA64_OBJECTS)
! ENDIF
! IF $(AMD64)
PASS0_OBJECTS=$(PASS0_OBJECTS) $(PASS0_AMD64_OBJECTS)
! ENDIF
! IF $(ARM)
PASS0_OBJECTS=$(PASS0_OBJECTS) $(PASS0_ARM_OBJECTS)
! ENDIF
!ENDIF

!ifndef MIDL
MIDL = midl
!endif

MIDL = $(_CONCURRENT_MIDL_RUN) $(MIDL)

# Disable midl timestamps wherever possible
MIDL_FLAGS=$(MIDL_FLAGS) /no_stamp /nologo $(MIDL_WX_SWITCH)

!IFDEF USE_OLE_MC
MC = mc -o
!ELSE
MC = mc
!ENDIF

!IF "$(IDL_TYPE)" == "ole" || "$(IDL_TYPE)" == ""
IDL_TYPE=OLE
!ELSEIF "$(IDL_TYPE)" == "rpc"
IDL_TYPE=RPC
!ELSEIF "$(IDL_TYPE)" == "bem"
IDL_TYPE=BEM
!ENDIF

!IFNDEF PASS0_HEADERDIR
!  if $(USE_OBJECT_ROOT)
PASS0_HEADERDIR=$(OBJ_PATH)\$(O)
!  elseif "$(BUILD_PRODUCT)" == "NT"
PASS0_HEADERDIR=$(O)
!  else
PASS0_HEADERDIR=.
!  endif
!ENDIF

MIDL_TARGET_NT40  = NT40
MIDL_TARGET_WIN2K = NT50
MIDL_TARGET_WINXP = NT51
MIDL_TARGET_VISTA = NT60
MIDL_TARGET_WIN7  = NT61


!IFNDEF MIDL_TARGET

!    IF $(WIN32_WINNT_VERSION) == 0x0601
# Continue to default to Vista due to extra requirement to link to ole32.dll in Win7 stubs
MIDL_TARGET=$(MIDL_TARGET_VISTA)
!    ELSEIF $(WIN32_WINNT_VERSION) == 0x0600
MIDL_TARGET=$(MIDL_TARGET_VISTA)
!    ELSEIF $(WIN32_WINNT_VERSION) == 0x0502
MIDL_TARGET=$(MIDL_TARGET_WINXP)
!    ELSEIF $(WIN32_WINNT_VERSION) == 0x0501
MIDL_TARGET=$(MIDL_TARGET_WIN2K)
!    ELSEIF $(WIN32_WINNT_VERSION) == 0x0500
MIDL_TARGET=$(MIDL_TARGET_WIN2K)
!    ELSE
!        if !$(WIN64)
MIDL_NO_ROBUST=1
!        else
MIDL_TARGET=$(MIDL_TARGET_WIN2K)
!        endif
!    ENDIF

!ELSE

# Don't build MIDL stubs that are too new for the OS being targeted

!    IF "$(MIDL_TARGET)" == "$(MIDL_TARGET_WIN7)"

!        IF "$(SUBSYSTEM_WINVER)" < "$(SUBSYSTEM_601)"
!        ERROR MIDL_TARGET=$(MIDL_TARGET) mismatch with SUBSYSTEM_VERSION=$(SUBSYSTEM_WINVER). MIDL_TARGET must not be newer.
!        ENDIF

!    ELSEIF "$(MIDL_TARGET)" == "$(MIDL_TARGET_VISTA)"

!        IF "$(SUBSYSTEM_WINVER)" < "$(SUBSYSTEM_600)"
!        ERROR MIDL_TARGET=$(MIDL_TARGET) mismatch with SUBSYSTEM_VERSION=$(SUBSYSTEM_WINVER). MIDL_TARGET must not be newer.
!        ENDIF

!    ELSEIF "$(MIDL_TARGET)" == "$(MIDL_TARGET_WINXP)"

!        IF "$(SUBSYSTEM_WINVER)" < "$(SUBSYSTEM_501)"
!        ERROR MIDL_TARGET=$(MIDL_TARGET) mismatch with SUBSYSTEM_VERSION=$(SUBSYSTEM_WINVER). MIDL_TARGET must not be newer.
!        ENDIF

!    ELSEIF "$(MIDL_TARGET)" == "$(MIDL_TARGET_WIN2K)"

!        IF "$(SUBSYSTEM_WINVER)" < "$(SUBSYSTEM_500)"
!        ERROR MIDL_TARGET=$(MIDL_TARGET) mismatch with SUBSYSTEM_VERSION=$(SUBSYSTEM_WINVER). MIDL_TARGET must not be newer.
!        ENDIF

# else MIDL_TARGET is set old enough it'll run on anything.

!    ENDIF

!ENDIF

!IF defined(MIDL_NO_ROBUST)
!if !$(WIN64) || ("$(MIDL_PROTOCOL)" == "dce" && defined(RPC_TEST_OS64))
!undef MIDL_TARGET
!else
MIDL_TARGET=NT50
!undef MIDL_NO_ROBUST
!endif
!ENDIF

!IF "$(IDL_TYPE)" == "BEM"
!undef MIDL_TARGET
!IFDEF MIDL_EXPORT
!ERROR Export Files not supported for BEM interfaces.
!ENDIF
!ENDIF


MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION) -sal $(MIDL_PLATFORM_FLAG)

!IFDEF MIDL_TARGET
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION) -target $(MIDL_TARGET)
!ENDIF

!IFDEF MIDL_PROTOCOL
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION) -protocol $(MIDL_PROTOCOL)
!ENDIF

!IFDEF MIDL_NO_ROBUST
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION) -no_robust
!ENDIF

!IFDEF MIDL_EXPORT
!IF !defined(MIDL_EXPORTDIR)
MIDL_EXPORTDIR=$(PASS0_HEADERDIR)
!ENDIF
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION) -export -export_file $(MIDL_EXPORTDIR)\$(<F:.idl=_export.mef)
!ENDIF


#
# Default MIDL_TLBDIR, and don't need to check if it exists in the default case.
#
! if !defined(MIDL_TLBDIR) && $(USE_OBJECT_ROOT)

MIDL_TLBDIR=$(OBJ_PATH)\$(O)
!if !defined(MIDL_TLBNAME)
MIDL_TLBNAME=$(<B)
!endif
MIDL_TLBSWITCH=/tlb $(OBJ_PATH)\$(O)\$(MIDL_TLBNAME).tlb

! else

!  ifdef MIDL_TLBDIR
!   if !exist($(MIDL_TLBDIR))
!    if [mkdir $(MIDL_TLBDIR)]
!    endif
!   endif
MIDL_TLBSWITCH=/tlb $(MIDL_TLBDIR)\$(<F:.idl=.tlb)
!  else
MIDL_TLBSWITCH=
!  endif
! endif

!ifndef PACKING
PACKING= /Zp8
!endif

!IF "$(IDL_TYPE)" == "OLE"

#! IF DEFINED(PASS0_CLIENTDIR) || DEFINED(PASS0_SERVERDIR)
#!  ERROR PASS0_CLIENTDIR and PASS0_SERVERDIR can only be used with IDL_TYPE=RPC!
#! ENDIF

! IFNDEF PASS0_SOURCEDIR
!  if $(USE_OBJECT_ROOT)
PASS0_SOURCEDIR=$(OBJ_PATH)\$(O)
!  elseif "$(BUILD_PRODUCT)" == "NT"
PASS0_SOURCEDIR=$(O)
!  else
PASS0_SOURCEDIR=.
!  endif
! ENDIF

! IFNDEF MIDL_UUIDDIR
MIDL_UUIDDIR=$(PASS0_SOURCEDIR)
! ENDIF

! ifndef PASS0_UUIDDIR
PASS0_UUIDDIR=$(MIDL_UUIDDIR)
! endif

!ifdef USE_IDLBASED_DLLDATA
DLLDATA_NAME=$(<F:.idl=_dlldata.c)
!else
DLLDATA_NAME=dlldata.c
!endif

! IFNDEF NO_PASS0_RULES

!if !exist($(PASS0_SOURCEDIR))
!if [mkdir $(PASS0_SOURCEDIR)]
!endif
!endif

!if !exist($(MIDL_UUIDDIR))
!if [mkdir $(MIDL_UUIDDIR)]
!endif
!endif

.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    /dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    /iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{..}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    /dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    /iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$O}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    /dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    /iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$(OBJ_PATH)\$O}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    /dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    /iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

! ENDIF

!ELSEIF "$(IDL_TYPE)" == "RPC"

! IFNDEF PASS0_CLIENTDIR
!  if $(USE_OBJECT_ROOT)
PASS0_CLIENTDIR=$(OBJ_PATH)\$(O)
!  elseif "$(BUILD_PRODUCT)" == "NT"
PASS0_CLIENTDIR=$(O)
!  else
PASS0_CLIENTDIR=$(TARGETPATH)
!  endif
! ENDIF

! IFNDEF PASS0_SERVERDIR
!  if $(USE_OBJECT_ROOT)
PASS0_SERVERDIR=$(OBJ_PATH)\$(O)
!  elseif "$(BUILD_PRODUCT)" == "NT"
PASS0_SERVERDIR=$(O)
!  else
PASS0_SERVERDIR=$(PASS0_CLIENTDIR)
!  endif
! ENDIF

! IFNDEF NO_PASS0_RULES

!if !exist($(PASS0_CLIENTDIR))
!if [mkdir $(PASS0_CLIENTDIR)]
!endif
!endif
!if !exist($(PASS0_SERVERDIR))
!if [mkdir $(PASS0_SERVERDIR)]
!endif
!endif

.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    /sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{..}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    /sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$O}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    /sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$(OBJ_PATH)\$O}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    /sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

! ENDIF

!ELSEIF "$(IDL_TYPE)" == "BEM"

! IFNDEF PASS0_CLIENTDIR
!  if $(USE_OBJECT_ROOT)
PASS0_CLIENTDIR=$(OBJ_PATH)\$(O)
!  elseif "$(BUILD_PRODUCT)" == "NT"
PASS0_CLIENTDIR=$(O)
!  else
PASS0_CLIENTDIR=$(TARGETPATH)
!  endif
! ENDIF

! IFNDEF PASS0_SERVERDIR
!  if $(USE_OBJECT_ROOT)
PASS0_SERVERDIR=$(OBJ_PATH)\$(O)
!  elseif "$(BUILD_PRODUCT)" == "NT"
PASS0_SERVERDIR=$(O)
!  else
PASS0_SERVERDIR=$(PASS0_CLIENTDIR)
!  endif
! ENDIF

! IFNDEF MIDL_UUIDDIR
MIDL_UUIDDIR=$(PASS0_HEADERDIR)
! ENDIF

! ifndef PASS0_UUIDDIR
PASS0_UUIDDIR=$(MIDL_UUIDDIR)
! endif

!ifdef USE_IDLBASED_CONTRACTDATA
CONTRACTDATA_NAME=$(<F:.idl=_contractdata.c)
!else
CONTRACTDATA_NAME=contractdata.c
!endif

! IFNDEF NO_PASS0_RULES

!if !exist($(PASS0_CLIENTDIR))
!if [mkdir $(PASS0_CLIENTDIR)]
!endif
!endif
!if !exist($(PASS0_SERVERDIR))
!if [mkdir $(PASS0_SERVERDIR)]
!endif
!endif
!if !exist($(PASS0_UUIDDIR))
!if [mkdir $(PASS0_UUIDDIR)]
!endif
!endif


.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /emhostfile $(PASS0_CLIENTDIR)\$(<F:.idl=_host.cpp) \
    /emextfile $(PASS0_SERVERDIR)\$(<F:.idl=_ext.cpp) \
    /contractdata $(PASS0_SERVERDIR)\$(CONTRACTDATA_NAME) \
    /iid $(PASS0_UUIDDIR)\$(<F:.idl=_i.c) \
    /minWin \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{..}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /emhostfile $(PASS0_CLIENTDIR)\$(<F:.idl=_host.cpp) \
    /emextfile $(PASS0_SERVERDIR)\$(<F:.idl=_ext.cpp) \
    /contractdata $(PASS0_SERVERDIR)\$(CONTRACTDATA_NAME) \
    /iid $(PASS0_UUIDDIR)\$(<F:.idl=_i.c) \
    /minWin \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$O}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /emhostfile $(PASS0_CLIENTDIR)\$(<F:.idl=_host.cpp) \
    /emextfile $(PASS0_SERVERDIR)\$(<F:.idl=_ext.cpp) \
    /contractdata $(PASS0_SERVERDIR)\$(CONTRACTDATA_NAME) \
    /iid $(PASS0_UUIDDIR)\$(<F:.idl=_i.c) \
    /minWin \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$(OBJ_PATH)\$O}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    /emhostfile $(PASS0_CLIENTDIR)\$(<F:.idl=_host.cpp) \
    /emextfile $(PASS0_SERVERDIR)\$(<F:.idl=_ext.cpp) \
    /contractdata $(PASS0_SERVERDIR)\$(CONTRACTDATA_NAME) \
    /iid $(PASS0_UUIDDIR)\$(<F:.idl=_i.c) \
    /minWin \
    /header $@ \
    /cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

! ENDIF

!ELSE

! ERROR Invalid IDL_TYPE value. Supported values: OLE, BEM, and RPC.

!ENDIF  # IDL_TYPE

CPPXX = $(C_PREPROCESSOR_FLAGS:/Tc=)
CPPXX = $(CPPXX:-Tc=)

!IFNDEF NO_PASS0_RULES

! IFNDEF MC_SOURCEDIR
! IFDEF PASS0_SOURCEDIR
MC_SOURCEDIR=$(PASS0_SOURCEDIR)
! ELSE
MC_SOURCEDIR=$(PASS0_CLIENTDIR)
! ENDIF
! ENDIF

!if defined(MC_WINMETAPATH)
!  error You may not define MC_WINMETAPATH.
!endif

MC_WINMETAPATH=$(SDK_INC_PATH)\winmeta.xml

!if defined(MC_EVENTMANPATH)
!  error You may not define MC_EVENTMANPATH.
!endif

MC_EVENTMANPATH=$(SDK_INC_PATH)\eventman.xsd

.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

{..}.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

{..}.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

{$O}.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

{$O}.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

{$(OBJ_PATH)\$O}.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

{$(OBJ_PATH)\$O}.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

!if "$(MC_SOURCEDIR)" != "$(OBJ_PATH)\$O"

{$(OBJ_PATH)\$O}.mc{$(OBJ_PATH)\$O}.h:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

{$(OBJ_PATH)\$O}.mc{$(OBJ_PATH)\$O}.rc:
    $(MC) /h $(PASS0_HEADERDIR) /r $(MC_SOURCEDIR) $(MC_FLAGS) $<
    if not exist $@ echo error : $@ not produced

!endif

#
# ManagedObjectFormat files
#   First preprocess MOF via the C pre processor
#   Next separate MOF into MOF and MFL, then concatenate them and
#   finally compile into binary form
#

!if "$O" != "."

{..\}.mof{$O}.mof:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

{}.mof{$O}.mof:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

{$O}.mof{$O}.bmf:
!ifdef MOFCOMP_NO_DEFAULT_NAMESPACE
    mofcomp -Amendment:ms_409 -MFL:$O\MFL.MFL -MOF:$O\MOF.MOF $<
!else
    mofcomp -N:root\wmi -Amendment:ms_409 -MFL:$O\MFL.MFL -MOF:$O\MOF.MOF $<
!endif
    wmimofck -y$O\MOF.MOF -z$O\MFL.MFL $O\MOFMFL.MOF
    mofcomp -WMI -B:$@ $O\MOFMFL.MOF

{..}.mof{$(OBJ_PATH)\$O}.mof:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

{}.mof{$(OBJ_PATH)\$O}.mof:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

{$(OBJ_PATH)\$O}.mof{$(OBJ_PATH)\$O}.bmf:
    cd $(OBJ_PATH)
!ifdef MOFCOMP_NO_DEFAULT_NAMESPACE
    mofcomp -Amendment:ms_409 -MFL:$O\MFL.MFL -MOF:$O\MOF.MOF $O\$(<F)
!else
    mofcomp -N:root\wmi -Amendment:ms_409 -MFL:$O\MFL.MFL -MOF:$O\MOF.MOF $O\$(<F)
!endif
    cd $(MAKEDIR)
    wmimofck -y$(OBJ_PATH)\$O\MOF.MOF -z$(OBJ_PATH)\$O\MFL.MFL $(OBJ_PATH)\$O\MOFMFL.MOF
    mofcomp -WMI -B:$@ $(OBJ_PATH)\$O\MOFMFL.MOF


!ifdef USE_MIDL_FOR_MKTYPLIB

MIDL_MKTYPLIB_FLAGS=$(MKTYPLIB_FLAGS:-h =/header )
MIDL_MKTYPLIB_FLAGS=$(MIDL_MKTYPLIB_FLAGS:/h =/header )

MIDL_MKTYPLIB_FLAGS = \
    $(PACKING) \
    $(INCPATH0) \
    /char unsigned \
    /ms_ext \
    /c_ext \
    $(C_DEFINES) /D__MKTYPLIB__ \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $(MIDL_MKTYPLIB_FLAGS) \
    /tlb $@ \
    /cpp_cmd $(MIDL_CPP) \
    /mktyplib203

.odl{$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

.odl{$(OBJ_PATH)\$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..\}.odl{$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..}.odl{$(OBJ_PATH)\$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

.tdl{$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

.tdl{$(OBJ_PATH)\$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..\}.tdl{$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..}.tdl{$(OBJ_PATH)\$O}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

!else

.odl{$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $O\MyTypLib.TMP

.odl{$(OBJ_PATH)\$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(OBJ_PATH)\$O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(OBJ_PATH)\$O\MyTypLib.TMP

{..}.odl{$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $O\MyTypLib.TMP

{..}.odl{$(OBJ_PATH)\$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(OBJ_PATH)\$O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(OBJ_PATH)\$O\MyTypLib.TMP

.tdl{$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $O\MyTypLib.TMP

.tdl{$(OBJ_PATH)\$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(OBJ_PATH)\$O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(OBJ_PATH)\$O\MyTypLib.TMP

{..}.tdl{$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $O\MyTypLib.TMP

{..}.tdl{$(OBJ_PATH)\$O}.tlb:
    @echo mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(OBJ_PATH)\$O\MyTypLib.TMP
$(CPPXX: =
)
/D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @mktyplib /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(OBJ_PATH)\$O\MyTypLib.TMP

!endif

#
# UA file inference rules
#
.SUFFIXES: .h1c .h1s

!if $(USE_OBJECT_ROOT)
.h1c{$(OBJ_PATH)\$O}.h1s:
!else
.h1c{$O}.h1s:
!endif
    set BUILDMSG=Compiling UA file $<
    apcompnt -p $< -o $@
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) $@



# OSSINFO must be set in the *environment* for the ASN compiler to find its
# configuration file, $(OSSINFO)\ossinfo.

! ifndef OSSINFO
OSSINFO=$(SDK_LIB_DEST)
! endif

! ifndef ASNDEFAULTFILE
ASNDEFAULTFILE=$(OSSINFO)\asn1dflt.z4
! endif

! ifndef ASNSYNTAX
ASNSYNTAX=-1990
! endif

ASNFLAGS=$(ASNDEFAULTFILE) $(ASNSYNTAX) $(ASNFLAGS)

# if ASNDBG is explicitly set, let that control whether the voluminous ASN
# symbols are suppressed. Otherwise, suppress the symbols for free builds.

! ifdef ASNDBG
!  if $(ASNDBG) == 0
ASNFLAGS=-minimize $(ASNFLAGS)
!  endif
! elseif $(FREEBUILD)
ASNFLAGS=-minimize $(ASNFLAGS)
! endif

{}.asn{$(PASS0_HEADERDIR)}.h:
    asn1 $(ASNFLAGS) -out $(PASS0_HEADERDIR)\$(@B) $<

!ENDIF

#
# Default language ID to US English (0x0409)
#

!IFDEF RCCODEPAGE
RCOPTIONS=$(RCOPTIONS) -c $(RCCODEPAGE)
!ENDIF

!IFNDEF RCNOFONTMAP
RCOPTIONS=-z "MS Sans Serif,Helv/MS Shell Dlg" $(RCOPTIONS)
!ENDIF

SXS_RC_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES)
SXS_RC_MANIFEST_DEFINES=$(SXS_RC_MANIFEST_DEFINES:"\"=""")
SXS_RC_MANIFEST_DEFINES=$(SXS_RC_MANIFEST_DEFINES:\""=""")
RCOPTIONS=$(SXS_RC_MANIFEST_DEFINES) $(RCOPTIONS)
!ifdef RCLANGUAGE
RCOPTIONS=-l $(RCLANGUAGE) $(RCOPTIONS)
!else
RCOPTIONS=-l 409 $(RCOPTIONS)
!endif

!ifdef DO_LANGUAGE_NEUTRAL
RCOPTIONS=$(RCOPTIONS) $(LANGUAGE_NEUTRAL_RESOURCE) -fm $*.muires
!ENDIF


!if "$(BUILD_LCE_FILE)" == "1"
RCOPTIONS=$(RCOPTIONS) -ta -tn $(LCE_FILE)
!endif


RC_COMPILER=rc.exe $(RCOPTIONS)

INCPATHRC = $(INCPATH0: =)
INCPATHRC = $(INCPATHRC:-I=;)
INCPATHRC = $(INCPATHRC:/I=;)

CDEFINERC = $(CDEFINES:  = )
CDEFINERC = $(CDEFINERC:  = )

!ifdef RC_FORCE_INCLUDE_FILES
# Concatenate the FORCE_INCLUDES files in front of the .rc file.
# We put nul in front because there is an extra leading semicolon which produces
# an extra leading plus sign.
RC_TEMP1=$(@R).rc_temp1
RC_FORCE_INCLUDE_FILES_CMD=$(_COPYFILE) nul$(RC_FORCE_INCLUDE_FILES:;=+)+$< $(RC_TEMP1)
INCPATHRC=$(INCPATHRC);..
!else
RC_TEMP1=$<
RC_FORCE_INCLUDE_FILES_CMD=
!endif

!ifdef RC_FORCE_INCLUDE_STRING
RC_TEMP2=$(@R).rc_temp2
INCPATHRC=$(INCPATHRC);..
!else
RC_TEMP2=$(RC_TEMP1)
!endif

RC_TEMP=$(RC_TEMP2)

!ifdef SXS_MANIFEST_IN_RESOURCES
MAKE_MANIFEST_CMD=nmake.exe /nologo /f $(NTMAKEENV)\makefile.def $(SXS_MANIFEST_OBJ1)
!else
MAKE_MANIFEST_CMD=
!endif

{$O}.rc{$O}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) /r /fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! ifdef RC_FORCE_INCLUDE_STRING
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) /r /fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)

{$O}.rc{$(OBJ_PATH)\$O}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) /r /fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! ifdef RC_FORCE_INCLUDE_STRING
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) /r /fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)

{$(OBJ_PATH)\$O}.rc{$(OBJ_PATH)\$O}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) /r /fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! ifdef RC_FORCE_INCLUDE_STRING
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) /r /fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)

{..\}.rc{$O}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) /r /fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! ifdef RC_FORCE_INCLUDE_STRING
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) /r /fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)

{..\}.rc{$(OBJ_PATH)\$O}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) /r /fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! ifdef RC_FORCE_INCLUDE_STRING
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) /r /fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)

{}.rc{$O}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) /r /fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! ifdef RC_FORCE_INCLUDE_STRING
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) /r /fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)

{}.rc{$(OBJ_PATH)\$O}.res:
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) /r /fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! ifdef RC_FORCE_INCLUDE_STRING
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) /r /fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)

{..\}.rc.rcpp:
    set include=$(INCPATHRC);$(INCLUDE)
    $(RC_COMPILER) /r /p /fo $(@R).tmp $(CDEFINERC) $<
    @set include=$(INCLUDE)

{}.rc.rcpp:
    set include=$(INCPATHRC);$(INCLUDE)
    $(RC_COMPILER) /r /p /fo $(@R).tmp $(CDEFINERC) $<
    @set include=$(INCLUDE)

.thk{$(OBJ_PATH)\$O}.asm:
    thunk /o $@ $<

JVC = jvc /nologo

!ifndef JAVA_DEBUG_FLAGS
!if $(FREEBUILD)
JAVA_DEBUG_FLAGS = /O
!else
JAVA_DEBUG_FLAGS = /g
!endif
!endif

!ifndef JAVA_WARNING_FLAGS
JAVA_WARNING_FLAGS = /w4
!endif

JAVA_BASE_CLASS = \
    $(SDK_PATH)\classes\afc.zip; \
    $(SDK_PATH)\classes\classes.zip

JAVA_CLASS_PATH = $(JAVA_BASE_CLASS); $(MAKEDIR); $(USER_CLASS_PATH)
JAVA_CLASS_PATH = $(JAVA_CLASS_PATH: =)

JVC_FLAGS = /cp $(JAVA_CLASS_PATH) $(JAVA_DEBUG_FLAGS) $(JAVA_WARNING_FLAGS) /d $(OBJ_PATH)\$O

{$(MAKEDIR)}.java{$(OBJ_PATH)\$O}.class:
    $(JVC) $(JVC_FLAGS) $<

#
# The point of these constant response file names is primarly to provide stability
# so that logs can be diffed to verify that changes cause no "real" change.
#
# These file names should be kept short to avoid path length bugs in nmake/cmd.
# In particular, constructs such as $@.responsefile have been seen to exceed nmake/cmd's limited capacity.
#
# These names also provide some additional debuggability in the face of BUILD_DEBUG's switching
# of NoKeep to Keep. You do not then have to discover the response file name to open and view it.
# However that debuggability is reduced by occasional response file reuse, which can be fixed if desired.
#
ECHO_RSP = $(OBJ_PATH)\$O\echo.msg
CL_RSP   = $(OBJ_PATH)\$O\cl.rsp
CLCOD_RSP = $(OBJ_PATH)\$O\clcod.rsp
LINK_RSP = $(OBJ_PATH)\$O\lnk.rsp
BINPLACE_RESPONSE_FILE = $(OBJ_PATH)\$O\binp.rsp
BINPLACE_RESPONSE_FILE_IND = $(OBJ_PATH)\$O\binp.ind.rsp
LIB_RESPONSE_FILE = $(OBJ_PATH)\$O\lib.rsp
PUBLISH_RESPONSE_FILE = $(OBJ_PATH)\$O\pub.rsp
PERL_RESPONSE_FILE = $(OBJ_PATH)\$O\perl.rsp
MANAGED_CODE_BUILD_TOOL_RESPONSE_FILE=$(OBJ_PATH)\$O\mgd.rsp
TYPE_RESPONSE_FILE=$(OBJ_PATH)\$O\type.rsp
BINDROP_RESPONSE_FILE=$(OBJ_PATH)\$O\bindrop.rsp

#
# Expand spaces to newlines, replace double # signs with spaces.
#
EX_CXX_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS: =^
)
EX_CXX_COMPILER_FLAGS=$(EX_CXX_COMPILER_FLAGS:^#^#= )

EX_C_COMPILER_FLAGS=$(C_COMPILER_FLAGS: =^
)
EX_C_COMPILER_FLAGS=$(EX_C_COMPILER_FLAGS:^#^#= )

EX_CXX_COMPILER_FLAGS_NOPCH=$(CXX_COMPILER_FLAGS_NOPCH: =^
)
EX_CXX_COMPILER_FLAGS_NOPCH=$(EX_CXX_COMPILER_FLAGS_NOPCH:^#^#= )

EX_C_COMPILER_FLAGS_NOPCH=$(C_COMPILER_FLAGS_NOPCH: =^
)
EX_C_COMPILER_FLAGS_NOPCH=$(EX_C_COMPILER_FLAGS_NOPCH:^#^#= )

EX_C_COMPILER_FLAGS_COD=$(EX_C_COMPILER_FLAGS)
EX_C_COMPILER_FLAGS_COD=$(EX_C_COMPILER_FLAGS_COD:/GL=/wd4652)
# replace runs of newlines with single newlines
EX_C_COMPILER_FLAGS_COD=$(EX_C_COMPILER_FLAGS_COD:^
^
=^
)
EX_C_COMPILER_FLAGS_COD=$(EX_C_COMPILER_FLAGS_COD:^
^
=^
)

EX_CXX_COMPILER_FLAGS_COD=$(EX_CXX_COMPILER_FLAGS)
EX_CXX_COMPILER_FLAGS_COD=$(EX_CXX_COMPILER_FLAGS_COD:/GL=/wd4652)
EX_CXX_COMPILER_FLAGS_COD=$(EX_CXX_COMPILER_FLAGS_COD:^
^
=^
)
EX_CXX_COMPILER_FLAGS_COD=$(EX_CXX_COMPILER_FLAGS_COD:^
^
=^
)

EX_C_COMPILER_FLAGS_PP=$(EX_C_COMPILER_FLAGS)
EX_C_COMPILER_FLAGS_PP=$(EX_C_COMPILER_FLAGS_PP:/d1PrivateNativeTypes=)
EX_C_COMPILER_FLAGS_PP=$(EX_C_COMPILER_FLAGS_PP:^
^
=^
)
EX_C_COMPILER_FLAGS_PP=$(EX_C_COMPILER_FLAGS_PP:^
^
=^
)

EX_CXX_COMPILER_FLAGS_PP=$(EX_CXX_COMPILER_FLAGS)
EX_CXX_COMPILER_FLAGS_PP=$(EX_CXX_COMPILER_FLAGS_PP:/d1PrivateNativeTypes=)
EX_CXX_COMPILER_FLAGS_PP=$(EX_CXX_COMPILER_FLAGS_PP:^
^
=^
)
EX_CXX_COMPILER_FLAGS_PP=$(EX_CXX_COMPILER_FLAGS_PP:^
^
=^
)

!ifdef USECXX_FLAG
#
# This ought to go elsewhere
#
!if "$(URT_VER)" >= "2"
C_COMPILER_FLAGS_NOPCH=$(C_COMPILER_FLAGS_NOPCH) $(MANAGED_CXX_FLAGS)
!endif
!endif

!if !$(USE_OBJECT_ROOT)

{$O}.cxx{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{$(OBJ_PATH)\$O}.cxx{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{..\}.cxx{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\}.cxx{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.cxx{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.cxx{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{$O}.cpp{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{$(OBJ_PATH)\$O}.cpp{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{..\}.cpp{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\}.cpp{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.cpp{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.cpp{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{}.cxx{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{}.cxx{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{$(TARGET_DIRECTORY)\}.cxx{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{$(TARGET_DIRECTORY)\}.cxx{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{}.cpp{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{}.cpp{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{$(TARGET_DIRECTORY)\}.cpp{$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{$(TARGET_DIRECTORY)\}.cpp{$(OBJ_PATH)\$O}.obj::
    $(CXX_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(EX_CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

!endif

{..\}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC
$(EX_CXX_COMPILER_FLAGS_COD)
$<
<<Keep

{..\}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(EX_CXX_COMPILER_FLAGS_PP)
<<Keep

{..\}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC
$(EX_CXX_COMPILER_FLAGS_COD)
$<
<<Keep

{..\}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(EX_CXX_COMPILER_FLAGS_PP)
<<Keep

{}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(EX_CXX_COMPILER_FLAGS_COD)
<<Keep

{}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(EX_CXX_COMPILER_FLAGS_PP)
<<Keep

{}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(EX_CXX_COMPILER_FLAGS_COD)
<<Keep

{}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(EX_CXX_COMPILER_FLAGS_PP)
<<Keep

!if !$(USE_OBJECT_ROOT)

{..\}.c{$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\}.c{$(OBJ_PATH)\$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.c{$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.c{$(OBJ_PATH)\$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{$O}.c{$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{$(OBJ_PATH)\$O}.c{$(OBJ_PATH)\$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{}.c{$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{}.c{$(OBJ_PATH)\$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{$(TARGET_DIRECTORY)\}.c{$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(MAKEDIR)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{$(TARGET_DIRECTORY)\}.c{$(OBJ_PATH)\$O}.obj::
    $(C_COMPILER_NAME) @<<$(CL_RSP)
/Fo"$(OBJ_PATH)\$O/"
/FC
$(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

{..\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS_COD)
<<Keep

!if !$(USE_OBJECT_ROOT)

{$O}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS_COD)
<<Keep

!endif

{..\$(TARGET_DIRECTORY)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS_COD)
<<Keep

!if !$(USE_OBJECT_ROOT)

{$O}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS_PP)
<<Keep

!endif

!if $(USE_OBJECT_ROOT)

{$(OBJ_PATH)\$O}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS_PP)
<<Keep

!endif

{..\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS_PP)
<<Keep

{..\$(TARGET_DIRECTORY)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<Keep

{}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS_COD)
<<Keep

{$(TARGET_DIRECTORY)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
<<Keep

{}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS_PP)
<<Keep

{$(TARGET_DIRECTORY)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS_PP)
<<Keep

{}.c{$(TARGET_DIRECTORY)\}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS_PP)
<<Keep

# } }

#
# C# compiler rules
#

EX_MANAGED_COMPILER_FLAGS=$(MANAGED_STD_FLAGS)

!if 0
!if $(USE_OBJECT_ROOT)

{..}.cs{$(OBJ_PATH)\$O}.dll::
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG)
    @$(CS_COMPILER_NAME) @<<$(CS_RSP)
$(EX_MANAGED_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..}.vb{$(OBJ_PATH)\$O}.dll::
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG)
    @$(VB_NET_COMPILER_NAME) @<<$(VB_RSP)
$(EX_MANAGED_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

!endif
!endif

#
# resgen rules
#

!if !$(USE_OBJECT_ROOT)

.resz{$O}.resources:
    resxgen $< $*.resx
    resgen $*.resx $@

.resx{$O}.resources:
    resgen $< $@

.txt{$O}.resources:
    resgen $< $@

!endif

!if $(USE_OBJECT_ROOT)

.resz{$(OBJ_PATH)\$O}.resources:
    resxgen $< $*.resx
    resgen $*.resx $@

.resx{$(OBJ_PATH)\$O}.resources:
    resgen $< $@

.txt{$(OBJ_PATH)\$O}.resources:
    resgen $< $@

!endif

!if 0

#
# SDL proxy generation rules
#
.sdl.cs::
    webserviceutil /c:proxy /path:$<

!endif

!if "$(NTNOFUZZYLOOKUP)" == "1"
LIBRARY_OBJS=
!else
LIBRARY_OBJS = $(LIBRARY_OBJS) $(HEADEROBJNAME)
!endif

!ifdef USE_INCREMENTAL_LINKING
IMPLIB_DEPEND =
!else
IMPLIB_DEPEND = $(LIBRARY_OBJS)
!endif

#
# inference rules for preprocessing manifests
# It would be nice to go from .manifest to .manifest.obj, but nmake doesn't work that way.
# There is some precedent for going from .src to .manifest, but I'd rather generated files
# end in obj. But we can't go from .manifest to .manifestobj either, because of the case
# of manifests not in resources.
#
# .man is for fitting in 8.3
#
.SUFFIXES: .manifest .man .o_manifest

# This string is needed in at least four places in the tree, so factor it to here.
SYSTEM_COMPATIBLE_ASSEMBLY_NAME=Microsoft.Windows.SystemCompatible
DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME=\
    -DSYSTEM_COMPATIBLE_ASSEMBLY_NAME="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\"" \
    -DLSYSTEM_COMPATIBLE_ASSEMBLY_NAME=L"\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\""

SYSTEM_COMPATIBLE_ASSEMBLY_VERSION=6.0
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3=$(VER_PRODUCTBUILD)
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4=$(VER_PRODUCTBUILD_QFE)

SXS_MANIFEST_DEFINES= \
 -DSXS_PROCESSOR_ARCHITECTURE="\"$(SXS_PROCESSOR_ARCHITECTURE)\"" \
 -DSXS_TARGET="\"$(TARGETNAME).$(TARGETEXT:lib=dll)\"" \
 $(DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME) \
 $(SXS_MANIFEST_DEFINES)
!ifdef SXS_AUTO_VERSION
# Some assemblies shipped with policy versions unrelated to their manifest version --
# in the event that the policy is now at a higher version than the corresponding
# assembly, we won't override it using our default behavior of using a policy version
# equal to the current assembly version. In this case provide an override mechanism:
# in sources set SXS_OVERRIDE_POLICY_VERSION=(major).(minor) and also use
# SXS_OVERRIDE_POLICY_VERSION as the version in your manifest and we will take care
# of adding the third and fourth parts and making it a string.
SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) -DSXS_MAJMIN_ASSEMBLY_VERSION=$(SXS_ASSEMBLY_VERSION) \
 -DSXS_OVERRIDE_POLICY_VERSION_MAJMIN=$(SXS_OVERRIDE_POLICY_VERSION)
!else
SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) -DSXS_ASSEMBLY_VERSION="\"$(SXS_ASSEMBLY_FULL_VERSION)\""
!endif

!if "$(SXS_ASSEMBLY_LANGUAGE)" != ""
SXS_MANIFEST_DEFINES=-DSXS_ASSEMBLY_LANGUAGE="\"$(SXS_ASSEMBLY_LANGUAGE)\"" $(SXS_MANIFEST_DEFINES)
SXS_MANIFEST_DEFINES=-DSXS_LANGUAGE="\"$(SXS_ASSEMBLY_LANGUAGE)\"" $(SXS_MANIFEST_DEFINES)
!endif

!if "$(SXS_ASSEMBLY_NAME)" != ""
SXS_MANIFEST_DEFINES=-DSXS_ASSEMBLY_NAME="\"$(SXS_ASSEMBLY_NAME)\"" $(SXS_MANIFEST_DEFINES)
!endif


#MANIFEST_PREPROCESSOR_NAME=$(C_PREPROCESSOR_NAME)
# $(TARGET_CPP) does not include /FIwarning.h.
# Otherwise we have to filter the data through, like Perl:
# while (<>) {
#       if (!/^#pragma.+/ && !/^$/) {
#               print;
#       }
#}
!ifndef MANIFEST_PREPROCESSOR_NAME
!ifdef SXS_AUTO_VERSION
MANIFEST_PREPROCESSOR_NAME=$(C_PREPROCESSOR_NAME)
!else
MANIFEST_PREPROCESSOR_NAME=preprocessor
!endif
!endif

#
# Auto versioning can be made simpler.
# Perl and the C preprocessor can be removed.
# The original author did not seem to know about LINKER_FLAGS.
#
!ifdef SXS_AUTO_VERSION
MANIFEST_VERSION_HEADER=$(SDK_INC_PATH)\sxsmanifest.h
MANIFEST_PREPROCESSOR_FLAGS=$(MANIFEST_PREPROCESSOR_FLAGS) \
    /EP /nologo /I$(SDK_INC_PATH)
MANIFEST_TRIMMER=$(_PERL) -ne "print if (!/^.pragma/ && /^.+/)"
MANIFEST_PREPROCESS=$(MANIFEST_PREPROCESSOR_NAME) \
    $(MANIFEST_PREPROCESSOR_FLAGS) /FI$(MANIFEST_VERSION_HEADER) \
    $(SXS_MANIFEST_DEFINES) $< | $(MANIFEST_TRIMMER) > $@.temp
!else
MANIFEST_PREPROCESS=$(MANIFEST_PREPROCESSOR_NAME) -o $@.temp -i $< $(SXS_MANIFEST_DEFINES)
!endif

#
# .manifest -> .man
#
{}.manifest{$(OBJ_PATH)\$O}.man:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{..}.manifest{$(OBJ_PATH)\$O}.man:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{..\..}.manifest{$(OBJ_PATH)\$O}.man:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{$(SXS_MANIFEST_SOURCE)}.manifest{$(OBJ_PATH)\$O}.man:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

#
# .manifest -> .manifest
#
{}.manifest{$(OBJ_PATH)\$O}.manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{..}.manifest{$(OBJ_PATH)\$O}.manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{..\..}.manifest{$(OBJ_PATH)\$O}.manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{$(SXS_MANIFEST_SOURCE)}.manifest{$(OBJ_PATH)\$O}.manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

#
# .manifest -> .o_manifest
#
{}.manifest{$(OBJ_PATH)\$O}.o_manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{..}.manifest{$(OBJ_PATH)\$O}.o_manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{..\..}.manifest{$(OBJ_PATH)\$O}.o_manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

{$(SXS_MANIFEST_SOURCE)}.manifest{$(OBJ_PATH)\$O}.o_manifest:
    -$(_DEL)
    $(MANIFEST_PREPROCESS)
    $(_MOVE)

#
# Standard inference rule for generating machine specific def files.
#

.SUFFIXES: .def .src

!if !$(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.src{$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\$(TARGET_DIRECTORY)\}.src{$(OBJ_PATH)\$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{..\}.src{$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\}.src{$(OBJ_PATH)\$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{}.src{$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{}.src{$(OBJ_PATH)\$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{..\}.def{$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\}.def{$(OBJ_PATH)\$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

{}.def{$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{}.def{$(OBJ_PATH)\$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if !$(USE_OBJECT_ROOT)

# one more level down for HALS
{..\..\}.src{$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!if $(USE_OBJECT_ROOT)

{..\..\}.src{$(OBJ_PATH)\$O}.def:
    @$(_TYPE) <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!endif

!ifdef NO_BROWSER_FILE
BROWSERFILE=
!else
! ifdef BROWSER_INFO
!  ifndef BROWSERFILE
!   if "$(TARGETNAME)" == ""
BROWSERFILE=
!   else
BROWSERFILE=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).bsc
!   endif
!  endif
! else
BROWSERFILE=
! endif
!endif

!if defined (USE_LINT) && ("$(LINT_TYPE)" != "all")

!if $(USE_OBJECT_ROOT)

{}.cxx{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)}.cxx{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..}.cxx{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)}.cxx{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{}.cpp{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)}.cpp{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..}.cpp{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)}.cpp{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{}.c{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)}.c{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..}.c{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)}.c{$(OBJ_PATH)\$O}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
!endif
    $(LINT_CMD) $<

!endif
!endif


#
# Standard list of targets: all. all is the default target.
#

!IFNDEF PASS0ONLY
all: \
!if !defined(BUILD_PASS_INDEPENDENT)
        PassIndependentTargets_Infs \
        PassIndependentTargets_Binplace \
!endif
        $(OBJ_PATH)\$O\_objects.mac \
        $(OBJ_PATH)\$O\_objects.mac.verify.$(BUILD_PASS).mac \
! ifdef DO_LANGUAGE_NEUTRAL
        $(RC_CONFIG_OBJ1) \
!   ifdef DELTA_RC_CONFIG
        $(RC_CONFIG_OBJ2) \
!   endif
! endif
!ifdef _ASSEMBLY_IDENTITY
        $(OBJ_PATH)\$O\_asmid.inc \
        $(OBJ_PATH)\$O\_asmid.xml \
!endif
        $(_O_BINARY_METADATA) \
        $(NTTARGETFILE0)  \
# Support to compile licensing manifest
!if defined(SLS_LICENSING_MANIFEST)
        $(SLS_LICENSING_TARGETS) \
!endif
!if !defined(BUILD_PASS_INDEPENDENT)
        PassIndependentTargets_Manifests \
!endif
        $(WPP_TARGETS) \
        $(PASS0_OBJECTS) \
!if defined(EVENTS_MANIFEST)
        $(OBJ_PATH)\$O\_event_manifests \
!endif
        _concurrent_midl_join \
        PASS0_Pub    \
        PASS0_Binp   \
        $(PRECOMPILED_TARGET) \
        $(HEADEROBJNAME) \
!if "$(XAML_COMPILATION)" == "1"
        build_xaml  \
!endif
!if defined(COMPILE_RESOURCES_IN_PASS1) \
        || ("$(TARGETTYPE)" != "DYNLINK" \
            && "$(TARGETTYPE)" != "EXPORT_DRIVER" \
            && "$(TARGETTYPE)" != "PROGLIB")
        $(_RES_FILE) \
!endif
        build_objects \
        $(SXS_MANIFEST_OBJ1) \
        $(SXS_MANIFEST_OBJ2) \
        $(SXS_PDB_NAMER) \
        $(TARGETLOBFILES1) \
        $(TARGETLIBFILES) \
        $(NTTARGETFILE1)  \
!if defined(DO_LANGUAGE_NEUTRAL) && !defined(NOLINK) && "$(MYMUILINK)" != "" && "$(TARGET)" != ""
        $(TARGET).mui \
!endif
!if  defined(DO_LSBUILD) && !defined(NOLINK) && "$(LCG_DEPEND)" != ""
        $(LCG_TARGET) \
! endif
        $(TARGETEXEFILES) \
        $(BROWSERFILE)   \
        $(TARGETLOBFILES2) \
        PASS1_Pub     \
        PASS1_Binp   \
        build_umobjects \
!ifndef NOLINK
        $(UMEXEFILES) \
!endif
        $(NTTARGETFILES) \
!if "$(BUILD_PASS)" == "PASS2" || "$(BUILD_PASS)" == "PASSALL"
        $(NTTARGETFILE2) \
!endif
!if !defined(NOLINK)
!endif
!if ("$(MAKEDLL)" != "" && !defined(NOLINK))
        $(_O_ASMMETA) \
!else
!  if "$(ASMMETA_INPUT)" != "" && "$(TARGETTYPE)" == "NOTARGET"
!    if exist($(ASMMETA_INPUT))
        $(_O_ASMMETA) \
!    endif
!  endif
!endif
        PASS2_Binp    \
        $(SN_SIGN_SPEC) \
!if defined(BOOT_SIGN_SPEC)
!  if "$(BUILD_PASS)" == "PASS2"
        $(BOOT_SIGN_SPEC) \
!  else
!    if defined(BOOT_LOADER_CRITICAL_MISC_FILES) && "$(BUILD_PASS)" == "PASS1"
        $(BOOT_SIGN_SPEC) \
!    endif
!  endif
!endif
!if defined(WDK_MANIFEST_NAME)
!   if "$(BUILD_PASS)" == "PASS2"
        $(WDK_MANIFEST_NAME) \
!   else if "$(TARGETTYPE)" == "NOTARGET" && (defined(WDKMSI) || defined(WDKFCI) || defined(WDKLCI) || defined(WDKFILES) || defined(WDKSXE) || defined(WDKBIND) || defined(WDKUI) || defined(WDKWIX) || defined(WDKUPDATE))
        $(WDK_MANIFEST_NAME) \
!   else if ("$(TARGETTYPE)" == "LIBRARY" || ("$(TARGETTYPE)" == "DYNLINK" && "$(MANAGED_CODE)" == "1")) && "$(BUILD_PASS)" == "PASS1" && defined(WDKMSI) && !defined(PASS2_BINPLACE)
        $(WDK_MANIFEST_NAME) \
!   endif
!endif
        $(_OUTPUT_MANIFEST) \
# These are very special macros that are created based on the pass currently running
# and the content of the PASS# variants of each macro. The code block we run in each
# pass is identical and they never run at the same time, so this enables us to
# re-use as much of the infrastructure as possible.
        $(LANG_MISCFILES_LOG) \
        $(LOC_MISCFILES_LOG) \
        $(LOC_MUI_MISCFILES_LOG) \
        $(PRELOC_MISCFILES_LOG) \
        $(PRELOC_MUI_MISCFILES_LOG) \
        $(PRELOC_MUI_ONLY_MISCFILES_LOG) \
        $(MULTI_MISCFILES_LOG) \
        $(MULTI_MUI_MISCFILES_LOG) \
        $(LOC_PLA_XML_FILES_LOG) \
!if "$(BUILD_PASS)" == "PASS1"
# Special target for binplacing Perf Counter files.
! ifdef LOC_PERF_COUNTERS
        binplace_loc_perf_counters \
! endif
# Special target for binplacing MSC files.
! ifdef LOC_MSC_FILES
        binplace_loc_msc_files \
! endif
!endif
!if !$(MISCFILES_DURING_LINK) || !defined(NOLINK)
! if "$(MISCFILES: =)" != "" || defined(SXS_MISCFILES) || "$(_O_SXS_RESOURCES_MANIFEST)" != ""
        $(MISCFILES) \
        $(SXS_MISCFILES) \
        $(_O_SXS_RESOURCES_MANIFEST) \
!  ifdef _NTTREE
        binplace_miscfiles \
!  endif
! endif
# Generate the files to binplace so that if they need to be built,
# nmake knows to build these files _before_ processing the macros.
        $(LANG_MISCFILES) \
        $(LOC_MISCFILES) \
        $(LOC_MUI_MISCFILES) \
        $(PRELOC_MISCFILES) \
        $(PRELOC_MUI_MISCFILES) \
        $(PRELOC_MUI_ONLY_MISCFILES) \
        $(MULTI_MISCFILES) \
        $(MULTI_MUI_MISCFILES) \
!endif
!ifdef _RUN_SXS_LOG_CMD
        sxs_log_cmd \
!endif
        BINARY_Pub  \
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES)
        $(OBJ_PATH)\$O\_keyfile.al \
        $(OBJ_PATH)\$O\$(TARGETNAME).resources.dll \
!endif


!if defined(_O_SXS_RESOURCES_MANIFEST)

$(_O_SXS_RESOURCES_MANIFEST):
    set BUILDMSG=making $(@F)
    -$(_DEL)
    set createfile=<<$@.temp
<assembly
    xmlns="urn:schemas-microsoft-com:asm.v1"
    manifestVersion="1.0"
    >
    <assemblyIdentity
        type="win32"
        name="$(SXS_ASSEMBLY_NAME).Resources"
        version="$(SXS_ASSEMBLY_FULL_VERSION)"
        processorArchitecture="$(SXS_PROCESSOR_ARCHITECTURE)"
        publicKeyToken="6595b64144ccf1df"
    />
    <file name="$(TARGETNAME).$(TARGETEXT).mui"/>
    <memberships xmlns="urn:schemas-microsoft-com:asm.v3">
        <categoryMembership>
            <id
                name="Microsoft.Windows.Fusion_Components_All"
                version="$(VER_PRODUCTVERSION_STR)"
                processorArchitecture="$(SXS_PROCESSOR_ARCHITECTURE)"
                language="neutral"
                buildType="$(MANIFEST_BUILD_TYPE)"
                publicKeyToken="1122334455667788"
            />
        </categoryMembership>
    </memberships>
</assembly>
<<Keep
    $(_MOVE)

!endif

# make a target that always build
sxs_log_cmd:
    $(SXS_LOG_CMD)



binplace_miscfiles: $(MISCFILES) $(SXS_MISCFILES) $(_O_SXS_RESOURCES_MANIFEST)
!ifndef NO_BINPLACE
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MAKEDIR) BINPLACE_MISCFILES=$**
<<$(BUILD_NOKEEP)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) @<<$(BINPLACE_RESPONSE_FILE)
$**
<<$(BUILD_NOKEEP)
!endif

# These are special in that we binplace the files specified to two destinations -
# one language neutral and one language specific. We also create LCG files for them
# so that the language specific files can be localized. This is all done to support
# the legacy performance counter infrastrusture where English is assumed to be the
# neutral/default stuff all rolled into one file.
binplace_loc_perf_counters: $(LOC_PERF_COUNTERS)
!ifndef NO_BINPLACE
    @$(_TYPE) <<$(BINPLACE_RESPONSE_FILE)
$(MAKEDIR) BINPLACE_LOC_PERF_COUNTERS=$**
<<$(BUILD_NOKEEP)
    $(_PERL) $(RAZZLETOOLPATH)\VerifyUnicode.pl -files:<<$(PERL_RESPONSE_FILE)
$**
<<$(BUILD_NOKEEP)
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST $(LOC_PERF_COUNTERS_TARGET_DESTINATION):$(PERF_COUNTERS_TARGET_DESTINATION) @<<$(BINPLACE_RESPONSE_FILE)
$**
<<$(BUILD_NOKEEP)
!endif
# LOC_PERF_COUNTERS always runs regardless of BUILD_LCG or it's cousins
!if "$(DO_LSBUILD)" == "1"
    set BUILDMSG=making LOC_PERF_COUNTERS with CreateLCGFile.pl
    set createfile=<<$(OBJ_PATH)\$O\loc_perf_counters.lcg.lst
$(**: =
)
<<Keep
! ifndef NO_BINPLACE
     set createfile=<<$(OBJ_PATH)\$O\loc_perf_counters.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST $(LOC_PERF_COUNTERS_TARGET_DESTINATION)
<<Keep
! endif # NO_BINPLACE
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(OBJ_PATH)\$O\loc_perf_counters.lcg.lst \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
        /unicode \
! ifndef NO_BINPLACE
        /b:$(OBJ_PATH)\$O\loc_perf_counters.lcg.binplace.txt \
        /r:$(LCG_BINPLACE_TARGET) \
! endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
!endif # DO_LSBUILD



# These are special in that we binplace the files specified to two destinations -
# one language neutral and one language specific. We also create LCG files for them
# so that the language specific files can be localized. This is all done to support
# the legacy MSC files we have to ship but cannot change the format of - and where English
# is assumed to be the neutral/default stuff all rolled into one file.
binplace_loc_msc_files: $(LOC_MSC_FILES)
!ifndef NO_BINPLACE
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MAKEDIR) BINPLACE_LOC_MSC_FILES=$**
<<$(BUILD_NOKEEP)
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST $(LOC_MSC_FILES_TARGET_DESTINATION):$(MSC_FILES_TARGET_DESTINATION) @<<$(BINPLACE_RESPONSE_FILE)
$**
<<$(BUILD_NOKEEP)
!endif
# LOC_MSC_FILES always runs regardless of BUILD_LCG or it's cousins
!if "$(DO_LSBUILD)" == "1"
    set BUILDMSG=making LOC_MSC_FILES with CreateLCGFile.pl
    set createfile=<<$(OBJ_PATH)\$O\loc_msc_files.lcg.lst
$(**: =
)
<<Keep
! ifndef NO_BINPLACE
     set createfile=<<$(OBJ_PATH)\$O\loc_msc_files.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST $(LOC_MSC_FILES_TARGET_DESTINATION)
<<Keep
! endif # NO_BINPLACE
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(OBJ_PATH)\$O\loc_msc_files.lcg.lst \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
! ifndef NO_BINPLACE
        /b:$(OBJ_PATH)\$O\loc_msc_files.lcg.binplace.txt \
        /r:$(LCG_BINPLACE_TARGET) \
! endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
!endif # DO_LSBUILD


# LOC_PLA_XML_FILES need to be binplaced and run through SplitStrings.js to create a
# language specific .plaxml file which also needs to be binplaced. We also need to
# create and binplace an LCG for the language specific .plaxml file we created.
# $? is the files with a later timestamp than $(LOC_PLA_XML_FILES_LOG)
# $(LOC_PLA_XML_FILES_LOG) is the list of files that were processed, binplaced,
# and had LCG files generated for them.
!if defined(LOC_PLA_XML_FILES_LOG)
$(LOC_PLA_XML_FILES_LOG): $(LOC_PLA_XML_FILES)
     set createfile=<<$(LOC_PLA_XML_FILES_LOG)
$?
<<Keep
     $(_PERL) $(RAZZLETOOLPATH)\SplitPlaXmlStrings.pl \
        /i:$(LOC_PLA_XML_FILES_LOG) \
        /o:$(LOC_PLA_XML_FILES_RESOURCE_LIST) \
        /d:$(OBJ_PATH)\$O
! ifndef NO_BINPLACE
     $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) @$(LOC_PLA_XML_FILES_LOG)
     $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) /R $(_NTTREE)\$(LOC_BIN) @$(LOC_PLA_XML_FILES_RESOURCE_LIST)
! endif
# LOC_PLA_XML_FILES always runs regardless of BUILD_LCG or it's cousins
! if "$(DO_LSBUILD)" == "1"
     set BUILDMSG=making LOC_PLA_XML_FILES with CreateLCGFile.pl
     set createfile=<<$(OBJ_PATH)\$O\loc_pla_xml_files.lcg.lst
$(?:.xml=.plaxml)
<<Keep
!  ifndef NO_BINPLACE
     set createfile=<<$(LOC_PLA_XML_FILES_LCG_BINPLACE_TXT)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # NO_BINPLACE
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(LOC_PLA_XML_FILES_RESOURCE_LIST) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!  ifndef NO_BINPLACE
        /b:$(LOC_PLA_XML_FILES_LCG_BINPLACE_TXT) \
        /r:$(LCG_BINPLACE_TARGET) \
!  endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
! endif # DO_LSBUILD
!endif # LOC_PLA_XML_FILES_LOG

build_objects: $(TARGETOBJFILES)

build_umobjects: $(UMOBJFILES)

!ELSE   # PASS0ONLY

all: \
!if !defined(BUILD_PASS_INDEPENDENT)
        PassIndependentTargets_Infs \
        PassIndependentTargets_Binplace \
!endif
        $(OBJ_PATH)\$O\_objects.mac.verify.$(BUILD_PASS).mac \
!ifdef _ASSEMBLY_IDENTITY
        $(OBJ_PATH)\$O\_asmid.inc \
        $(OBJ_PATH)\$O\_asmid.xml \
!endif
        $(_O_BINARY_METADATA) \
        $(NTTARGETFILE0)  \
# Support to compile licensing manifest
!if defined(SLS_LICENSING_MANIFEST)
        $(SLS_LICENSING_TARGETS) \
!endif
!if !defined(BUILD_PASS_INDEPENDENT)
        $(SOURCE_MANIFEST) \
        $(WOW64_SOURCE_MANIFEST) \
        $(MULTI_SOURCE_MANIFEST) \
        $(MULTI_WOW64_SOURCE_MANIFEST) \
        $(PROD_SOURCE_MANIFEST) \
        $(PROD_WOW64_SOURCE_MANIFEST) \
        $(INTERNAL_SOURCE_MANIFEST) \
        $(INTERNAL_WOW64_SOURCE_MANIFEST) \
        $(EDITION_SOURCE_MANIFEST) \
        $(WINPE_SOURCE_MANIFEST) \
!endif
        $(WPP_TARGETS) \
        $(PASS0_OBJECTS) \
!if defined(EVENTS_MANIFEST)
        $(OBJ_PATH)\$O\_event_manifests \
!endif
!if defined(COUNTERS_MANIFEST)
        BUILD_COUNTERS_MANIFEST \
!endif
!if defined(WSUTIL_METADATA)
        WSUTIL \
!endif
! ifdef DO_LANGUAGE_NEUTRAL
        $(RC_CONFIG_OBJ1) \
!   ifdef DELTA_RC_CONFIG
        $(RC_CONFIG_OBJ2) \
!   endif
! endif
# These are very special macros that are created based on the pass currently running
# and the content of the PASS# variants of each macro. The code block we run in each
# pass is identical and they never run at the same time, so this enables us to
# re-use as much of the infrastructure as possible.
        $(LANG_MISCFILES_LOG) \
        $(LOC_MISCFILES_LOG) \
        $(LOC_MUI_MISCFILES_LOG) \
        $(PRELOC_MISCFILES_LOG) \
        $(PRELOC_MUI_MISCFILES_LOG) \
        $(PRELOC_MUI_ONLY_MISCFILES_LOG) \
        $(MULTI_MISCFILES_LOG) \
        $(MULTI_MUI_MISCFILES_LOG) \
    _concurrent_midl_join \
    PASS0_Pub \
    PASS0_Binp \
!if "$(XAML_COMPILATION)" == "1"
    build_xaml  \
!endif
!if defined(RESGEN_SOURCES)
    PASS0_Resgen \
!endif

!ENDIF  # PASS0ONLY

_concurrent_midl_join:
!if defined(_CONCURRENT_MIDL_JOIN)
    set BUILDMSG=waiting for asynchronous midl
    $(_CONCURRENT_MIDL_JOIN)
!endif

#
# temporary to validate changes in build.exe
#
$(OBJ_PATH)\$O\_objects.mac.verify.$(BUILD_PASS).mac:
!if 0
    <<$@.cmd
        if not exist $(OBJ_PATH)\$O\_objects.mac goto :eof
        $(_COPYFILE) /y $(OBJ_PATH)\$O\_objects.mac $@
        for %%a in ($(OBJ_PATH)\$O\_objects.mac.verify.*.mac) do (diff $(OBJ_PATH)\$O\_objects.mac %%a > $@.diff || $(_PERL) -pi -e "s/^(.)/$(@F) : error \1/g" < $@.diff)
<<Keep
!endif

$(OBJ_PATH)\$O\_objects.mac: $(SOURCES_USED)
    @echo Rebuilding $@ $(SOURCES_USED).
    @build /O /Z /f /$(TARGET_DIRECTORY:i386=x86)
    @if exist $@ @echo nmake : error: $@ was changed during the build process and the build results may not be valid. Please re-build this directory.
# The following line is intended to produce an error -- access denied.
    @if exist $@ mkdir \ 2>nul


#
# LANG_MISCFILES support
#
# These are files that are "language specific but not localizable". They need
# to be in the language pack but do not need to be localized. We just binplace
# the files as-is. No MUI splitting needs needs to be done on these files.
#
!if defined(LANG_MISCFILES_LOG)
$(LANG_MISCFILES_LOG): $(LANG_MISCFILES)
# $? is the files with a later timestamp than $(LANG_MISCFILES_LOG)
# $(LANG_MISCFILES_LOG) is the list of files that were binplaced.
     set createfile=<<$(LANG_MISCFILES_LOG)
$?
<<Keep
! ifndef NO_BINPLACE
     $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) /R $(_NTTREE)\$(LOC_BIN) @$(LANG_MISCFILES_LOG)
! endif
!endif # LANG_MISCFILES_LOG


#
# LOC_MISCFILES support
#
# These are files that need to be localized so we just need to create an LCG
# for them and then binplace the file and the LCG files. No MUI splitting needs
# needs to be done on these files. This is typically done on checked in files
# or on files generated by other directories where you are using the proper
# cross-directory syncronization to make this directory/operation happen last.
#
!if defined(LOC_MISCFILES_LOG)
$(LOC_MISCFILES_LOG): $(LOC_MISCFILES)
# $? is the files with a later timestamp than $(LOC_MISCFILES_LOG)
# $(LOC_MISCFILES_LOG) is the list of files that were split, binplaced,
# and had LCG files generated for them.
     set createfile=<<$(LOC_MISCFILES_LOG)
$?
<<Keep
! ifndef NO_BINPLACE
     $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) /R $(_NTTREE)\$(LOC_BIN) @$(LOC_MISCFILES_LOG)
! endif
! if "$(DO_LSBUILD)" == "1"
!  ifndef NO_BINPLACE
     set BUILDMSG=making $(BUILD_PASS)_LOC_MISCFILES with CreateLCGFile.pl
     set createfile=<<$(LOC_MISCFILES_LCG_BINPLACE_TXT)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # NO_BINPLACE
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(LOC_MISCFILES_LOG) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!  ifndef NO_BINPLACE
        /b:$(LOC_MISCFILES_LCG_BINPLACE_TXT) \
        /r:$(LCG_BINPLACE_TARGET) \
!  endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
! endif # DO_LSBUILD
!endif # LOC_MISCFILES_LOG


#
# LOC_MUI_MISCFILES support
#
# These are similar to LOC_MISCFILES, but we need to do MUI splitting on these files
# first, then binplace both of the resulting files, and then create LCG files
# for each of the resulting MUI files. This is typically done on checked in files
# or on files generated by other directories where you are using the proper
# cross-directory syncronization to make this directory/operation happen last.
#
!if defined(LOC_MUI_MISCFILES_LOG)
$(LOC_MUI_MISCFILES_LOG): $(LOC_MUI_MISCFILES)
# $? is the files with a later timestamp than $(LOC_MUI_MISCFILES_LOG)
# $(LOC_MUI_MISCFILES_LOG) is the list of files that were split, binplaced,
# and had LCG files generated for them.
     set createfile=<<$(LOC_MUI_MISCFILES_LOG)
$?
<<Keep
    $(_PERL) $(RAZZLETOOLPATH)\SplitMiscFiles.pl \
!if defined(BINPLACE_NO_SYMCHK) || defined(NO_BINPLACE)
        /nosym \
!endif
        /i:$(LOC_MUI_MISCFILES_LOG) \
        /n:$(LOC_MUI_MISCFILES_NEUTRAL_LIST) \
        /r:$(LOC_MUI_MISCFILES_RESOURCE_LIST) \
        /m:"$(LANGUAGE_NEUTRAL_RESOURCE_MUIRCT)" \
        /t:$(OBJ_PATH)\$O
! ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) \
!  if "$(LOCALIZE_BASE_FILE)" == "1"
    /R $(_NTTREE)\$(LOC_MULTI) \
!  endif # LOCALIZE_BASE_FILE
    @$(LOC_MUI_MISCFILES_NEUTRAL_LIST)
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) \
    -G5 $(LANGUAGE_NEUTRAL_RESDIR) @$(LOC_MUI_MISCFILES_RESOURCE_LIST)
! endif # NO_BINPLACE
! if "$(DO_LSBUILD)" == "1"
!  ifndef NO_BINPLACE
     set BUILDMSG=making $(BUILD_PASS)_LOC_MUI_MISCFILES with CreateLCGFile.pl
     set createfile=<<$(LOC_MUI_MISCFILES_LCG_BINPLACE_TXT)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # NO_BINPLACE
!  if "$(LOCALIZE_BASE_FILE)" == "1"
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(LOC_MUI_MISCFILES_NEUTRAL_LIST) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
        /b:$(LOC_MUI_MISCFILES_LCG_BINPLACE_TXT) \
        /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
!  endif # LOCALIZE_BASE_FILE
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(LOC_MUI_MISCFILES_RESOURCE_LIST) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!  ifndef NO_BINPLACE
        /b:$(LOC_MUI_MISCFILES_LCG_BINPLACE_TXT) \
        /r:$(LCG_BINPLACE_TARGET) \
!  endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
! endif # DO_LSBUILD
!endif # LOC_MUI_MISCFILES_LOG


#
# PRELOC_MISCFILES support
#
# These are similar to MISCFILES, except that they are pre-localized.
# This is typically done on checked in files that are already localized.
# We do not need to create an LCG file for these files.
#
!if defined(PRELOC_MISCFILES_LOG)
$(PRELOC_MISCFILES_LOG): $(PRELOC_MISCFILES)
# $? is the files with a later timestamp than $(PRELOC_MISCFILES_LOG)
     set createfile=<<$(PRELOC_MISCFILES_LOG)
$?
<<Keep
! ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) /R $(_NTTREE)\$(PRELOC_BINPLACE_DIR) @$(PRELOC_MISCFILES_LOG)
! endif
!endif # PRELOC_MISCFILES_LOG


#
# PRELOC_MUI_MISCFILES support
#
# These are similar to MISCFILES, except that they are pre-localized and
# that they need to be MUI split and the resulting file + MUI file
# binplaced. This is typically done on checked in files that are already
# localized. We do not need to create an LCG file for these files.
#
!if defined(PRELOC_MUI_MISCFILES_LOG)
$(PRELOC_MUI_MISCFILES_LOG): $(PRELOC_MUI_MISCFILES)
# $? is the files with a later timestamp than $(PRELOC_MUI_MISCFILES_LOG)
     set createfile=<<$(PRELOC_MUI_MISCFILES_LOG)
$?
<<Keep
    $(_PERL) $(RAZZLETOOLPATH)\SplitMiscFiles.pl \
!if defined(BINPLACE_NO_SYMCHK) || defined(NO_BINPLACE)
        /nosym \
!endif
        /i:$(PRELOC_MUI_MISCFILES_LOG) \
        /n:$(PRELOC_MUI_MISCFILES_NEUTRAL_LIST) \
        /r:$(PRELOC_MUI_MISCFILES_RESOURCE_LIST) \
        /m:"$(LANGUAGE_NEUTRAL_RESOURCE_MUIRCT)" \
        /t:$(OBJ_PATH)\$O
! ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) @$(PRELOC_MUI_MISCFILES_NEUTRAL_LIST) \
    /R $(_NTTREE)\$(PRELOC_BINPLACE_DIR) @$(PRELOC_MUI_MISCFILES_RESOURCE_LIST)
! endif
!endif # PRELOC_MUI_MISCFILES_LOG


#
# PRELOC_MUI_ONLY_MISCFILES support
#
# These are similar to MISCFILES, except that they are pre-localized and
# that they need to be MUI split - but only the resulting MUI file needs
# to be binplaced. This is typically done on checked in files that are
# already localized. We do not need to create an LCG file for these files.
#
!if defined(PRELOC_MUI_ONLY_MISCFILES_LOG)
$(PRELOC_MUI_ONLY_MISCFILES_LOG): $(PRELOC_MUI_ONLY_MISCFILES)
# $? is the files with a later timestamp than $(PRELOC_MUI_ONLY_MISCFILES_LOG)
     set createfile=<<$(PRELOC_MUI_ONLY_MISCFILES_LOG)
$?
<<Keep
    $(_PERL) $(RAZZLETOOLPATH)\SplitMiscFiles.pl \
!if defined(BINPLACE_NO_SYMCHK) || defined(NO_BINPLACE)
        /nosym \
!endif
        /i:$(PRELOC_MUI_ONLY_MISCFILES_LOG) \
        /n:$(PRELOC_MUI_ONLY_MISCFILES_NEUTRAL_LIST) \
        /r:$(PRELOC_MUI_ONLY_MISCFILES_RESOURCE_LIST) \
        /m:"$(LANGUAGE_NEUTRAL_RESOURCE_MUIRCT)" \
        /t:$(OBJ_PATH)\$O
! ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) /R $(_NTTREE)\$(PRELOC_BINPLACE_DIR) @$(PRELOC_MUI_ONLY_MISCFILES_RESOURCE_LIST)
! endif
!endif # PRELOC_MUI_ONLY_MISCFILES_LOG


#
# Any localizable MISCFILES that need to go into the ML postbuild go into the
# MULTI_MISCFILES macro instead of the MISCFILES macro. Any files specified by
# MULTI_MISCFILES will have LCG files created for them by calling CreateLCGFile.pl
# for them, in addition to the binplacing of the files to %_NTTREE%\loc\src\multi.
# The resulting LCG file will be binplaced to %_NTTREE%\%LCG_BINPLACE_ROOT%, plus
# any additional relative destination path for the original file.
#
!if defined(MULTI_MISCFILES_LOG)
$(MULTI_MISCFILES_LOG): $(MULTI_MISCFILES)
# $? is the files with a later timestamp than $(MULTI_MISCFILES_LOG)
# $(MULTI_MISCFILES_LOG) is the list of files that were split, binplaced,
# and had LCG files generated for them.
     set createfile=<<$(MULTI_MISCFILES_LOG)
$?
<<Keep
! ifndef NO_BINPLACE
     $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) /R $(_NTTREE)\$(LOC_MULTI) @$(MULTI_MISCFILES_LOG)
! endif # NO_BINPLACE
! if "$(DO_LSBUILD)" == "1"
!  ifndef NO_BINPLACE
     set BUILDMSG=making $(BUILD_PASS)_MULTI_MISCFILES with CreateLCGFile.pl
     set createfile=<<$(MULTI_MISCFILES_LCG_BINPLACE_TXT)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # NO_BINPLACE
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(MULTI_MISCFILES_LOG) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!  ifndef NO_BINPLACE
        /b:$(MULTI_MISCFILES_LCG_BINPLACE_TXT) \
        /r:$(LCG_BINPLACE_TARGET) \
!  endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
! endif # DO_LSBUILD
!endif # MULTI_MISCFILES_LOG


#
# MULTI_MUI_MISCFILES support
#
# These are similar to MULTI_MISCFILES, but we need to do MUI splitting on these files
# first, then binplace both of the resulting files, and then create LCG files
# for each of the resulting MUI files. This is typically done on checked in files
# or on files generated by other directories where you are using the proper
# cross-directory syncronization to make this directory/operation happen last.
#
!if defined(MULTI_MUI_MISCFILES_LOG)
$(MULTI_MUI_MISCFILES_LOG): $(MULTI_MUI_MISCFILES)
# $? is the files with a later timestamp than $(MULTI_MUI_MISCFILES_LOG)
# $(MULTI_MUI_MISCFILES_LOG) is the list of files that were split, binplaced,
# and had LCG files generated for them.
     set createfile=<<$(MULTI_MUI_MISCFILES_LOG)
$?
<<Keep
    $(_PERL) $(RAZZLETOOLPATH)\SplitMiscFiles.pl \
!if defined(BINPLACE_NO_SYMCHK) || defined(NO_BINPLACE)
        /nosym \
!endif
        /i:$(MULTI_MUI_MISCFILES_LOG) \
        /n:$(MULTI_MUI_MISCFILES_NEUTRAL_LIST) \
        /r:$(MULTI_MUI_MISCFILES_RESOURCE_LIST) \
        /m:"$(LANGUAGE_NEUTRAL_RESOURCE_MUIRCT)" \
        /t:$(OBJ_PATH)\$O
! ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(BINPLACE_LC_MISCFLAGS) @$(MULTI_MUI_MISCFILES_NEUTRAL_LIST) \
        /R $(_NTTREE)\$(LOC_MULTI) @$(MULTI_MUI_MISCFILES_RESOURCE_LIST)
! endif
! if "$(DO_LSBUILD)" == "1"
!  ifndef NO_BINPLACE
     set BUILDMSG=making $(BUILD_PASS)_MULTI_MUI_MISCFILES with CreateLCGFile.pl
     set createfile=<<$(MULTI_MUI_MISCFILES_LCG_BINPLACE_TXT)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # NO_BINPLACE
!  if "$(LOCALIZE_BASE_FILE)" == "1"
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(MULTI_MUI_MISCFILES_NEUTRAL_LIST) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
        /b:$(MULTI_MUI_MISCFILES_LCG_BINPLACE_TXT) \
        /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
!  endif # LOCALIZE_BASE_FILE
     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /m:$(MULTI_MUI_MISCFILES_RESOURCE_LIST) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
!  ifndef NO_BINPLACE
        /b:$(MULTI_MUI_MISCFILES_LCG_BINPLACE_TXT) \
        /r:$(LCG_BINPLACE_TARGET) \
!  endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
! endif # DO_LSBUILD
!endif # MULTI_MUI_MISCFILES_LOG

!endif

!ifdef NO_BINPLACE
PassIndependentTargets_Binplace:

PASS0_BINP:

PASS1_BINP:

PASS2_BINP:

!else
#
# TBD clean this up the way I had MikeR clean up his stuff -- move the per-pass macros
# into pass agnostic macros and then write the code just once.
#
# Other cleanup is needed here too.
#
PassIndependentTargets_Binplace:
!if (defined(PASS_INDEPENDENT_BINPLACE) || defined(DL_MANIFESTS) || defined(REPL_MANIFESTS)) && "$(BUILD_PASS)" != "PASS1" && "$(BUILD_PASS)" != "PASS2"
! if defined(BUILD_DEBUG)
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MAKEDIR) PASS_INDEPENDENT_BINPLACE=$(PASS_INDEPENDENT_BINPLACE)
$(MAKEDIR) DL_MANIFESTS=$(DL_MANIFESTS)
$(MAKEDIR) MUI= $(MUI)
!  if "$(MUI)" == "0"
$(MAKEDIR) MUI_COMMENT= $(MUI_COMMENT)
!  endif
$(MAKEDIR) MISC_MUI_OFF= $(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
! endif
    @set createfile=<<$(OBJ_PATH)\$O\misc_mui_off
$(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
   @set createfile=<<$(OBJ_PATH)\$O\pass_independent_binp_mui_exclude
<<$(BUILD_NOKEEP)
  $(NOECHO)$(_PERL) -e "my $$muioff;open MISCMUIOFF,'$(OBJ_PATH)\$O\misc_mui_off';while (<MISCMUIOFF>){$$muioff .= $$_;}close MISCMUIOFF;open EXCLUDE, '>>$(OBJ_PATH)\$O\pass0_binp_mui_exclude';foreach $$i (split(';',$$muioff)){$$i=~ s/,.+$$//;$$i=~ s/^\s*//;$$i=~ s/\s*$$//;print EXCLUDE qq($$i\n);}close EXCLUDE;"
  $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=$(OBJ_PATH)\$O\pass0_independent_binp_mui_exclude
    $(BINPLACE_TOOL) @<<$(BINPLACE_RESPONSE_FILE_IND)
        $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
!  if defined(PASS_INDEPENDENT_BINPLACE)
        $(PASS_INDEPENDENT_BINPLACE)
!  endif
!  if defined(DL_MANIFESTS)
        /:DEST Setup\Sources\dlmanifests
        $(DL_MANIFESTS)
!  endif
!  if defined(REPL_MANIFESTS)
        /:DEST Setup\Sources\ReplacementManifests
        $(REPL_MANIFESTS)
!  endif
<<$(BUILD_NOKEEP)
    $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=
!endif

PASS0_BINP:
!if defined(PASS0_BINPLACE) && "$(BUILD_PASS)" != "PASS1" && "$(BUILD_PASS)" != "PASS2"
!if defined(BUILD_DEBUG)
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MAKEDIR) PASS0_BINPLACE=$(PASS0_BINPLACE)
$(MAKEDIR) MUI= $(MUI)
! if "$(MUI)" == "0"
$(MAKEDIR) MUI_COMMENT= $(MUI_COMMENT)
! endif
$(MAKEDIR) MISC_MUI_OFF= $(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
!endif
    @set createfile=<<$(OBJ_PATH)\$O\misc_mui_off
$(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
    @set createfile=<<$(OBJ_PATH)\$O\pass0_binp_mui_exclude
<<$(BUILD_NOKEEP)
    $(NOECHO)$(_PERL) -e "my $$muioff;open MISCMUIOFF,'$(OBJ_PATH)\$O\misc_mui_off';while (<MISCMUIOFF>){$$muioff .= $$_;}close MISCMUIOFF;open EXCLUDE, '>>$(OBJ_PATH)\$O\pass0_binp_mui_exclude';foreach $$i (split(';',$$muioff)){$$i=~ s/,.+$$//;$$i=~ s/^\s*//;$$i=~ s/\s*$$//;print EXCLUDE qq($$i\n);}close EXCLUDE;"
    $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=$(OBJ_PATH)\$O\pass0_binp_mui_exclude
    $(BINPLACE_TOOL) @<<$(BINPLACE_RESPONSE_FILE)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
$(PASS0_BINPLACE)
<<$(BUILD_NOKEEP)
    $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=
!endif

PASS1_BINP:
!if defined(PASS1_BINPLACE) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2"
!if defined(BUILD_DEBUG)
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MAKEDIR) PASS1_BINPLACE=$(PASS1_BINPLACE)
$(MAKEDIR) MUI= $(MUI)
! if "$(MUI)" == "0"
$(MAKEDIR) MUI_COMMENT= $(MUI_COMMENT)
! endif
$(MAKEDIR) MISC_MUI_OFF= $(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
!endif
    @set createfile=<<$(OBJ_PATH)\$O\misc_mui_off
$(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
    @set createfile=<<$(OBJ_PATH)\$O\pass1_binp_mui_exclude
<<$(BUILD_NOKEEP)
    $(NOECHO)$(_PERL) -e "my $$muioff;open MISCMUIOFF,'$(OBJ_PATH)\$O\misc_mui_off';while (<MISCMUIOFF>){$$muioff .= $$_;}close MISCMUIOFF;open EXCLUDE, '>>$(OBJ_PATH)\$O\pass1_binp_mui_exclude';foreach $$i (split(';',$$muioff)){$$i=~ s/,.+$$//;$$i=~ s/^\s*//;$$i=~ s/\s*$$//;print EXCLUDE qq($$i\n);}close EXCLUDE;"
    $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=$(OBJ_PATH)\$O\pass1_binp_mui_exclude
    $(BINPLACE_TOOL) @<<$(BINPLACE_RESPONSE_FILE)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
$(PASS1_BINPLACE)
<<$(BUILD_NOKEEP)
    $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=
!endif

PASS2_BINP:
!if defined(PASS2_BINPLACE) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS1"
!if defined(BUILD_DEBUG)
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MAKEDIR) PASS2_BINPLACE=$(PASS2_BINPLACE)
$(MAKEDIR) MUI= $(MUI)
! if "$(MUI)" == "0"
$(MAKEDIR) MUI_COMMENT= $(MUI_COMMENT)
! endif
$(MAKEDIR) MISC_MUI_OFF= $(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
!endif
    @set createfile=<<$(OBJ_PATH)\$O\misc_mui_off
$(MISC_MUI_OFF)
<<$(BUILD_NOKEEP)
    @set createfile=<<$(OBJ_PATH)\$O\pass2_binp_mui_exclude
<<$(BUILD_NOKEEP)
    $(NOECHO)$(_PERL) -e "my $$muioff;open MISCMUIOFF,'$(OBJ_PATH)\$O\misc_mui_off';while (<MISCMUIOFF>){$$muioff .= $$_;}close MISCMUIOFF;open EXCLUDE, '>>$(OBJ_PATH)\$O\pass2_binp_mui_exclude';foreach $$i (split(';',$$muioff)){$$i=~ s/,.+$$//;$$i=~ s/^\s*//;$$i=~ s/\s*$$//;print EXCLUDE qq($$i\n);}close EXCLUDE;"
    $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=$(OBJ_PATH)\$O\pass2_binp_mui_exclude
    $(BINPLACE_TOOL) @<<$(BINPLACE_RESPONSE_FILE)
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
$(PASS2_BINPLACE)
<<$(BUILD_NOKEEP)
    $(NOECHO)set LANGUAGE_NEUTRAL_EXCLUDE_FILE=
!endif
!endif

!ifndef PASS_INDEPENDENT_TARGETS  # { {

!ifdef PASS0_PUBLISH
_PASS0_PUBLISH_LOWERCASE=$(PASS0_PUBLISH)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:A=a)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:D=d)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:E=e)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:M=m)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:L=l)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:T=t)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:X=x)

# Remove spaces, tabs, and carriage returns, so that when
# we search for ".dll}", etc. below it will effectively
# check if the destination filename ends with ".dll".
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE: =)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:	=)
_PASS0_PUBLISH_LOWERCASE=$(_PASS0_PUBLISH_LOWERCASE:^
=)
!endif

!ifdef PASS1_PUBLISH
_PASS1_PUBLISH_LOWERCASE=$(PASS1_PUBLISH)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:A=a)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:D=d)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:E=e)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:M=m)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:L=l)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:S=s)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:T=t)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:X=x)

# Remove spaces, tabs, and carriage returns, so that when
# we search for ".dll}", etc. below it will effectively
# check if the destination filename ends with ".dll".
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE: =)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:	=)
_PASS1_PUBLISH_LOWERCASE=$(_PASS1_PUBLISH_LOWERCASE:^
=)

!if    "$(_PASS1_PUBLISH_LOWERCASE:.asmmeta}=)" != "$(_PASS1_PUBLISH_LOWERCASE)"
! error : Publish .asmmeta files in pass 0, not pass 1.
!endif

!endif

!if    "$(_PASS0_PUBLISH_LOWERCASE:.dll}=)" != "$(_PASS0_PUBLISH_LOWERCASE)" \
    || "$(_PASS0_PUBLISH_LOWERCASE:.exe}=)" != "$(_PASS0_PUBLISH_LOWERCASE)" \
    || "$(_PASS0_PUBLISH_LOWERCASE:.metadata_dll}=)" != "$(_PASS0_PUBLISH_LOWERCASE)" \
    || "$(_PASS0_PUBLISH_LOWERCASE:.metadata_exe}=)" != "$(_PASS0_PUBLISH_LOWERCASE)" \

#
# only redist drops from devdiv should publish .metadata_dll, .metadata_exe, exe, .dll
#
!if ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\com\netfx\binary_release") \
 || ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\com\netfx\1.1") \
 || ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\intl\en-us\src\redist\mspartners\winfx.35") \
 || ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\intl\en-us\src\redist\mspartners\winfx.30\wpf\binary_release") \
 || ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\intl\en-us\src\redist\mspartners\winfx.30\wcf\binary_release") \
 || ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\intl\en-us\src\redist\mspartners\winfx.30\wwf\binary_release") \
 || ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\redist\mspartners\netfx35\cdf\binary_release") \
 || ("$(MAKEDIR_LOWERCASE)" == "$(BASEDIR)\redist\mspartners\netfx35\linq\binary_release")

!else

! error Do not publish .exes or .dlls or .metadata_dll or .metadata_exe files.
!ifdef _PROJECT_BUILDS_MANAGED_CODE
! error Just publish .asmmeta files.
!endif # } }


#
# Check pass1_publish only during pass 1 because it can contain $(TARGET) that is .lib in pass 1
#  but .dll in pass 2.
#
!if defined(PASS1_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2" && !defined(PASS1_NOLIB) # { {
!if    "$(_PASS1_PUBLISH_LOWERCASE:.dll}=)" != "$(_PASS1_PUBLISH_LOWERCASE)" \
    || "$(_PASS1_PUBLISH_LOWERCASE:.exe}=)" != "$(_PASS1_PUBLISH_LOWERCASE)" \
    || "$(_PASS1_PUBLISH_LOWERCASE:.metadata_dll}=)" != "$(_PASS1_PUBLISH_LOWERCASE)" \
    || "$(_PASS1_PUBLISH_LOWERCASE:.metadata_exe}=)" != "$(_PASS1_PUBLISH_LOWERCASE)" # { {
! error Do not publish .exes or .dlls or .metadata_dll or .metadata_exe files.
!ifdef _PROJECT_BUILDS_MANAGED_CODE # { {
! error Just publish .asmmeta files.
!endif # } }
!endif # } }
!endif # } }
!endif # } }
!endif # } }

# { {

PASS0_Pub: $(PASS0_OBJECTS) $(NTTARGETFILE0) _concurrent_midl_join
!if defined(PASS0_PUBLISH) && "$(BUILD_PASS)" != "PASS1" && "$(BUILD_PASS)" != "PASS2"
    set BUILDMSG=$(@F)
    $(PUBLISH_CMD) /O_BINARY_METADATA:$(_O_BINARY_METADATA) -F <<$(PUBLISH_RESPONSE_FILE).pass0
$(PASS0_PUBLISH:}=}
)
<<$(BUILD_NOKEEP)
    set BUILDMSG=$(@F) done
!endif

# { {

PASS1_Pub: $(NTTARGETFILE1)
!if defined(PASS1_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2" && !defined(PASS1_NOLIB)
    set BUILDMSG=$(@F)
    $(PUBLISH_CMD) -F <<$(PUBLISH_RESPONSE_FILE).pass1
$(PASS1_PUBLISH:}=}
)
<<$(BUILD_NOKEEP)
    set BUILDMSG=$(@F) done
!endif

#
# Binary drop runs only during the link phase
#

# { {

BINARY_Pub:
!ifdef BINARY_PUBLISH
! if "$(BINPUBLISH)" == "1"
    $(BINDROP_CMD) -F <<$(BINDROP_RESPONSE_FILE)
$(BINARY_PUBLISH:}=}
)
<<$(BUILD_NOKEEP)
! else
    @echo BINARY_PUBLISH_PROJECTS in environment doesn't contain $(_PROJECT_) -
    @echo binaries will not be published.
! endif
!else if defined(BINARY_PUBLISH_FILES)
! if "$(BINPUBLISH)" == "1"
    @cmd /v:on /c make_publish_spec $(BINARY_PUBLISH_ROOT) $(OBJ_PATH)\$O $(BINARY_PUBLISH_FILES) | $(BINDROP_CMD) -I
! else
    @echo BINARY_PUBLISH_PROJECTS in environment doesn't contain $(_PROJECT_) -
    @echo binaries will not be published.
! endif
!endif

!endif


# Support to compile licensing manifest
!if defined(SLS_LICENSING_MANIFEST)
!    include $(RAZZLETOOLPATH)\licensing.inc
!endif

!  if $(FREEBUILD) || defined(BUILD_CHECKED_KERNEL)
MANIFEST_BUILD_TYPE=release
!  else
MANIFEST_BUILD_TYPE=debug
!  endif


# Support to compile CMI manifests
!if    defined(SOURCE_MANIFEST) \
    || defined(WOW64_SOURCE_MANIFEST) \
    || defined(MULTI_SOURCE_MANIFEST) \
    || defined(MULTI_WOW64_SOURCE_MANIFEST) \
    || defined(PROD_SOURCE_MANIFEST) \
    || defined(PROD_WOW64_SOURCE_MANIFEST) \
    || defined(EVENTS_MANIFEST) \
    || defined(SLS_LICENSING_MANIFEST) \
    || defined(EDITION_SOURCE_MANIFEST) \
    || defined(WINPE_SOURCE_MANIFEST)

! ifndef MANIFEST_COMPILER_ARGUMENTS

MANIFEST_HASH_ALGORITHM=SHA1

MANIFEST_VERSION=$(VER_PRODUCTVERSION_STR)


# We don't do the language replacements unless someone tells us to.
# Everything in the product should have these handled during postbuild.
!ifndef CMI_MANIFEST_REPLACE_LANGUAGES
CMI_MANIFEST_REPLACE_LANGUAGES=0
!endif

!if defined(CMI_MANIFEST_REPLACE_LANGUAGES)
! if "$(CMI_MANIFEST_REPLACE_LANGUAGES)" != "1" && "$(CMI_MANIFEST_REPLACE_LANGUAGES)" != "0"
!  error CMI_MANIFEST_REPLACE_LANGUAGES must 0, 1, or not defined.
! endif
!endif

!if "$(CMI_MANIFEST_REPLACE_LANGUAGES)" == "1"

#
# People who specify their CMI manifest language
#
!  ifdef CMI_MANIFEST_LANGUAGE
MANIFEST_LANGUAGE=$(CMI_MANIFEST_LANGUAGE)
!  else
MANIFEST_LANGUAGE=neutral
!  endif

#
# MUI related substitutions
#
!  ifdef CMI_MANIFEST_CULTURE_NAME_STRING
MANIFEST_CULTURE_NAME_STRING=$(CMI_MANIFEST_CULTURE_NAME_STRING)
!  else
MANIFEST_CULTURE_NAME_STRING=en-US
!  endif

!  ifdef CMI_MANIFEST_CULTURE_NEUTRAL_NAME_STRING
MANIFEST_CULTURE_NEUTRAL_NAME_STRING=$(CMI_MANIFEST_CULTURE_NEUTRAL_NAME_STRING)
!  else
MANIFEST_CULTURE_NEUTRAL_NAME_STRING=en
!  endif

!  ifdef CMI_MANIFEST_CULTURE_SPECIFIC_NAME_STRING
MANIFEST_CULTURE_SPECIFIC_NAME_STRING=$(CMI_MANIFEST_CULTURE_SPECIFIC_NAME_STRING)
!  else
MANIFEST_CULTURE_SPECIFIC_NAME_STRING=en-US
!  endif

!  ifdef CMI_MANIFEST_CULTURE_LANG_ID_HEX
MANIFEST_CULTURE_LANG_ID_HEX=$(CMI_MANIFEST_CULTURE_LANG_ID_HEX)
!  else
MANIFEST_CULTURE_LANG_ID_HEX=0409
!  endif

!  ifdef CMI_MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX
MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX=$(CMI_MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX)
!  else
MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX=0009
!  endif

!  ifdef CMI_MANIFEST_CULTURE_FULL_LANG_ID_HEX
MANIFEST_CULTURE_FULL_LANG_ID_HEX=$(CMI_MANIFEST_CULTURE_FULL_LANG_ID_HEX)
!  else
MANIFEST_CULTURE_FULL_LANG_ID_HEX=0409
!  endif

!endif #!if $(CMI_MANIFEST_REPLACE_LANGUAGES) == "1"



#
# URT related substitutions
#

#
# MANIFEST_CLR_VERSION_STR is expected to have this format: v(\d+)\.(\d+)\.(\d+)
# for example v1.0.3705
#

!if 0 # FUTURE This will take a bit more work to jive with the
      # various manifest content around the tree.
      # People hardcode various values and some people use the bogus 1.0.0 value.

!if defined(URT_VER)
!include $(NTMAKEENV)\clr_versions.inc
!  if "$(URT_VER)" == "1.1"
MANIFEST_CLR_VERSION_STR=$(URT_VER_1_1)
!  elseif "$(URT_VER)" == "2.0"
MANIFEST_CLR_VERSION_STR=$(URT_VER_2_0)
!  else
!    error Unknown URT_VER.
!  endif
MANIFEST_CLR_PATH=$$(runtime.windows)\Microsoft.NET\Framework\$(MANIFEST_CLR_VERSION_STR)
!endif

!else

!  if (!defined(URT_VER) || "$(URT_VER)" == "1.2") && defined(URT_VER_1_2)
MANIFEST_CLR_VERSION_STR=$(URT_VER_1_2)
!  endif
!  if "$(URT_VER)" == "1.1" && defined(URT_VER_1_2)
MANIFEST_CLR_VERSION_STR=$(URT_VER_1_1)
!  endif
!  if "$(URT_VER)" == "1.0" && defined(URT_VER_1_2)
MANIFEST_CLR_VERSION_STR=$(URT_VER_1_0)
!  endif

#
# in case nothing is defined
#
!  ifndef MANIFEST_CLR_VERSION_STR
MANIFEST_CLR_VERSION_STR=v1.0.0
!endif

MANIFEST_CLR_PATH=$$(runtime.windows)\Microsoft.NET\Framework\$(MANIFEST_CLR_VERSION_STR)

!endif

#
# temporary public key token until the fusion manifest compilation support
# gets checked in
#
!  ifndef MANIFEST_PUBLIC_KEY_TOKEN
MANIFEST_PUBLIC_KEY_TOKEN=1122334455667788
!  endif

#
# file containing security descriptor definitions for WRP objects
#
!  ifndef MANIFEST_SDDL_FILE
MANIFEST_SDDL_FILE=@$(NTMAKEENV)\manifest_sddl.txt
!  endif

#
# build platform, for x86/wow64 it is win32, for 64-bit builds it is win64
#
!ifndef BUILD_WIN_PLATFORM
!if $(386)
BUILD_WIN_PLATFORM=win32
!else
BUILD_WIN_PLATFORM=win64
!endif
!endif

#
# all the $(build.xyz) keys are case insensitive, but values are case sensitive
#
MANIFEST_COMPILER_BASE_ARGUMENTS=\
    $$(build.version) $(MANIFEST_VERSION) \
!if "$(TARGETTYPE)" != "NOTARGET"
# This is for if the manifests live with the code.
# It doesn't yet work, but only one directory could even use it: \nt\ds\security\services\ca\certmmc.
#   $$(build.assemblyVersion) $(ASSEMBLY_IDENTITY_VERSION) \
!endif
# This is a compromise for manifests that don't live with the code.
    $$(build.WindowsManagedAssemblyVersion) $(WINDOWS_ASSEMBLY_VERSION) \
    $$(build.MediaCenterManagedVersion) $(M_C_MANAGED_VERSION) \
    $$(build.majorVersion),$$(build.minorVersion),$$(build.buildNumber),$$(build.revision):(\d+)\.(\d+)\.(\d+)\.(\d+) $(MANIFEST_VERSION) \
    $$(build.majorMinor) $(VER_PRODUCTVERSION_STRING) \
    $$(build.majorMinorZeroZero) $(VER_PRODUCTVERSION_STRING).0.0 \
    $$(build.majorMinorStarStar) $(VER_PRODUCTVERSION_STRING).*.* \
    $$build.version $(MANIFEST_VERSION) \
    $$(build.language) $(MANIFEST_LANGUAGE) \
    $$build.language $(MANIFEST_LANGUAGE) \
    $$(build.buildType) $(MANIFEST_BUILD_TYPE) \
    $$build.buildType $(MANIFEST_BUILD_TYPE) \
    $$(build.processorArchitecture) $(SXS_PROCESSOR_ARCHITECTURE) \
    $$(build.hashAlgorithmType) $(MANIFEST_HASH_ALGORITHM) \
    $$build.processor $(SXS_PROCESSOR_ARCHITECTURE) \
    $$(build.winPlatform) $(BUILD_WIN_PLATFORM) \
!if "$(PROCESSOR_ARCHITECTURE_LOWERCASE)" == "$(_BUILDARCH)"
    $$(build.hostarch) $(PROCESSOR_ARCHITECTURE) \
!else
    $$(build.hostarch) x86 \
!endif
!if "$(CMI_MANIFEST_REPLACE_LANGUAGES)" == "1"
    $$(build.cultureNameString) $(MANIFEST_CULTURE_NAME_STRING) \
    $$(build.cultureNeutralNameString) $(MANIFEST_CULTURE_NEUTRAL_NAME_STRING) \
    $$(build.cultureSpecificNameString) $(MANIFEST_CULTURE_SPECIFIC_NAME_STRING) \
    $$(build.cultureLangIdHex) $(MANIFEST_CULTURE_LANG_ID_HEX) \
    $$(build.culturePrimaryLangIdHex) $(MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX) \
    $$(build.cultureFullLangIdHex) $(MANIFEST_CULTURE_FULL_LANG_ID_HEX) \
!endif
!if defined(MANIFEST_CLR_VERSION_STR)
    $$(build.clrVersionStr) $(MANIFEST_CLR_VERSION_STR) \
!endif
!if defined(MANIFEST_CLR_PATH)
    $$(build.clrPath) $(MANIFEST_CLR_PATH) \
!endif
    $$(build.windowsPublicKeyToken) $(WINDOWS_PUBLIC_KEY_TOKEN) \
    $$(build.publicKeyToken) $(MANIFEST_PUBLIC_KEY_TOKEN) \
!if defined(MANIFEST_CLR_VERSION_STR)
    $$(build.clrVersion):v(.+) $(MANIFEST_CLR_VERSION_STR) \
!endif
    -SDDL_CONFIG_FILE $(MANIFEST_SDDL_FILE)
! endif

#
# CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS must be a list of name-value pairs.
#
# 1. The name must either of format $(build.*) or $build.*
# 2. The value must not be spaces or empty.
# 3. If name or value contains space, it must be quoted.
# 4. name and value must be delimited by a space
# 5. each pair must be delimited by a space
# 6. a name specified here can NOT override any default name specified in
#    this makefile.def
#
# N.B. name is case-censitive.
#
# e.g.
#
# CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS=\
#    $$(build.myTargetName) $(TARGETNAME) \
#    $$(build.myTargetPath) $(TARGETPATH)
#
! ifdef CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS
MANIFEST_COMPILER_ARGUMENTS=$(CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS) $(MANIFEST_COMPILER_BASE_ARGUMENTS)
!else
MANIFEST_COMPILER_ARGUMENTS=$(MANIFEST_COMPILER_BASE_ARGUMENTS)
! endif

! ifdef CMI_MANIFEST_BINPLACE
MANIFEST_DIRECTORY=$(CMI_MANIFEST_BINPLACE)
!undef MANIFEST_DIRECTORY2
! else
MANIFEST_DIRECTORY=cmicomponents
MANIFEST_DIRECTORY2=cmiconverted
!undef MANIFEST_DIRECTORY2
! endif

! ifdef CMI_MANIFEST_LANGUAGE
MANIFEST_DIRECTORY=$(MANIFEST_DIRECTORY)\$(LANGUAGE)
!  ifdef MANIFEST_DIRECTORY2
MANIFEST_DIRECTORY2=$(MANIFEST_DIRECTORY2)\$(LANGUAGE)
!  endif
! endif

! ifndef CMI_BINPLACE_OVERRIDE
CMI_RES_BINPLACE=$(LOC_BIN)\cmicomponents.raw
! else
CMI_RES_BINPLACE=$(CMI_BINPLACE_OVERRIDE)
! endif

! ifndef CMI_MULTI_BINPLACE_OVERRIDE
CMI_MULTI_BINPLACE=$(LOC_MULTI)\cmicomponents.raw
! else
CMI_MULTI_BINPLACE=$(CMI_MULTI_BINPLACE_OVERRIDE)
! endif

CV_BCZOPTIONS=/systemerrorstoconsole /nowarnings /failurestoconsole /ignorescope=inter /ignoreviewtype=compiled /basedir=$(MAKEDIR) /omitmetadata /logdir=$(OBJ_PATH)\$O /savemeta=$(OBJ_PATH)\$O\cvexceptionlists /findstaleexceptions=$(OBJ_PATH)\$O

!if !defined(CV_BCZPROFILE) || "$(CV_BCZPROFILE)" == ""
CV_BCZPROFILE=bcz.profile
!endif

! ifdef SOURCE_MANIFEST
$(SOURCE_MANIFEST): $(CMI_MANIFESTS)
    set BUILDMSG=DiagValid is validating manifest instrumentation.
    "diagvalid.exe" "$(RAZZLETOOLPATH)\diagvalid\exceptions.xml" $?
!  ifndef DISABLE_CV
    set BUILDMSG=Component Validation is validating manifests.
    $(_URTRUN_20) ValidateManifest $(CV_BCZOPTIONS) $(CV_OPTIONS) /useprofile=$(CV_BCZPROFILE) <<$(@D)\ManifestsToBevalidated
$?
<<$(BUILD_NOKEEP)
!  endif
!   ifdef CACHE_SOURCE_MANIFESTS
    set BUILDMSG=Source manifests are being cached.
    $(_URTRUN_20) CacheManifest $(MAKEDIR) $(CACHE_SOURCE_MANIFESTS) <<$(@D)\ManifestsToBeCached
$?
<<$(BUILD_NOKEEP)
!   endif
! if !defined(DISABLE_SOURCE_MANIFEST_VALIDATION)
    set BUILDMSG=Manifest schema and formatting is being checked.
    checksourcemanifests -obj:$(OBJ_PATH)\$O <<$(@D)\ManifestsToBeChecked
$(**: =
)
<<$(BUILD_NOKEEP)
! endif
#
# ! means loop
# $? is the manifests with a later timestamp than $(SOURCE_MANIFEST)
# $(SOURCE_MANIFEST) is the list of manifests to be binplaced
# The .vbs manifest compiler takes ....foo.man and outputs $O\foo.man.temp0
# The RC manifest compiler takes $O\foo.man.temp0 and outputs $O\foo.man.temp1
# The temp file $O\foo.man.temp0 is deleted
# ManifestCompilerPass2.cmd takes $O\foo.man.temp1 and outputs $O\foo.man.
#
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)
    !$(MANIFEST_RCPARSER_CMD) $(@D)\$(?F).temp0 $(@D)\$(?F).temp1 -l $(@D)\rcmanparse.log -a
    !$(_DELFILE) $(@D)\$(?F).temp0
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2):$(MANIFEST_DIRECTORY) \
!   else
    $(MANIFEST_DIRECTORY) \
!   endif
    @$@.temp /:DEST $(CMI_RES_BINPLACE) @$@.temp.resources
!  endif

!  if defined(WINPE_COMPILE_SMI_MANIFEST) && !defined(NO_BINPLACE)
!   if "$(WINPE_COMPILE_SMI_MANIFEST)" != "1"
!    error WINPE_COMPILE_SMI_MANIFEST must be set to 1 or not defined
!   endif
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) \
!   if !defined(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE)
                    /:DEST WinPE_SMI_Manifests \
!   else
                    /P $(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE) \
!   endif
                    @$@.temp
!  endif
!  if defined(SKU_SETTINGS_OVERRIDE_FILES)
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) \
        /:DEST SKU-Settings-Overrides $(SKU_SETTINGS_OVERRIDE_FILES)
!  endif

# Create LCG files for CMI_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_MANIFESTS with CreateLCGFile.pl
       set createfile=<<$(@D)\cmi_manifests.lcg.lst
$(**: =
)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\cmi_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST cmicomponents.raw
<<keep
!   endif # NO_BINPLACE
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\cmi_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\cmi_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # ifndef NO_BINPLACE
            /l:$(LANGUAGE)
!  endif # if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"

    move $@.temp $@

! endif # ifdef SOURCE_MANIFEST



! ifdef WOW64_SOURCE_MANIFEST
$(WOW64_SOURCE_MANIFEST): $(CMI_WOW64_MANIFESTS)
    set build.arch=wow64
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\wow64_$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) wow64
    !$(MANIFEST_RCPARSER_CMD) $(@D)\wow64_$(?F).temp0 $(@D)\wow64_$(?F).temp1 -l $(@D)\rcmanparse.log -a
    set build.arch=$(_BUILDARCH)
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -OutputFilePrefix wow64_ -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS) $(CMI_WOW64_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2)\wow6432:$(MANIFEST_DIRECTORY)\wow6432 \
!   else
        $(MANIFEST_DIRECTORY)\wow6432 \
!   endif
        @$@.temp /:DEST $(CMI_RES_BINPLACE)\wow6432 @$@.temp.resources
!  endif

# Create LCG files for CMI_WOW64_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_WOW64_MANIFESTS with CreateLCGFile.pl
       set BUILDMSG=$(@D)\cmi_wow64_manifests.lcg.lst
       set createfile=<<$(@D)\cmi_wow64_manifests.lcg.lst
wow64_$(**F: =
wow64_)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\cmi_wow64_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST cmicomponents.raw\wow6432
<<keep
!   endif # NO_BINPLACE
        cd $(@D)
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\cmi_wow64_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\cmi_wow64_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
            /l:$(LANGUAGE)
        cd $(MAKEDIR)
!  endif # DO_LSBUILD && BUILD_CMI_LCG

    move $@.temp $@

! endif





! ifdef MULTI_SOURCE_MANIFEST
!message MULTI_SOURCE_MANIFEST is $(MULTI_SOURCE_MANIFEST) : $(CMI_MULTI_MANIFESTS)
$(MULTI_SOURCE_MANIFEST): $(CMI_MULTI_MANIFESTS)
    set BUILDMSG=Making CMI_MULTI_MANIFESTS with $(MULTI_SOURCE_MANIFEST) : $(CMI_MULTI_MANIFESTS)
    set BUILDMSG=DiagValid is validating manifest instrumentation.
    "diagvalid.exe" "$(RAZZLETOOLPATH)\diagvalid\exceptions.xml" $?
!  ifndef DISABLE_CV
    set BUILDMSG=Component Validation is validating manifests.
    $(_URTRUN_20) ValidateManifest $(CV_BCZOPTIONS) $(CV_OPTIONS) /useprofile=$(CV_BCZPROFILE) <<$(@D)\MultiManifestsToBevalidated
$?
<<$(BUILD_NOKEEP)
!  endif
!   ifdef CACHE_SOURCE_MANIFESTS
    set BUILDMSG=Source manifests are being cached.
    $(_URTRUN_20) CacheManifest $(MAKEDIR) $(CACHE_SOURCE_MANIFESTS) <<$(@D)\ManifestsToBeCached
$?
<<$(BUILD_NOKEEP)
!   endif
#
# ! means loop
# $? is the manifests with a later timestamp than $(MULTI_SOURCE_MANIFEST)
# $(MULTI_SOURCE_MANIFEST) is the list of manifests to be binplaced
# The .vbs manifest compiler takes ....foo.man and outputs $O\foo.man.temp0
# The RC manifest compiler takes $O\foo.man.temp0 and outputs $O\foo.man.temp1
# The temp file $O\foo.man.temp0 is deleted
# ManifestCompilerPass2.cmd takes $O\foo.man.temp1 and outputs $O\foo.man.
#
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)
    !$(MANIFEST_RCPARSER_CMD) $(@D)\$(?F).temp0 $(@D)\$(?F).temp1 -l $(@D)\rcmanparse.log -a
    !$(_DELFILE) $(@D)\$(?F).temp0
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2):$(MANIFEST_DIRECTORY) \
!   else
    $(MANIFEST_DIRECTORY) \
!   endif
    @$@.temp /:DEST $(CMI_MULTI_BINPLACE) @$@.temp.resources
!  endif

!  if defined(WINPE_COMPILE_SMI_MANIFEST) && !defined(NO_BINPLACE)
!   if "$(WINPE_COMPILE_SMI_MANIFEST)" != "1"
!    error WINPE_COMPILE_SMI_MANIFEST must be set to 1 or not defined
!   endif
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) \
!   if !defined(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE)
                    /:DEST WinPE_SMI_Manifests \
!   else
                    /P $(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE) \
!   endif
                    @$@.temp
!  endif

!  if defined(SKU_SETTINGS_OVERRIDE_FILES)
    $(BINPLACE_CMD) /:DEST SKU-Settings-Overrides $(SKU_SETTINGS_OVERRIDE_FILES)
!  endif

# Create LCG files for CMI_MULTI_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_MULTI_MANIFESTS with CreateLCGFile.pl
       set createfile=<<$(@D)\cmi_multi_manifests.lcg.lst
$(**: =
)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\cmi_multi_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST cmicomponents.raw
<<keep
!   endif # NO_BINPLACE
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\cmi_multi_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\cmi_multi_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # ifndef NO_BINPLACE
            /l:$(LANGUAGE)
!  endif # if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"

    move $@.temp $@

! endif # ifdef MULTI_SOURCE_MANIFEST




! ifdef MULTI_WOW64_SOURCE_MANIFEST
$(MULTI_WOW64_SOURCE_MANIFEST): $(CMI_MULTI_WOW64_MANIFESTS)
    set build.arch=wow64
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\wow64_$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) wow64
    !$(MANIFEST_RCPARSER_CMD) $(@D)\wow64_$(?F).temp0 $(@D)\wow64_$(?F).temp1 -l $(@D)\rcmanparse.log -a
    set build.arch=$(_BUILDARCH)
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -OutputFilePrefix wow64_ -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS) $(CMI_WOW64_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2)\wow6432:$(MANIFEST_DIRECTORY)\wow6432 \
!   else
        $(MANIFEST_DIRECTORY)\wow6432 \
!   endif
        @$@.temp /:DEST $(CMI_MULTI_BINPLACE)\wow6432 @$@.temp.resources
!  endif

# Create LCG files for CMI_WOW64_MULTI_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_WOW64_MULTI_MANIFESTS with CreateLCGFile.pl
       set BUILDMSG=$(@D)\cmi_wow64_multi_manifests.lcg.lst
       set createfile=<<$(@D)\cmi_wow64_multi_manifests.lcg.lst
wow64_$(**F: =
wow64_)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\cmi_wow64_multi_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST cmicomponents.raw\wow6432
<<keep
!   endif # NO_BINPLACE
        cd $(@D)
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\cmi_wow64_multi_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\cmi_wow64_multi_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
            /l:$(LANGUAGE)
        cd $(MAKEDIR)
!  endif # DO_LSBUILD && BUILD_CMI_LCG

! endif




! ifdef PROD_SOURCE_MANIFEST
$(PROD_SOURCE_MANIFEST): $(CMI_PROD_MANIFESTS)
    set build.production=1
    set BUILDMSG=DiagValid is validating manifest instrumentation.
    "diagvalid.exe" "$(RAZZLETOOLPATH)\diagvalid\exceptions.xml" $?
!ifndef DISABLE_CV
    set BUILDMSG=Component Validation is validating manifests.
    $(_URTRUN_20) ValidateManifest $(CV_BCZOPTIONS) $(CV_OPTIONS) /useprofile=$(CV_BCZPROFILE) <<$(@D)\ProdManifestsToBevalidated
$?
<<$(BUILD_NOKEEP)
!endif
!   ifdef CACHE_SOURCE_MANIFESTS
    set BUILDMSG=Source manifests are being cached.
    $(_URTRUN_20) CacheManifest $(MAKEDIR) $(CACHE_SOURCE_MANIFESTS) <<$(@D)\ManifestsToBeCached
$?
<<$(BUILD_NOKEEP)
!   endif
! if !defined(DISABLE_SOURCE_MANIFEST_VALIDATION)
    set BUILDMSG=Manifest schema and formatting is being checked.
    checksourcemanifests -obj:$(OBJ_PATH)\$O <<$(@D)\ManifestsToBeChecked
$(**: =
)
<<$(BUILD_NOKEEP)
! endif
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\prod_$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE) $$(build.production) 1
    !$(MANIFEST_RCPARSER_CMD) $(@D)\prod_$(?F).temp0 $(@D)\prod_$(?F).temp1 -l $(@D)\prod_rcmanparse.log -a
    set build.production=
    !$(_DELFILE) $(@D)\prod_$(?F).temp0
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -OutputFilePrefix prod_ -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2)\production:$(MANIFEST_DIRECTORY)\production \
!   else
    $(MANIFEST_DIRECTORY)\production \
!   endif
    @$@.temp /:DEST $(CMI_RES_BINPLACE)\production @$@.temp.resources
!  endif

!if defined(WINPE_COMPILE_SMI_MANIFEST) && !defined(NO_BINPLACE)
! if "$(WINPE_COMPILE_SMI_MANIFEST)" != "1"
!  error WINPE_COMPILE_SMI_MANIFEST must be set to 1 or not defined
! endif
  $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) \
! if !defined(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE)
                    /:DEST WinPE_SMI_Manifests \
! else
                    /P $(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE) \
! endif
                    @$@.temp
!endif

#!if defined(SKU_SETTINGS_OVERRIDE_FILES)
#    $(BINPLACE_CMD) /:DEST SKU-Settings-Overrides $(SKU_SETTINGS_OVERRIDE_FILES)
#!endif

# Create LCG files for CMI_PROD_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_PROD_MANIFESTS (production) with CreateLCGFile.pl
       set BUILDMSG= DIR: $(@D)
       set createfile=<<$(@D)\cmi_prod_manifests.lcg.lst
prod_$(**F: =
prod_)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\cmi_prod_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST cmicomponents.raw
<<keep
!   endif # NO_BINPLACE
        cd $(@D)
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\cmi_prod_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\cmi_prod_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
            /l:$(LANGUAGE)
        cd $(MAKEDIR)
!  endif # DO_LSBUILD && BUILD_CMI_LCG

    move $@.temp $@

! endif # ifdef PROD_SOURCE_MANIFEST

! ifdef PROD_WOW64_SOURCE_MANIFEST
$(PROD_WOW64_SOURCE_MANIFEST): $(CMI_WOW64_PROD_MANIFESTS)
    set build.arch=wow64
    set build.production=1
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\prod_wow64_$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) wow64 $$(build.production) 1
    !$(MANIFEST_RCPARSER_CMD) $(@D)\prod_wow64_$(?F).temp0 $(@D)\prod_wow64_$(?F).temp1 -l $(@D)\rcmanparse.log -a
    set build.production=
    set build.arch=$(_BUILDARCH)
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -OutputFilePrefix prod_wow64_ -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS) $(CMI_WOW64_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2)\wow6432\production:$(MANIFEST_DIRECTORY)\wow6432\production \
!   else
        $(MANIFEST_DIRECTORY)\wow6432\production \
!   endif
        @$@.temp /:DEST $(CMI_RES_BINPLACE)\wow6432\production @$@.temp.resources
!  endif

# Create LCG files for CMI_WOW64_PROD_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_WOW64_PROD_MANIFESTS (production) with CreateLCGFile.pl
       set createfile=<<$(@D)\prod_cmi_wow64_manifests.lcg.lst
prod_wow64_$(**F: =
prod_wow64_)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\prod_cmi_wow64_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST cmicomponents.raw\wow6432
<<keep
!   endif # NO_BINPLACE
        cd $(@D)
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\prod_cmi_wow64_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\prod_cmi_wow64_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
            /l:$(LANGUAGE)
        cd $(MAKEDIR)
!  endif # DO_LSBUILD && BUILD_CMI_LCG

    move $@.temp $@

! endif # ifdef PROD_WOW64_SOURCE_MANIFEST

# Note that the internal CMI_PROD_MANIFESTS targets DO NOT
# create LCG files. That is done by the production targets.
# there should never be  reason to have different resources for
# production vs. internal distributions - that is just asking to waste
# localizer's time.
! ifdef INTERNAL_SOURCE_MANIFEST
$(INTERNAL_SOURCE_MANIFEST): $(CMI_PROD_MANIFESTS)
    set build.internal=1
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\internal_$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)  $$(build.internal) 1
    !$(MANIFEST_RCPARSER_CMD) $(@D)\internal_$(?F).temp0 $(@D)\internal_$(?F).temp1 -l $(@D)\internal_rcmanparse.log -a
    set build.internal=
    !$(_DELFILE) $(@D)\internal_$(?F).temp0
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -OutputFilePrefix internal_ -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2)\internal:$(MANIFEST_DIRECTORY)\internal \
!   else
    $(MANIFEST_DIRECTORY)\internal \
!   endif
    @$@.temp /:DEST $(CMI_RES_BINPLACE)\internal @$@.temp.resources
!  endif

!if defined(WINPE_COMPILE_SMI_MANIFEST) && !defined(NO_BINPLACE)
! if "$(WINPE_COMPILE_SMI_MANIFEST)" != "1"
!  error WINPE_COMPILE_SMI_MANIFEST must be set to 1 or not defined
! endif
  $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) \
! if !defined(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE)
                    /:DEST WinPE_SMI_Manifests \
! else
                    /P $(WINPE_COMPILE_SMI_MANIFEST_PLACEFILE) \
! endif
                    @$@.temp
!endif

! endif # ifdef INTERNAL_SOURCE_MANIFEST

! ifdef INTERNAL_WOW64_SOURCE_MANIFEST
$(INTERNAL_WOW64_SOURCE_MANIFEST): $(CMI_WOW64_PROD_MANIFESTS)
    set build.arch=wow64
    set build.internal=1
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\internal_wow64_$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) wow64 $$(build.internal) 1
    !$(MANIFEST_RCPARSER_CMD) $(@D)\internal_wow64_$(?F).temp0 $(@D)\internal_wow64_$(?F).temp1 -l $(@D)\rcmanparse.log -a
    set build.arch=$(_BUILDARCH)
    set build.internal=
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -OutputFilePrefix internal_wow64_ -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS) $(CMI_WOW64_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2)\wow6432\internal:$(MANIFEST_DIRECTORY)\wow6432\internal \
!   else
        $(MANIFEST_DIRECTORY)\wow6432\internal \
!   endif
        @$@.temp /:DEST $(CMI_RES_BINPLACE)\wow6432\internal @$@.temp.resources
!  endif

    move $@.temp $@

! endif # ifdef INTERNAL_WOW64_SOURCE_MANIFEST

! ifdef EDITION_SOURCE_MANIFEST
$(EDITION_SOURCE_MANIFEST): $(CMI_EDITION_MANIFESTS)
    set BUILDMSG=DiagValid is validating manifest instrumentation.
    "diagvalid.exe" "$(RAZZLETOOLPATH)\diagvalid\exceptions.xml" $?
!  ifndef DISABLE_CV
    set BUILDMSG=Component Validation is validating manifests.
    $(_URTRUN_20) ValidateManifest $(CV_BCZOPTIONS) $(CV_OPTIONS) /useprofile=$(CV_BCZPROFILE) <<$(@D)\ManifestsToBevalidated
$?
<<$(BUILD_NOKEEP)
!  endif
!   ifdef CACHE_SOURCE_MANIFESTS
    set BUILDMSG=Source manifests are being cached.
    $(_URTRUN_20) CacheManifest $(MAKEDIR) $(CACHE_SOURCE_MANIFESTS) <<$(@D)\ManifestsToBeCached
$?
<<$(BUILD_NOKEEP)
!   endif
! if !defined(DISABLE_SOURCE_MANIFEST_VALIDATION)
    set BUILDMSG=Manifest schema and formatting is being checked.
    checksourcemanifests -obj:$(OBJ_PATH)\$O <<$(@D)\ManifestsToBeChecked
$(**: =
)
<<$(BUILD_NOKEEP)
! endif
#
# ! means loop
# $? is the manifests with a later timestamp than $(SOURCE_MANIFEST)
# $(SOURCE_MANIFEST) is the list of manifests to be binplaced
# The .vbs manifest compiler takes ....foo.man and outputs $O\foo.man.temp0
# The RC manifest compiler takes $O\foo.man.temp0 and outputs $O\foo.man.temp1
# The temp file $O\foo.man.temp0 is deleted
# ManifestCompilerPass2.cmd takes $O\foo.man.temp1 and outputs $O\foo.man.
#
    !$(MANIFEST_COMPILER_CMD) $? $(@D)\$(?F).temp0 $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)
    !$(MANIFEST_RCPARSER_CMD) $(@D)\$(?F).temp0 $(@D)\$(?F).temp1 -l $(@D)\rcmanparse.log -a
    !$(_DELFILE) $(@D)\$(?F).temp0
    $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST Editions \
    @$@.temp /:DEST Editions @$@.temp.resources

    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2):$(MANIFEST_DIRECTORY) \
!   else
    $(MANIFEST_DIRECTORY) \
!   endif
    @$@.temp /:DEST $(CMI_RES_BINPLACE) @$@.temp.resources
!  endif


# Create LCG files for CMI_EDITION_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_EDITION_MANIFESTS with CreateLCGFile.pl
       set createfile=<<$(@D)\cmi_edition_manifests.lcg.lst
$(**F: =
)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\cmi_edition_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST Editions.raw
<<keep
!   endif # NO_BINPLACE
        cd $(@D)
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\cmi_edition_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\cmi_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
            /l:$(LANGUAGE)
        cd $(MAKEDIR)
!  endif # DO_LSBUILD && BUILD_CMI_LCG

    move $@.temp $@

! endif # ifdef EDITION_SOURCE_MANIFEST


! ifdef WINPE_SOURCE_MANIFEST
$(WINPE_SOURCE_MANIFEST): $(CMI_WINPE_MANIFESTS)
   set build.arch=
   !$(MANIFEST_COMPILER_CMD) $? $(@D)\winpe_$(?F).temp1 $(MANIFEST_COMPILER_BASE_ARGUMENTS) $(CMI_WINPE_MANIFEST_COMPILER_EXTRA_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)
   set build.arch=$(_BUILDARCH)
   $(_PERL) $(RAZZLETOOLPATH)\ManifestCompilerPass2.cmd -OutputFilePrefix winpe_ -InputManifestList << -OutputManifestList $@.temp -PerfTrackManifests "$(PERFTRACK_MANIFESTS)" -PerfTrackOptions " $(PERFTRACK_OPTIONS)" -ObjectPath $(@D) -MtOptions "$(MT_OPTIONS)" -ManifestsWithSpuriousCompositions "$(CMI_MANIFESTS_WITH_SPURIOUS_COMPOSITIONS)"
$?
<<$(BUILD_NOKEEP)
!  ifndef NO_BINPLACE
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) /:DEST \
!   ifdef MANIFEST_DIRECTORY2
        $(MANIFEST_DIRECTORY2):$(MANIFEST_DIRECTORY) \
!   else
    $(MANIFEST_DIRECTORY) \
!   endif
    @$@.temp /:DEST $(CMI_RES_BINPLACE) @$@.temp.resources
!  endif

# Create LCG files for CMI_WINPE_MANIFESTS files if needed
!  if "$(DO_LSBUILD)" == "1" && "$(BUILD_CMI_LCG)" == "1"
       set BUILDMSG=making CMI_WINPE_MANIFESTS with CreateLCGFile.pl
       set createfile=<<$(@D)\cmi_winpe_manifests.lcg.lst
winpe_$(**F: =
winpe_)
<<keep
!   ifndef NO_BINPLACE
        set createfile=<<$(@D)\cmi_winpe_manifests.lcg.binplace.txt
$(BINPLACE_FLAGS) /:DEST cmicomponents.raw
<<keep
!   endif # NO_BINPLACE
        cd $(@D)
        $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
            /c \
            /m:$(@D)\cmi_winpe_manifests.lcg.lst \
            /t:$(@D) \
            $(LSBUILD_PARSER_ID_OPTION) \
            $(ALT_LCI_DIR_OPTION) \
            /s:$(LSBUILD_PARSER_SETTINGS) \
!   ifndef NO_BINPLACE
            /b:$(@D)\cmi_manifests.lcg.binplace.txt \
            /r:$(LCG_BINPLACE_TARGET) \
!   endif # NO_BINPLACE
            /l:$(LANGUAGE)
        cd $(MAKEDIR)
!  endif # DO_LSBUILD && BUILD_CMI_LCG

    move $@.temp $@

! endif


!endif # defined(SOURCE_MANIFEST) || defined(WOW64_SOURCE_MANIFEST) || defined(EVENTS_MANIFEST) || defined(SLS_LICENSING_MANIFEST) || defined(EDITION_SOURCE_MANIFEST) || defined(WINPE_SOURCE_MANIFEST)


!ifndef PASS_INDEPENDENT_TARGETS # { {

#
# Currently, service tables are sorted according to profile data on WIN64,
# but not X86.
#
# 32-bit binaries built for Wow64 (ntdll, etc.) must also use the sorted
# tables.
#
# Use GENSRV_PREPROCESS for "normal" service table preprocessing, and
# GENSRV_PREPROCESS_WOW64 for wow64 binary generation.
#

GENSRV_PREPROCESS_WOW64 = $(C_PREPROCESSOR) $** | gensrv -prof $(BASE_INC_PATH)\services.prof > $@
!if $(IA64) || $(AMD64)
GENSRV_PREPROCESS = $(GENSRV_PREPROCESS_WOW64)
!else
GENSRV_PREPROCESS = $(C_PREPROCESSOR) $** > $@
!endif

!if defined(NTTARGETFILES) \
    || defined(NTTARGETFILE0) \
    || defined(NTTARGETFILE1) \
    || defined(NTTARGETFILE2) \
    || defined(USE_MAKEFILE_INC) \

! INCLUDE .\makefile.inc
!ENDIF

!if "$(XAML_COMPILATION)" == "1"
! INCLUDE $(NTMAKEENV)\wcpcompiler.inc
!endif

!if defined(_PROJECT_BUILDS_MANAGED_CODE) && ("$(BUILD_PRODUCT)" == "NT") && "$(MANAGED_TARGET_TYPE)" != "module" # { {

!ifdef INTERNALS_VISIBLE_TO

# Add asmmeta flags
#
ASMMETA_PRESERVE_INTERNALS_VISIBLE_TO_ATTRIBUTE = 1

# Get rid of spaces.
#
INTERNALS_VISIBLE_TO=$(INTERNALS_VISIBLE_TO: =)

# get rid of the leading ; if there is one
#
INTERNALS_VISIBLE_TO=; $(INTERNALS_VISIBLE_TO)
INTERNALS_VISIBLE_TO=$(INTERNALS_VISIBLE_TO:; ;=)
INTERNALS_VISIBLE_TO=$(INTERNALS_VISIBLE_TO:; =)

# get rid of the trailing ; if there is one
#
INTERNALS_VISIBLE_TO=$(INTERNALS_VISIBLE_TO) ;
INTERNALS_VISIBLE_TO=$(INTERNALS_VISIBLE_TO:; ;=)
INTERNALS_VISIBLE_TO=$(INTERNALS_VISIBLE_TO: ;=)

!endif

!ifdef COM_VISIBLE # { {
!  if "$(COM_VISIBLE)" == "0" # { {
COM_VISIBLE=false
!  endif # } }
!  if "$(COM_VISIBLE)" == "1" # { {
COM_VISIBLE=true
!  endif # } }
!else # } {
COM_VISIBLE=false
!endif # } }

!if defined(_C_SHARP) # { {
#
# Disable warning CS1699 to use _keyfile.cs
#
!  ifdef COMPLUS_VERSION # {
!    if "$(COMPLUS_VERSION)" >= "v2.0" # {
USER_CS_FLAGS=$(USER_CS_FLAGS) /nowarn:1699
!    endif # }
!  endif # }


!if $(USE_OBJECT_ROOT)
_MANAGED_SOURCES=$(_MANAGED_SOURCES) $(OBJ_PATH)\$O\_generated.cs
$(OBJ_PATH)\$O\_generated.cs: \
!else
_MANAGED_SOURCES=$(_MANAGED_SOURCES) $O\_generated.cs
$O\_generated.cs: \
!endif
$(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
//
// <copyright file="_generated.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>Generated file with version information.</summary>
//

!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Runtime.InteropServices.ComVisible($(COM_VISIBLE))]
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!if defined(SEPARATE_FILE_AND_INFORMATIONAL_VERSION) && defined(VER_FILEVERSION_STR)
[assembly:System.Reflection.AssemblyFileVersion("$(VER_FILEVERSION_STR)")]
!elseif defined(VER_PRODUCTVERSION_STR)
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
!if defined(SEPARATE_FILE_AND_INFORMATIONAL_VERSION)
!  ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyInformationalVersion("$(VER_PRODUCTVERSION_STR)")]
!  elseif defined(VER_FILEVERSION_STR)
[assembly:System.Reflection.AssemblyInformationalVersion("$(VER_FILEVERSION_STR)")]
!  endif
!endif
!ifdef INTERNALS_VISIBLE_TO
[assembly:System.Runtime.CompilerServices.InternalsVisibleTo("$(INTERNALS_VISIBLE_TO:;="^)]
[assembly:System.Runtime.CompilerServices.InternalsVisibleTo(")")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)

!elseif defined(MANAGED_CXX) # } {

!  ifndef _MANAGED_CXX_LIBRARY # { {

!    if "$(BUILD_PASS)" != "PASS0" # { {

!if $(USE_OBJECT_ROOT)
OBJECTS=$(OBJECTS)               $(OBJ_PATH)\$O\_generated.obj
TARGETOBJFILES=$(TARGETOBJFILES) $(OBJ_PATH)\$O\_generated.obj
IMPLIB_DEPEND=$(IMPLIB_DEPEND)   $(OBJ_PATH)\$O\_generated.obj
$(OBJ_PATH)\$O\_generated.cpp: \
!else
OBJECTS=$(OBJECTS)               $O\_generated.obj
TARGETOBJFILES=$(TARGETOBJFILES) $O\_generated.obj
IMPLIB_DEPEND=$(IMPLIB_DEPEND)   $O\_generated.obj
$O\_generated.cpp: \
!endif
$(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if "$(PRECOMPILED_INCLUDE)" != "" && "$(PRECOMPILED_CXX)" != "" && "$(NTNOPCH)" != "1"
#include "$(PRECOMPILED_INCLUDE_BASENAME)"
!endif
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System::Resources::NeutralResourcesLanguage("en")];
!endif
[assembly:System::Runtime::InteropServices::ComVisible($(COM_VISIBLE))];
!ifdef ASSEMBLY_IDENTITY_VERSION
[assembly:System::Reflection::AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")];
!endif
!ifdef VER_PRODUCTNAME_STR
[assembly:System::Reflection::AssemblyProduct("$(VER_PRODUCTNAME_STR)")];
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System::Reflection::AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")];
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System::Reflection::AssemblyCompany("$(VER_COMPANYNAME_STR)")];
!endif
!if defined(SEPARATE_FILE_AND_INFORMATIONAL_VERSION) && defined(VER_FILEVERSION_STR)
[assembly:System::Reflection::AssemblyFileVersion("$(VER_FILEVERSION_STR)")];
!endif
!if defined(SEPARATE_FILE_AND_INFORMATIONAL_VERSION)
!  ifdef VER_PRODUCTVERSION_STR
[assembly:System::Reflection::AssemblyInformationalVersion("$(VER_PRODUCTVERSION_STR)")];
!  elseif defined(VER_FILEVERSION_STR)
[assembly:System::Reflection::AssemblyInformationalVersion("$(VER_FILEVERSION_STR)")];
!  endif
!endif
!if defined(INTERNALS_VISIBLE_TO)
[assembly:System::Runtime::CompilerServices::InternalsVisibleTo("$(INTERNALS_VISIBLE_TO:;="^)];
[assembly:System::Runtime::CompilerServices::InternalsVisibleTo(")")];
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs "$(_ASSEMBLY_IDENTITY)" $@.temp c
!endif
    $(_MOVE)

!    endif # } }
!  endif # } }

!elseif defined(_VB) # } {

#
# Disable warning keyfile warning - change to same test as above for CS when compiler is updated.
#
USER_VB_NET_FLAGS=$(USER_VB_NET_FLAGS) /nowarn:41008

!if $(USE_OBJECT_ROOT)
_MANAGED_SOURCES=$(_MANAGED_SOURCES) $(OBJ_PATH)\$O\_generated.vb
$(OBJ_PATH)\$O\_generated.vb: \
!else
_MANAGED_SOURCES=$(_MANAGED_SOURCES) $O\_generated.vb
$O\_generated.vb: \
!endif
$(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
<assembly:System.Resources.NeutralResourcesLanguage("en")>
!endif
<assembly:System.Runtime.InteropServices.ComVisible($(COM_VISIBLE))>
<assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")>
!ifdef VER_PRODUCTNAME_STR
<assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")>
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
<assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")>
!endif
!ifdef VER_COMPANYNAME_STR
<assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")>
!endif
!if defined(SEPARATE_FILE_AND_INFORMATIONAL_VERSION) && defined(VER_FILEVERSION_STR)
<assembly:System.Reflection.AssemblyFileVersion("$(VER_FILEVERSION_STR)")>
!elseif defined(VER_PRODUCTVERSION_STR)
<assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")>
!endif
!if defined(SEPARATE_FILE_AND_INFORMATIONAL_VERSION)
!  ifdef VER_PRODUCTVERSION_STR
<assembly:System.Reflection.AssemblyInformationalVersion("$(VER_PRODUCTVERSION_STR)")>
!  elseif defined(VER_FILEVERSION_STR)
<assembly:System.Reflection.AssemblyInformationalVersion("$(VER_FILEVERSION_STR)")>
!  endif
!endif
!if defined(INTERNALS_VISIBLE_TO)
<assembly:System.Runtime.CompilerServices.InternalsVisibleTo("$(INTERNALS_VISIBLE_TO:;="^)>
<assembly:System.Runtime.CompilerServices.InternalsVisibleTo(")")>
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs "$(_ASSEMBLY_IDENTITY)" $@.temp managed_vb
!endif
    $(_MOVE)

!elseif defined(_TLBIMP) # } {

!else # } {

!  error unknown language

!endif # _C_SHARP, MANAGED_CXX, _VB, _TLBIMP # } }


!endif # _PROJECT_BUILDS_MANAGED_CODE } }


!IF "$(PRECOMPILED_INCLUDE)" != ""
! ifdef PRECOMPILED_SOURCEFILE
!  ifdef PRECOMPILED_INCLUDE_BASENAME
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE) $(PRECOMPILED_SOURCEFILE)
!  else
PRECOMPILED_INCLUDE_BASENAME=$(?F)
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE)
!  endif
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(ECHO_PRECOMPILED_MSG1)
<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<< $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
!if "$(PRECOMPILED_CXX)" == ""
$(EX_C_COMPILER_FLAGS_NOPCH)
!else
$(EX_CXX_COMPILER_FLAGS_NOPCH)
!endif
/Yl$(TARGETNAME) /Yc$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE) $(HEADEROBJ)
<<$(BUILD_NOKEEP)
! else
!  ifndef PRECOMPILED_INCLUDE_BASENAME
PRECOMPILED_INCLUDE_BASENAME=$(?F)
!  endif
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE)
    @$(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(ECHO_PRECOMPILED_MSG2)

#include "$(PRECOMPILED_INCLUDE_BASENAME)"

<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<< $(PRECOMPILED_FLAG)<<$(OBJ_PATH)\$O\pch_hdr.src
!if "$(PRECOMPILED_CXX)" == ""
$(EX_C_COMPILER_FLAGS_NOPCH)
!else
$(EX_CXX_COMPILER_FLAGS_NOPCH)
!endif
/Yl$(TARGETNAME) /Yc$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE) $(HEADEROBJ)
<<$(BUILD_NOKEEP)
#include "$(PRECOMPILED_INCLUDE_BASENAME)"
<<KEEP
! endif

pch_hdr.pp:
    set _CL_=/P
    -$(_DELFILE) pch_hdr.i pch_hdr.pp
    nmake /nologo /f $(NTMAKEENV)\makefile.def $(PRECOMPILED_TARGET) $(HEADEROBJNAME)
    rename pch_hdr.i pch_hdr.pp

!ENDIF

!if !defined(NOLINK) && "$(UMAPPL)" != ""

#
# Standard inference rule for User Mode object files that produce User Mode
# image files
#
UMEXEFILE_LIBS = $(BO_LIB) $(UMLIBS) $(LIBC_LIB) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)

$(UMEXEFILES): $(UMOBJFILES) $(UMEXEFILE_LIBS) $(UMRES)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
$(DYNAMICBASE_FLAG)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(HEADEROBJNAME: =
)
$(LINKER_OPTIDATA)
/subsystem:$(SUBSYSTEM)
/base:$(UMBASE)
$(UMENTRY)
$(UMRES: =
)
$(*R).obj
$(UMEXEFILE_LIBS: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)
!endif

!if "$(BROWSERFILE)" != ""

! ifndef BSCMAKE_FLAGS
BSCMAKE_FLAGS = -nologo
! endif

$(BROWSERFILE) : \
! if "$(OBJECTS)" != "" || "$(OTHER_SBR_FILES)" != ""
                $(OBJ_PATH)\$O\*.sbr $(OTHER_SBR_FILES)
    bscmake $(BSCMAKE_FLAGS) -o "$(BROWSERFILE)" @<<$(OBJ_PATH)\$O\bscmake.rsp
$(**: =
)
<<$(BUILD_NOKEEP)
! endif
!endif

#
# These dependencies produce the target binaries from the object files.
# These will trigger the sources to object inference rules to generate the
# object files.
#

!IF "$(TARGET)" != ""
! IF "$(TARGETTYPE)" == "PROGLIB"
$(TARGET:.exe=.lib) $(DYNLINK_EXP): \
!  if "$(BUILD_PASS)" != "PASS2"
                                         $(IMPLIB_DEPEND) \
!  endif
                                         $(DLLDEF)
    $(LIB_NAME) /out:$(@R).lib @<<$(LIB_RESPONSE_FILE)
$(LIBRARIAN_FLAGS: =
)
!if !defined(MCPP_TYPE)
/def:$(DLLDEF)
!endif
$(LIBRARY_OBJS: =
)
<<$(BUILD_NOKEEP)
    $(LINT_CMD2)

$(TARGET): $(_RES_FILE) $(OBJECTS) $(DYNLINK_EXP) $(UMRES) $(BO_LIB) $(UMLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
$(DYNAMICBASE_FLAG)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(HEADEROBJNAME: =
)
$(LINKER_OPTIDATA)
/subsystem:$(SUBSYSTEM)
/base:$(UMBASE)
$(UMENTRY: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)


! ELSEIF "$(TARGETTYPE)" == "PROGRAM"

!    if (!defined(_C_SHARP) && !defined(_VB))
$(TARGET): $(UMRES) $(_RES_FILE) $(OBJECTS) $(BO_LIB) $(CRTLIBS) $(UMLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
$(DYNAMICBASE_FLAG)
/subsystem:$(SUBSYSTEM)
/base:$(UMBASE)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(UMENTRY: =
)
$(LINKER_OPTIDATA)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(LINT_CMD2)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)


!  ELSE  # _C_SHARP or _VB is set
#
# Tlbimp does not support response files and tends to have short command lines.
# _MANAGED_SOURCES is $(SOURCES) but with .rc, .idl removed.
#
$(TARGET) : $(_MANAGED_SOURCES) $(_RES_FILE)
!if !defined(_TLBIMP)
    $(NOECHO) $(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MANAGED_CODE_BUILD_CMD)
<<$(BUILD_NOKEEP)
    $(NOECHO) $(MANAGED_CODE_BUILD_TOOL) @<<$(MANAGED_CODE_BUILD_TOOL_RESPONSE_FILE)
$(MANAGED_CODE_BUILD_SWITCHES)
$(_MANAGED_SOURCES)
<<$(BUILD_NOKEEP)
!else
    $(MANAGED_CODE_BUILD_TOOL) $(MANAGED_CODE_BUILD_SWITCHES) $(_MANAGED_SOURCES)
!endif
!if defined(_RES_FILE) && defined(_TLBIMP)
    ildasm /nobar /text $@ /out:$@.ilasm
    move $@ $@_no_res
    ilasm /quiet /dll /res:$(_RES_FILE) /output=$@ $@.ilasm $(ILASM_MACHINE_SWITCH)
!endif
    $(IBC_CMD)
    $(MANAGED_NXCOMPAT_CMD)
    $(POST_MANAGED_BUILD_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)


!  ENDIF # _C_SHARP || _VB

! ELSEIF "$(TARGETTYPE)" == "DYNLINK"

!  ifdef NO_DLL_EXPORTS
DYNLINK_EXP=
!  elseif (!defined(_C_SHARP) && !defined(_VB) && !defined(_TLBIMP))
$(DYNLINK_LIB) $(DYNLINK_EXP) : \
!   if "$(BUILD_PASS)" != "PASS2"
                                $(IMPLIB_DEPEND) $(DLLLIBOBJECTS) \
!   endif
                                $(DLLDEF)
    $(LIB_NAME) /out:$(DYNLINK_LIB) @<<$(LIB_RESPONSE_FILE)
$(LIBRARIAN_FLAGS: =
)
!if !defined(MCPP_TYPE)
/def:$(DLLDEF)
!endif
$(LIBRARY_OBJS: =
)
<<$(BUILD_NOKEEP)
!   IF "$(DLLLIBOBJECTS)" != " "
    $(LIB_NAME) /out:$(DYNLINK_LIB) @<<$(LIB_RESPONSE_FILE)
$(LIBRARIAN_FLAGS: =
)
$(@R).lib
$(DLLLIBOBJECTS)
<<$(BUILD_NOKEEP)
!   ENDIF
    $(LINT_CMD2)
!  endif # NO_DLL_EXPORTS

!  IF "$(MAKEDLL)" != ""

!    if (!defined(_C_SHARP) && !defined(_VB) && !defined(_TLBIMP))

$(TARGET): $(DYNLINK_EXP) $(_RES_FILE) $(OBJECTS) $(BO_LIB) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(DYNAMICBASE_FLAG)
$(LINKER_STACKSIZE_DLL)
/dll
$(ORDER: =
)
$(LINKER_OPTIDATA)
/base:$(DLLBASE)
/subsystem:$(SUBSYSTEM)
$(DLLENTRY: =
)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGN_THEME_FILE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)
!if defined(NO_PUBLIC_EXPORTS)
    $(_DELFILE) $(@R).lib
!endif
    $(VALIDATE_DLLDEF_CMD)
    $(DETECT_UNUSED_LIBS_CMD)

!  ELSE  # _C_SHARP || _VB || _TLBIMP is set
#
# Tlbimp does not support response files and tends to have short command lines.
# _MANAGED_SOURCES is $(SOURCES) but with .rc, .idl removed.
#
$(TARGET) : $(_MANAGED_SOURCES) $(_RES_FILE)
!if !defined(_TLBIMP)
    $(NOECHO) $(_TYPE) <<$(TYPE_RESPONSE_FILE)
$(MANAGED_CODE_BUILD_CMD)
<<$(BUILD_NOKEEP)
    $(NOECHO) $(MANAGED_CODE_BUILD_TOOL) @<<$(MANAGED_CODE_BUILD_TOOL_RESPONSE_FILE)
$(MANAGED_CODE_BUILD_SWITCHES)
$(_MANAGED_SOURCES)
<<$(BUILD_NOKEEP)
!else
    $(MANAGED_CODE_BUILD_TOOL) $(MANAGED_CODE_BUILD_SWITCHES) $(_MANAGED_SOURCES)
!endif
!if defined(_RES_FILE) && defined(_TLBIMP)
    ildasm /nobar /text $@ /out:$@.ilasm
    move $@ $@_no_res
    ilasm /quiet /dll /res:$(_RES_FILE) /output=$@ $@.ilasm $(ILASM_MACHINE_SWITCH)
!endif
    $(IBC_CMD)
    $(MANAGED_NXCOMPAT_CMD)
    $(POST_MANAGED_BUILD_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)


!  ENDIF # _C_SHARP || _VB || _TLBIMP

!  ENDIF # "$(MAKEDLL)" != ""

! ELSEIF "$(TARGETTYPE)" == "LIBRARY"

$(TARGET): $(OBJECTS) $(OBJLIBFILES)
    -@erase $@ 2>nul
    $(LIBRARIAN) @<<$(LIB_RESPONSE_FILE)
$(HEADEROBJNAME: =
)
$(OBJECTS: =
)
$(OBJLIBFILES: =
)
<<$(BUILD_NOKEEP)

    $(LINT_CMD2)
! ELSEIF "$(TARGETTYPE)" == "DRIVER" || \
    "$(TARGETTYPE)" == "MINIPORT"

$(TARGET): $(_RES_FILE) $(OBJECTS) $(BO_LIB) $(MACHINE_TARGETLIBS) $(CRTLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
$(ORDER: =
)
$(SECTION_INFO1)
$(SECTION_INFO2)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
/base:$(DRIVERBASE)
!  IF "$(DRIVERTYPE)" == "VXD"
/def:$(DLLDEF)
!  ELSE
$(DRIVER_ALIGN_SWITCH)
/subsystem:native,$(SUBSYSTEM_NATVER)
/entry:$(DRIVER_ENTRY)$(ENTRY_SUFFIX)
!endif
/out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)


! ELSEIF "$(TARGETTYPE)" == "GDI_DRIVER"

$(TARGET): $(_RES_FILE) $(OBJECTS) $(BO_LIB) $(MACHINE_TARGETLIBS) $(CRTLIBS) $(GDI_DRIVER_LIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
/dll
$(ORDER: =
)
$(SECTION_INFO1)
$(SECTION_INFO2)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(DRIVER_ALIGN_SWITCH)
/subsystem:native,$(SUBSYSTEM_NATVER)
/base:$(DRIVERBASE)
/entry:$(GDI_DRIVER_ENTRY)$(GDI_ENTRY_SUFFIX)
/out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)


! ELSEIF "$(TARGETTYPE)" == "EXPORT_DRIVER"

$(DYNLINK_EXP) $(DYNLINK_LIB) : \
!  if "$(BUILD_PASS)" != "PASS2"
!if $(USE_DLLDEF_OBJECTS)
        $(DLLDEF_OBJECTS) \
!else
        $(BO_LIB) \
        $(LINKLIBS) \
!endif
        $(DLLLIBOBJECTS) \
!  endif
        $(DLLDEF) \
        $(OBJECTS)
    $(LIB_NAME) /out:$(DYNLINK_LIB) @<<$(LIB_RESPONSE_FILE)
$(LIBRARIAN_FLAGS: =
)
!if !defined(MCPP_TYPE)
/def:$(DLLDEF)
!endif
$(OBJECTS)
!if $(USE_DLLDEF_OBJECTS)
$(DLLDEF_OBJECTS)
!else
$(LINKLIBS)
!endif
<<$(BUILD_NOKEEP)
!  if "$(DLLLIBOBJECTS)" != " "
    $(LIB_NAME) /out:$(DYNLINK_LIB) @<<$(LIB_RESPONSE_FILE)
$(LIBRARIAN_FLAGS: =
)
$(DYNLINK_LIB)
$(DLLLIBOBJECTS)
<<$(BUILD_NOKEEP)
!  endif
    $(LINT_CMD2)

!  IF "$(MAKEDLL)" != ""
$(TARGET): $(DYNLINK_EXP) $(_RES_FILE) $(OBJECTS) $(BO_LIB) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(ORDER: =
)
$(LINKER_STACKSIZE_DLL)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(DRIVER_ALIGN_SWITCH)
/subsystem:native,$(SUBSYSTEM_NATVER)
/base:$(DRIVERBASE)
/entry:$(DRIVER_ENTRY)$(ENTRY_SUFFIX)
/out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)
!  ENDIF

! ELSEIF "$(TARGETTYPE)" == "HAL"

!  IF "$(MAKEDLL)" == ""
$(TARGET) $(DYNLINK_EXP): \
        $(DLLDEF) \
        $(OBJ_PATH)\$O\*.obj \
!if $(USE_DLLDEF_OBJECTS)
        $(DLLDEF_OBJECTS)
!else
        $(LINKLIBS)
!endif
    $(LIB_NAME) /out:$(@R).lib @<<$(LIB_RESPONSE_FILE)
$(LIBRARIAN_FLAGS: =
)
!if !defined(MCPP_TYPE)
/def:$(DLLDEF)
!endif
$(OBJ_PATH)\$O\*.obj
!if $(USE_DLLDEF_OBJECTS)
$(DLLDEF_OBJECTS)
!else
$(LINKLIBS)
!endif
<<$(BUILD_NOKEEP)

!  ELSE

$(TARGET:.dll=.lib) $(DYNLINK_EXP): $(DLLDEF) $(OBJ_PATH)\$O\*.obj \
!if $(USE_DLLDEF_OBJECTS)
        $(DLLDEF_OBJECTS)
!else
        $(LINKLIBS)
!endif
    $(LIB_NAME) /out:$(@R).lib @<<$(LIB_RESPONSE_FILE)
$(LIBRARIAN_FLAGS: =
)
!if !defined(MCPP_TYPE)
/def:$(DLLDEF)
!endif
$(OBJ_PATH)\$O\*.obj
!if $(USE_DLLDEF_OBJECTS)
$(DLLDEF_OBJECTS)
!else
$(LINKLIBS)
!endif
<<$(BUILD_NOKEEP)

$(TARGET): $(DYNLINK_EXP) $(_RES_FILE) $(OBJECTS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(HAL_ALIGN_SWITCH)
/subsystem:$(SUBSYSTEM)
/base:$(HALBASE)
/dll
/noentry
/out:$(TARGET)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)
!  ENDIF

! ELSEIF "$(TARGETTYPE)" == "CATALOG"

MAKECAT=makecat

# Make sure we have all of the parameters we need.
!  if !defined(CATALOG_CERT)
CATALOG_CERT=0
!  endif
!  if !defined(CATALOG_DISPLAY)
CATALOG_DISPLAY=Microsoft Security Catalog
!  endif
!  if !defined(CATALOG_URL)
CATALOG_URL=http://www.microsoft.com
!  endif
!  if !defined(CATALOG_OS_VERSION_LIST)
CATALOG_OS_VERSION_LIST=$(CATALOG_OS_VERSION)
!  endif

CATALOG_CDF=$(TARGET).cdf
CATALOG_CMD=$(MAKECAT) -v -o $(TARGET).hash $(CATALOG_CDF)
!  if defined(CATALOG_MINSIZE) && "$(CATALOG_MINSIZE)" != "0"
CATALOG_CMD=$(CATALOG_CMD) -s $(CATALOG_MINSIZE)
!  endif

CATALOG_SIGN_CMD=ntsign  -cert $(CATALOG_CERT) -url "$(CATALOG_URL)" -displayname "$(CATALOG_DISPLAY)" $(TARGET)


# The actual catalog config file target.
$(TARGET): $(SOURCES)
    set BUILDMSG=making $(@F)
    set createfile=<<$(@R)_pre.txt
$**
<<Keep
    echo $(CATALOG_OS_VERSION_LIST) > "$(@R)_version.txt"
!  ifdef CATALOG_DRM_FILE_LIST
    echo $(CATALOG_DRM_FILE_LIST) > "$(@R)_drm.txt"
!  endif
    @$(_PERL) $(RAZZLETOOLPATH)\cdf_create.pl \
!  ifdef CATALOG_DRM_FILE_LIST
      -drm_list  "$(@R)_drm.txt"           \
!  endif
!  if defined(CATALOG_PE_TRUSTED) && "$(CATALOG_PE_TRUSTED)" != "0"
      -petrusted                           \
!  endif
    -catalog "$@"                          \
    -version_list "$(@R)_version.txt"      \
    -cdf "$(CATALOG_CDF)"                  \
    -file_list "$(@R)_pre.txt"
    $(CATALOG_CMD)
    $(CATALOG_SIGN_CMD) -mdok
    $(BINPLACE_CMD)

! ELSEIF "$(TARGETTYPE)" == "MSI"

$(TARGET): $(SOURCES)
    set BUILDMSG=making $(@F)
    $(_PERL) $(RAZZLETOOLPATH)\make_msi.pl @<<$(@R).msi_response
sources=$**
candle_flags=$(USER_CANDLE_FLAGS)
light_flags=$(USER_LIGHT_FLAGS)
objpath=$(OBJ_PATH)\$O
target=$(TARGET)
<<$(BUILD_NOKEEP)
    $(BINPLACE_CMD)

! ENDIF
!ENDIF

! if defined(DO_LANGUAGE_NEUTRAL) && !defined(NOLINK) && "$(MYMUILINK)" != "" && "$(TARGET)" != ""
$(TARGET).mui: $(MYMUILINK)
 <<$@.cmd
   set BUILDMSG=making $(@F)
   @type $@.cmd
   @del $(TARGET).muilnk 2>nul
   @del $(TARGET).notloc 2>nul
   @for %%k in ($**) do if exist %%~dpnk.muires @echo %%~dpnk.muires>>$(TARGET).muilnk
   @if not exist $(TARGET).muilnk @echo notloc>$(TARGET).mui.notloc
   @if not exist $(TARGET).muilnk echo Build_Status  LN_MUI_STS: LGNSTS_NOLOCRESOURCE $(@B)
   @if exist $(TARGET).muilnk (
!if defined(_TLBIMP) || defined(_C_SHARP) || defined(_VB)
        echo error : error Win32 resources in tlbimp/C#/VB are not localizable.
!else
        echo Build_Status Generating : Creating MUI file: LN_MUI_STS: LGNSTS_MUIED $(@F)
        $(LINKER) $(LANGUAGE_NEUTRAL_LINK_FLAG) /out:$@ @$(TARGET).muilnk
!endif
    )
   @del $(TARGET).muilnk 2>nul
!  ifdef SIGNCODE_CMD
   @if exist $@ $(SIGNCODE_CMD)
!  endif
!  ifndef NO_BINPLACE
        @if exist $@ ( $(BINPLACE_TOOL) -G5 $(LANGUAGE_NEUTRAL_RESDIR) $(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS) $(TARGET).mui )
!  endif
<<$(BUILD_NOKEEP)
!ENDIF

!IFNDEF NOLINK

! if defined(NTKERNEL)

$(OBJ_PATH)\$O\$(NTKERNEL).exe: $(NTRES) $(@D)\$(NTKERNEL).obj  \
                        $(BO_LIB) $(KERNEL_LIBS) \
                        $(LINKLIBS)
    $(LINKER) @<<$(LINK_RSP)
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(NTKERNEL_LINK_OPTIONS: =
)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(KERNEL_ALIGN_SWITCH)
/subsystem:$(SUBSYSTEM)
$(**: =
)
<<$(BUILD_NOKEEP)
!  if !defined(NO_BINPLACE) && defined(DO_LSBUILD) && defined(LOCALIZE_BASE_FILE)
    set BUILDMSG=making base file $O\$(@F) with CreateLCGFile.pl
    set createfile=<<$@.binplace.txt \
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
!  endif # !NO_BINPLACE && DO_LSBUILD && LOCALIZE_BASE_FILE
    $(POST_BUILD_CMD)
    $(MAXDEP_CMD)
    $(PGULOG_CMD)
    $(OBFUSCATOR_CMD)
    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(_BINPLACE_TARGET_COMMAND)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)
    $(LOCALIZE_BASE_FILE_CMD)
    $(_CHECK_IMPORTS_COMMAND)
    $(_CHECK_DELAYLOAD_COMMAND)
! ENDIF
!ENDIF

!IF DEFINED(USE_LINT) && ("$(LINT_TYPE)" == "all")

$(OBJ_PATH)\$O\$(LINT_OUTPUT).$(LINT_EXT): $(TARGETOBJFILES)
    $(LINT_ALL_CMD) $(SOURCES)
!ENDIF

$(OBJ_PATH)\$O\*.res : $(MASTER_VERSION_FILE)
$O\*.res : $(MASTER_VERSION_FILE)

!ifdef SXS_MANIFEST_OBJ2
$(SXS_MANIFEST_OBJ2) : $(SXS_MANIFEST_OBJ1)
    $(_COPYFILE) $(SXS_MANIFEST_OBJ1) $(SXS_MANIFEST_OBJ2)
!endif

!ifdef SXS_PDB_NAMER
$(SXS_PDB_NAMER) : $(SXS_MANIFEST_OBJ1)
    $(MANIFEST_PREPROCESSOR_NAME) $(MANIFEST_PREPROCESSOR_FLAGS) -DSXS_WANT_ASSEMBLY_VERSION \
    $(SXS_MANIFEST_DEFINES) -DSXS_PRE=/pdb:$(OBJ_PATH)\$O\$(SXS_PDB_WOW6432_W_PREFIX)$(SXS_ASSEMBLY_NAME:.=) \
    -DSXS_POST=$(TARGETNAME:.=).pdb $(MANIFEST_VERSION_HEADER) | $(MANIFEST_TRIMMER) > $@
!endif

#
# RC Config
#
.SUFFIXES: .muimanifest .rcconfig .rcc .drcc
#
# .muimanifest -> .rcc

!ifdef DO_LANGUAGE_NEUTRAL
{..\..}.muimanifest{$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..\..}.muimanifest{$(OBJ_PATH)\$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.muimanifest{$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.muimanifest{$(OBJ_PATH)\$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.muimanifest{$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.muimanifest{$(OBJ_PATH)\$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

!endif  #DO_LANGUAGE_NEUTRAL

# .rcconfig -> .rcc
!ifdef DO_LANGUAGE_NEUTRAL
{$(RC_CONFIG_ROOT)}.rcconfig{$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{$(RC_CONFIG_ROOT)}.rcconfig{$(OBJ_PATH)\$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..\..}.rcconfig{$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..\..}.rcconfig{$(OBJ_PATH)\$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.rcconfig{$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.rcconfig{$(OBJ_PATH)\$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.rcconfig{$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.rcconfig{$(OBJ_PATH)\$O}.rcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

!endif  #DO_LANGUAGE_NEUTRAL


#
# delta RC config related
#
!    ifdef DELTA_RC_CONFIG

#{$(RC_CONFIG_ROOT)}.muimanifest{$O}.drcc:
#    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)
#
#{$(RC_CONFIG_ROOT)}.muimanifest{$(OBJ_PATH)\$O}.drcc:
#    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

!ifdef DO_LANGUAGE_NEUTRAL
{..\..}.muimanifest{$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..\..}.muimanifest{$(OBJ_PATH)\$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.muimanifest{$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.muimanifest{$(OBJ_PATH)\$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.muimanifest{$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.muimanifest{$(OBJ_PATH)\$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

!endif #DO_LANGUAGE_NEUTRAL


#{$(RC_CONFIG_ROOT)}.rcconfig{$O}.drcc:
#    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)
#
#{$(RC_CONFIG_ROOT)}.rcconfig{$(OBJ_PATH)\$O}.drcc:
#    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

!ifdef DO_LANGUAGE_NEUTRAL
{..\..}.rcconfig{$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..\..}.rcconfig{$(OBJ_PATH)\$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.rcconfig{$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{..}.rcconfig{$(OBJ_PATH)\$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.rcconfig{$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

{}.rcconfig{$(OBJ_PATH)\$O}.drcc:
    $(RC_CONFIG_PREPROCESSOR_NAME) -o $@ -i $< $(RC_CONFIG_DEFINES)

!endif #DO_LANGUAGE_NEUTRAL

!endif
#
# [GorN] 3/30/2000
#
#    WPP. extra rules. Can't have them before the rule to build "all"
#

!if defined(RUN_WPP) && exist(obj\_tracewpp.mac)
WPP_DEFINE_RULES=1
!  include obj\_tracewpp.mac
!endif


!if defined(DO_LSBUILD) && !defined(NOLINK) && "$(LCG_DEPEND)" != ""
$(LCG_TARGET): $(LCG_DEPEND)
    set BUILDMSG=making $O\$(@F) with CreateLCGFile.pl
! ifndef NO_BINPLACE
    set createfile=<<$@.binplace.txt
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep
! endif # NO_BINPLACE
    $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /g:$(LCG_TARGET) \
        /f:$(LCG_SOURCE) \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
! ifndef NO_BINPLACE
        /b:$@.binplace.txt \
        /r:$(LCG_BINPLACE_TARGET) \
! endif # NO_BINPLACE
        $(LSBUILD_LCE_OPTION)
!endif # DO_LSBUILD


#
# Make the individual pieces and the keyform of the assembly identity available.
#
$(OBJ_PATH)\$O\_asmid.inc: $(SOURCES_USED)
    set BUILDMSG=making $(@F)
!if "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)"
    -$(_DEL)
    idtool -id $(_ASSEMBLY_IDENTITY) -GenerateMakefileInc > $@.temp || @echo error : error idtool error
!if !defined(_MANAGED_CXX_LIBRARY) && "$(MANAGED_TARGET_TYPE)" != "module"
#
# temporarily do tlbimp stuff here
#
    asmIdToAttribs "$(_ASSEMBLY_IDENTITY)" $@.temp tlbimp
!endif
    echo _ASSEMBLY_IDENTITY=$(_ASSEMBLY_IDENTITY) >> $@.temp
    $(_MOVE)
!else
    echo. > $@
!endif

$(OBJ_PATH)\$O\_asmid.xml: $(SOURCES_USED)
    set BUILDMSG=making $(@F)
!if "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)"
    -$(_DEL)
    idtool -id $(_ASSEMBLY_IDENTITY) -EmptyComponentManifest -out $@.temp || @echo error : error idtool error
    $(_MOVE)
!endif

#
# disassemble code .dll to metadata source with versions with asmmeta.exe
# remove versions with asmmeta.cmd /removeversions
# compare/copy to source directory with asmmeta.cmd /feedback
#

!if defined(_O_ASMMETA) && defined(_O_ASMMETA_OUTPUT) && defined(SOURCE_ASMMETA) && defined(ASMMETA_INPUT)

$(_O_ASMMETA): $(_O_ASMMETA_OUTPUT)
    set BUILDMSG=making $(@F)
    -$(_DEL)
    if exist $** asmmeta.cmd /remove_versions:$** /out:$@.temp /OBJ_PATH:$(OBJ_PATH) /O:$O
    if exist $** asmmeta.cmd /FeedbackAsmmetaBuiltFromDll:$@.temp /out:$(SOURCE_ASMMETA) /OBJ_PATH:$(OBJ_PATH) /O:$O
    @if not exist $** @echo error : error skipping asmmeta.cmd /remove... and /feedback... due to earlier errors
    $(_MOVE)

$(_O_ASMMETA_OUTPUT): $(ASMMETA_INPUT)
    set BUILDMSG=making $(@F)
    -$(_DEL)
    if exist $** \
        $(_URTRUN_20) \
            asmmeta.exe \
                $(ASMMETA_EXE_FLAGS) \
                /config=$(RAZZLETOOLPATH)\managed\v2.0\asmmeta.config \
!if "$(ASMMETA_PRESERVE_INTERNALS_VISIBLE_TO_ATTRIBUTE)" == "1"
                /config=$(RAZZLETOOLPATH)\managed\v2.0\asmmeta.PreserveInternalsVisibleToAttribute.config \
!endif
!if "$(ASMMETA_PRESERVE_EXTENSION_ATTRIBUTE)" == "1"
                /config=$(RAZZLETOOLPATH)\managed\v2.0\asmmeta.PreserveExtensionAttribute.config \
!endif
                /spaces=2 \
!ifndef ASMMETA_NO_1_SWITCH
                /1 \
!endif
                /out:$@.temp \
                $** \
        || @echo error : error asmmeta.exe error
    @if not exist $** @echo error : error skipping asmmeta.exe due to earlier errors
    $(_MOVE)

!endif

#
# Add versions to public metadata managed il-assembly and then assemble.
#

!if defined(_O_BINARY_METADATA) && defined(SOURCE_ASMMETA)

#
# Move the code .pdb around because ilasm.exe deletes it when building
# the metadata .dll.
#
$(_O_BINARY_METADATA): $(OBJ_PATH)\$O\$(TARGETNAME).asmmeta_ver_pass0
    set BUILDMSG=making $(@F)
# TBD -- see about simplifying this
    -$(_DEL)
    @if exist $(OBJ_PATH)\$O\$(TARGETNAME).pdb move $(OBJ_PATH)\$O\$(TARGETNAME).pdb $(OBJ_PATH)\$O\c00057ce4b4d42a68370d9ccc49ce200.pdb
    if exist $** ilasm /nologo /quiet /dll /out:$@.temp $** || @echo error : error ilasm error
    @if exist $(OBJ_PATH)\$O\c00057ce4b4d42a68370d9ccc49ce200.pdb move $(OBJ_PATH)\$O\c00057ce4b4d42a68370d9ccc49ce200.pdb $(OBJ_PATH)\$O\$(TARGETNAME).pdb
    $(_MOVE)

$(OBJ_PATH)\$O\$(TARGETNAME).asmmeta_ver_pass0: $(SOURCE_ASMMETA)
    set BUILDMSG=making $(@F)
    -$(_DEL)
    if exist $** asmmeta.cmd /insert_versions:$** /out:$@.temp /OBJ_PATH:$(OBJ_PATH) /O:$O
    $(_MOVE)
!endif

#
# TBD: We should just wrap al in Perl or JScript instead of writing out _keyfile.al.
# That will also get us better error reporting.
#

$(OBJ_PATH)\$O\_keyfile.al: $(SOURCES_USED)
#
# This is based on the other _keyfile.* code.
# It is a little different because it outputs a response file.
# I don't remember why the slash removal check.
#
!if defined(_ASSEMBLY_IDENTITY) \
    && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
    && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" # { {
    -$(_DEL)
    asmIdToAttribs "$(_ASSEMBLY_IDENTITY)" $@.temp al
    $(_MOVE)
!else
    echo. > $@
!endif # } }

!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) # { {

_AL_COMMAND_LINE1=\
    /objpath:$(OBJ_PATH) \
    /o:$O \
    /out:$@ \
    /culture:en \
    @$(@D)\_keyfile.al \
    /version:"$(ASSEMBLY_IDENTITY_VERSION)" \
!if defined(SEPARATE_FILE_AND_INFORMATIONAL_VERSION) && defined(VER_FILEVERSION_STR)
    /fileversion:"$(VER_FILEVERSION_STR)" \
!elseif defined(VER_PRODUCTVERSION_STR)
    /fileversion:"$(VER_PRODUCTVERSION_STR)" \
!endif
    $(_LANGUAGE_SPECIFIC_MANAGED_RESOURCES_AL_FLAGS)

#
# This has spaces that should not be changed to newlines.
#
_AL_COMMAND_LINE2=\
!ifdef VER_PRODUCTNAME_STR
    /Product:"$(VER_PRODUCTNAME_STR)" \
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
    /Copyright:"$(VER_LEGALCOPYRIGHT_STR)" \
!endif
!ifdef VER_COMPANYNAME_STR
    /Company:"$(VER_COMPANYNAME_STR)" \
!endif

_AL_COMMAND_LINE1=$(_AL_COMMAND_LINE1:    = )
_AL_COMMAND_LINE1=$(_AL_COMMAND_LINE1:   = )
_AL_COMMAND_LINE1=$(_AL_COMMAND_LINE1:  = )
_AL_COMMAND_LINE1_NEWLINES=$(_AL_COMMAND_LINE1: = ^
 )

_AL_COMMAND_LINE=$(_AL_COMMAND_LINE1) $(_AL_COMMAND_LINE2)

$(OBJ_PATH)\$O\$(TARGETNAME).resources.dll: \
        $(OBJ_PATH)\$O\_keyfile.al \
        $(_MANAGED_RESOURCES_SATELLITE_ASSEMBLY_DEPENDENCIES)
    $(_PERL) $(RAZZLETOOLPATH)\CreateManagedResourceSatelliteAssembly.pl @<<$(PERL_RESPONSE_FILE)
$(_AL_COMMAND_LINE)
<<$(BUILD_NOKEEP)

    $(MANAGED_SIGNCODE_CMD)
    $(SIGNCODE_CMD)

    $(BINPLACE_TOOL) \
        $(BINPLACE_FLAGS) \
!if "$(TARGET_DESTINATION)" != "retail"
        /:DEST loc\src\bin\managed\$(TARGET_DESTINATION) \
!else
        /:DEST loc\src\bin\managed \
!endif
        $@

!if "$(DO_LSBUILD)" == "1" && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
     set BUILDMSG=making managed code resources with CreateLCGFile.pl
     set createfile=<<$(OBJ_PATH)\$(O)\managed_resources.lcg.binplace.txt
$(BINPLACE_FLAGS) $(BINPLACE_TARGET_FLAGS)
<<Keep

     $(_PERL) $(RAZZLETOOLPATH)\CreateLCGFile.pl \
        /f:$@ \
        /t:$(OBJ_PATH)\$O \
        $(LSBUILD_PARSER_ID_OPTION_MANAGED) \
        $(ALT_LCI_DIR_OPTION) \
        /l:$(LANGUAGE) \
        /s:$(LSBUILD_PARSER_SETTINGS) \
! ifndef NO_BINPLACE
        /b:$(OBJ_PATH)\$(O)\managed_resources.lcg.binplace.txt \
        /r:$(LCG_BINPLACE_TARGET_MANAGED) \
        /TargetName:$(TARGETNAME) \
        /TargetExt:$(LINK_TARGETEXT) \
! endif
        $(LSBUILD_LCE_OPTION)
!endif # DO_LSBUILD

!endif # } }

!endif # } }


PassIndependentTargets_Manifests: \
 $(SOURCE_MANIFEST) \
 $(WOW64_SOURCE_MANIFEST) \
 $(MULTI_SOURCE_MANIFEST) \
 $(MULTI_WOW64_SOURCE_MANIFEST) \
 $(PROD_SOURCE_MANIFEST) \
 $(PROD_WOW64_SOURCE_MANIFEST) \
 $(INTERNAL_SOURCE_MANIFEST) \
 $(INTERNAL_WOW64_SOURCE_MANIFEST) \
 $(EDITION_SOURCE_MANIFEST) \
 $(WINPE_SOURCE_MANIFEST) \

#
# TBD: We should just wrap al in Perl or JScript instead of writing out _keyfile.al.
# That will also get us better error reporting.
#


PassIndependentTargets_Infs: \
 $(PRINTER_INFS_LOG) \
 $(MANIFESTED_PRINTER_INFS_LOG) \
 $(DRIVER_INFS_LOG) \
 $(MANIFESTED_INFS_LOG) \
 $(NON_PNP_INFS_LOG) \
 $(NON_PNP_SIGN_INFS_LOG) \
 $(LOC_PRINTER_INFS_LOG) \
 $(LOC_MANIFESTED_PRINTER_INFS_LOG) \
 $(LOC_DRIVER_INFS_LOG) \
 $(LOC_MANIFESTED_INFS_LOG) \
 $(LOC_NON_PNP_INFS_LOG) \
 $(LOC_NON_PNP_SIGN_INFS_LOG) \
 $(PRELOC_PRINTER_INFS_LOG) \

PassIndependentTargets: \
    PassIndependentTargets_Manifests \
!if !defined(MANIFESTONLY)
    PassIndependentTargets_Infs \
    PassIndependentTargets_Binplace \
!endif

!if defined(EVENTS_MANIFEST) # { {

!ifndef EVENTS_GENERATED_EVENT_HEADER_FILE_BASENAME # { {

EVENTS_GENERATED_EVENT_HEADER_FILE_BASENAME=$(?B)EventMacros

!endif # } }


!ifdef EVENTS_GENERATE_EVENTS_FOR_DOWNLEVEL # { {

MC_GENERATE_EVENTS_FOR_DOWNLEVEL = -mof

!else # } {

MC_GENERATE_EVENTS_FOR_DOWNLEVEL=

!endif # } }


!ifdef EVENTS_GENERATE_EVENTS_FOR_USERMODE # { {

MC_GENERATE_EVENTS_FOR_USERMODE = -um

!else # } {

MC_GENERATE_EVENTS_FOR_USERMODE=

!endif # } }


!ifdef EVENTS_GENERATE_EVENTS_FOR_KERNELMODE # { {

MC_GENERATE_EVENTS_FOR_KERNELMODE = -km

!else # } {

MC_GENERATE_EVENTS_FOR_KERNELMODE=

!endif # } }


!ifdef EVENTS_GENERATE_EVENTS_FOR_CS # { {

MC_GENERATE_EVENTS_FOR_CS = -cs $(EVENTS_GENERATE_EVENTS_FOR_CS)

!else # } {

MC_GENERATE_EVENTS_FOR_CS=

!endif # } }


!ifdef EVENTS_GENERATED_EVENT_MACRO_PREFIX # { {

EVENTS_GENERATED_EVENT_MACRO_PREFIX_OPTION = -p $(EVENTS_GENERATED_EVENT_MACRO_PREFIX)

!else # } {
EVENTS_GENERATED_EVENT_MACRO_PREFIX_OPTION=

!endif # } }

!ifdef EVENTS_GENERATE_EVENTS_REMOVE_PREFIX # { {

EVENTS_GENERATE_EVENTS_REMOVE_PREFIX_OPTION = -P $(EVENTS_GENERATE_EVENTS_REMOVE_PREFIX)

!else # } {

EVENTS_GENERATE_EVENTS_REMOVE_PREFIX_OPTION=

!endif # } }

EVENTS_VALIDATE_OPTION = -t $(RAZZLETOOLPATH)\providers\Vista
MC_GENERATE_EVENT_OPTIONS = $(MC_GENERATE_EVENTS_FOR_USERMODE) \
	                        $(MC_GENERATE_EVENTS_FOR_KERNELMODE) \
	                        $(MC_GENERATE_EVENTS_FOR_CS) \
	                        $(MC_GENERATE_EVENTS_FOR_DOWNLEVEL) \
	                        $(EVENTS_GENERATED_EVENT_MACRO_PREFIX_OPTION) \
	                        $(EVENTS_GENERATE_EVENTS_REMOVE_PREFIX_OPTION) \
                                $(EVENTS_VALIDATE_OPTION)



!if !defined(EVENTS_MANIFEST_OUTPUT_FILE_BASENAME) # { {

EVENTS_MANIFEST_OUTPUT_FILE_BASENAME=$(?B)Events

#
# For a single file in the current directory, state a target
# with a dependency that many directories depend on.
# This does not work for multiple event manifests or event manifests outside
# the current directory.
#

!if "$(EVENTS_MANIFEST:\=)" == "$(EVENTS_MANIFEST)" # { {

_OLD_EVENTS_MANIFEST_OUTPUT_FILE_BASENAME=$(EVENTS_MANIFEST:.manifest=)
!if "$(_OLD_EVENTS_MANIFEST_OUTPUT_FILE_BASENAME)" == "$(EVENTS_MANIFEST)" # { {
_OLD_EVENTS_MANIFEST_OUTPUT_FILE_BASENAME=$(EVENTS_MANIFEST:.man=)
!endif # } }
_OLD_EVENTS_MANIFEST_OUTPUT_FILE_BASENAME=$(_OLD_EVENTS_MANIFEST_OUTPUT_FILE_BASENAME)Events

$(OBJ_PATH)\$O\$(_OLD_EVENTS_MANIFEST_OUTPUT_FILE_BASENAME).h : $(OBJ_PATH)\$O\_event_manifests

!endif # } }

!else # } {

#
# See if we can remove this.
#
$(OBJ_PATH)\$O\$(EVENTS_MANIFEST_OUTPUT_FILE_BASENAME).h : $(OBJ_PATH)\$O\_event_manifests

!endif # } }


$(OBJ_PATH)\$O\_event_manifests : $(EVENTS_MANIFEST)
    set BUILDMSG=processing EVENTS_MANIFEST=$(EVENTS_MANIFEST:  = )
! if defined(SOURCE_MANIFEST) || defined(WOW64_SOURCE_MANIFEST) || defined(EDITION_SOURCE_MANIFEST) || defined(WINPE_SOURCE_MANIFEST)
    nmake /f $(NTMAKEENV)\makefile.def $(SOURCE_MANIFEST) $(WOW64_SOURCE_MANIFEST) $(EDITION_SOURCE_MANIFEST) $(WINPE_SOURCE_MANIFEST)
! endif
! if !defined(DISABLE_SOURCE_MANIFEST_VALIDATION)
    set BUILDMSG=Manifest formatting for event manifests is being checked.
    set DO_NOT_CHECK_MANIFEST_SCHEMA=1
    set DO_NOT_CHECK_MANIFEST_SCHEMATRON=1
    checksourcemanifests -obj:$(OBJ_PATH)\$O <<$(OBJ_PATH)\$O\ManifestsToBeChecked
$(**: =
)
<<$(BUILD_NOKEEP)
! endif

    !$(MANIFEST_COMPILER_CMD) $? $(OBJ_PATH)\$(O)\$(?F) $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)
    !$(MC) /h $(PASS0_HEADERDIR) /W $(MC_WINMETAPATH) /w $(MC_EVENTMANPATH) /r $(MC_SOURCEDIR) /z $(EVENTS_MANIFEST_OUTPUT_FILE_BASENAME) $(MC_GENERATE_EVENT_OPTIONS) $(MC_FLAGS) $(OBJ_PATH)\$(O)\$(?F) $(EVENTS_MANIFEST_MC_INPUT_FILE)
    set _createfile=<<$@
<<Keep

!endif # } }


# must be left in nmake for case sensitivity
!if defined(USE_sTATIC_MFC)
!error $(MAKEDIR) : USE_sTATIC_MFC does nothing. Remove it.
!endif

!if defined(LINKER_FLAFS)
#!error $(MAKEDIR): LINKER_FLAFS does not do anything. Remove it.
!message $(MAKEDIR): LINKER_FLAFS does not do anything. Remove it.
!endif

#
# Convert .dui into .duip files
#

!if "$(BUILD_PASS)" == "PASS2" || "$(BUILD_PASS)" == "PASS1"
! if defined(DUI_PATH)
!include $(NTMAKEENV)\makefile.dui
! endif
!endif

!if "$(BUILD_PASS)" == "PASS0" && defined(COUNTERS_MANIFEST)
! include $(NTMAKEENV)\makefile.ctrpp
!endif

