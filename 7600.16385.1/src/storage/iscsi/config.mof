//***************************************************************************
//
//  config.mof
// 
//  Module: iScsi Discovery api
//
//  Purpose: Definitions for configuring HBA cards
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#define MODULE_HEADER \
"\n" \
"//***************************************************************************\n" \
"//\n" \
"//  iscsicfg.h\n" \
"// \n" \
"//  Module: iScsi Discovery api\n" \
"//\n" \
"//  Purpose: Header defining interface between user mode configuration\n" \
"//           apps and HBA driver miniport.\n" \
"//\n" \
"//  Copyright (c) 2001 Microsoft Corporation\n" \
"//\n" \
"//***************************************************************************\n\n" 

//
// Do not cause headers to be generated from common.mof
//
#define GENERATE_HEADER FALSE

//
// Include common definitions
//
#include "common.mof"



//
// TCP/IP configuration class, implement one instance for each port on
// your adapter
//
[
 WMI,
 guid("{7A2C6C2B-E5A5-49ad-AD68-133089ACD74D}"),
 Dynamic,
 Provider("wmiprov"),
 DisplayName("TCP/IP configuration") : amended,
 cpp_quote(MODULE_HEADER
           "#include <iscsidef.h>\n\n"
"//\n"
"//\n"
"// This class is required.\n"
"//\n"         
"// TCP/IP configuration class, implement one instance for each IP address on\n"
"// your adapter. For example, if you adapter supports 3 IP addresses then\n"
"// your adapter would implement 3 instances of this class.\n"
"//\n"
"// This class uses PDO instance names with 1 instance for each TCP/IP interface.\n"
"//\n"
          )
]
class MSiSCSI_TCPIPConfig
{
    [key]
    string InstanceName;
    
    boolean Active;

    [read, write,
     WmiDataId(1),
     DisplayName("Use Link Local Address") : amended,
     description("TRUE if the adapter should use an autogenerated and non routable (link local) address as its IP address.") : amended
    ]
    boolean UseLinkLocalAddress;

    [read, write,
     WmiDataId(2),
     displayName("DHCP Enabled") : amended,
     description("TRUE if the adapter should use DHCP to discovery its IP address information.") : amended
    ]
    boolean EnableDHCP;

    [read, write,
     WmiDataId(3),
     displayName("Use DHCP for DNS") : amended,
     description("TRUE if the adapter should use DHCP to discover DNS addresses.") : amended
    ]
    boolean UseDHCPForDNS;

    [read,
     WmiDataId(4),
     description("IP Versions supported **Add #defines**") : amended,
     BitValues{ "IPV4", "IPV6"},
     BitMap{"0x00000001", "0x00000002"}
    ]
    uint32 IPVersions;
    
    [read, write,
     WmiDataId(5),
     DisplayName("IP Address") : amended,
     description("IP address of the adapter") : amended
    ]
    ISCSI_IP_Address IpAddress;

    [read, write,
     WmiDataId(6),
     DisplayName("Default Gateway") : amended,
     Description("Static Default Gateway IP address") : amended
    ]
    ISCSI_IP_Address DefaultGateway;

    [read, write,
     WmiDataId(7),
     DisplayName("Subnet Mask") : amended,
     Description("Static Subnet Mask") : amended
    ]
    ISCSI_IP_Address SubnetMask;    

    [read, write,
     WmiDataId(8),
     DisplayName("Preferred DNS Server") : amended,
     Description("Preferred DNS Server") : amended
    ]
    ISCSI_IP_Address PreferredDNSServer;    

    [read, write,
     WmiDataId(9),
     DisplayName("Alternate DNS Server") : amended,
     Description("Alternate DNS Server") : amended
    ]
    ISCSI_IP_Address AlternateDNSServer;    

};

//
// NIC Port configuration class, implement one instance for each port on
// your adapter
//
[
 WMI,
 guid("{C75258E9-BE79-4a48-A23D-EEB6F8FB940C}"),
 Dynamic,
 DisplayName("NIC Port Configuration") : amended,
 Provider("wmiprov"),
cpp_quote(
"//\n"
"// This class is optional.\n"
"//\n"
"// NIC Port configuration class, implement one instance for each physical \n"
"// network interface port on your adapter.\n"
"//\n"
"// This class uses PDO instance names with 1 instance for each physical\n"
"// network interface port on your adapter.\n"
"//\n"
"\n"
"typedef enum \n"
"{\n"
"    ISCSI_NIC_LINKSTATE_DISCONNECTED = 0,\n"
"    ISCSI_NIC_LINKSTATE_CONNECTED = 1\n"
"} ISCSI_NIC_LINKSTATE, *PISCSI_NIC_LINKSTATE;\n"
)
]
class MSiSCSI_NICConfig
{
    [key]
    string InstanceName;
    
    boolean Active;

    [read,
     WmiDataId(1),
     DisplayName("Link Speed") : amended,
     Description("Speed of network link in megabits per second.") : amended
    ]
    uint32 LinkSpeed;

    [read,
     WmiDataId(2),
     DisplayName("Max Link Speed") : amended,
     Description("Maximum Speed of network link in megabits per second.") : amended
    ]
    uint32 MaxLinkSpeed;

    [read,
     WmiDataId(3),
     DisplayName("Link State") : amended,
     description("Link State **typedef**") : amended,
     Values{"Media Disconnected", "Media Connected"} : amended,
     ValueMap{"0", "1"}
    ]
    uint32 LinkState;
    
    [read,
     WmiDataId(4),
     DisplayName("Max Frame Size") : amended,
     description("Maximum frame size") : amended
    ]
    uint32 MaxFrameSize;
    
    [read,
     WmiDataId(5),
     DisplayName("MAC Address") : amended,
     description("Ethernet MAC Address") : amended
    ]
    uint8 MacAddress[6];

};

[WMI,
 guid("{53EF8D5F-36F3-4124-8B76-C6AD521A1021}"),
 Dynamic, Provider("wmiprov"),
 DisplayName("Boot device configuration") : amended,
 cpp_quote(
"//\n"
"// This class is optional.\n"
"//\n"
"// This class exposes the boot configuration if the adapter is configured to\n"
"// boot from an iSCSI disk.\n"          
"//\n"
"// This class uses PDO instance names with a single instance.\n"
"//\n"
         )        
]
class MSiSCSI_BootConfiguration
{
    [key]
    string InstanceName;
    
    boolean Active;

    [read,
     write,
     WmiDataId(1),
     Description("LUN on target to use as boot device.") : amended,
     DisplayName("Target LUN") : amended
    ]
    uint64 LUN;

    [ read, write,
     WmiDataId(2),
     SECURITY_FLAG_QUALIFIERS
    ]
    ISCSI_SECURITY_FLAGS SecurityFlags;

    [ read, write,
     WmiDataId(3),
     description("Size in bytes of Target Username.") : amended
    ] uint32 UsernameSize;

    [ read, write,
      WmiDataId(4),
      description("Size in bytes of Target Password.") : amended
    ] uint32 PasswordSize;
                     
    [ read, write,
     WmiDataId(5),
     description("If TRUE dynamically discover boot device.") : amended
    ]
    boolean DiscoverBootDevice;
    
    [ read, write,
      WmiDataId(6),
     MaxLen(MAX_ISCSI_NAME_LEN),
     description("The InitiatorNode specifies the iSCSI name of the initiator node to use for the connection. If empty, then the adapter can choose any initiator node name.") : amended
    ] string InitiatorNode;

    [ read, write,
     WmiDataId(7),
     MaxLen(MAX_ISCSI_NAME_LEN),
     description("TargetName specifies the iSCSI target name on which the boot device resides.") : amended
    ] string TargetName;

    [ read, write,
      WmiDataId(8),
     description("Target portal to use for connection to the target.") : amended
    ] ISCSI_TargetPortal TargetPortal;

    [read, write,
     WmiDataId(9),
     description("Options that affect how login is performed. See ISCSI_LoginOptions") : amended
    ] ISCSI_LoginOptions LoginOptions;
    
    [ read, write,
     WmiDataId(10),
     WmiSizeIs("UsernameSize"),
     description("**extra fields** Authentication Username, for CHAP this is the CHAP Name (CHAP_N) use when authenticating with the target. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding.") : amended
    ] uint8 Username[];
    
    [ read, write,
     WmiDataId(11),
     WmiSizeIs("PasswordSize"),
     description("Authentication Password, for CHAP this is the shared secret to use when generating the response to the target challange. This field is a variable length array.") : amended
    ] uint8 Password[]; 
};


//
// Types of encryption supported
//
#define ENCRYPTION_TYPES_QUALIFIERS \
     Values {"No Encryption/Authentication", \
             "3DES HMAC/SHA1", \
             "AES-CTR/CBC-MAC with XCBC"} : amended, \
     ValueMap{ "0", "1", "2" }


[
 WMI,
 guid("{225B9D64-47A9-41c8-81CD-69BC02652D87}"),
 Dynamic,
 Provider("wmiprov"),
 DisplayName("Security Capabilities") : amended,
 cpp_quote(
"//\n"
"// This class is required if adapter supports IPSEC.\n"
"//\n"
"// This class exposes the security capabilities if the adapter \n"
"// supports IPSEC.\n"
"//\n"
"// This class uses PDO instance names with a single instance.\n"
"//\n"
"typedef enum {\n"
"    ISCSI_ENCRYPT_NONE = 0,\n"
"    ISCSI_ENCRYPT_3DES_HMAC_SHA1 = 1,\n"
"    ISCSI_ENCRYPT_AES_CTR = 2              \n"
"} ISCSI_ENCRYPTION_TYPES, *PISCSI_ENCRYPTION_TYPES;\n\n"
          )
]
class MSiSCSI_SecurityCapabilities
{
    [key]
    string InstanceName;
    
    boolean Active;

    [read,
    DisplayName("Protect iSCSI") : amended,
     WmiDataId(1),
     description("TRUE if the adapter can use IPSEC to protect iSCSI traffic.") : amended
    ]
    boolean ProtectiScsiTraffic;

    
    [read,
     WmiDataId(2),
     DisplayName("Protect iSNS") : amended,
     description("TRUE if the adapter can use IPSEC to protect iSNS traffic.") : amended
    ]
    boolean ProtectiSNSTraffic;
    
    [read,
     WmiDataId(3),
     DisplayName("Certificates Supported") : amended,
     description("TRUE if adapter supports certificates") : amended
    ]
    boolean CertificatesSupported;
    
    [read,
     WmiDataId(4),
     DisplayName("Encryption Types Available") : amended,
     description("Number of encryption types available.")
    ]
    uint32 EncryptionAvailableCount;
    
    [ read,
     WmiDataId(5),
     WmiSizeIs("EncryptionAvailableCount"),
     ENCRYPTION_TYPES_QUALIFIERS,
     DisplayName("Encryption Types") : amended,
     description("**typedef** Array of encryption types. This field is a variable length array.")
    ]
    uint32 EncryptionAvailable[];    
};


[WMI,
 guid("{45755098-4291-43df-9720-B58642DD63DF}"),
 Dynamic,
 Provider("wmiprov"),
 DisplayName("Discovery Configuration") : amended,
 cpp_quote(
"//\n"
"// This class is required.\n"
"//\n"
"// This class exposes the configuration capabilities for the adapter to be able to\n"
"// perform target discovery. An adapter needs to support target discovery\n"
"// if it is ever placed on a separate network from the PC NIC. Although\n"
"// the iSCSI Initiator service can use this class with any discovery mechanism\n"
"// the best results are obtained by using iSNS.\n"
"//\n"
"// This class uses PDO instance names with a single instance.\n"
"//\n"
          )
]
class MSiSCSI_DiscoveryConfig
{
    [key]
    string InstanceName;
    
    boolean Active;

    [WmiDataId(1),
     read, write,
     description("TRUE if adapter should perform target discovery via iSNS.") : amended
    ] boolean PerformiSNSDiscovery;

    [WmiDataId(2),
     read, write,
     description("TRUE if adapter should perform target discovery via SLP.") : amended
    ] boolean PerformSLPDiscovery;

    [WmiDataId(3),
     read, write,
     description("TRUE if adapter should perform automatic discovery of iSNS server.") : amended
    ] boolean AutomaticiSNSDiscovery;
    
    [WmiDataId(4),
     read, write,
     MaxLen(256),
     description("Default initiator name for registering with iSNS.") : amended
    ] string InitiatorName;
    
    [WmiDataId(5),
     read, write,    
     description("If AutomaticiSNSDiscovery is FALSE then this contains the fixed addresses of iSNS servers") : amended
    ] ISCSI_IP_Address iSNSServer;
    
};

[WMI,
 guid("{8EAEF9D8-C053-49d3-9205-65C703C2ECC1}"),
 Dynamic,
 Provider("wmiprov"),
 DisplayName("Radius Configuration") : amended,
 cpp_quote(
"//\n"
"// This class is required if adapter supports using RADIUS for CHAP authentication.\n"
"//\n"
"// This class exposes the configuration capabilities if the adapter able to\n"
"// use radius to perform CHAP authentication. Using RADIUS is encouraged\n"
"// since it allows centralized management of CHAP credentials.\n"
"//\n"
"// This class uses PDO instance names with a single instance.\n"
"//\n"
          )
]
class MSiSCSI_RADIUSConfig
{
    [key]
    string InstanceName;
    
    boolean Active;

    [WmiDataId(1),
     read, write,
     description("TRUE if adapter should use RADIUS for CHAP authentication") : amended
    ] boolean UseRADIUSForCHAP;

    [WmiDataId(2),
     read, write,
     description("Size in bytes of shared secret used to communicate with RADIUS servers") : amended
    ] uint32 SharedSecretSizeInBytes;

    [WmiDataId(3),
     read, write,    
     description("Fixed address of primary RADIUS server") : amended
    ] ISCSI_IP_Address RADIUSServer;

    [WmiDataId(4),
     read, write,    
     description("Fixed address of backup RADIUS server") : amended
    ] ISCSI_IP_Address BackupRADIUSServer;

    [WmiDataId(5),
     Description("Must be zero")
    ]
    uint32 Reserved;
    
    [WmiDataId(6),
     read, write,
     WmiSizeIs("SharedSecretSizeInBytes"),
     description("Shared secret for communicating with primary and backup RADIUS servers. This field is a variable length array.") : amended
    ] uint8 SharedSecret[];

};
