// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
028ac712-a759-9e99-8b7b-520b2442d816 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp261 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp249 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp458 30 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp445 29 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp431 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp377 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp334 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp676 41 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp837 46 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp810 45 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp791 44 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp703 42 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp964 52 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp920 50 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp943 51 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp886 48 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp870 47 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1037 57 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 55 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1023 56 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp985 54 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp978 53 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1062 59 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1051 58 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1091 61 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1073 60 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
#typev  lpcmsg_cpp1132 63 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1103 62 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp647 40 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp527 32 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp546 34 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp621 39 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp609 38 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp595 37 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp572 36 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp553 35 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp534 33 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp515 31 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
44c8bbd1-3219-e984-b943-3e91f2d3d76c WUDFPlatform // SRC=host.cpp MJ= MN=
#typev  host_cpp471 14 "%0No kernel-mode debugger found." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp422 11 "%0User-mode debugger found - breaking in." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp459 13 "%0Breaking into kernel debugger." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp444 12 "%0No user-mode debugger found." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp411 10 "%0Waiting %10!d! seconds for debugger to attach." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
TimeoutSeconds, ItemLong -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
45d88299-86b1-28d9-9de7-58394d4976c2 WUDFPlatform // SRC=PlatformStackTracker.cpp MJ= MN=
#typev  PlatformStackTracker_cpp191 11 "%0Failed to reload symbols for object tracking - %10!s!.  Stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::ReloadSymbols
{
hr, ItemHRESULT -- 10
}
#typev  PlatformStackTracker_cpp141 10 "%0Failed to initialize symbols, error %10!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadSymbols
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
4b897bf9-5f73-eee4-04b9-2467c50e510f WUDFPlatform // SRC=EventLogProvider.cpp MJ= MN=
#typev  EventLogProvider_cpp106 10 "%0Error allocating new CEventLogProvider object for %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_LOG FUNC=CEventLogProvider::Create
{
ProviderGuid, ItemGuid -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
543ccf5a-bd78-d91f-f49c-dbee2fd8edf1 lpc // SRC=lpc_xp.cpp MJ= MN=
#typev  lpc_xp_cpp219 10 "%0lpcport got a message!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WorkerThread
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
6597c489-c68a-a64b-657f-76816afd8eb4 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp117 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp103 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp90 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp77 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp55 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp47 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp21 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
#typev  lpcport_cpp132 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp123 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp295 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp177 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp212 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp263 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp274 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp233 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp285 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp163 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
6af7a82d-966a-d60c-af1e-f5af6d17191b lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp755 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp718 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp739 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp727 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp707 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp702 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp832 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp776 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp818 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp806 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp797 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp785 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp769 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp355 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp387 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp363 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp322 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp267 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp258 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp247 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp238 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp211 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp201 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp157 10 "%0 Entering %!FUNC!(%10!d!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
LoopBackPortPrefix, ItemWString -- 12
}
#typev  lpc_cpp513 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp435 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp413 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp395 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp587 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_ADD_DEVICE,0x3
WudfMsg_CREATE,0x4
WudfMsg_CLOSE,0x5
WudfMsg_CLEANUP,0x6
WudfMsg_READ,0x7
WudfMsg_WRITE,0x8
WudfMsg_IOCONTROL,0x9
WudfMsg_Cancel,0xA
WudfMsg_DEVICE_POWER_DOWN_COMPLETE,0xB
WudfMsg_FramworkMax,0xC
WudfMsg_ExitProcess,0xD
WdfProcMgmt_Message_Reserved,0xE
WdfProcMgmt_Message_ControlObjectName,0xF
WdfProcMgmt_Message_QueryProcess,0x10
WdfProcMgmt_Message_OpenProcess,0x11
WdfProcMgmt_Message_CloseProcess,0x12
WudfMsg_Connect,0x13
WudfMsg_Max,0x14
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
7f60a5c4-ccc3-54ac-9e85-1f43d2961238 LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp130 11 "%0%!FUNC!: unable to create listen object %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfLpcCorePortInterface::Listen
{
listenDeviceName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp109 10 "%0unable to construct server port name %10!s!\%11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Listen
{
WUDFLPC_DEVICE_DOSNAME, ItemWString -- 10
ServerPortName, ItemWString -- 11
hResult, ItemHRESULT -- 12
}
#typev  lpccore_cpp208 13 "%0%!FUNC!: unable to connect to %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfLpcCorePortInterface::Connect
{
serverDeviceFullName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp188 12 "%0unable to construct server port name \\.\%10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Connect
{
ServerPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  lpccore_cpp257 14 "%0WUDFLPC_CLOSE_COMM_PORT_HANDLE_INPUT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DeletePort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp359 15 "%0IOCTL_LPC_SEND_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SendMessageW
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp511 17 "%0bytesReturned (0x%10!x!) not same as expected (0x%11!x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::CreateResourceReserve
{
bytesReturned, ItemLong -- 10
sizeof(output), ItemLong -- 11
}
#typev  lpccore_cpp500 16 "%0IOCTL_LPC_RESERVE_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::CreateResourceReserve
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp557 18 "%0IOCTL_LPC_RELEASE_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DeleteResourceReserve
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp651 19 "%0IOCTL_LPC_IMPERSONATE_CLIENT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ImpersonateClientOfPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp721 20 "%0unable to duplicate connection handle for communication handle %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::AcceptConnectPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp830 21 "%0IOCTL_LPC_SEND_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SendWaitReceivePort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp919 22 "%0WUDFLPC_CLOSE_COMM_PORT_HANDLE_INPUT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DisconnectPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp1024 23 "%0CWdfLpcCorePortInterface::SetAccessControl failure with %10!s! & %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SetAccessControl
{
ntStatus, ItemNTSTATUS -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp1087 24 "%0IOCTL_LPC_CLEAR_ACCESS_CONTROL failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ClearAccessControl
{
winerr, ItemWINERROR -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
ad2438f4-42f0-4ddd-67b1-b24ddd9c179c WUDFPlatform // SRC=TraceSession.cpp MJ= MN=
#typev  TraceSession_cpp405 17 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLAGS, ItemWString -- 10
logFlags, ItemLong -- 11
}
#typev  TraceSession_cpp390 16 "%0%10!s! has invalid value %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp383 15 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp364 14 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLUSH_PERIOD_SECONDS, ItemWString -- 10
flushPeriod, ItemLong -- 11
}
#typev  TraceSession_cpp346 13 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_KD, ItemWString -- 10
logKd, ItemLong -- 11
}
#typev  TraceSession_cpp328 12 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_START_NEW_SESSION, ItemWString -- 10
logStartNewSession, ItemLong -- 11
}
#typev  TraceSession_cpp307 11 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_ENABLE, ItemWString -- 10
logEnable, ItemLong -- 11
}
#typev  TraceSession_cpp287 10 "%0Error opening configuration registry key %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
RegistryBase, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  TraceSession_cpp602 18 "%0Caller requested private logger but set no default GUIDs" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_TRACING FUNC=CTraceSession::Start
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
c4571f6b-44c6-e672-69e4-565970fd6d88 WUDFPlatform // SRC=platform.cpp MJ= MN=
#typev  platform_cpp1470 21 "%0unable to get userSid" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1452 20 "%0unable to get domainName buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1445 19 "%0unable to get userSid buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1414 18 "%0username: %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
userName, ItemWString -- 10
}
#typev  platform_cpp1407 17 "%0unable to get username" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1395 16 "%0unable to get username buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1558 23 "%0Error reading registry value %10!s!.  er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  platform_cpp1530 22 "%0Registry value %10!s! was expected to be a REG_DWORD." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
}
#typev  platform_cpp2223 26 "%0MiniDumpWriteDump succeeded" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
}
#typev  platform_cpp2210 25 "%0MiniDumpWriteDump failed with error %10!x!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
result, ItemLong -- 10
}
#typev  platform_cpp370 11 "%0Error %10!s! trying to open root registry key %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
result, ItemWINERROR -- 10
WDF_ROOT_KEY, ItemWString -- 11
}
#typev  platform_cpp358 10 "%0Minidump flags set to %10!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
g_MiniDumpType, ItemLong -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
#typev  platform_cpp596 15 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp584 14 "%0Failed to allocate %10!I64u! bytes for directory path string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
(logPathCch * sizeof(WCHAR)), ItemULongLong -- 10
}
#typev  platform_cpp572 13 "%0Log directory path is too long (%10!I64u!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
logPathCch, ItemULongLong -- 10
}
#typev  platform_cpp559 12 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp2090 24 "%0Create dump file %10!s! failed with error %11!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcess
{
m_ProcessInfo.FullDumpFileName, ItemWString -- 10
GetLastError(), ItemLong -- 11
}
#typev  platform_cpp3166 30 "%0WUDF Host Problem %10!s! (pid %11!#x!) detected by %12!s! - exit code is %13!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::ReportHostProblem
{
Problem->ProblemCode, ItemEnum(WudfOperationType) -- 10
GetProcessId(HostProcess), ItemLong -- 11
Problem->Detector, ItemEnum(WdfComponentType) -- 12
Problem->ExitCode, ItemLong -- 13
}
#typev  platform_cpp3409 33 "%0Canonicalization: Path %10!s! ends with trailing . or space." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3425 34 "%0Canonicalization: Path %10!s! does not start with [a-z]:\." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3554 41 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3541 40 "%0Canonicalization: Error allocating %10!Iu! characters for long path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
longPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3521 39 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3500 38 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3487 37 "%0Canonicalization: Error allocating %10!Iu! characters for path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3467 36 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3447 35 "%0Canonicalization: Found invalid character %10!hd! at position %11!Iu! in path %12!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path[invalidCharacterIndex], ItemShort -- 10
invalidCharacterIndex, ItemPtr -- 11
Path, ItemWString -- 12
}
#typev  platform_cpp3395 32 "%0Canonicalization: File name is too short." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp3375 31 "%0Canonicalization: File name is an invalid length. (too long or not null terminated - unsafe to print" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp2668 27 "%0WUDF DriverStop %10!s! error %11!#I64x! component %12!s!
	@ %13!s!:
%14!s!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::InnerDriverStop
{
g_pwszErrorTypeNames[Type], ItemWString -- 10
ErrorNumber, ItemLongLongX -- 11
g_pwszComponentNames[Platform->m_ProcessInfo.Component], ItemWString -- 12
Location, ItemWString -- 13
Message ? Message : '', ItemString -- 14
}
#typev  platform_cpp2839 29 "%0Parameter %10!d!: %11!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
parameterNumber, ItemLong -- 10
(PVOID) exception->ExceptionInformation[parameterNumber], ItemPtr -- 11
}
#typev  platform_cpp2823 28 "%0WUDF Unhandled Exception %10!#x! @ %11!p!. %12!d! parameters" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
exception->ExceptionCode, ItemLong -- 10
exception->ExceptionAddress, ItemPtr -- 11
exception->NumberParameters, ItemLong -- 12
}
#enumv WudfOperationType
{
WudfOperation_Invalid,0x0
WudfOperation_Init,0x1
WudfOperation_HostShutdown,0x2
WudfOperation_Pnp,0x3
WudfOperation_Cleanup,0x4
WudfOperation_Close,0x5
WudfOperation_Cancel,0x6
WudfOperation_IO,0x7
WudfOperation_Other,0x8
WudfOperation_Max,0x9
}
#enumv WdfComponentType
{
WdfComponentInvalid,0x0
WdfComponentPlatform,0x1
WdfComponentReflector,0x2
WdfComponentDriverManager,0x3
WdfComponentHost,0x4
WdfComponentFramework,0x5
WdfComponentTest,0x6
WdfComponentMax,0x7
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
df2126ed-5040-975a-0500-18405e37aecb lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp297 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp271 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp846 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp419 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp470 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp444 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp403 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp742 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp756 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp728 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp673 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp535 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp626 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp615 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp596 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp225 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp205 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp111 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp96 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp83 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp63 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp23 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:66 (UTC) [tracepdb]
f5aa8cc4-9eee-0bfa-38fb-1cf1dd99b18d lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp84 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp65 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp35 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp19 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp198 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp180 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp153 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
028ac712-a759-9e99-8b7b-520b2442d816 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp261 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp249 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp458 30 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp445 29 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp431 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp377 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp334 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp676 41 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp837 46 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp810 45 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp791 44 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp703 42 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp964 52 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp920 50 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp943 51 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp886 48 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp870 47 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1037 57 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 55 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1023 56 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp985 54 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp978 53 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1062 59 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1051 58 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1091 61 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1073 60 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
#typev  lpcmsg_cpp1132 63 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1103 62 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp647 40 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp527 32 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp546 34 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp621 39 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp609 38 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp595 37 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp572 36 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp553 35 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp534 33 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp515 31 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
05f62194-68aa-ead2-d555-7c22c0a5838e WUDFPlatform // SRC=EventLogProvider.cpp MJ= MN=
#typev  EventLogProvider_cpp113 10 "%0Error allocating new CEventLogProvider object for %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_LOG FUNC=CEventLogProvider::Create
{
ProviderGuid, ItemGuid -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
44c8bbd1-3219-e984-b943-3e91f2d3d76c WUDFPlatform // SRC=host.cpp MJ= MN=
#typev  host_cpp471 14 "%0No kernel-mode debugger found." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp422 11 "%0User-mode debugger found - breaking in." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp459 13 "%0Breaking into kernel debugger." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp444 12 "%0No user-mode debugger found." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp411 10 "%0Waiting %10!d! seconds for debugger to attach." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
TimeoutSeconds, ItemLong -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
45d88299-86b1-28d9-9de7-58394d4976c2 WUDFPlatform // SRC=PlatformStackTracker.cpp MJ= MN=
#typev  PlatformStackTracker_cpp191 11 "%0Failed to reload symbols for object tracking - %10!s!.  Stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::ReloadSymbols
{
hr, ItemHRESULT -- 10
}
#typev  PlatformStackTracker_cpp141 10 "%0Failed to initialize symbols, error %10!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadSymbols
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
472e856c-4fa2-0621-c0ff-08a7a7738a2e lpc // SRC=lpcinterface2.cpp MJ= MN=
#typev  lpcinterface2_cpp103 11 "%0%!FUNC!: unable to create lpc object directory %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpcInterface::WdfCreateHostProcessLpcObjectDirectory
{
nameString.Buffer, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcinterface2_cpp88 10 "%0%!FUNC!: %10!s! port directory created" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpcInterface::WdfCreateHostProcessLpcObjectDirectory
{
nameString.Buffer, ItemWString -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
6597c489-c68a-a64b-657f-76816afd8eb4 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp117 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp103 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp90 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp77 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp55 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp47 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp21 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
#typev  lpcport_cpp132 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp123 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp295 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp177 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp212 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp263 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp274 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp233 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp285 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp163 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
6af7a82d-966a-d60c-af1e-f5af6d17191b lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp755 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp718 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp739 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp727 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp707 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp702 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp832 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp776 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp818 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp806 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp797 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp785 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp769 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp355 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp387 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp363 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp322 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp267 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp258 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp247 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp238 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp211 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp201 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp157 10 "%0 Entering %!FUNC!(%10!d!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
LoopBackPortPrefix, ItemWString -- 12
}
#typev  lpc_cpp513 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp435 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp413 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp395 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp587 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_ADD_DEVICE,0x3
WudfMsg_CREATE,0x4
WudfMsg_CLOSE,0x5
WudfMsg_CLEANUP,0x6
WudfMsg_READ,0x7
WudfMsg_WRITE,0x8
WudfMsg_IOCONTROL,0x9
WudfMsg_Cancel,0xA
WudfMsg_DEVICE_POWER_DOWN_COMPLETE,0xB
WudfMsg_FramworkMax,0xC
WudfMsg_ExitProcess,0xD
WdfProcMgmt_Message_Reserved,0xE
WdfProcMgmt_Message_ControlObjectName,0xF
WdfProcMgmt_Message_QueryProcess,0x10
WdfProcMgmt_Message_OpenProcess,0x11
WdfProcMgmt_Message_CloseProcess,0x12
WudfMsg_Connect,0x13
WudfMsg_Max,0x14
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
8b6af58f-6b5c-0c7c-ecf0-2a259db58e55 WUDFPlatform // SRC=WerReport.cpp MJ= MN=
#typev  WerReport_cpp546 10 "%0%!FUNC!: Error %10!s! adding dump to report." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::AddDump
{
hr, ItemHRESULT -- 10
}
#typev  WerReport_cpp599 11 "%0%!FUNC!: Error %10!s! generating dump for report." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::GenerateAndAddDump
{
hr, ItemHRESULT -- 10
}
#typev  WerReport_cpp650 13 "%0%!FUNC!: Result of submitting incident report is %10!d!." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::Submit
{
result, ItemLong -- 10
}
#typev  WerReport_cpp643 12 "%0%!FUNC!: Error %10!s! submitting report." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::Submit
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
ad2438f4-42f0-4ddd-67b1-b24ddd9c179c WUDFPlatform // SRC=TraceSession.cpp MJ= MN=
#typev  TraceSession_cpp405 17 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLAGS, ItemWString -- 10
logFlags, ItemLong -- 11
}
#typev  TraceSession_cpp390 16 "%0%10!s! has invalid value %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp383 15 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp364 14 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLUSH_PERIOD_SECONDS, ItemWString -- 10
flushPeriod, ItemLong -- 11
}
#typev  TraceSession_cpp346 13 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_KD, ItemWString -- 10
logKd, ItemLong -- 11
}
#typev  TraceSession_cpp328 12 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_START_NEW_SESSION, ItemWString -- 10
logStartNewSession, ItemLong -- 11
}
#typev  TraceSession_cpp307 11 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_ENABLE, ItemWString -- 10
logEnable, ItemLong -- 11
}
#typev  TraceSession_cpp287 10 "%0Error opening configuration registry key %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
RegistryBase, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  TraceSession_cpp602 18 "%0Caller requested private logger but set no default GUIDs" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_TRACING FUNC=CTraceSession::Start
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
b33db5bc-1a48-d7c1-da97-000eabef9793 WUDFPlatform // SRC=platform_lh.cpp MJ= MN=
#typev  platform_lh_cpp80 12 "%0%!FUNC!: unable to get service sid size %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=CPlatform::AllocateServiceSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  platform_lh_cpp66 11 "%0%!FUNC!: unable to allocate allocate sid buffer of %10!u! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=CPlatform::AllocateServiceSid
{
serviceSidSize, ItemLong -- 10
}
#typev  platform_lh_cpp56 10 "%0%!FUNC!: unable to get service sid size %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=CPlatform::AllocateServiceSid
{
ntStatus, ItemNTSTATUS -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
c4571f6b-44c6-e672-69e4-565970fd6d88 WUDFPlatform // SRC=platform.cpp MJ= MN=
#typev  platform_cpp1470 21 "%0unable to get userSid" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1452 20 "%0unable to get domainName buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1445 19 "%0unable to get userSid buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1414 18 "%0username: %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
userName, ItemWString -- 10
}
#typev  platform_cpp1407 17 "%0unable to get username" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1395 16 "%0unable to get username buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1558 23 "%0Error reading registry value %10!s!.  er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  platform_cpp1530 22 "%0Registry value %10!s! was expected to be a REG_DWORD." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
}
#typev  platform_cpp2223 26 "%0MiniDumpWriteDump succeeded" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
}
#typev  platform_cpp2210 25 "%0MiniDumpWriteDump failed with error %10!x!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
result, ItemLong -- 10
}
#typev  platform_cpp370 11 "%0Error %10!s! trying to open root registry key %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
result, ItemWINERROR -- 10
WDF_ROOT_KEY, ItemWString -- 11
}
#typev  platform_cpp358 10 "%0Minidump flags set to %10!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
g_MiniDumpType, ItemLong -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
#typev  platform_cpp596 15 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp584 14 "%0Failed to allocate %10!I64u! bytes for directory path string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
(logPathCch * sizeof(WCHAR)), ItemULongLong -- 10
}
#typev  platform_cpp572 13 "%0Log directory path is too long (%10!I64u!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
logPathCch, ItemULongLong -- 10
}
#typev  platform_cpp559 12 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp2090 24 "%0Create dump file %10!s! failed with error %11!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcess
{
m_ProcessInfo.FullDumpFileName, ItemWString -- 10
GetLastError(), ItemLong -- 11
}
#typev  platform_cpp3166 30 "%0WUDF Host Problem %10!s! (pid %11!#x!) detected by %12!s! - exit code is %13!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::ReportHostProblem
{
Problem->ProblemCode, ItemEnum(WudfOperationType) -- 10
GetProcessId(HostProcess), ItemLong -- 11
Problem->Detector, ItemEnum(WdfComponentType) -- 12
Problem->ExitCode, ItemLong -- 13
}
#typev  platform_cpp3409 33 "%0Canonicalization: Path %10!s! ends with trailing . or space." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3425 34 "%0Canonicalization: Path %10!s! does not start with [a-z]:\." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3554 41 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3541 40 "%0Canonicalization: Error allocating %10!Iu! characters for long path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
longPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3521 39 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3500 38 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3487 37 "%0Canonicalization: Error allocating %10!Iu! characters for path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3467 36 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3447 35 "%0Canonicalization: Found invalid character %10!hd! at position %11!Iu! in path %12!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path[invalidCharacterIndex], ItemShort -- 10
invalidCharacterIndex, ItemPtr -- 11
Path, ItemWString -- 12
}
#typev  platform_cpp3395 32 "%0Canonicalization: File name is too short." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp3375 31 "%0Canonicalization: File name is an invalid length. (too long or not null terminated - unsafe to print" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp2668 27 "%0WUDF DriverStop %10!s! error %11!#I64x! component %12!s!
	@ %13!s!:
%14!s!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::InnerDriverStop
{
g_pwszErrorTypeNames[Type], ItemWString -- 10
ErrorNumber, ItemLongLongX -- 11
g_pwszComponentNames[Platform->m_ProcessInfo.Component], ItemWString -- 12
Location, ItemWString -- 13
Message ? Message : '', ItemString -- 14
}
#typev  platform_cpp2839 29 "%0Parameter %10!d!: %11!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
parameterNumber, ItemLong -- 10
(PVOID) exception->ExceptionInformation[parameterNumber], ItemPtr -- 11
}
#typev  platform_cpp2823 28 "%0WUDF Unhandled Exception %10!#x! @ %11!p!. %12!d! parameters" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
exception->ExceptionCode, ItemLong -- 10
exception->ExceptionAddress, ItemPtr -- 11
exception->NumberParameters, ItemLong -- 12
}
#enumv WudfOperationType
{
WudfOperation_Invalid,0x0
WudfOperation_Init,0x1
WudfOperation_HostShutdown,0x2
WudfOperation_Pnp,0x3
WudfOperation_Cleanup,0x4
WudfOperation_Close,0x5
WudfOperation_Cancel,0x6
WudfOperation_IO,0x7
WudfOperation_Other,0x8
WudfOperation_Max,0x9
}
#enumv WdfComponentType
{
WdfComponentInvalid,0x0
WdfComponentPlatform,0x1
WdfComponentReflector,0x2
WdfComponentDriverManager,0x3
WdfComponentHost,0x4
WdfComponentFramework,0x5
WdfComponentTest,0x6
WdfComponentMax,0x7
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
cede42c9-4540-25bd-6b5d-02da36b083d3 lpc // SRC=lpc_lh.cpp MJ= MN=
#typev  lpc_lh_cpp33 10 "%0%!FUNC!: unable to get allocate io completion port" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpcInit
{
}
#typev  lpc_lh_cpp103 11 "%0unable to assoicate connport 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::ListenInit
{
ConnPort, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp150 12 "%0unable to assoicate CommPort 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::ConnectInit
{
CommPort, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp205 14 "%0%!FUNC!: unable to init shutdown message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfWorkerThread::WdfWorkerThread
{
}
#typev  lpc_lh_cpp196 13 "%0%!FUNC!: unable to allocate memory for shutdown message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfWorkerThread::WdfWorkerThread
{
}
#typev  lpc_lh_cpp302 15 "%0fired %10!u! shutdown messages" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ShutdownAllWorkerThreads
{
numberShutdownMessageFired, ItemLong -- 10
}
#typev  lpc_lh_cpp384 17 "%0%!FUNC!: terminating..." //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_WORKER FUNC=WdfLpc::WorkerThread
{
}
#typev  lpc_lh_cpp431 18 "%0%!FUNC!: receiveMessage 0x%10!p! (0x%11!x!) not processed" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_WORKER FUNC=WdfLpc::WorkerThread
{
message, ItemPtr -- 10
ALPC_GET_MESSAGE_TYPE(message), ItemLong -- 11
}
#typev  lpc_lh_cpp374 16 "%0message received on invalid LPC port handle 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_WORKER FUNC=WdfLpc::WorkerThread
{
portHandle, ItemPtr -- 10
}
#typev  lpc_lh_cpp613 25 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::CreateLoopback
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_lh_cpp595 24 "%0unable to assoicate commport 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackClient, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp578 23 "%0unable to assoicate connport 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackServer, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp542 22 "%0loopback Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackClient->GetName(), ItemWString -- 10
}
#typev  lpc_lh_cpp525 21 "%0loopback server port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackServer->GetName(), ItemWString -- 10
}
#typev  lpc_lh_cpp506 20 "%0unable to get my sid" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
}
#typev  lpc_lh_cpp466 19 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::CreateLoopback
{
LoopBackPortPrefix, ItemWString -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
df2126ed-5040-975a-0500-18405e37aecb lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp297 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp271 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp846 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp419 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp470 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp444 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp403 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp756 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp742 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp728 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp673 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp535 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp626 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp615 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp596 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp225 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp205 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp111 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp96 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp83 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp63 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp23 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
ede4bcd5-c8d7-9f3e-b1a0-5e313e778548 LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp226 10 "%0unable to connect to %10!s!. %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Connect
{
ServerPortName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:82 (UTC) [tracepdb]
f5aa8cc4-9eee-0bfa-38fb-1cf1dd99b18d lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp84 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp65 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp35 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp19 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp198 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp180 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp153 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
028ac712-a759-9e99-8b7b-520b2442d816 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp261 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp249 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp458 30 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp445 29 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp431 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp377 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp334 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp676 41 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp837 46 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp810 45 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp791 44 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp703 42 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp964 52 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp920 50 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp943 51 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp886 48 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp870 47 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1037 57 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 55 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1023 56 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp985 54 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp978 53 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1062 59 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1051 58 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1091 61 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1073 60 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
#typev  lpcmsg_cpp1132 63 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1103 62 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp647 40 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp527 32 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp546 34 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp621 39 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp609 38 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp595 37 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp572 36 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp553 35 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp534 33 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp515 31 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
05fb7e18-f163-ec7a-a2e3-6d07b28a3f98 LpcCore // SRC=control.cpp MJ= MN=
#typev  control_cpp225 15 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp210 14 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp180 12 "%0%!FUNC!: unable to allocate sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
}
#typev  control_cpp193 13 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
}
#typev  control_cpp647 23 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp615 22 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp572 21 "%0control object ioctl sent from unexpected pid 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
PsGetCurrentProcessId(), ItemPtr -- 10
}
#typev  control_cpp1599 32 "%0unable to get driver manager sid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
}
#typev  control_cpp1588 31 "%0unable to GetTokenInformation %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1572 30 "%0unable to allocate %10!u! bytes for user token info" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
returnLength, ItemLong -- 10
}
#typev  control_cpp1561 29 "%0NtQueryInformationToken did not fail with STATUS_BUFFER_TOO_SMALL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1543 28 "%0unable to open process token %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1526 27 "%0unable to open process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp80 11 "%0Unable to init LpcControlDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::s_CreateInstance
{
}
#typev  control_cpp72 10 "%0Unable to allocate Lpc Control Device object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::s_CreateInstance
{
}
#typev  control_cpp403 20 "%0unable to allocate listening device %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp386 19 "%0process has no permission to create listen object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
}
#typev  control_cpp359 18 "%0create listening object not allowed until driver manager is loaded %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp343 17 "%0calling process is not driver manager process" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
}
#typev  control_cpp309 16 "%0opening control device not allowed from user mode %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp971 26 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=LpcControlDevice::DeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp818 25 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=LpcControlDevice::DeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp727 24 "%0control object ioctl sent from unexpected pid 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::DeviceIoControl
{
PsGetCurrentProcessId(), ItemPtr -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
3dc35813-9134-c578-842d-9da79385fd97 LpcCore // SRC=listen.cpp MJ= MN=
#typev  listen_cpp233 16 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  listen_cpp218 15 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  listen_cpp188 13 "%0%!FUNC!: unable to allocate sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
}
#typev  listen_cpp201 14 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
}
#typev  listen_cpp84 12 "%0Unable to init LpcListenDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
}
#typev  listen_cpp76 11 "%0Unable to allocate Lpc listen Device object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
}
#typev  listen_cpp63 10 "%0creating listen device %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
ListenDeviceName, ItemWString -- 10
}
#typev  listen_cpp475 18 "%0connection not accepted" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::Create
{
}
#typev  listen_cpp431 17 "%0LpcListenDevice 0x%10!p! not ready for accepting connection" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::Create
{
this, ItemPtr -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
543ccf5a-bd78-d91f-f49c-dbee2fd8edf1 lpc // SRC=lpc_xp.cpp MJ= MN=
#typev  lpc_xp_cpp219 10 "%0lpcport got a message!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WorkerThread
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
6597c489-c68a-a64b-657f-76816afd8eb4 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp132 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp123 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp295 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp177 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp212 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp263 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp274 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp233 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp285 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp163 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcport_cpp117 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp103 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp90 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp77 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp55 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp47 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp21 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
6af7a82d-966a-d60c-af1e-f5af6d17191b lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp755 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp718 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp739 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp727 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp707 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp702 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp832 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp776 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp818 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp806 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp797 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp785 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp769 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp513 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp435 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp413 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp395 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp587 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
#typev  lpc_cpp355 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp387 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp363 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp322 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp267 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp258 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp247 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp238 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp211 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp201 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp157 10 "%0 Entering %!FUNC!(%10!d!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
LoopBackPortPrefix, ItemWString -- 12
}
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_ADD_DEVICE,0x3
WudfMsg_CREATE,0x4
WudfMsg_CLOSE,0x5
WudfMsg_CLEANUP,0x6
WudfMsg_READ,0x7
WudfMsg_WRITE,0x8
WudfMsg_IOCONTROL,0x9
WudfMsg_Cancel,0xA
WudfMsg_DEVICE_POWER_DOWN_COMPLETE,0xB
WudfMsg_FramworkMax,0xC
WudfMsg_ExitProcess,0xD
WdfProcMgmt_Message_Reserved,0xE
WdfProcMgmt_Message_ControlObjectName,0xF
WdfProcMgmt_Message_QueryProcess,0x10
WdfProcMgmt_Message_OpenProcess,0x11
WdfProcMgmt_Message_CloseProcess,0x12
WudfMsg_Connect,0x13
WudfMsg_Max,0x14
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
bcb64868-11d7-c79e-860e-320318da2f39 LpcCore // SRC=device.cpp MJ= MN=
#typev  device_cpp395 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::~LpcDevice
{
}
#typev  device_cpp377 26 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::~LpcDevice
{
}
#typev  device_cpp409 29 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::s_WdmDeviceObject2LpcDevice
{
deviceExtension->LpcDevice, ItemPtr -- 10
}
#typev  device_cpp405 28 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::s_WdmDeviceObject2LpcDevice
{
DeviceObject, ItemPtr -- 10
}
#typev  device_cpp913 41 "%0output buffer too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::ValidateDeviceIoControlBufferSizes
{
}
#typev  device_cpp902 40 "%0input buffer too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::ValidateDeviceIoControlBufferSizes
{
}
#typev  device_cpp361 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp128 13 "%0%!FUNC!: unsupported device type %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
DeviceType, ItemLong -- 10
}
#typev  device_cpp313 24 "%0%!FUNC!: unable to create symbolic link %10!s! for %11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
m_DosDeviceName.Buffer, ItemWString -- 10
ntDeviceNameUnicode.Buffer, ItemWString -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  device_cpp296 23 "%0%!FUNC!: unable to build dos device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp282 22 "%0%!FUNC!: unable to allocate memory for dos device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp272 21 "%0%!FUNC!: dos device name length >= MAXUSHORT." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp245 20 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp231 19 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp214 18 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp198 17 "%0%!FUNC!: unable to create device object. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp173 16 "%0%!FUNC!: unable to build nt device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp159 15 "%0%!FUNC!: unable to allocate memory for nt device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp146 14 "%0%!FUNC!: invalid device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp90 12 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!s!, %13!d!, %14!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::LpcDevice
{
LpcDriver, ItemPtr -- 10
LpcDeviceName, ItemWString -- 11
WdmDeviceName, ItemWString -- 12
DeviceType, ItemLong -- 13
Parent, ItemPtr -- 14
}
#typev  device_cpp462 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::ProcessIrp
{
status, ItemNTSTATUS -- 10
}
#typev  device_cpp427 30 "%0 Entering %!FUNC!(%10!p! (%11!d!))" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::ProcessIrp
{
Irp, ItemPtr -- 10
majorFunc, ItemLong -- 11
}
#typev  device_cpp773 39 "%0%!FUNC!: invalid user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp736 38 "%0%!FUNC!: invalid user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp689 37 "%0%!FUNC!: invalid output user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp676 36 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp661 35 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp610 34 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp565 33 "%0%!FUNC!: invalid output user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp552 32 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
c7b72a01-b61c-3d0a-bef0-64acae9ec2a9 LpcCore // SRC=driver.cpp MJ= MN=
#typev  driver_cpp126 15 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Unload
{
}
#typev  driver_cpp113 14 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Unload
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp230 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Dispatch
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp206 18 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Dispatch
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  driver_cpp294 21 "%0 Exiting  %!FUNC! => (fastio completed:%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_FastIoDeviceDispatch
{
requestCompleted, ItemLong -- 10
}
#typev  driver_cpp266 20 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_FastIoDeviceDispatch
{
DeviceObject, ItemPtr -- 10
FileObject, ItemPtr -- 11
}
#typev  driver_cpp355 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::~LpcDriver
{
}
#typev  driver_cpp352 24 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::~LpcDriver
{
}
#typev  driver_cpp346 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::LpcDriver
{
NT_SUCCESS(ntStatus), ItemListLong(false,true) -- 10
}
#typev  driver_cpp307 22 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::LpcDriver
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp157 17 "%0Unable to init LpcDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriver::s_CreateInstance
{
}
#typev  driver_cpp148 16 "%0Unable to allocate LpcDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriver::s_CreateInstance
{
}
#typev  driver_cpp101 13 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriverEntry
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp73 12 "%0Unable to allocate driver object extension" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriverEntry
{
}
#typev  driver_cpp60 11 "%0WUDF LPC Driver is loading" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriverEntry
{
}
#typev  driver_cpp58 10 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriverEntry
{
DriverObject, ItemPtr -- 10
RegistryPath, ItemPWString -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
d331aa10-2787-9748-f3ba-ec26a4befbd3 LpcCore // SRC=communication.cpp MJ= MN=
#typev  communication_cpp2266 18 "%0Unable to find reserved message 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::FindAndRemoveMessage
{
MessageId, ItemLong -- 10
}
#typev  communication_cpp201 12 "%0Unable to init lpcCommContext object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::MessageQueues
{
}
#typev  communication_cpp145 11 "%0Unable to init messageQueues object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::s_CreateInstance
{
}
#typev  communication_cpp137 10 "%0Unable to allocate messageQueues object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::s_CreateInstance
{
}
#typev  communication_cpp371 15 "%0%!FUNC!: unable to get allocate se client object list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::LpcCommContext
{
}
#typev  communication_cpp2185 17 "%0unable to retrieve sync message reply" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::SendMessageSync
{
}
#typev  communication_cpp2139 16 "%0Unable to send sync message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::SendMessageSync
{
}
#typev  communication_cpp290 14 "%0Unable to init lpcCommContext object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::s_CreateInstance
{
}
#typev  communication_cpp282 13 "%0Unable to allocate lpc communication object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::s_CreateInstance
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
df2126ed-5040-975a-0500-18405e37aecb lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp297 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp271 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp846 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp419 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp470 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp444 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp403 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp742 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp756 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp728 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp673 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp535 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp626 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp615 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp596 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp225 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp205 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp111 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp96 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp83 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp63 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp23 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
ef9a3964-9fb2-b160-dcc2-372b57031e2d LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp224 14 "%0IOCTL_LPC_QUERY_INTERFACE failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp200 13 "%0unable to create IOCTL_LPC_QUERY_INTERFACE irp %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp171 12 "%0unable to connect to %10!s!. %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ServerPortName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccore_cpp134 11 "%0unable to allocate server port full name buffer %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
serverPortFullNameLen * sizeof(serverPortFullName[0]), ItemLong -- 10
}
#typev  lpccore_cpp124 10 "%0ServerPortName with prefix is longer than maximum UNICODE_STRING length" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:678 (UTC) [tracepdb]
f5aa8cc4-9eee-0bfa-38fb-1cf1dd99b18d lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp84 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp65 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp35 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp19 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp198 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp180 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp153 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:85 (UTC) [tracepdb]
028ac712-a759-9e99-8b7b-520b2442d816 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp261 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp249 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp458 30 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp445 29 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp431 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp377 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp334 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp676 41 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp837 46 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp810 45 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp791 44 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp703 42 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp964 52 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp920 50 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp943 51 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp886 48 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp870 47 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1037 57 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 55 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1023 56 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp985 54 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp978 53 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1062 59 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1051 58 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1091 61 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1073 60 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
#typev  lpcmsg_cpp1132 63 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1103 62 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp647 40 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp527 32 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp546 34 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp621 39 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp609 38 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp595 37 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp572 36 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp553 35 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp534 33 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp515 31 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:85 (UTC) [tracepdb]
6597c489-c68a-a64b-657f-76816afd8eb4 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp132 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp123 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp295 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp177 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp212 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp263 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp274 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp233 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp285 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp163 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcport_cpp117 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp103 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp90 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp77 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp55 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp47 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp21 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:85 (UTC) [tracepdb]
6af7a82d-966a-d60c-af1e-f5af6d17191b lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp755 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp718 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp739 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp727 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp707 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp702 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp832 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp776 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp818 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp806 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp797 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp785 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp769 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp513 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp435 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp413 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp395 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp587 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
#typev  lpc_cpp355 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp387 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp363 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp322 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp267 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp258 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp247 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp238 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp211 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp201 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp157 10 "%0 Entering %!FUNC!(%10!d!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
LoopBackPortPrefix, ItemWString -- 12
}
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_ADD_DEVICE,0x3
WudfMsg_CREATE,0x4
WudfMsg_CLOSE,0x5
WudfMsg_CLEANUP,0x6
WudfMsg_READ,0x7
WudfMsg_WRITE,0x8
WudfMsg_IOCONTROL,0x9
WudfMsg_Cancel,0xA
WudfMsg_DEVICE_POWER_DOWN_COMPLETE,0xB
WudfMsg_FramworkMax,0xC
WudfMsg_ExitProcess,0xD
WdfProcMgmt_Message_Reserved,0xE
WdfProcMgmt_Message_ControlObjectName,0xF
WdfProcMgmt_Message_QueryProcess,0x10
WdfProcMgmt_Message_OpenProcess,0x11
WdfProcMgmt_Message_CloseProcess,0x12
WudfMsg_Connect,0x13
WudfMsg_Max,0x14
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:85 (UTC) [tracepdb]
cede42c9-4540-25bd-6b5d-02da36b083d3 lpc // SRC=lpc_lh.cpp MJ= MN=
#typev  lpc_lh_cpp33 10 "%0%!FUNC!: unable to get allocate io completion port" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpcInit
{
}
#typev  lpc_lh_cpp103 11 "%0unable to assoicate connport 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::ListenInit
{
ConnPort, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp150 12 "%0unable to assoicate CommPort 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::ConnectInit
{
CommPort, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp205 14 "%0%!FUNC!: unable to init shutdown message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfWorkerThread::WdfWorkerThread
{
}
#typev  lpc_lh_cpp196 13 "%0%!FUNC!: unable to allocate memory for shutdown message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfWorkerThread::WdfWorkerThread
{
}
#typev  lpc_lh_cpp302 15 "%0fired %10!u! shutdown messages" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ShutdownAllWorkerThreads
{
numberShutdownMessageFired, ItemLong -- 10
}
#typev  lpc_lh_cpp384 17 "%0%!FUNC!: terminating..." //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_WORKER FUNC=WdfLpc::WorkerThread
{
}
#typev  lpc_lh_cpp431 18 "%0%!FUNC!: receiveMessage 0x%10!p! (0x%11!x!) not processed" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_WORKER FUNC=WdfLpc::WorkerThread
{
message, ItemPtr -- 10
ALPC_GET_MESSAGE_TYPE(message), ItemLong -- 11
}
#typev  lpc_lh_cpp374 16 "%0message received on invalid LPC port handle 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_WORKER FUNC=WdfLpc::WorkerThread
{
portHandle, ItemPtr -- 10
}
#typev  lpc_lh_cpp613 25 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::CreateLoopback
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_lh_cpp595 24 "%0unable to assoicate commport 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackClient, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp578 23 "%0unable to assoicate connport 0x%10!p! with a completion port %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackServer, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpc_lh_cpp542 22 "%0loopback Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackClient->GetName(), ItemWString -- 10
}
#typev  lpc_lh_cpp525 21 "%0loopback server port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::CreateLoopback
{
m_LoopBackServer->GetName(), ItemWString -- 10
}
#typev  lpc_lh_cpp466 19 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::CreateLoopback
{
LoopBackPortPrefix, ItemWString -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:85 (UTC) [tracepdb]
df2126ed-5040-975a-0500-18405e37aecb lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp297 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp271 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp846 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp419 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp470 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp444 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp403 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp756 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp742 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp728 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp673 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp535 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp626 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp615 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp596 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp225 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp205 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp111 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp96 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp83 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp63 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp23 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:85 (UTC) [tracepdb]
ede4bcd5-c8d7-9f3e-b1a0-5e313e778548 LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp226 10 "%0unable to connect to %10!s!. %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Connect
{
ServerPortName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2008-1-19:5:52:50:85 (UTC) [tracepdb]
f5aa8cc4-9eee-0bfa-38fb-1cf1dd99b18d lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp84 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp65 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp35 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp19 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp198 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp180 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp153 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
072653f1-0c10-42af-5191-ae89cc876071 WUDFx // SRC=WdfDevice.cpp MJ= MN=
#typev  WdfDevice_cpp645 14 "%0%!FUNC!: No default queue for this device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::GetDefaultIoQueue
{
}
#typev  WdfDevice_cpp1099 24 "%0%!FUNC!: Error hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AssignDeviceInterfaceState
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1482 29 "%0%!FUNC!: PostEvent failure - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::PostEvent
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1471 28 "%0%!FUNC!: Invalid event type, %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::PostEvent
{
WdfEventType, ItemLong -- 10
}
#typev  WdfDevice_cpp1863 35 "%0%!FUNC!: Driver attempting to delete a device object (0x%10!p!) owned by WDF" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::DeleteWdfObject
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp2422 52 "%0%!FUNC!: Could not QI 0x%10!p! for file object. Internal error %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::CloseFile
{
pFxContext, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfDevice_cpp3101 70 "%0%!FUNC!: Acquiring the presentation lock for device (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp3093 69 "%0%!FUNC!: Invalid operation. The device (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp3125 72 "%0%!FUNC!: Releasing the presentation lock for device (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp3118 71 "%0%!FUNC!: Invalid operation. The device (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp250 12 "%0Can't Create or Delete a WDFQUEUE in the middle of a power operation" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfDevice::RemoveQueueReferences
{
}
#typev  WdfDevice_cpp241 11 "%0Can't delete default queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfDevice::RemoveQueueReferences
{
pQueue, ItemPtr -- 10
}
#typev  WdfDevice_cpp464 13 "%0%!FUNC!: The device is an invalid state, probably in deletion" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::GetDriver
{
}
#typev  WdfDevice_cpp885 23 "%0%!FUNC!: Error hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateDeviceInterface
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp869 22 "%0%!FUNC!: Error allocating device interface object - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateDeviceInterface
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1432 27 "%0%!FUNC!: The device is an invalid state, probably in deletion" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::RetrieveDevicePropertyStore
{
}
#typev  WdfDevice_cpp1422 26 "%0%!FUNC!: The device is an invalid state, probably in deletion" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::RetrieveDevicePropertyStore
{
}
#typev  WdfDevice_cpp1412 25 "%0%!FUNC!: NULL is an invalid paramater" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::RetrieveDevicePropertyStore
{
}
#typev  WdfDevice_cpp1728 34 "%0%!FUNC!:Unable to copy kernel device name hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1715 33 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for device key path" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
}
#typev  WdfDevice_cpp1693 32 "%0%!FUNC!:Registry key open failed for the PDO key, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfDevice_cpp1674 31 "%0%!FUNC!:Unable to copy kernel device name hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1661 30 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for kernel device name" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
}
#typev  WdfDevice_cpp1939 36 "%0%!FUNC!: Invalid request type,%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::DispatchRequest
{
requestType, ItemLong -- 10
}
#typev  WdfDevice_cpp1962 37 "%0%!FUNC!: Invalid operation. The device queues are not configured" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::DispatchRequest
{
}
#typev  WdfDevice_cpp2315 51 "%0%!FUNC!: Could not QI 0x%10!p! for file object. Internal error %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::CleanupFile
{
pFxContext, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfDevice_cpp2486 55 "%0%!FUNC!: Could not commit request object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::ReadFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2460 54 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::ReadFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2444 53 "%0%!FUNC!: Read message, IWudfIoIrp:0x%10!p!, Context:0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::ReadFile
{
pReadIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp2557 58 "%0%!FUNC!: Could not commit request object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::WriteFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2531 57 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::WriteFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2515 56 "%0%!FUNC!: Write message, IWudfIoIrp 0x%10!p!, Context 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::WriteFile
{
pWriteIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp2625 61 "%0%!FUNC!: Could not commit request object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::DeviceControl
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2599 60 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::DeviceControl
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2583 59 "%0%!FUNC!: DeviceControl message, IWudfIoIrp 0x%10!p!, Context: 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::DeviceControl
{
pDevCntrlIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp2731 67 "%0The queue parameter (0x%10!p!) passed to ConfigureRequestDispatching doesn't match the queue (0x%11!p!) previously registered with the framwork" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
pQueueObj, ItemPtr -- 10
m_DispatchTable[RequestType], ItemPtr -- 11
}
#typev  WdfDevice_cpp2718 66 "%0The device is NOT configured for this request type (0x%10!d!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
RequestType, ItemLong -- 10
}
#typev  WdfDevice_cpp2695 65 "%0The device is already configured for this request type (0x%10!d!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
RequestType, ItemLong -- 10
}
#typev  WdfDevice_cpp2683 64 "%0IWDFIoQueue argument is the default queue. It is not valid to change request dispatching on the default queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
}
#typev  WdfDevice_cpp2671 63 "%0The queue parameter (0x%10!p!) passed to ConfigureRequestDispatching doesn't belong to this device" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
pQueueObj, ItemPtr -- 10
}
#typev  WdfDevice_cpp2656 62 "%0Invalid operation. The driver must either have IQueueCallbackDefaultIoHandler or handler for request type %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
RequestType, ItemLong -- 10
}
#typev  WdfDevice_cpp2985 68 "%0%!FUNC!: Unexpected completion callback.  Minor code = 0x%10!x!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::ProcessPnPCompletion
{
minorFunction, ItemLong -- 10
}
#typev  WdfDevice_cpp170 10 "%0%!FUNC!: Releasing resources in CWdfDevice" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::~CWdfDevice
{
}
#typev  WdfDevice_cpp2160 50 "%0%!FUNC!: UNKNOWN IRP (type (0x%10!x!, 0x%11!x!))" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
majorFunction, ItemLong -- 10
pPnpIrp->GetMinorFunction(), ItemLong -- 11
}
#typev  WdfDevice_cpp2148 49 "%0%!FUNC!: UNSUPPORTED IRP (type (0x%10!x!, 0x%11!x!))" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
majorFunction, ItemLong -- 10
minorFunction, ItemLong -- 11
}
#typev  WdfDevice_cpp2089 45 "%0%!FUNC!: IRP_MN_CANCEL_STOP_DEVICE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2098 46 "%0%!FUNC!: IRP_MN_QUERY_CAPABILITIES" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2107 47 "%0%!FUNC!: IRP_MN_QUERY_PNP_DEVICE_STATE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2063 42 "%0%!FUNC!: IRP_MN_SURPRISE_REMOVAL" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2119 48 "%0%!FUNC!: UNSUPPORTED IRP (type (0x%10!x!, 0x%11!x!))" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
majorFunction, ItemLong -- 10
minorFunction, ItemLong -- 11
}
#typev  WdfDevice_cpp2072 43 "%0%!FUNC!: IRP_MN_QUERY_STOP_DEVICE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2027 38 "%0%!FUNC!: IRP_MN_START_DEVICE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2036 39 "%0%!FUNC!: IRP_MN_QUERY_REMOVE_DEVICE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2054 41 "%0%!FUNC!: IRP_MN_REMOVE_DEVICE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2045 40 "%0%!FUNC!: IRP_MN_CANCEL_REMOVE_DEVICE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
#typev  WdfDevice_cpp2081 44 "%0%!FUNC!: IRP_MN_STOP_DEVICE" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::DispatchPnP
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
#typev  WdfDevice_cpp781 21 "%0%!FUNC!: Failed inserting queue into the object tree %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp746 19 "%0%!FUNC!: Attempting to create a default queue, when one is already present, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp760 20 "%0%!FUNC!: failed creating queue %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp719 18 "%0%!FUNC!: failed creating queue %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp697 17 "%0Can't create Queue in the middle of a power operation" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfDevice::CreateIoQueue
{
}
#typev  WdfDevice_cpp687 16 "%0%!FUNC!: Invalid paramater: The IUnknown* parameter is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
}
#typev  WdfDevice_cpp677 15 "%0%!FUNC!: Invalid paramater: IWDFIoQueue parameter is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
0b125d6a-4f8d-6362-ca0c-3fefddacbc7d WUDFx // SRC=WdfUtilRegPropVariantConv.cpp MJ= MN=
#typev  WdfUtilRegPropVariantConv_cpp952 42 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::NumberToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp564 28 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp552 27 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp537 26 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp524 25 "%0%!FUNC!: Registry value expansion failed for value %10!s!, hr = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
pwszExpandSz, ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfUtilRegPropVariantConv_cpp507 24 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp488 23 "%0%!FUNC!: ppwszValue is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
}
#typev  WdfUtilRegPropVariantConv_cpp478 22 "%0%!FUNC!: cbDataLen is non-zero but pwszExpandSz is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
}
#typev  WdfUtilRegPropVariantConv_cpp895 41 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp880 40 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp868 39 "%0%!FUNC!: SizeTToInt failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1090 48 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1078 47 "%0%!FUNC!: StringCchCopy failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
}
#typev  WdfUtilRegPropVariantConv_cpp1059 46 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1046 45 "%0%!FUNC!: Data length 0x%10!I64x! is longer than MAX_INT" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
cb, ItemLongLongX -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1024 44 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1002 43 "%0%!FUNC!: string array is NULL while count is non-zero: %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
cElems, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp343 19 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp330 18 "%0%!FUNC!: Data length 0x%10!I64x! is longer than MAX_INT" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
cb, ItemLongLongX -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp316 17 "%0%!FUNC!: StringCchLengthA failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp287 16 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp393 20 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp414 21 "%0%!FUNC!: Unsupported variant type %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
propvar.vt, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp646 30 "%0%!FUNC!: OUT args are not non-NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
}
#typev  WdfUtilRegPropVariantConv_cpp752 37 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp740 36 "%0%!FUNC!: Number of elements is too high %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
cElements, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp721 35 "%0%!FUNC!: CWdfDynamicArray<LPWSTR>::Add failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp706 34 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp694 33 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp679 32 "%0%!FUNC!: StringCchLength failed for %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
pwszMultiSz, ItemWString -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp655 31 "%0%!FUNC!: Data is not WCHAR aligned" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
}
#typev  WdfUtilRegPropVariantConv_cpp637 29 "%0%!FUNC!: arg pwszMultiSz is NULL while cbDataLen is %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
cbDataLen, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp136 13 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp121 12 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp107 11 "%0%!FUNC!: StringCchLength failed with hr = %10!s! data in the registy may be missing NULL terminator" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp210 15 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp199 14 "%0%!FUNC!: Unrecognized registry data type %10!d! converting to BLOB" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
dwRegType, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp85 10 "%0%!FUNC!: pValue is NULL while cbDataLen is %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
cbDataLen, ItemLong -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
0d6489d3-a45d-b62c-763f-8c36979bc8db WUDFx // SRC=FxRequestBuffer.h MJ= MN=
#typev  FxRequestBuffer_h241 11 "%0%!FUNC!: BufferOffset or length too big" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=FxRequestBuffer::ValidateMemoryOffsets
{
}
#typev  FxRequestBuffer_h231 10 "%0%!FUNC!: BufferOffset too big" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=FxRequestBuffer::ValidateMemoryOffsets
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
13c3156e-68cf-7142-2ba8-fecbb0c14ea9 WUDFx // SRC=WdfDriverCreatedFile.cpp MJ= MN=
#typev  WdfDriverCreatedFile_cpp97 10 "%0File Allocation failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfDriverCreatedFile::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
150dba21-b721-ebd8-774b-2ae3dee71b7a WUDFx // SRC=WdfDeviceInterface.cpp MJ= MN=
#typev  WdfDeviceInterface_cpp286 11 "%0%!FUNC!: Error %10!s! destroying device interface (%11!s!, %12!s!)." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDeviceInterface::Unregister
{
hr, ItemHRESULT -- 10
&(this->m_InterfaceClassGuid), ItemGuid -- 11
this->m_ReferenceString ? this->m_ReferenceString : L'(null)', ItemWString -- 12
}
#typev  WdfDeviceInterface_cpp142 10 "%0%!FUNC!: Error allocating new device interface object." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDeviceInterface::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
1746138b-d777-6e3e-e7aa-c9a7df9d7807 WUDFx // SRC=WdfUsbInterface.cpp MJ= MN=
#typev  WdfUsbInterface_cpp121 10 "%0Falied to allocate CWdfUsbInterface, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbInterface::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
226be879-113b-8c8a-a57e-b6c491c180a3 WUDFx // SRC=WdfObject.cpp MJ= MN=
#typev  WdfObject_cpp238 10 "%0%!FUNC!: Ref count of Object 0x%10!p!, type=0x%11!x! transitioning from 0 to 1. This is typically caused by incorrect manipulation of object reference count" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfObject::AddRef
{
this, ItemPtr -- 10
m_Type, ItemLong -- 11
}
#typev  WdfObject_cpp291 12 "%0%!FUNC!: Object is not in DeletedAndDisposed state when its refcount dropped to 0.This is OK in the cases where the object was released due to initialization failure, but in other cases, this indicates a premature Release, Object = 0x%10!p!, State = %11!d!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_OBJECT FUNC=CWdfObject::Release
{
this, ItemPtr -- 10
m_State, ItemLong -- 11
}
#typev  WdfObject_cpp281 11 "%0%!FUNC!: Ref count of Object 0x%10!p!, type=0x%11!x! transitioning from 0 to -1. This is typically caused by incorrect manipulation of object reference count" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfObject::Release
{
this, ItemPtr -- 10
m_Type, ItemLong -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
256dcbfc-07b5-e94b-82e6-0d89f3a1361a WUDFx // SRC=WdfRequestQueue.cpp MJ= MN=
#typev  WdfRequestQueue_cpp594 11 "%0Request obj 0x%10!p! on RequestQueue 0x%11!p! cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfRequestQueue::CancelRoutineInternal
{
pRequestObj, ItemPtr -- 10
p, ItemPtr -- 11
}
#typev  WdfRequestQueue_cpp244 10 "%0%!FUNC!:Invalid tag context, 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfRequestQueue::GetNextRequest
{
TagContext, ItemPtr -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
2ef7cfe1-4507-6c5b-57cb-96061f9f5dcd WUDFx // SRC=WdfWin32Target.h MJ= MN=
#typev  WdfWin32Target_h122 10 "%0Falied to allocate CWdfWin32Target, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_WIN32_IOTARGET FUNC=CWdfWin32Target::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
342193e4-3ab1-4a67-90c7-8e99b7767da2 WUDFx // SRC=WdfRegPropertyStore.cpp MJ= MN=
#typev  WdfRegPropertyStore_cpp184 15 "%0%!FUNC!: ppvObject is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::QueryInterface
{
}
#typev  WdfRegPropertyStore_cpp285 17 "%0%!FUNC!: RegQueryInfoKey failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameCount
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp257 16 "%0pdwCount is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameCount
{
}
#typev  WdfRegPropertyStore_cpp403 20 "%0Index %10!d! is out of range" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
iProp, ItemLong -- 10
}
#typev  WdfRegPropertyStore_cpp411 21 "%0RegEnumValue failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp367 19 "%0%!FUNC!: RegQueryInfoKey failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp332 18 "%0ppwszName is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
}
#typev  WdfRegPropertyStore_cpp526 25 "%0RegQueryValueEx failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp505 24 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfRegPropertyStore_cpp476 23 "%0%!FUNC!: pwszName is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp465 22 "%0%!FUNC!: pv is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp591 27 "%0%!FUNC!: pwszName is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::SetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp579 26 "%0%!FUNC!: pv is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::SetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp765 31 "%0%!FUNC!: Unable to open key with access KEY_QUERY_VALUE, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::InitFromRegKey
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp714 30 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfRegPropertyStore::InitFromRegKey
{
}
#typev  WdfRegPropertyStore_cpp695 29 "%0%!FUNC!: Invalid subkey path length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfRegPropertyStore::InitFromRegKey
{
hr, ItemHRESULT -- 10
}
#typev  WdfRegPropertyStore_cpp682 28 "%0%!FUNC!: hKey is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::InitFromRegKey
{
}
#typev  WdfRegPropertyStore_cpp114 12 "%0%!FUNC!: hKey is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreatePropStoreFromRegKey
{
}
#typev  WdfRegPropertyStore_cpp139 14 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreatePropStoreFromRegKey
{
hr, ItemHRESULT -- 10
}
#typev  WdfRegPropertyStore_cpp123 13 "%0%!FUNC!: ppPropStore is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreatePropStoreFromRegKey
{
}
#typev  WdfRegPropertyStore_cpp106 11 "%0%!FUNC!: pwszSubKey is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreatePropStoreFromRegKey
{
}
#typev  WdfRegPropertyStore_cpp98 10 "%0%!FUNC!: pDeviceStack is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreatePropStoreFromRegKey
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
370cbf56-85ce-360d-f926-3d7eccfcedde WUDFx // SRC=wudfobject.cpp MJ= MN=
#typev  wudfobject_cpp77 10 "%0%!FUNC!: Initialization failed 0x%10!p!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWudfObject::Initialize
{
this, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfobject_cpp91 11 "%0%!FUNC!: 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_OBJECT FUNC=CWudfObject::OnDispose
{
this, ItemPtr -- 10
}
#typev  wudfobject_cpp165 12 "%0%!FUNC! failed: 0x%10!p!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWudfObject::Commit
{
this, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfobject_cpp221 13 "%0%!FUNC!: Could not assign object context, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWudfObject::AssignObjectContext
{
hr, ItemHRESULT -- 10
}
#typev  wudfobject_cpp238 14 "%0%!FUNC!: NULL is an invalid input paramater" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWudfObject::RetrieveObjectContext
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
3923635c-8ddb-08c4-daa0-4be242fbe01a WUDFx // SRC=wdfdriver.cpp MJ= MN=
#typev  wdfdriver_cpp543 23 "%0%!FUNC!: User object creation failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreateWdfObject
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp63 11 "%0%!FUNC!: Releasing UMD's IDriverEntry interface" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDriver::~CWdfDriver
{
}
#typev  wdfdriver_cpp58 10 "%0%!FUNC!: Cleaning up CWUDFDEvice" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDriver::~CWdfDriver
{
}
#typev  wdfdriver_cpp380 22 "%0%!FUNC!:Unable to copy kernel device name hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp363 21 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for kernel device name" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
}
#typev  wdfdriver_cpp342 20 "%0%!FUNC!:Unable to copy the configuration path %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp329 19 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
}
#typev  wdfdriver_cpp314 18 "%0%!FUNC!:Device Instance ID string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp296 17 "%0%!FUNC!:Unable to copy the configuration path %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp282 16 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
}
#typev  wdfdriver_cpp265 15 "%0%!FUNC!:Registry path string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp250 14 "%0%!FUNC!:Registry key open failed for the PDO key, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
lRetVal, ItemWINERROR -- 10
}
#typev  wdfdriver_cpp226 13 "%0%!FUNC!: Could not allocate resource, hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp632 24 "%0%!FUNC!: Invalid arguments passed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreatePreallocatedWdfMemory
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp695 25 "%0%!FUNC!: Invalid arguments passed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreateWdfMemory
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp159 12 "%0%!FUNC!: Initialization failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
3970f212-a319-0adc-62f2-5d4fee82e866 WUDFx // SRC=WdfUsbTargetDevice.cpp MJ= MN=
#typev  WdfUsbTargetDevice_cpp634 12 "%0failed to retrieve config descriptor for config %10!d!, error = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetDevice::RetrieveNumInterfaces
{
ConfigIndex, ItemLong -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfUsbTargetDevice_cpp175 10 "%0Falied to allocate CWdfUsbTargetDevice, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetDevice::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbTargetDevice_cpp300 11 "%0unable to allocate USB device control context returning, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetDevice::FormatControlRequest
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
5458e0f0-a340-9cc5-3ea5-479dc22cbe54 WUDFx // SRC=WdfIoQueue.cpp MJ= MN=
#typev  WdfIoQueue_cpp2552 66 "%0%!FUNC!: Acquiring the presentation lock for IoQueue (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2546 65 "%0%!FUNC!: Invalid operation. The IoQueue (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2573 68 "%0%!FUNC!: Releasing the presentation lock for IoQueue (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2567 67 "%0%!FUNC!: Invalid operation. The IoQueue (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2950 73 "%0%!FUNC!:  status 0x%10!x! is invalid, Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SetState
{
NewStatus, ItemLong -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1125 34 "%0Could not get the request type, completing with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1089 31 "%0%!FUNC!: Driver hasn't registered for OnClose notification.Framework is automatically completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1116 33 "%0Request 0x%10!p! of type 0x%11!x! dispatched to Driver" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
pRequestObj, ItemPtr -- 10
RequestType, ItemLong -- 11
}
#typev  WdfIoQueue_cpp994 28 "%0%!FUNC!: Driver hasn't registered for OnRead notification.Framework completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1023 29 "%0%!FUNC!: Driver hasn't registered for OnWrite notification.Framework completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1058 30 "%0%!FUNC!: Driver hasn't registered for OnDeviceIoControl notification.Framework completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1103 32 "%0%!FUNC!: Unknown request type(0x%10!x!), not delivered to driver" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
RequestType, ItemLong -- 10
}
#typev  WdfIoQueue_cpp962 27 "%0%!FUNC!: INTERNAL ERROR: unable to QI IWDFIoRequest interface" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
}
#typev  WdfIoQueue_cpp952 26 "%0%!FUNC!: INTERNAL ERROR: unable to QI IWDFIoQueue interface" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
}
#typev  WdfIoQueue_cpp1200 38 "%0FxIoQueue::RequestCompleteEvent Request 0x%10!p! is on a cancellation list for Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
RequestObj, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1181 37 "%0FxIoQueue::RequestCompleteEvent Request 0x%10!p! Has been used as a TagRequest in WdfIoQueuePeekNextRequest. A TagRequest can not be used until its been returned by WdfIoQueueRetrieveRequest." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
RequestObj, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1172 36 "%0FxIoQueue::RequestCompleteEvent Request 0x%10!p! not Driver owned! It is an error to call IWDFIoRequest::Complete on a non driver owned request." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
RequestObj, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1160 35 "%0Fired, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
this, ItemPtr -- 10
RequestObj, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1409 42 "%0ProcessCancelledRequests: Calling Driver for Request 0x%10!p!, queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessCancelledRequests
{
pReqObj, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3053 75 "%0%!FUNC!: Can not delete Queue 0x%10!p! because it has %11!d! Queued Requests and %12!d! Driver Pending Requests" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DeleteWdfObject
{
this, ItemPtr -- 10
queuedCount, ItemLong -- 11
pendingCount, ItemLong -- 12
}
#typev  WdfIoQueue_cpp3039 74 "%0%!FUNC!: Queue 0x%10!p! State 0x%11!x! incorrect for deleting. Must clear WdfIoQueueAcceptRequests" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DeleteWdfObject
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
}
#typev  WdfIoQueue_cpp3497 86 "%0%!FUNC!: Queue 0x%10!p! is paused" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3486 85 "%0%!FUNC!:Queue 0x%10!p! is powered off" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3475 84 "%0%!FUNC!:Can not be called on a parallel Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3452 83 "%0%!FUNC!: Driver called IWDFIoQueue::RetrieveNextRequest on a sequential queue with no outstanding requests, Queue 0x%10!p!. This can cause a race with automatically dispatched requests. Call IWDFIoQueue::RetrieveNextRequest before completing the current request(s)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3437 82 "%0%!FUNC!: TagRequest 0x%10!p! is not referenced or owned by driver" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
TagRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4264 105 "%0%!FUNC!:Invalid power state 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
m_PowerState, ItemLong -- 10
}
#typev  WdfIoQueue_cpp4251 104 "%0Power Resume: Queue 0x%10!p! is now powered on and I/O has resumed" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4236 103 "%0Power Resume: Driver has no callback for EvtIoResume registered on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4221 102 "%0Power Resume, Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4168 101 "%0Power Resume: Driver has no power paused requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4147 100 "%0Power Resume: Driver has power paused requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4124 99 "%0Power Stop: Driver has acknowledged all in-flight requests, but Queue 0x%10!p! has outstanding callbacks" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4105 98 "%0Power Stop: Queue 0x%10!p! is now powered off with no in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4089 97 "%0Power Stop: Waiting for Driver to complete or acknowledge in-flight requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4054 96 "%0Power Purge Notifying Driver, Driver has no EvtIoStop callback registered Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4034 95 "%0Power Purge Notifying Driver, Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4015 94 "%0Power Purge Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3964 93 "%0Power Stop, Driver has no IQueueCallbackIoStop callback registered Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3945 92 "%0Power Stop Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3883 91 "%0Power purge: Queue 0x%10!p! is purging without in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3863 90 "%0%!FUNC!: Queue 0x%10!p! is purging with in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3840 89 "%0%!FUNC!: Queue 0x%10!p! is powering off without in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3817 88 "%0%!FUNC!: Queue 0x%10!p! is powering off with in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp552 15 "%0%!FUNC!: Invalid IWDFFile param:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RetrieveNextRequestByFileObject
{
pFile, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1453 43 "%0Executing work item, Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue_WorkItemThunk
{
pWdfQueueObj, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1486 45 "%0%!FUNC!:The queue 0x%10!p! is being rundown" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::EnqueueWorkItem
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1478 44 "%0%!FUNC!:Work item pending for queue 0x%10!p!, no need to queue another one" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::EnqueueWorkItem
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp183 10 "%0Queue is idle, calling driver callback" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessStopComplete
{
}
#typev  WdfIoQueue_cpp758 23 "%0%!FUNC!: For manual queues each of the following callbacks must be NULL -     Create:0x%10!p!, Read:0x%11!p!, Write:0x%12!p!, DevIoCtrl:0x%13!p!, Driver's IUnknown:0x%14!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
pCreateCallback, ItemPtr -- 10
pReadCallback, ItemPtr -- 11
pWriteCallback, ItemPtr -- 12
pDevIoControlCallback, ItemPtr -- 13
pCallbackInterface, ItemPtr -- 14
}
#typev  WdfIoQueue_cpp731 22 "%0%!FUNC!: No valid callbacks on the non-manual queue. IUnknown:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
pCallbackInterface, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp683 21 "%0%!FUNC!: Internal error: Unable to initialize base CWdfObject" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
}
#typev  WdfIoQueue_cpp670 20 "%0%!FUNC!: Unable to create the poweridle event, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
err, ItemWINERROR -- 10
}
#typev  WdfIoQueue_cpp656 19 "%0%!FUNC!: Unable to create an event, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
err, ItemWINERROR -- 10
}
#typev  WdfIoQueue_cpp638 18 "%0%!FUNC!: Unable to create the work-item completion event, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
err, ItemWINERROR -- 10
}
#typev  WdfIoQueue_cpp619 17 "%0%!FUNC!: Invalid input. pCallbackInterface:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
pCallbackInterface, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp608 16 "%0%!FUNC!: Invalid dispatch mode(0x%10!x!) specified for queue:0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
DispatchType, ItemLong -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3394 81 "%0Queue is purged, calling driver callback" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPurgeComplete
{
}
#typev  WdfIoQueue_cpp2830 72 "%0%!FUNC!: notify method == NULL on WdfIoQueue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessReadyNotify
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1851 54 "%0No requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1827 53 "%0Driver has %10!d! requests and WdfIoQueueDispatchSequential, waiting... Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
m_DriverIoCount, ItemLong -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1811 52 "%0Queue HoldCount != 0, is %10!d!, queue 0x%11!p!, State %12!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
m_HoldCount, ItemLong -- 10
this, ItemPtr -- 11
m_Status, ItemLong -- 12
}
#typev  WdfIoQueue_cpp1797 51 "%0Queue not in Dispatching state, queue 0x%10!p!, State 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
}
#typev  WdfIoQueue_cpp1780 50 "%0Driver has configured Queue 0x%10!p! for WdfIoQueueDispatchManual" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1732 49 "%0Queue 0x%10!p! Power Transition State %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
m_PowerState, ItemLong -- 11
}
#typev  WdfIoQueue_cpp1660 48 "%0In Thread (ID:%10!d!), processing requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
GetCurrentThreadId(), ItemLong -- 10
}
#typev  WdfIoQueue_cpp1641 47 "%0Presentation lock for Queue 0x%10!p! already held, deferring to workitem" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2033 56 "%0Queuing Request 0x%10!p! on Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequestFromForward
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp2020 55 "%0Queue 0x%10!p! is not accepting requests State 0x%11!x!, request 0x%12!p!. Returning error" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequestFromForward
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
pRequest, ItemPtr -- 12
}
#typev  WdfIoQueue_cpp2187 61 "%0%!FUNC!: Cannot forward a requestwhen the queue in middle of a power transition 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2169 60 "%0%!FUNC!: Request 0x%10!p! is cancelable. Call IWDFRequest::UnmarkCancelable before Forwarding to another Queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2155 59 "%0%!FUNC!: Request 0x%10!p! Has been used as a TagRequest in WdfIoQueueFindRequest. A TagRequest can not be used until its been retrieved by WdfIoQueueRetrieveFoundRequest" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2148 58 "%0%!FUNC!: Request 0x%10!p! not owned by driver! Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp2117 57 "%0FxIoQueue::ForwardRequest Cannot forward a request to the same queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2342 62 "%0%!FUNC!:Request 0x%10!p! (ID:0x%11!I64x!) was cancelled while on queue 0x%12!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CancelForQueue
{
pRequest, ItemPtr -- 10
pRequest->GetHostIrpId(), ItemLongLongX -- 11
this, ItemPtr -- 12
}
#typev  WdfIoQueue_cpp2430 64 "%0%!FUNC!: CWdfIoRequest 0x%10!p! (ID:0x%11!I64x!) is already on list, CWdfIoRequest::m_OwnerListEntry is busy!, Queue 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CancelForDriver
{
pRequest, ItemPtr -- 10
pRequest->GetHostIrpId(), ItemLongLongX -- 11
this, ItemPtr -- 12
}
#typev  WdfIoQueue_cpp2420 63 "%0%!FUNC!: Host has canceled Request 0x%10!p! in driver for queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CancelForDriver
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp2642 71 "%0%!FUNC! Request 0x%10!p! is already not cancelable" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCancelable
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2626 70 "%0%!FUNC!: Request 0x%10!p! is already cancelable" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCancelable
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2600 69 "%0%!FUNC!: Request 0x%10!p! not owned by driver! Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCancelable
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3306 80 "%0%!FUNC!: queue 0x%10!p! all driver cancellable requests cancelled" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3267 78 "%0%!FUNC!: WdfIoQueue 0x%10!p! all Queued requests cancelled" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3278 79 "%0%!FUNC!: Cancelling Request 0x%10!p!, Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3238 77 "%0%!FUNC!:Queue 0x%10!p! already has a PurgeComplete callback registered 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
m_PurgeCompleteCallback.m_spCallback.p, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3210 76 "%0%!FUNC!:Queue 0x%10!p! already has a SynchronousPurgeComplete registered" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3684 87 "%0%!FUNC!: WaitForSingleObject on power idle event failed (%10!s!) on Queue (0x%11!p!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::StopProcessingForPower
{
GetLastError(), ItemWINERROR -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp255 12 "%0Queue 0x%10!p! already has a IdleComplete callback registered 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueStop
{
this, ItemPtr -- 10
m_StopCompleteCallback.m_spCallback.p, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp226 11 "%0%!FUNC!:Queue 0x%10!p! already has a SynchronousPurgeComplete registered" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueStop
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp381 13 "%0%!FUNC!: Failed (%10!s!) for queue:0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DrainSynchronously
{
err, ItemWINERROR -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp425 14 "%0%!FUNC!: Failed (%10!s!) for for queue:0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::PurgeSynchronously
{
err, ItemWINERROR -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp913 25 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CreateAndInitialize
{
}
#typev  WdfIoQueue_cpp903 24 "%0%!FUNC!: Invalid parameter: CWdfIoQueue is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CreateAndInitialize
{
}
#typev  WdfIoQueue_cpp1316 41 "%0Queuing Request 0x%10!p! on Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequest
{
pReqObj, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1305 40 "%0Queue is configured to automatically complete zero-length request" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequest
{
}
#typev  WdfIoQueue_cpp1257 39 "%0Queue 0x%10!p! is not accepting requests status %11!d! cancelling request 0x%12!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequest
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
pReqObj, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
54bbf3ba-7692-0127-ad7a-28f91cc02559 WUDFx // SRC=wudfpnp.cpp MJ= MN=
#typev  wudfpnp_cpp724 11 "%0%!FUNC!: Failed to allocate Pnp state history, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CPnpEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfpnp_cpp697 10 "%0%!FUNC!: Failed to allocate Pnp event queue, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CPnpEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfpnp_cpp1314 17 "%0%!FUNC!: No pending Pnp IRP available" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpSendStartDeviceDownTheStack
{
}
#typev  wudfpnp_cpp1079 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPnp::ProcessEvent
{
}
#typev  wudfpnp_cpp1021 15 "%0current state %10!lu!, policy event %11!lu! is not a known dropped event, known dropped events are %12!lu!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::ProcessEvent
{
(ULONG)GetDevicePnpState(), ItemLong -- 10
(ULONG)event, ItemLong -- 11
entry->StateInfo.KnownDroppedEvents, ItemLong -- 12
}
#typev  wudfpnp_cpp1005 14 "%0%!FUNC!: current pnp state %10!lu! dropping event %11!lu!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::ProcessEvent
{
(ULONG)GetDevicePnpState(), ItemLong -- 10
(ULONG)event, ItemLong -- 11
}
#typev  wudfpnp_cpp886 13 "%0%!FUNC!: The PnP queue is full.  This shouldn't be able to happen." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::ProcessEvent
{
}
#typev  wudfpnp_cpp878 12 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPnp::ProcessEvent
{
Event, ItemEnum(FxPnpEvent) -- 10
}
#enumv FxPnpEvent
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
59d783cd-883b-fbcf-95a1-79e82ebeca7d WUDFx // SRC=WudfPowerStateFn.cpp MJ= MN=
#typev  WudfPowerStateFn_cpp1661 63 "%0SelfManagedIoEventStart (power) failed, status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPower::PowerStartSelfManagedIo
{
status, ItemNTSTATUS -- 10
}
#typev  WudfPowerStateFn_cpp1851 70 "%0D0Entry failed, old state %10!lu!, status %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPower::PowerWaking
{
pThis->m_pDevice->GetPowerDeviceState(), ItemLong -- 10
status, ItemNTSTATUS -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
65a0afde-99e8-ea74-604f-1d0a217b1ff2 WUDFx // SRC=WdfDeviceInit.cpp MJ= MN=
#typev  WdfDeviceInit_cpp144 10 "%0%!FUNC!: NULL is an invalid paramater" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDeviceInit::RetrieveDevicePropertyStore
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
6ca76f75-0894-ecfa-6e9a-92baed4ff193 WUDFx // SRC=WudfOneShotTimer.h MJ= MN=
#typev  WudfOneShotTimer_h192 11 "%0CreateTimerQueueTimer Allocation failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfOneShotTimer::Initialize
{
dwErr, ItemWINERROR -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
#typev  WudfOneShotTimer_h140 10 "%0CWudfOneShotTimer Allocation failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfOneShotTimer::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
6f2d74cb-04ff-869f-d50a-da5addf902ce WUDFx // SRC=wdfiotarget.cpp MJ= MN=
#typev  wdfiotarget_cpp501 12 "%0IoTarget %10!p!, Request %11!p! is being canceled on another thread, allowing other thread to complete request, not resending" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::DrainPendedRequestsLocked
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  wdfiotarget_cpp728 13 "%0IoTarget %10!p! stopped, but is current in the %11!d! state, not started or stopped" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::GotoStopState
{
this, ItemPtr -- 10
m_State, ItemLong -- 11
}
#typev  wdfiotarget_cpp994 14 "%0%!FUNC!:WDFIOTARGET %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RemoveCompletedRequestLocked
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp1251 17 "%0Target %10!p!, setting stop event %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RequestCompletionRoutine
{
this, ItemPtr -- 10
m_SentIoEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp1243 16 "%0Request %10!p! completed in completion routine" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RequestCompletionRoutine
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp1186 15 "%0%!FUNC!:WDFIOTARGET %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RequestCompletionRoutine
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp1688 23 "%0Starting timer on request %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp1666 22 "%0Pending request %10!p!, target %11!p! is paused, %12!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
this, ItemPtr -- 11
hr, ItemNTSTATUS -- 12
}
#typev  wdfiotarget_cpp1595 21 "%0failing request %10!p!, target %11!p! not accepting reqeusts, state %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
this, ItemPtr -- 11
m_State, ItemLong -- 12
}
#typev  wdfiotarget_cpp1561 20 "%0ignoring WDFIOTARGET %10!p! state, sending request %11!p!, state %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
m_State, ItemLong -- 12
}
#typev  wdfiotarget_cpp1507 19 "%0Request %10!p!, could not create timer, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  wdfiotarget_cpp1464 18 "%0WDFREQUEST %10!p! already sent to a target" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp1811 27 "%0Sending request %10!p!, Irp %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
Request, ItemPtr -- 10
Request->GetSubmitIrp(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp1795 26 "%0action 0x%10!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
action, ItemLong -- 10
}
#typev  wdfiotarget_cpp1756 25 "%0Failed to allocate wait event for sync request, Target %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp1738 24 "%0Target %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp2085 31 "%0Target %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::TimerCallback
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp2213 33 "%0Target %10!p!, setting stop event %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::CompleteCanceledRequest
{
this, ItemPtr -- 10
m_SentIoEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp2205 32 "%0Request %10!p! completed in from cancel" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::CompleteCanceledRequest
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp2323 34 "%0unable to allocate request context returning, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfIoTarget::_FormatIoRequest
{
hr, ItemHRESULT -- 10
}
#typev  wdfiotarget_cpp2518 35 "%0unable to allocate request context returning, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfIoTarget::_FormatIoctlRequest
{
hr, ItemHRESULT -- 10
}
#typev  wdfiotarget_cpp308 11 "%0Sending request %10!p!, Irp %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitPendedRequest
{
Request, ItemPtr -- 10
Request->GetSubmitIrp(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp274 10 "%0I/O Target Allocation failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
76a51eca-c999-1879-c952-fd9518cf732e WUDFx // SRC=wudfselfmanagedio.cpp MJ= MN=
#typev  wudfselfmanagedio_cpp207 11 "%0%!FUNC!: Failed to allocate self managed io state history, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CSelfManagedIoEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfselfmanagedio_cpp180 10 "%0%!FUNC!: Failed to allocate self managed io event event queue, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CSelfManagedIoEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfselfmanagedio_cpp337 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfSelfManagedIo::ProcessEvent
{
}
#typev  wudfselfmanagedio_cpp294 12 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfSelfManagedIo::ProcessEvent
{
Event, ItemEnum(FxSelfManagedIoEvent) -- 10
}
#enumv FxSelfManagedIoEvent
{
SelfManagedIoEventInvalid,0x0
SelfManagedIoEventStart,0x1
SelfManagedIoEventCleanup,0x2
SelfManagedIoEventSuspend,0x4
SelfManagedIoEventFlush,0x8
SelfManagedIoEventNull,0xFF
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
7a5abd44-9f0b-01ff-56ce-9fcc944761bb WUDFx // SRC=WudfPnpStateFn.cpp MJ= MN=
#typev  WudfPnpStateFn_cpp138 12 "%0%!FUNC!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpEventEnableInterfaces
{
}
#typev  WudfPnpStateFn_cpp944 35 "%0%!FUNC!: QueryRemove failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpEventQueryRemoveAskDriver
{
status, ItemNTSTATUS -- 10
}
#typev  WudfPnpStateFn_cpp986 37 "%0%!FUNC!: No pending Pnp IRP available" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpEventQueryRemovePending
{
}
#typev  WudfPnpStateFn_cpp1091 40 "%0OnQueryStop failed - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpEventQueryStopAskDriver
{
status, ItemNTSTATUS -- 10
}
#typev  WudfPnpStateFn_cpp175 13 "%0%!FUNC!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpEventFailed
{
}
#typev  WudfPnpStateFn_cpp1304 47 "%0%!FUNC! Driver failed ReleaseHardware - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpEventRemovingDisableInterfaces
{
status, ItemNTSTATUS -- 10
}
#typev  WudfPnpStateFn_cpp1505 52 "%0%!FUNC!: No pending Pnp IRP available" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPnp::PnpEventRestartReleaseHardware
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
89d4757f-1e6d-8ca8-3e8f-b6ed28ead854 WUDFx // SRC=wudfpower.cpp MJ= MN=
#typev  wudfpower_cpp917 11 "%0%!FUNC!: Failed to allocate power state history, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CPowerEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfpower_cpp890 10 "%0%!FUNC!: Failed to allocate power event queue, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CPowerEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfpower_cpp1310 14 "%0%!FUNC! SelfManagedIoSuspend failed - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPower::PowerGotoDx
{
status, ItemNTSTATUS -- 10
}
#typev  wudfpower_cpp1488 15 "%0%!FUNC! D0Exit failed - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPower::PowerConnectInterruptFailed
{
status, ItemNTSTATUS -- 10
}
#typev  wudfpower_cpp1157 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPower::ProcessEvent
{
}
#typev  wudfpower_cpp1005 12 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPower::ProcessEvent
{
Event, ItemEnum(FxPowerEvent) -- 10
}
#typev  wudfpower_cpp1540 16 "%0%!FUNC!: D0Exit failed status = %10!s!, new state %11!lu!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPower::PowerGotoDxIoStopped
{
status, ItemNTSTATUS -- 10
state, ItemLong -- 11
}
#enumv FxPowerEvent
{
PowerEventInvalid,0x0
PowerD0,0x1
PowerDx,0x2
PowerWakeArrival,0x4
PowerWakeSucceeded,0x8
PowerWakeFailed,0x10
PowerWakeCanceled,0x20
PowerImplicitD0,0x40
PowerImplicitD3,0x80
PowerParentToD0,0x100
PowerPowerPolicySurpriseRemove,0x200
PowerMarkPageable,0x400
PowerMarkNonpageable,0x800
PowerCompleteD0,0x1000
PowerCompleteDx,0x2000
PowerEventMaximum,0xFF
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
8c230394-18cc-b23f-2d17-0bf5b640d020 WUDFx // SRC=WUDF.cpp MJ= MN=
#typev  WUDF_cpp156 11 "%0Global device stack table is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDriverTable::Remove
{
pDrvGlobal, ItemPtr -- 10
}
#typev  WUDF_cpp138 10 "%0Device Stack not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDriverTable::Remove
{
pDrvGlobal, ItemPtr -- 10
}
#typev  WUDF_cpp349 17 "%0%!FUNC!: IDriverEntry::OnInitialize invoked, %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp326 16 "%0%!FUNC!: Failed to insert into object tree %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp305 15 "%0%!FUNC!: Load driver failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp289 14 "%0%!FUNC!: Unable to create object tracker while tracking is enabled, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp271 13 "%0%!FUNC!: Unable to get host's event-log provider, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp242 12 "%0%!FUNC!: Not able to create driver global object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
8f2bedf6-f7fc-2ecf-4a1e-1fa5ec1d7bb1 WUDFx // SRC=WdfFile.cpp MJ= MN=
#typev  WdfFile_cpp87 12 "%0%!FUNC!:Initialization failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfFile::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfFile_cpp74 11 "%0%!FUNC!: Could not allocate WDF file object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfFile::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfFile_cpp62 10 "%0%!FUNC!: Invalid arguments" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfFile::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
a53ee7aa-839e-6961-f7f5-3429f8bed724 WUDFx // SRC=Framework.cpp MJ= MN=
#typev  Framework_cpp39 10 "%0%!FUNC!: Unable to initialize the global driver tracking table, %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=DllMain
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
acab3d89-769e-5919-6ab3-a29313975b9a WUDFx // SRC=WdfUtil.cpp MJ= MN=
#typev  WdfUtil_cpp28 10 "%0%!FUNC!: Device key path is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=WdfGetDevicePropertyStore
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
b1664086-05f4-1e25-46d9-ec8820f30e50 WUDFx // SRC=wudfpowerpolicy.cpp MJ= MN=
#typev  wudfpowerpolicy_cpp1709 11 "%0%!FUNC!: Failed to allocate power policy state history, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CPowerPolicyEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfpowerpolicy_cpp1682 10 "%0%!FUNC!: Failed to allocate power policy event queue, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CPowerPolicyEventQueue::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfpowerpolicy_cpp2066 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPowerPolicy::ProcessEvent
{
}
#typev  wudfpowerpolicy_cpp1932 15 "%0current state %10!lu!, policy event %11!lu! is not a known dropped event, known dropped events are %12!lu!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_PNP FUNC=CWudfPowerPolicy::ProcessEvent
{
(ULONG)GetDevicePowerPolicyState(), ItemLong -- 10
(ULONG)event, ItemLong -- 11
entry->StateInfo.Bits.KnownDroppedEvents, ItemLong -- 12
}
#typev  wudfpowerpolicy_cpp1925 14 "%0%!FUNC!: current pwr pol state %10!lu! dropping event %11!lu!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWudfPowerPolicy::ProcessEvent
{
(ULONG)GetDevicePowerPolicyState(), ItemLong -- 10
(ULONG)event, ItemLong -- 11
}
#typev  wudfpowerpolicy_cpp1794 13 "%0%!FUNC!: The Power queue is full.  This shouldn't happen." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfPowerPolicy::ProcessEvent
{
}
#typev  wudfpowerpolicy_cpp1787 12 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPowerPolicy::ProcessEvent
{
Event, ItemEnum(FxPowerPolicyEvent) -- 10
}
#enumv FxPowerPolicyEvent
{
PwrPolInvalid,0x0
PwrPolStart,0x1
PwrPolStop,0x2
PwrPolSx,0x4
PwrPolS0,0x8
PwrPolPowerDown,0x10
PwrPolPowerUp,0x20
PwrPolPowerDownIoStopped,0x40
PwrPolPowerUpHwStarted,0x80
PwrPolWakeArrived,0x100
PwrPolWakeSuccess,0x200
PwrPolWakeFailed,0x400
PwrPolIoPresent,0x800
PwrPolPowerTimeoutExpired,0x1000
PwrPolS0IdlePolicyChanged,0x2000
PwrPolSurpriseRemove,0x4000
PwrPolUsbSelectiveSuspendCallback,0x8000
PwrPolUsbSelectiveSuspendCompleted,0x10000
PwrPolPowerDownFailed,0x20000
PwrPolPowerUpFailed,0x40000
PwrPolPriorityEventsMask,0x607F0
PwrPolNull,0xFF
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
d1f278f4-d124-f2b9-c975-c99a308ee597 WUDFx // SRC=WdfIoRequest.cpp MJ= MN=
#typev  WdfIoRequest_cpp115 12 "%0%!FUNC!:Couldn't commit OutputBuffer memory buffer (0x%10!p!) for request type 0x%11!x! to the object tree, %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::Commit
{
m_pOutputBuffer, ItemPtr -- 10
this->m_RequestType, ItemLong -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfIoRequest_cpp94 11 "%0%!FUNC!:Couldn't commit InputBuffer memory buffer (0x%10!p!) for request type 0x%11!x! to the object tree, %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::Commit
{
m_pInputBuffer, ItemPtr -- 10
this->m_RequestType, ItemLong -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfIoRequest_cpp77 10 "%0%!FUNC!:Couldn't commit CWdfIoRequestObject (0x%10!p!) of type 0x%11!x! to the object tree, %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::Commit
{
this, ItemPtr -- 10
this->m_RequestType, ItemLong -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfIoRequest_cpp738 19 "%0%!FUNC!:WDFRequest 0x%10!p! doesn't belong to any queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::MarkCancelable
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp728 18 "%0%!FUNC!: Cancel callback cannot be NULL%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::MarkCancelable
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoRequest_cpp760 20 "%0%!FUNC!:WDFRequest 0x%10!p! doesn't belong to any queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::UnmarkCancelable
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp809 23 "%0Invalid parameter: The supplied destination queue 0x%10!p! is invalid, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoRequest::ForwardToIoQueue
{
pDestination, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp798 22 "%0Invalid parameter: The supplied destination queue (IWDFIoQueue:0x%10!p!) cannot be NULL, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoRequest::ForwardToIoQueue
{
pDestination, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp785 21 "%0Invalid operation: The request 0x%10!p! doesn't belong any queue, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoRequest::ForwardToIoQueue
{
this, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp1059 28 "%0Request 0x%10!p! already completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::InsertTailRequestQueue
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1032 27 "%0INTERNAL_ERROR: Already in Queue 0x%10!p! CWdfRequest 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::InsertTailRequestQueue
{
m_pRequestQueue, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoRequest_cpp1202 29 "%0Request 0x%10!p! has already been completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REQUEST FUNC=CWdfIoRequest::SetCompletionEvent
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1549 30 "%0%!FUNC!: Host canceling request(0x%10!p!) ID:0%11!I64x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::OnCancel
{
this, ItemPtr -- 10
this->m_pHostIrp->GetId(), ItemLongLongX -- 11
}
#typev  WdfIoRequest_cpp1622 31 "%0CWdfIoRequest 0x%10!p! not on CWdfRequestQueue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::RemoveFromRequestQueue
{
this, ItemPtr -- 10
m_pRequestQueue, ItemPtr -- 11
}
#typev  WdfIoRequest_cpp1739 35 "%0Could not cancel request %10!p!, already completed" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1729 34 "%0Request %10!p!, PIRP %11!p!, completed synchronously in cancel call, completing request on target %12!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
pHostIrp, ItemPtr -- 11
m_Target, ItemPtr -- 12
}
#typev  WdfIoRequest_cpp1710 33 "%0Request %10!p!, PIRP %11!p!, cancel result %12!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
pHostIrp, ItemPtr -- 11
result, ItemLong -- 12
}
#typev  WdfIoRequest_cpp1668 32 "%0Request %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1774 36 "%0%!FUNC!: Could not impersonate, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::Impersonate
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
#typev  WdfIoRequest_cpp426 17 "%0%!FUNC!:This type of request (0x%10!d!) have must information parameter set to zero" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfIoRequest::CompleteWithInformation
{
m_RequestType, ItemLong -- 10
}
#typev  WdfIoRequest_cpp406 16 "%0%!FUNC!: Completing a cancelable request IWDFIoRequest 0x%10!p!. This can result in a race condition that causes double completion. Call IWDFIoRequest::UnMarkCancelable before IWDFIoRequest::Complete. If UmarkCancelable fails, do not complete request until OnCancel is invoked." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CompleteWithInformation
{
static_cast<IWDFIoRequest *> (this), ItemPtr -- 10
}
#typev  WdfIoRequest_cpp930 26 "%0Sending request %10!p!, Irp %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoRequest::AsyncSend
{
this, ItemPtr -- 10
this->GetSubmitIrp(), ItemPtr -- 11
}
#typev  WdfIoRequest_cpp920 25 "%0action 0x%10!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoRequest::AsyncSend
{
Action, ItemLong -- 10
}
#typev  WdfIoRequest_cpp903 24 "%0%!FUNC!: IoTarget %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoRequest::AsyncSend
{
pTarget, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoRequest_cpp176 15 "%0%!FUNC!:Initialization failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfIoRequest::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoRequest_cpp158 14 "%0%!FUNC!:Out of memory. Cannot allocate a request object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CreateAndInitialize
{
}
#typev  WdfIoRequest_cpp148 13 "%0%!FUNC!:Invalid input: IWDFIoRequest param is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
d25d8265-8710-eb9f-5770-2b8e894b7511 WUDFx // SRC=wdfiotarget.h MJ= MN=
#typev  wdfiotarget_h500 10 "%0CreateTimerQueue failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::Initialize
{
dwErr, ItemWINERROR -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
ee9492c1-c643-ad1a-f883-fcbd4849e1e0 WUDFx // SRC=WdfMemoryBuffer.cpp MJ= MN=
#typev  WdfMemoryBuffer_cpp212 13 "%0%!FUNC!: SourceMemory is smaller than the requested number of bytes to be copied, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp195 12 "%0%!FUNC!: DestinationMemory is not large enough to contain the number of bytes requested to be copied" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
}
#typev  WdfMemoryBuffer_cpp169 11 "%0%!FUNC!: DestinationMemory is not large enough to contain the number of bytes requested to be copied" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
}
#typev  WdfMemoryBuffer_cpp142 10 "%0%!FUNC!: SourceMemory is smaller than the requested number of bytes to be copied, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp236 14 "%0%!FUNC!: Wdf Internal Error: Caller attempting to clobber preallocated memory" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::SetBufferInternal
{
}
#typev  WdfMemoryBuffer_cpp317 17 "%0%!FUNC!: Memory allocation failure %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp295 16 "%0%!FUNC!: Internal error: Unable to initialize base CWdfObject, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfMemoryBuffer::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp359 18 "%0%!FUNC!: Copying zero bytes is not allowed, 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CopyToBuffer
{
hr, ItemLong -- 10
}
#typev  WdfMemoryBuffer_cpp416 19 "%0%!FUNC!: Copying zero bytes is not allowed, 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CopyFromBuffer
{
hr, ItemLong -- 10
}
#typev  WdfMemoryBuffer_cpp486 20 "%0%!FUNC!: Zero buffer size is not allowed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::SetBuffer
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp268 15 "%0%!FUNC!: Memory allocation failure %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CreateAndInitalize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2008-1-19:5:52:52:862 (UTC) [tracepdb]
f9daaeeb-656c-d6ab-447d-4bc864533328 WUDFx // SRC=WdfUsbPipe.cpp MJ= MN=
#typev  WdfUsbPipe_cpp517 11 "%0Falied to allocate pipe transfer context, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::FormatTransferRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbPipe_cpp205 10 "%0Falied to allocate CWdfUsbTargetPipe, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
13f1c575-f0d7-916a-f0de-575c11434eb0 WUDFHost // SRC=wudfloader.cpp MJ= MN=
#typev  wudfloader_cpp199 11 "%0Global module table is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleTable::Remove
{
pModInfo, ItemPtr -- 10
}
#typev  wudfloader_cpp181 10 "%0Module not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleTable::Remove
{
pModInfo, ItemPtr -- 10
}
#typev  wudfloader_cpp651 21 "%0%!FUNC!: version mismatch. Component version = %10!d!.%11!d!, Max allowable version = %12!d!.%13!d! hr = %14!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
umdfVersion->MajorNumber, ItemLong -- 10
umdfVersion->MinorNumber, ItemLong -- 11
MaxAllowableVersion.MajorNumber, ItemLong -- 12
MaxAllowableVersion.MinorNumber, ItemLong -- 13
hr, ItemHRESULT -- 14
}
#typev  wudfloader_cpp779 25 "%0%!FUNC!: Your driver is not compatible with this framework.  To fix: recompile using the latest framework headers." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
}
#typev  wudfloader_cpp787 26 "%0%!FUNC!:Failed to load driver binary %10!s! with clsid %11!s!. hr = %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
&ClassId, ItemGuid -- 11
hr, ItemHRESULT -- 12
}
#typev  wudfloader_cpp722 24 "%0Error %10!s! - Could not create requested interface from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
hr, ItemHRESULT -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp704 23 "%0Error %10!s! - Could not get class factory interface from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
hr, ItemHRESULT -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp683 22 "%0Error %10!s! - Could not get DllGetClassObject function from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
error, ItemWINERROR -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp631 20 "%0Error %10!s! - Could not get umdf version from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
error, ItemWINERROR -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp608 19 "%0Load module %10!s! failed - error %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
error, ItemWINERROR -- 11
}
#typev  wudfloader_cpp592 18 "%0Loading module %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
}
#typev  wudfloader_cpp565 17 "%0Error - driver path %10!s! is not located under required driver root %11!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
g_wszDriverRootPath, ItemWString -- 11
}
#typev  wudfloader_cpp540 16 "%0Error canonicalizing driver path %10!s!: %11!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
LibraryFileName, ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfloader_cpp461 15 "%0Memory allocation failure" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstanceEx
{
}
#typev  wudfloader_cpp440 14 "%0Memory allocation failure" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstanceEx
{
}
#typev  wudfloader_cpp335 13 "%0%!FUNC!:Failed to load driver binary %10!s! with clsid %11!s!. hr = %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadFrameworkAndDriver
{
pcwszDriverFileName, ItemWString -- 10
&clsidDriver, ItemGuid -- 11
hr, ItemHRESULT -- 12
}
#typev  wudfloader_cpp302 12 "%0%!FUNC!:Failed to load framework binary %10!s!. hr = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadFrameworkAndDriver
{
pcwszFrameworkFileName, ItemWString -- 10
hr, ItemHRESULT -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
47bf4e7b-be8c-40bc-33e4-cf031502cfb8 WUDFHost // SRC=WudfDevStack.cpp MJ= MN=
#typev  WudfDevStack_cpp421 11 "%0Device %10!p! not found in device stack %11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::GetDeviceIndex
{
pDevice, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WudfDevStack_cpp1859 31 "%0%!FUNC!: Memory allocation failure" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::PostEvent
{
}
#typev  WudfDevStack_cpp1306 29 "%0Creating I/O Dispatcher failed : 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfDeviceStack::LoadIoDispatcher
{
hr, ItemLong -- 10
}
#typev  WudfDevStack_cpp1296 28 "%0Unsupported I/O Dispatcher specified : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfDeviceStack::LoadIoDispatcher
{
m_pwszIoDispatcher, ItemWString -- 10
}
#typev  WudfDevStack_cpp2481 35 "%0Global device stack table is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfDevStackTable::Remove
{
pDevStack, ItemPtr -- 10
}
#typev  WudfDevStack_cpp2462 34 "%0Device Stack not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfDevStackTable::Remove
{
pDevStack, ItemPtr -- 10
}
#typev  WudfDevStack_cpp162 10 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Create
{
}
#typev  WudfDevStack_cpp465 12 "%0AllocateEvent failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::ForwardSynchoronously
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDevStack_cpp1237 27 "%0%!FUNC!:Cannot open kernel control object: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1211 26 "%0%!FUNC! hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1194 25 "%0%!FUNC!: Unable to copy control device name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1174 24 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1157 23 "%0%!FUNC!:Unable to copy PDO name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1144 22 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1119 21 "%0%!FUNC!:Trailing name string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1106 20 "%0%!FUNC!:Unable to copy kernel device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1094 19 "%0%!FUNC!:Unable to copy device path name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1081 18 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for kernel device name" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1057 17 "%0%!FUNC!:Kernel device Name string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1044 16 "%0%!FUNC!:Unable to copy PDO name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1031 15 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1015 14 "%0%!FUNC!:PDO Name string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1803 30 "%0%!FUNC!: Cannot allocate set device interface message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::AllocateSetDeviceInterfaceMsg
{
}
#typev  WudfDevStack_cpp2062 33 "%0%!FUNC!: StringCchLen failed, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWudfDeviceStack::WriteValueToDeviceKey
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2044 32 "%0%!FUNC!: StringCchLen failed, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWudfDeviceStack::WriteValueToDeviceKey
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
#typev  WudfDevStack_cpp645 13 "%0%!FUNC!: BindIoCompletionCallback failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfDeviceStack::CreateWdfFileForOpenHandle
{
dwErr, ItemWINERROR -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
4999dc08-1139-2c41-de53-448c3e7390bf WUDFHost // SRC=WudfIoDispatcher.cpp MJ= MN=
#typev  WudfIoDispatcher_cpp108 11 "%0%!FUNC!: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfIoDispatcher::QueryInterface
{
hr, ItemHRESULT -- 10
}
#typev  WudfIoDispatcher_cpp291 12 "%0%!FUNC!: Canceling request %10!p! failed %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=HandleCancelationDefault
{
pCanceledIrp, ItemPtr -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  WudfIoDispatcher_cpp326 13 "%0%!FUNC!: Canceling request" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfIoDispatcher::OnCancel
{
}
#typev  WudfIoDispatcher_cpp65 10 "%0%!FUNC!: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfIoDispatcher::Create
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
616a3c02-a309-1202-63b0-dccbdc0e7e06 WUDFHost // SRC=WudfDriverCreatedFile.cpp MJ= MN=
#typev  WudfDriverCreatedFile_cpp385 10 "%0%!FUNC!:Memory allocation failure. Cannot create host process file object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDriverCreatedFile::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
67f4bb84-529e-8575-9319-e62378d4ebe9 WUDFHost // SRC=wudflpc.cpp MJ= MN=
#typev  wudflpc_cpp247 16 "%0%!FUNC!: Abnormal host shutdown: There is an active device stack in the host" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::PortIsClosed
{
}
#typev  wudflpc_cpp1770 54 "%0%!FUNC!: instance id = %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyHelper
{
instanceID, ItemWString -- 10
}
#typev  wudflpc_cpp1746 53 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyHelper
{
}
#typev  wudflpc_cpp1723 52 "%0%!FUNC!: SetupDiGetDeviceInstance failed %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceHwKeyHelper
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp1715 51 "%0%!FUNC!: SetupDiGetDeviceInstance misbehaving?? %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceHwKeyHelper
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp2148 60 "%0%!FUNC!: Thread exiting" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=LpcWorkerThreadThunk
{
}
#typev  wudflpc_cpp2136 59 "%0%!FUNC!: Cannot initialize COM runtime: 0x%10!X!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=LpcWorkerThreadThunk
{
hr, ItemLong -- 10
}
#typev  wudflpc_cpp1025 31 "%0%!FUNC!: Main thread exiting. Win32 status:0x%10!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::Run
{
status, ItemLong -- 10
}
#typev  wudflpc_cpp1018 30 "%0%!FUNC!: Event wait failed: Win32 err: %10!d!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Run
{
status, ItemLong -- 10
}
#typev  wudflpc_cpp1224 34 "%0%!FUNC!: unable to allocate memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetStringFromRegistry
{
}
#typev  wudflpc_cpp1212 33 "%0%!FUNC!: Invalid registry configuration: %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetStringFromRegistry
{
type, ItemLong -- 10
}
#typev  wudflpc_cpp2229 64 "%0%!FUNC!:failed to create LPC worker thread, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::CreateLPCAndThreads
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp2211 63 "%0%!FUNC!:Failed to get LPC worker object for system messages, NTSTATUS:0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::CreateLPCAndThreads
{
ntStatus, ItemLong -- 10
}
#typev  wudflpc_cpp2195 62 "%0Fail to get LPC object for system messages, NTSTATUS:0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::CreateLPCAndThreads
{
ntStatus, ItemLong -- 10
}
#typev  wudflpc_cpp2179 61 "%0Out of memory, not able to allcoate array for thread handles" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::CreateLPCAndThreads
{
}
#typev  wudflpc_cpp220 15 "%0%!FUNC!:Unable to connect to create system event server port %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_SysEventName, ItemWString -- 10
}
#typev  wudflpc_cpp198 14 "%0%!FUNC!: Could not create event. %10!s!=, %11!s!=" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
error, ItemWINERROR -- 10
hr, ItemHRESULT -- 11
}
#typev  wudflpc_cpp178 13 "%0%!FUNC!:Unable to connect to create iocancelevent server port %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_IoCancelEventName, ItemWString -- 10
}
#typev  wudflpc_cpp155 12 "%0%!FUNC!:Unable to connect to create ioevent server port %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_IoEventName, ItemWString -- 10
}
#typev  wudflpc_cpp132 11 "%0%!FUNC! ConvertStringSidToSid(%10!s!) failed %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_ServiceSid, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  wudflpc_cpp1520 45 "%0%!FUNC!:String operation failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp1506 44 "%0%!FUNC!:Out of memory. Not able to copy driver configuration path. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp1486 43 "%0Configuration error: Failed to read %10!s! value for driver %11!s!, err %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
WDF_DRIVER_IMAGE_PATH, ItemWString -- 10
driverName, ItemWString -- 11
err, ItemLong -- 12
}
#typev  wudflpc_cpp1461 42 "%0Configuration error: Invalid CLSID %10!s! for %11!s!, hr=0x%12!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
szClsid, ItemWString -- 10
driverName, ItemWString -- 11
hr, ItemLong -- 12
}
#typev  wudflpc_cpp1449 41 "%0Configuration error: CLSID not a REG_SZ type for %10!s!, Win32 err=%11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
driverName, ItemWString -- 10
err, ItemLong -- 11
}
#typev  wudflpc_cpp1436 40 "%0Unable to read CLSID from registry for %10!s!, err=%11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
driverName, ItemWString -- 10
err, ItemLong -- 11
}
#typev  wudflpc_cpp1415 39 "%0Unable to open driver Service key %10!s! : %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
driverName, ItemWString -- 10
err, ItemWINERROR -- 11
}
#typev  wudflpc_cpp1383 38 "%0Invalid configuration. DriverList key is empty." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
}
#typev  wudflpc_cpp1360 37 "%0Invalid configuration. Registry entry %10!s! could not be read, err %11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
WDF_DRIVER_LIST, ItemWString -- 10
err, ItemLong -- 11
}
#typev  wudflpc_cpp1317 36 "%0Unable to open service root key : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp1297 35 "%0%!FUNC!: RegOpenKeyEx %10!s! failed: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
WDF_SUB_KEY, ItemWString -- 10
err, ItemWINERROR -- 11
}
#typev  wudflpc_cpp1670 50 "%0%!FUNC!: Could not find an correct match for PDO. Error=%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::OpenDeviceHwKey
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp1657 49 "%0%!FUNC!: GetDeviceHwKeyHelper failed, PDO name. Error=%10!s!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::OpenDeviceHwKey
{
err, ItemWINERROR -- 10
pwszPdoName, ItemWString -- 11
}
#typev  wudflpc_cpp1603 48 "%0%!FUNC!: SetupDiGetClassDevs failed Error=%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::OpenDeviceHwKey
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp1583 47 "%0%!FUNC!: Memory allocation failure. hr = 0x%10!x!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::OpenDeviceHwKey
{
hr, ItemLong -- 10
}
#typev  wudflpc_cpp1566 46 "%0%!FUNC!: Invalid Pdo name. hr = 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::OpenDeviceHwKey
{
hr, ItemLong -- 10
}
#typev  wudflpc_cpp1873 56 "%0%!FUNC!: Invalid IRP! ((mj/mn)=(0x%10!x!, 0x%11!x!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::ProcessPnpPowerIrp
{
pMsg->MajorCode, ItemLong -- 10
pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp1829 55 "%0%!FUNC!: Received IRP (major/minor) = (0x%10!x!/0x%11!x!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::ProcessPnpPowerIrp
{
(ULONG)pMsg->MajorCode, ItemLong -- 10
(ULONG)pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp1062 32 "%0%!FUNC!: Error loading SetupApi.dll - %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::CreateDeviceStack
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
#typev  wudflpc_cpp1000 29 "%0Leaving %!FUNC!..." //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp976 28 "%0%!FUNC!: pnp message: WudfMsg_UNKNOWN" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp942 27 "%0%!FUNC!: pnp message: WudfMsg_ExitProcess" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp839 26 "%0%!FUNC!: Completion irp (code 0x%10!x!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
pPnpIrp->GetMinorFunction(), ItemLong -- 10
}
#typev  wudflpc_cpp799 25 "%0%!FUNC!: Builidng I/O Irp failed: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp784 24 "%0%!FUNC!: Message %10!d! for host file obj:0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
pIoMsg->Header.Message, ItemLong -- 10
pFileObj, ItemPtr -- 11
}
#typev  wudflpc_cpp653 23 "%0%!FUNC!: Builidng create Irp failed: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp639 22 "%0%!FUNC!: WudfMsg_CREATE for host file obj:0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
pHostFileObj, ItemPtr -- 10
}
#typev  wudflpc_cpp617 21 "%0%!FUNC!: LPC message(0x%10!x!) format is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp572 20 "%0%!FUNC!: Failing Add Device" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_PNP FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp533 19 "%0%!FUNC!:Failed Add Device, could not preallocate PnP UM irp" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_PNP FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp486 18 "%0%!FUNC!: LPC message(0x%10!x!) format is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp457 17 "%0%!FUNC!: Host process receives message: 0x%10!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp2096 58 "%0%!FUNC!:  PnP UM irp allocation failed((mj/mn)=(0x%10!x!, 0x%11!x!). Using fast reply" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::WudfPnpHandler
{
pMsg->MajorCode, ItemLong -- 10
pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp2004 57 "%0%!FUNC!: Using preallocted IRP ((mj/mn)=(0x%10!x!, 0x%11!x!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::WudfPnpHandler
{
pMsg->MajorCode, ItemLong -- 10
pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp82 10 "%0%!FUNC! Not able to allocate CLpcNotification object %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::CreateInstance
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
6f4e48cc-270a-1d97-402a-c1505079e03a WUDFHost // SRC=WudfIrp.h MJ= MN=
#typev  WudfIrp_h801 11 "%0%!FUNC!:Memory allocation failure %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfIoIrp,IWudfIoIrp,_WUDFMESSAGE_IO_HEADER *,_WUDFMESSAGE_REPLY_HEADER *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfIrp_h778 10 "%0hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfIoIrp,IWudfIoIrp,_WUDFMESSAGE_IO_HEADER *,_WUDFMESSAGE_REPLY_HEADER *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
#typev  WudfIrp_h801 11 "%0%!FUNC!:Memory allocation failure %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfPnpIrp,IWudfPnpIrp,_WUDFMESSAGE_IRP *,_WUDFMESSAGE_PNP_REPLY_ALL *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfIrp_h778 10 "%0hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfPnpIrp,IWudfPnpIrp,_WUDFMESSAGE_IRP *,_WUDFMESSAGE_PNP_REPLY_ALL *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
82378874-a7c3-659b-e183-3d84d4e20869 WUDFHost // SRC=WudfIoStack.cpp MJ= MN=
#typev  WudfIoStack_cpp82 10 "%0hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIoStack::Initialize
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
babe9194-4a72-9f19-d6ce-302cf70371f8 WUDFHost // SRC=WudfUsbDispatcher.cpp MJ= MN=
#typev  WudfUsbDispatcher_cpp92 11 "%0%!FUNC!: Could not create Win32 dispatcher object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_USB_DISPATCHER FUNC=CWudfUsbDispatcher::CreateUsbDispatcher
{
hr, ItemHRESULT -- 10
}
#typev  WudfUsbDispatcher_cpp78 10 "%0%!FUNC!: Error loading WINUSB.DLL - %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_USB_DISPATCHER FUNC=CWudfUsbDispatcher::CreateUsbDispatcher
{
hr, ItemHRESULT -- 10
}
#typev  WudfUsbDispatcher_cpp614 13 "%0WinUsb async operation failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfUsbDispatcher::SubmitUsbIo
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfUsbDispatcher_cpp189 12 "%0WinUsb_Initialize failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWudfUsbDispatcher::SubmitIo
{
dwErr, ItemWINERROR -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
d13099d8-241c-6fd8-b348-b61213fbec8a WUDFHost // SRC=wudfmain.cpp MJ= MN=
#typev  wudfmain_cpp201 10 "%0%!FUNC!: Exit: argc:%10!d!, %11!s! %12!s! %13!s! %14!s! %15!s! %16!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfCmdLineParams::CWudfCmdLineParams
{
argc, ItemLong -- 10
m_HostProcessGuid, ItemWString -- 11
m_IoEventName, ItemWString -- 12
m_SysEventName, ItemWString -- 13
m_IoCancelEventName, ItemWString -- 14
m_ServiceSid, ItemWString -- 15
m_LifetimeId, ItemWString -- 16
}
#typev  wudfmain_cpp287 14 "%0Host setting %10!s! not found" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=GetDwordHostSetting
{
ValueName, ItemWString -- 10
}
#typev  wudfmain_cpp263 13 "%0unable to open reg key %10!s!\%11!s! %12!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=GetDwordHostSetting
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
RegistrySubPath, ItemWString -- 11
result, ItemWINERROR -- 12
}
#typev  wudfmain_cpp250 12 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=GetDwordHostSetting
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  wudfmain_cpp230 11 "%0RegistrySubPath is NULL" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=GetDwordHostSetting
{
}
#typev  wudfmain_cpp368 16 "%0NOT waiting for debugger connection at host process start" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=WdfHostProcDbgBreakOnStart
{
}
#typev  wudfmain_cpp356 15 "%0%!FUNC!: Host process waiting for %10!s! debugger to connect, Timeout:%11!d! secs" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_INIT FUNC=WdfHostProcDbgBreakOnStart
{
(WudfUserDebugger == DbgBreakOnStartSettings.DebuggerType) ? L'user-mode' : L'user or kernel-mode', ItemWString -- 10
DbgBreakOnStartSettings.Timeout, ItemLong -- 11
}
#typev  wudfmain_cpp693 24 "%0%!FUNC!: Cannot initialize COM runtime: 0x%10!X!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=wmain
{
hr, ItemLong -- 10
}
#typev  wudfmain_cpp669 23 "%0%!FUNC!: Cannot allocate space to hold driver root - %10!d!." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=wmain
{
err, ItemLong -- 10
}
#typev  wudfmain_cpp815 25 "%0%!FUNC!: Leaving host process" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
}
#typev  wudfmain_cpp638 22 "%0Failed to initialize event log provider %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
hr, ItemHRESULT -- 10
}
#typev  wudfmain_cpp611 21 "%0Failed to get LPC interface %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
hr, ItemHRESULT -- 10
}
#typev  wudfmain_cpp558 20 "%0%!FUNC!: Error %10!s! building root directory name." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
hr, ItemHRESULT -- 10
}
#typev  wudfmain_cpp538 19 "%0%!FUNC!: Failed to get windows directory name: %10!s!." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
err, ItemWINERROR -- 10
}
#typev  wudfmain_cpp516 18 "%0Error converting Lifetime ID %10!s! to guid: %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
params.m_LifetimeId, ItemWString -- 10
rpcStatus, ItemWINERROR -- 11
}
#typev  wudfmain_cpp464 17 "%0%!FUNC!: Entering host process" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
d54250b9-eb97-5285-a800-4985ebb99695 WUDFHost // SRC=WudfIrp.cpp MJ= MN=
#typev  WudfIrp_cpp212 12 "%0Global Irp list is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::Remove
{
pIrp, ItemPtr -- 10
}
#typev  WudfIrp_cpp193 11 "%0Irp not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::Remove
{
pIrp, ItemPtr -- 10
}
#typev  WudfIrp_cpp247 13 "%0%!FUNC!: Could not find IRP ID:0x%10!I64x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::MarkCancel
{
RequestToCancel, ItemLongLongX -- 10
}
#typev  WudfIrp_cpp294 15 "%0%!FUNC!: IRP ID:0x%10!I64x!, Cancel flag set, Fx cancel routine 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::GetAndSetCancelCallback
{
RequestToCancel, ItemLongLongX -- 10
pCancelCallback, ItemPtr -- 11
}
#typev  WudfIrp_cpp288 14 "%0%!FUNC!: Could not find IRP ID:0x%10!I64x!. May have completed" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::GetAndSetCancelCallback
{
RequestToCancel, ItemLongLongX -- 10
}
#typev  WudfIrp_cpp330 16 "%0%!FUNC!: RevertToSelf failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWudfIrp::RevertImpersonation
{
hr, ItemHRESULT -- 10
}
#typev  WudfIrp_cpp1157 21 "%0Invalid pnp capability: %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfPnpIrp::SetPnpCap
{
Capability, ItemLong -- 10
}
#typev  WudfIrp_cpp1091 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPnpIrp::ForwardToRedirector
{
}
#typev  WudfIrp_cpp1061 19 "%0%!FUNC!: Irp type 0x%10!x! (WITHOUT completion callbacks)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfPnpIrp::ForwardToRedirector
{
GetMinorFunction(), ItemLong -- 10
}
#typev  WudfIrp_cpp1036 18 "%0%!FUNC!: Irp type 0x%10!x! (WITH completion callbacks)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfPnpIrp::ForwardToRedirector
{
GetMinorFunction(), ItemLong -- 10
}
#typev  WudfIrp_cpp987 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPnpIrp::ForwardToRedirector
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
e63b73c2-b038-9470-329d-71f5e22f94eb WUDFHost // SRC=WudfFileObj.cpp MJ= MN=
#typev  WudfFileObj_cpp211 12 "%0%!FUNC!:Memory allocation failure, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfFileObj::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfFileObj_cpp189 11 "%0%!FUNC!:Memory allocation failure. Cannot allocate framework fileobject array" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfFileObj::Initialize
{
}
#typev  WudfFileObj_cpp103 10 "%0%!FUNC!:Memory allocation failure. Cannot create host process file object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfFileObj::CreateAndInitialize
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
ec13bd59-1def-6e26-4512-4d039b62a1d4 WUDFHost // SRC=WudfWin32Dispatcher.cpp MJ= MN=
#typev  WudfWin32Dispatcher_cpp62 10 "%0%!FUNC!: Could not create Win32 dispatcher object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfWin32Dispatcher::Create
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:473 (UTC) [tracepdb]
f26ddcf0-6597-4fbc-b43d-913e2e335259 WUDFHost // SRC=WudfDefaultDispatcher.cpp MJ= MN=
#typev  WudfDefaultDispatcher_cpp350 11 "%0%!FUNC!: Canceling request %10!p! failed %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfDefaultDispatcher::CancelIo
{
pCanceledIrp, ItemPtr -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  WudfDefaultDispatcher_cpp561 16 "%0ReadFile failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoRead
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp629 17 "%0WriteFile failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoWrite
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp696 18 "%0DeviceIoControl failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoIoctl
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp473 15 "%0BindIoCompletionCallback failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp456 14 "%0CreateFile failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp423 13 "%0Calling win32 CreateFile with file name %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
pwszFileNameFullPath, ItemWString -- 10
}
#typev  WudfDefaultDispatcher_cpp401 12 "%0Allocating file name full path failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
}
#typev  WudfDefaultDispatcher_cpp84 10 "%0%!FUNC!: Could not create Win32 dispatcher object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::Create
{
hr, ItemHRESULT -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
1988ac41-deae-d637-51fa-89632bed1fe6 WUDFRd // SRC=lpcNotification.cpp MJ= MN=
#typev  lpcNotification_cpp76 13 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsConnected
{
STATUS_SUCCESS, ItemNTSTATUS -- 10
}
#typev  lpcNotification_cpp74 12 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsConnected
{
LpcConnPort, ItemPtr -- 10
LpcCommPort, ItemPtr -- 11
UniqueProcessId, ItemPtr -- 12
}
#typev  lpcNotification_cpp63 11 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsClosed
{
}
#typev  lpcNotification_cpp21 10 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsClosed
{
LpcCommPort, ItemPtr -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
1f8ab4b3-2834-cb7a-8412-40820e66bd78 WUDFRd // SRC=device.cpp MJ= MN=
#typev  device_cpp394 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::~RdDevice
{
}
#typev  device_cpp385 26 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::~RdDevice
{
}
#typev  device_cpp411 29 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdMimicDeviceFlags
{
}
#typev  device_cpp401 28 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdMimicDeviceFlags
{
}
#typev  device_cpp426 31 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdWdmDeviceObject2RdDevice
{
deviceExtension->RdDevice, ItemPtr -- 10
}
#typev  device_cpp422 30 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdWdmDeviceObject2RdDevice
{
DeviceObject, ItemPtr -- 10
}
#typev  device_cpp578 35 "%0%!FUNC!: unable to create/open wudf sub key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDevice::RdOpenRegKey
{
}
#typev  device_cpp532 34 "%0%!FUNC!: unable to open device key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdOpenRegKey
{
}
#typev  device_cpp513 33 "%0%!FUNC!: caller attempted to create/open WUDF sub-key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdOpenRegKey
{
}
#typev  device_cpp492 32 "%0%!FUNC!: caller attempted to create/open subkey with emptyname." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdOpenRegKey
{
}
#typev  device_cpp649 37 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::ProcessIrp
{
status, ItemNTSTATUS -- 10
}
#typev  device_cpp610 36 "%0 Entering %!FUNC!(%10!p! (%11!d!))" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::ProcessIrp
{
Irp, ItemPtr -- 10
majorFunc, ItemLong -- 11
}
#typev  device_cpp62 11 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdIoCompletion
{
Irp->IoStatus.Status, ItemNTSTATUS -- 10
}
#typev  device_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdIoCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  device_cpp360 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp133 13 "%0%!FUNC!: unsupported device type %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
DeviceType, ItemLong -- 10
}
#typev  device_cpp328 24 "%0%!FUNC!: unable to create symbolic link %10!s! for %11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
m_DosDeviceName.Buffer, ItemWString -- 10
ntDeviceNameUnicode.Buffer, ItemWString -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  device_cpp311 23 "%0%!FUNC!: unable to build dos device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp297 22 "%0%!FUNC!: unable to allocate memory for dos device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp286 21 "%0%!FUNC!: dosDeviceNameLen would exceeed MAXUSHORT" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp248 20 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp234 19 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp217 18 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp202 17 "%0%!FUNC!: unable to create device object. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp177 16 "%0%!FUNC!: unable to build nt device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp163 15 "%0%!FUNC!: unable to allocate memory for nt device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp151 14 "%0%!FUNC!: invalid device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp91 12 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!s!, %13!d!, %14!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdDevice
{
RdDriver, ItemPtr -- 10
RdDeviceName, ItemWString -- 11
WdmDeviceName, ItemWString -- 12
DeviceType, ItemLong -- 13
Parent, ItemPtr -- 14
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
39f64cfd-3c6e-a122-ff0f-89553e254f82 WUDFRd // SRC=process.cpp MJ= MN=
#typev  process_cpp336 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp322 22 "%0unable to connect to host system event port - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp308 21 "%0unable to connect to host io cancel port - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp294 20 "%0unable to connect to host io port - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp274 19 "%0%!FUNC!: unable to allocate a host process sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
}
#typev  process_cpp261 18 "%0%!FUNC!: unable to get rddriver" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
}
#typev  process_cpp99 14 "%0unable to copy str %10!s!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
str, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  process_cpp89 13 "%0unable to allocate buffer to copy str %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
str, ItemWString -- 10
}
#typev  process_cpp76 12 "%0invalid lpc port name %10!s!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
str, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  process_cpp117 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::RdProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp47 11 "%0%!FUNC!: invalid EPROCESS" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
}
#typev  process_cpp21 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::RdProcess
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  process_cpp176 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::~RdProcess
{
}
#typev  process_cpp152 16 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::~RdProcess
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
3fa5887d-2044-90e2-1204-cc2292f9b8d7 WUDFRd // SRC=fdoio.cpp MJ= MN=
#typev  fdoio_cpp133 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::~WudfFdoCreateContext
{
}
#typev  fdoio_cpp115 12 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::~WudfFdoCreateContext
{
}
#typev  fdoio_cpp210 15 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CreateMessage
{
msg, ItemPtr -- 10
}
#typev  fdoio_cpp152 14 "%0 Entering %!FUNC!(%10!s!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CreateMessage
{
FileName, ItemPWString -- 10
Irp, ItemPtr -- 11
Security, ItemPtr -- 12
}
#typev  fdoio_cpp292 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreateReply
{
}
#typev  fdoio_cpp242 17 "%0%!FUNC!: um driver failed create = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCreateReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp227 16 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreateReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp515 23 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CloseMessage
{
msg, ItemPtr -- 10
}
#typev  fdoio_cpp485 22 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CloseMessage
{
}
#typev  fdoio_cpp594 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseReply
{
}
#typev  fdoio_cpp544 25 "%0%!FUNC!: host process failed close message with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCloseReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp532 24 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp671 29 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdClose
{
STATUS_PENDING, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp634 28 "%0%!FUNC!: unable to send alpc msg to host" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdClose
{
}
#typev  fdoio_cpp610 27 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdClose
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp723 31 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CleanupMessage
{
msg, ItemPtr -- 10
}
#typev  fdoio_cpp688 30 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CleanupMessage
{
Irp, ItemPtr -- 10
Security, ItemPtr -- 11
}
#typev  fdoio_cpp775 34 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanupReply
{
}
#typev  fdoio_cpp744 33 "%0%!FUNC!: host process failed process clean up message with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCleanupReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp737 32 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanupReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp1555 61 "%0client process (0x%10!p!) in buffer (0x%11!p!) mapped to system (0x%12!p!) buffer (0x%13!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
inputMDL->Process, ItemPtr -- 10
InputBuffer, ItemPtr -- 11
m_RdDriver->GetSystemProcess(), ItemPtr -- 12
inputMDLMappedBuffer, ItemPtr -- 13
}
#typev  fdoio_cpp1548 60 "%0unable to map user input buffer mdl" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1529 59 "%0client process (0x%10!p!) out buffer (0x%11!p!) mapped to system (0x%12!p!) buffer (0x%13!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
outputMDL->Process, ItemPtr -- 10
OutputBuffer, ItemPtr -- 11
m_RdDriver->GetSystemProcess(), ItemPtr -- 12
outputMDLMappedBuffer, ItemPtr -- 13
}
#typev  fdoio_cpp1488 57 "%0invalid user input buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1522 58 "%0unable to map user output buffer mdl" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1449 55 "%0invalid user output buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1468 56 "%0unable to allocate MDL for input buffer 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
InputBuffer, ItemPtr -- 10
}
#typev  fdoio_cpp1429 54 "%0unable to allocate MDL for output buffer 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIo
{
OutputBuffer, ItemPtr -- 10
}
#typev  fdoio_cpp1383 53 "%0%!FUNC!: io not from kernel mode" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1374 52 "%0%!FUNC!: io not from kernel mode" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1362 51 "%0input 0x%10!x! and output 0x%11!x! buffers are large to be concatenated into one big buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdIo
{
InputBufferSize, ItemLong -- 10
OutputBufferSize, ItemLong -- 11
}
#typev  fdoio_cpp1739 62 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIo
{
alwaysReturnPending ? STATUS_PENDING : ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1347 50 "%0input 0x%10!x! and output 0x%11!x! buffers are large to be concatenated into one big buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdIo
{
InputBufferSize, ItemLong -- 10
OutputBufferSize, ItemLong -- 11
}
#typev  fdoio_cpp1286 49 "%0 Entering %!FUNC!(%10!p!, %11!d!, %12!p!, %13!d!, %14!p!, %15!d!, %16!p!, %17!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIo
{
Irp, ItemPtr -- 10
IoMethod, ItemLong -- 11
InputBuffer, ItemPtr -- 12
InputBufferSize, ItemLong -- 13
OutputBuffer, ItemPtr -- 14
OutputBufferSize, ItemLong -- 15
MessageIoHeader, ItemPtr -- 16
MessageSize, ItemLong -- 17
}
#typev  fdoio_cpp1923 64 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIoReply
{
}
#typev  fdoio_cpp1768 63 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIoReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp107 11 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::WudfFdoCreateContext
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp43 10 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::WudfFdoCreateContext
{
Fdo, ItemPtr -- 10
Qos, ItemPtr -- 11
}
#typev  fdoio_cpp470 21 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreate
{
STATUS_PENDING, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp323 20 "%0%!FUNC!: ioctl not from kernel mode" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdCreate
{
}
#typev  fdoio_cpp312 19 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreate
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp982 40 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRead
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp932 39 "%0%!FUNC!: unable to map output buffer to system space" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdRead
{
}
#typev  fdoio_cpp903 38 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRead
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1080 43 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdWrite
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1029 42 "%0%!FUNC!: unable to map input buffer to system space" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdWrite
{
}
#typev  fdoio_cpp999 41 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdWrite
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1198 47 "%0%!FUNC!: unable to map input buffer to system space" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdDeviceIoControl
{
}
#typev  fdoio_cpp1149 46 "%0input 0x%10!x! and output 0x%11!x! buffers are large to be concatenated into one big buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdDeviceIoControl
{
thisIrpStack->Parameters.DeviceIoControl.InputBufferLength, ItemLong -- 10
thisIrpStack->Parameters.DeviceIoControl.OutputBufferLength, ItemLong -- 11
}
#typev  fdoio_cpp1244 48 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1115 45 "%0MethodNeitherAction setting in the registry disallows METHOD_NEITHER IOs.  ioctl: 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdDeviceIoControl
{
thisIrpStack->Parameters.DeviceIoControl.IoControlCode, ItemLong -- 10
}
#typev  fdoio_cpp1101 44 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdDeviceIoControl
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1962 65 "%0RdFdoDevice 0x%10!p! completed %11!u! request(s) during the last timeout period" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdCleanupExtendTimeout
{
rdFdo, ItemPtr -- 10
currNumIOsCompleted - lastNumIOsCompleted, ItemLong -- 11
}
#typev  fdoio_cpp885 37 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanup
{
STATUS_PENDING, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp858 36 "%0%!FUNC!: unable to send alpc msg to host" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCleanup
{
}
#typev  fdoio_cpp790 35 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanup
{
Irp, ItemPtr -- 10
}
#enumv WudfProblem
{
WudfProblem_None,0x0
WudfProblem_Cancelled,0x1
WudfProblem_SendFailure,0x2
WudfProblem_Timeout,0x3
WudfProblem_InvalidRequest,0x4
WudfProblem_InvalidReply,0x5
WudfProblem_FailedCriticalOperation,0x6
WudfProblem_FailedToExit,0x7
WudfProblem_Disconnect,0x8
WudfProblem_LeakingHandle,0x9
WudfProblem_Max,0xA
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
48f568f5-06ec-f825-ab7c-dca0f8f1cd8d WUDFRd // SRC=dmControl.cpp MJ= MN=
#typev  dmControl_cpp150 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
}
#typev  dmControl_cpp133 15 "%0%!FUNC! created DM control object %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
GetName(), ItemWString -- 10
}
#typev  dmControl_cpp121 14 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp106 13 "%0unable to open a handle to self %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp86 12 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
}
#typev  dmControl_cpp74 11 "%0%!FUNC!: unable to allocate a DrvMgr sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
}
#typev  dmControl_cpp54 10 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
RdDriver, ItemPtr -- 10
DeviceName, ItemWString -- 11
ServiceProcessId, ItemPtr -- 12
}
#typev  dmControl_cpp201 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdCreate
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp167 17 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdCreate
{
Irp, ItemPtr -- 10
}
#typev  dmControl_cpp376 28 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
status, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp315 27 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
status, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp298 26 "%0%!FUNC!: invalide pdo name expectedLen %10!d! != actualLen %11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
(ULONG) pdoNameLen, ItemLong -- 10
(ULONG) actualPdoNameLen, ItemLong -- 11
}
#typev  dmControl_cpp289 25 "%0%!FUNC!: invalid pdo name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
setPidMessage->PdoName, ItemWString -- 10
status, ItemNTSTATUS -- 11
}
#typev  dmControl_cpp273 24 "%0%!FUNC!: pdo name too long 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
(ULONG) pdoNameSize, ItemLong -- 10
}
#typev  dmControl_cpp265 23 "%0%!FUNC!: message body size is bad" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
}
#typev  dmControl_cpp257 22 "%0%!FUNC!: message body too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
}
#typev  dmControl_cpp248 21 "%0%!FUNC!: message header too smaller" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
}
#typev  dmControl_cpp236 20 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
Irp, ItemPtr -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
4f7fd740-ddc3-a02e-ddfe-6d0e3cc5be1b WUDFRd // SRC=driver.cpp MJ= MN=
#typev  driver_cpp138 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdUnload
{
}
#typev  driver_cpp126 15 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdUnload
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp437 28 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::~RdDriver
{
}
#typev  driver_cpp424 27 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::~RdDriver
{
}
#typev  driver_cpp558 33 "%0 Exiting  %!FUNC! => (fastio completed:%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdFastIoDeviceDispatch
{
requestCompleted, ItemLong -- 10
}
#typev  driver_cpp535 32 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdFastIoDeviceDispatch
{
DeviceObject, ItemPtr -- 10
FileObject, ItemPtr -- 11
}
#typev  driver_cpp595 35 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDispatch
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp574 34 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDispatch
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  driver_cpp670 40 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdFreeUniqueDeviceName
{
UniqueName, ItemWString -- 10
}
#typev  driver_cpp917 51 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::CloseProcessMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp890 50 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::CloseProcessMessage
{
}
#typev  driver_cpp1133 62 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::UnprepareSharedResources
{
}
#typev  driver_cpp1118 61 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::UnprepareSharedResources
{
}
#typev  driver_cpp657 39 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdCreateUniqueName
{
name, ItemWString -- 10
}
#typev  driver_cpp649 38 "%0%!FUNC!: unable to create unique name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdCreateUniqueName
{
}
#typev  driver_cpp631 37 "%0unable to allocate buffer for unique device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdCreateUniqueName
{
}
#typev  driver_cpp610 36 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdCreateUniqueName
{
}
#typev  driver_cpp740 43 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::ControlObjectMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp698 42 "%0%!FUNC!: invalid control object name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::ControlObjectMessage
{
ControlObjectName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  driver_cpp685 41 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::ControlObjectMessage
{
ControlObjectName, ItemWString -- 10
}
#typev  driver_cpp808 46 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::QueryProcessMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp768 45 "%0%!FUNC!: invalid pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::QueryProcessMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp755 44 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::QueryProcessMessage
{
PdoName, ItemWString -- 10
}
#typev  driver_cpp876 49 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::OpenProcessMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp836 48 "%0%!FUNC!: invalid pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::OpenProcessMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp823 47 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::OpenProcessMessage
{
PdoName, ItemWString -- 10
}
#typev  driver_cpp1109 60 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::PrepareSharedResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1072 59 "%0unable to init cancel safe queue object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1064 58 "%0unable to allocate cancel safe queue object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp1052 57 "%0control object message failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
replyHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1044 56 "%0unable to sent control object info to drvmgr" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp1034 55 "%0unable to create control object message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp1023 54 "%0unable to init driver manager control object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1015 53 "%0unable to create driver manager control object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp985 52 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp418 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDriver
{
NT_SUCCESS(ntStatus), ItemListLong(false,true) -- 10
}
#typev  driver_cpp384 25 "%0%!FUNC!: unable to open WUDF key %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp356 24 "%0Driver Manager is not available - switching to nil mode." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
}
#typev  driver_cpp347 23 "%0unable to connect to lpc server port %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
m_WdfLpcInterface->WdfGetProcessManagementName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  driver_cpp322 22 "%0%!FUNC!: unable to allocate a DrvMgr sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDriver::RdDriver
{
}
#typev  driver_cpp298 21 "%0%!FUNC!: unable to allocate RdLpcNotification object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
}
#typev  driver_cpp289 20 "%0%!FUNC!: unable to allocate lpc object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
}
#typev  driver_cpp273 19 "%0%!FUNC!: unable to create periodic timer object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
}
#typev  driver_cpp261 18 "%0%!FUNC!: unable to get lpc interface object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
}
#typev  driver_cpp171 17 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDriver
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp114 14 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DriverEntry
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp77 11 "%0%!FUNC!: unable to allocate driver object extension" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=DriverEntry
{
}
#typev  driver_cpp98 13 "%0%!FUNC!: Unable to init RdDriver %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=DriverEntry
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp90 12 "%0%!FUNC!: unable to allocate RdDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=DriverEntry
{
}
#typev  driver_cpp62 10 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DriverEntry
{
DriverObject, ItemPtr -- 10
RegistryPath, ItemPWString -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
#typev  driver_cpp500 31 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdGetDriver
{
rdDriver, ItemPtr -- 10
}
#typev  driver_cpp490 30 "%0unable to get driver object extension" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdGetDriver
{
}
#typev  driver_cpp482 29 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdGetDriver
{
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
575d9658-7a6f-2094-0272-ddd29849b86f WUDFRd // SRC=fdo.cpp MJ= MN=
#typev  fdo_cpp1167 46 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRemoveDeviceFinal
{
}
#typev  fdo_cpp1624 50 "%0unable to terminate host process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdFdoDevice::RdCloseProcessReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1611 49 "%0unable to open host process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdFdoDevice::RdCloseProcessReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp2279 70 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSetHostProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp2262 69 "%0%!FUNC!: invalid host process object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSetHostProcess
{
}
#typev  fdo_cpp2258 68 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSetHostProcess
{
RdProcess, ItemPtr -- 10
}
#typev  fdo_cpp2325 74 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::HostProcessReady
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp2305 73 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::HostProcessReady
{
}
#typev  fdo_cpp2480 79 "%0%!FUNC!: reporting device failed due to %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPnpDeviceState
{
m_HostProblem.ProblemCode, ItemEnum(WudfProblem) -- 10
}
#typev  fdo_cpp763 40 "%0%!FUNC!: total string size too large %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp749 39 "%0%!FUNC!: invalid reference string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp734 38 "%0%!FUNC!: total string size too large %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp720 37 "%0%!FUNC!: invalid attach device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp704 36 "%0%!FUNC!: invalid pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp830 41 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::AddDeviceMessage
{
msg, ItemPtr -- 10
}
#typev  fdo_cpp688 35 "%0%!FUNC!: host process object is null" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
}
#typev  fdo_cpp683 34 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::AddDeviceMessage
{
}
#typev  fdo_cpp945 43 "%0devobj 0x%10!p! found attached on top of UMDF reflector (this =0x%11!p!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdStartDevice
{
thisDeviceObject, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  fdo_cpp921 42 "%0IoGetAttachedDeviceReference should never fail but it did" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdStartDevice
{
}
#typev  fdo_cpp1394 47 "%0%!FUNC!: (%10!u!, %11!u!) PnpTracker is already allocated" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPreallocatePnpTracker
{
IRP_MJ_PNP, ItemLong -- 10
IrpMinorCode, ItemLong -- 11
}
#typev  fdo_cpp1474 48 "%0%!FUNC!: (%10!u!, %11!u!) PnpTracker is already allocated" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPreallocatePowerTracker
{
IRP_MJ_POWER, ItemLong -- 10
IrpMinorCode, ItemLong -- 11
}
#typev  fdo_cpp2895 81 "%0%!FUNC!: asking drvmgr to terminate host for rdFdo 0x%10!p! - normal termination" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendCloseProcessMessage
{
this, ItemPtr -- 10
}
#typev  fdo_cpp2886 80 "%0%!FUNC!: asking drvmgr to terminate host for rdFdo 0x%10!p! for reason %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendCloseProcessMessage
{
this, ItemPtr -- 10
m_HostProblem.ProblemCode, ItemEnum(WudfProblem) -- 11
}
#typev  fdo_cpp131 14 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::DisableDevice
{
}
#typev  fdo_cpp99 13 "%0%!FUNC!: error %10!s! reporting device termination PNP event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::DisableDevice
{
status, ItemNTSTATUS -- 10
}
#typev  fdo_cpp92 12 "%0%!FUNC!: reported device termination PNP event." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::DisableDevice
{
}
#typev  fdo_cpp53 11 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::DisableDevice
{
}
#typev  fdo_cpp45 10 "%0 Entering %!FUNC!(%10!s!: Operation %11!s! Message %12!s! Status %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::DisableDevice
{
Problem->ProblemCode, ItemEnum(WudfProblem) -- 10
Problem->Operation, ItemEnum(WudfOperationType) -- 11
Problem->Message, ItemEnum(_WUDFMESSAGE) -- 12
Problem->Status, ItemNTSTATUS -- 13
}
#typev  fdo_cpp661 33 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDeviceReply
{
}
#typev  fdo_cpp644 32 "%0%!FUNC!: host process fails adddevice %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDeviceReply
{
m_AddDeviceNtStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp624 31 "%0%!FUNC!: Aborting AddDevice due to host problem %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDeviceReply
{
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 10
}
#typev  fdo_cpp608 30 "%0%!FUNC!: failing AddDevice because host process returns a NULL context" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDeviceReply
{
}
#typev  fdo_cpp603 29 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDeviceReply
{
ReplyAddDevice, ItemPtr -- 10
}
#typev  fdo_cpp1122 45 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRemoveDevice
{
}
#typev  fdo_cpp1043 44 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRemoveDevice
{
RemoveIrp, ItemPtr -- 10
PnpTracker, ItemPtr -- 11
}
#typev  fdo_cpp2467 78 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdFdoDevice::RdReply
{
}
#typev  fdo_cpp2409 76 "%0%!FUNC!: Received bad reply to message %10!d! (%11!p!) - problem %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdReply
{
messageId, ItemLong -- 10
replyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdo_cpp2420 77 "%0%!FUNC!: Received good reply to message %10!d! (%11!p!) - status %12!#x!" //   LEVEL=(NT_SUCCESS(replyHeader->NtStatus) ? TRACE_LEVEL_INFORMATION : TRACE_LEVEL_ERROR) FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdReply
{
messageId, ItemLong -- 10
replyHeader, ItemPtr -- 11
replyHeader->NtStatus, ItemLong -- 12
}
#typev  fdo_cpp2351 75 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdFdoDevice::RdReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  fdo_cpp3047 83 "%0Host replied to power down completion message with error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendPowerDownCompletionMsgToHost
{
pwrDownCompletionReplyHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp3038 82 "%0unable to send power down completion message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdFdoDevice::SendPowerDownCompletionMsgToHost
{
}
#typev  fdo_cpp593 28 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDeviceReply
{
}
#typev  fdo_cpp548 27 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDeviceReply
{
LpcMessage, ItemPtr -- 10
RdFdo, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  fdo_cpp527 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdOpenProcessReply
{
}
#typev  fdo_cpp379 25 "%0%!FUNC!: unable to allocate control object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdOpenProcessReply
{
}
#typev  fdo_cpp350 24 "%0%!FUNC!: no host process assoicated with device" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdOpenProcessReply
{
}
#typev  fdo_cpp316 23 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdOpenProcessReply
{
ReplyOpenProcess, ItemPtr -- 10
}
#typev  fdo_cpp295 22 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdOpenProcessReply
{
}
#typev  fdo_cpp249 21 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdOpenProcessReply
{
LpcMessage, ItemPtr -- 10
RdFdo, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  fdo_cpp2165 67 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp2138 66 "%0%!FUNC!: skipping OpenProcess message since LPC didn't initialize" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp2120 65 "%0%!FUNC! sending WdfProcMgmt_Message_OpenProcess message %10!s! w/ timeout of %11!u! secs" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
GetName(), ItemWString -- 10
queryProcessReply->ProcessTimeout, ItemLong -- 11
}
#typev  fdo_cpp2111 64 "%0unable to query process properties %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
queryProcessReplyHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp2103 63 "%0unable to query process" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp2093 62 "%0%!FUNC! sending WdfProcMgmt_Message_QueryProcess message %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
GetName(), ItemWString -- 10
}
#typev  fdo_cpp2035 61 "%0lower device set DO_POWER_INRUSH.  not supported" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp2014 60 "%0%!FUNC!: unable to attach to devnode. pdo = 0x%10!p!, status = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
m_Pdo, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  fdo_cpp1949 59 "%0m_UpperDriverOK = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
m_UpperDriverOK, ItemLong -- 10
}
#typev  fdo_cpp1919 58 "%0m_MethodNeitherAction = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
m_MethodNeitherAction, ItemLong -- 10
}
#typev  fdo_cpp1913 57 "%0invalid method neither action value in registry %10!u!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
*(PWDF_METHOD_NEITHER_ACTION_TYPE)keyInfo->Data, ItemLong -- 10
}
#typev  fdo_cpp1883 56 "%0m_NumDeviceInterfacesMax = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
m_NumDeviceInterfacesMax, ItemLong -- 10
}
#typev  fdo_cpp1858 55 "%0%!FUNC!: impersonation not allowed" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp1847 54 "%0%!FUNC!: impersonation level is set to %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
m_ImpersonationLevel, ItemLong -- 10
}
#typev  fdo_cpp1765 53 "%0%!FUNC!: unable to get allocate symbolic link list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp1746 52 "%0%!FUNC!: unable to get allocate device interface list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp1684 51 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdFdoDevice
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  fdo_cpp202 19 "%0%!FUNC!: unable to allocate RdFdoDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
}
#typev  fdo_cpp188 18 "%0%!FUNC!: unable to query pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp174 17 "%0%!FUNC!: unable to allocate memory for pdo name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
}
#typev  fdo_cpp228 20 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp163 16 "%0%!FUNC!: unable to query pdo name length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp149 15 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDevice
{
DriverObject, ItemPtr -- 10
PhysicalDeviceObject, ItemPtr -- 11
}
#enumv WudfProblem
{
WudfProblem_None,0x0
WudfProblem_Cancelled,0x1
WudfProblem_SendFailure,0x2
WudfProblem_Timeout,0x3
WudfProblem_InvalidRequest,0x4
WudfProblem_InvalidReply,0x5
WudfProblem_FailedCriticalOperation,0x6
WudfProblem_FailedToExit,0x7
WudfProblem_Disconnect,0x8
WudfProblem_LeakingHandle,0x9
WudfProblem_Max,0xA
}
#enumv WudfOperationType
{
WudfOperation_Invalid,0x0
WudfOperation_Init,0x1
WudfOperation_HostShutdown,0x2
WudfOperation_Pnp,0x3
WudfOperation_Cleanup,0x4
WudfOperation_Close,0x5
WudfOperation_Cancel,0x6
WudfOperation_IO,0x7
WudfOperation_Other,0x8
WudfOperation_Max,0x9
}
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_ADD_DEVICE,0x3
WudfMsg_CREATE,0x4
WudfMsg_CLOSE,0x5
WudfMsg_CLEANUP,0x6
WudfMsg_READ,0x7
WudfMsg_WRITE,0x8
WudfMsg_IOCONTROL,0x9
WudfMsg_Cancel,0xA
WudfMsg_DEVICE_POWER_DOWN_COMPLETE,0xB
WudfMsg_FramworkMax,0xC
WudfMsg_ExitProcess,0xD
WdfProcMgmt_Message_Reserved,0xE
WdfProcMgmt_Message_ControlObjectName,0xF
WdfProcMgmt_Message_QueryProcess,0x10
WdfProcMgmt_Message_OpenProcess,0x11
WdfProcMgmt_Message_CloseProcess,0x12
WudfMsg_Connect,0x13
WudfMsg_Max,0x14
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
64d17371-6481-7a2a-214d-e60f3f352c79 WUDFRd // SRC=pnp.cpp MJ= MN=
#typev  pnp_cpp1469 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostIrpReply
{
}
#typev  pnp_cpp1318 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostIrpReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  pnp_cpp1592 29 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostCompletionReply
{
}
#typev  pnp_cpp1509 28 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostCompletionReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  pnp_cpp1731 35 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
STATUS_MORE_PROCESSING_REQUIRED, ItemNTSTATUS -- 10
}
#typev  pnp_cpp1702 34 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
}
#typev  pnp_cpp329 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpTracker
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  pnp_cpp319 11 "%0%!FUNC!: unable to allocate workitem ..." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpTracker
{
}
#typev  pnp_cpp241 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpTracker
{
RdFdoDevice, ItemPtr -- 10
Irp, ItemPtr -- 11
Rules, ItemPtr -- 12
AssumeDeviceDisabled, ItemListLong(false,true) -- 13
}
#typev  pnp_cpp1279 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostReply
{
}
#typev  pnp_cpp1249 24 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  pnp_cpp1678 33 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
status, ItemNTSTATUS -- 10
}
#typev  pnp_cpp1673 32 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
PnpTracker, ItemPtr -- 12
}
#typev  pnp_cpp1213 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  pnp_cpp1135 22 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHost
{
Irp, ItemPtr -- 10
Completion, ItemListLong(false,true) -- 11
}
#typev  pnp_cpp1642 31 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpForwardToLowerDevice
{
}
#typev  pnp_cpp1616 30 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpForwardToLowerDevice
{
}
#typev  pnp_cpp1090 21 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpProcessor
{
}
#typev  pnp_cpp1038 20 "%0%!FUNC!: completing pnp irp 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpProcessor
{
m_Irp, ItemPtr -- 10
}
#typev  pnp_cpp774 19 "%0%!FUNC!: forward irp to host on its way DOWN" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnpProcessor
{
}
#typev  pnp_cpp719 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpProcessor
{
}
#typev  pnp_cpp1774 37 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCallbackAtPassiveInSystemProcess
{
}
#typev  pnp_cpp1758 36 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCallbackAtPassiveInSystemProcess
{
DeviceObject, ItemPtr -- 10
PnpTracker, ItemPtr -- 11
}
#typev  pnp_cpp635 16 "%0%!FUNC!: completing pnp irp %10!p! due to %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
Irp, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  pnp_cpp676 17 "%0%!FUNC!: Dispatch: returning %10!s! for PnP irp %11!p! (type %12!#x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
ntStatus, ItemNTSTATUS -- 10
Irp, ItemPtr -- 11
minorFunc, ItemLong -- 12
}
#typev  pnp_cpp590 15 "%0%!FUNC!: no preallocated pnp tracker for semi-critical irp (%10!u!, %11!u!)" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
majorFunc, ItemLong -- 10
minorFunc, ItemLong -- 11
}
#typev  pnp_cpp550 14 "%0%!FUNC!: host process is not ready for irp 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
Irp, ItemPtr -- 10
}
#typev  pnp_cpp527 13 "%0%!FUNC!: Dispatch: Received PnP irp %10!p! (type %11!#x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
Irp, ItemPtr -- 10
minorFunc, ItemLong -- 11
}
#enumv WudfProblem
{
WudfProblem_None,0x0
WudfProblem_Cancelled,0x1
WudfProblem_SendFailure,0x2
WudfProblem_Timeout,0x3
WudfProblem_InvalidRequest,0x4
WudfProblem_InvalidReply,0x5
WudfProblem_FailedCriticalOperation,0x6
WudfProblem_FailedToExit,0x7
WudfProblem_Disconnect,0x8
WudfProblem_LeakingHandle,0x9
WudfProblem_Max,0xA
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
a7fa1268-8888-a9d8-42d9-53a4054fa2da WUDFRd // SRC=DeviceInterface.cpp MJ= MN=
#typev  DeviceInterface_cpp241 12 "%0%!FUNC!: unable to enable device interface %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::EnableInterface
{
m_InterfaceSymbolicLink.Buffer, ItemWString -- 10
}
#typev  DeviceInterface_cpp290 13 "%0%!FUNC!: unable to disable device interface %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::DisableInterface
{
m_InterfaceSymbolicLink.Buffer, ItemWString -- 10
}
#typev  DeviceInterface_cpp125 11 "%0%!FUNC!: unable to register device interface %10!s!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::RdDeviceInterface
{
&m_InterfaceGuid, ItemGuid -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  DeviceInterface_cpp99 10 "%0%!FUNC!: unable to allocate a buffer for reference string" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::RdDeviceInterface
{
}
#typev  DeviceInterface_cpp387 16 "%0%!FUNC!: unable to create symbolic link. %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  DeviceInterface_cpp370 15 "%0%!FUNC!: Unable to allocate a buffer for symbolic link string" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp355 14 "%0%!FUNC!: Symbolic link name is too long, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
ntStatus, ItemNTSTATUS -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
ddb3f8f8-28f4-a8d5-f6bf-86625dfb35f0 WUDFRd // SRC=cancel.cpp MJ= MN=
#typev  cancel_cpp589 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::WaitForCancelRoutineToRun
{
}
#typev  cancel_cpp556 22 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::WaitForCancelRoutineToRun
{
CancelWorkItem, ItemPtr -- 10
}
#typev  cancel_cpp928 33 "%0%!FUNC!: host returned invalid status %10!s! for cancel message.  context 0x%11!p!, ID 0x%12!I64x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::RdCancelReply
{
ReplyHeader->NtStatus, ItemNTSTATUS -- 10
CancelWorkItem->m_CreateContext, ItemPtr -- 11
CancelWorkItem->m_RequestIdToCancel, ItemLongLongX -- 12
}
#typev  cancel_cpp918 32 "%0%!FUNC!: host asking to retry cancel message for context 0x%10!p!, ID 0x%11!I64x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::RdCancelReply
{
CancelWorkItem->m_CreateContext, ItemPtr -- 10
CancelWorkItem->m_RequestIdToCancel, ItemLongLongX -- 11
}
#typev  cancel_cpp105 11 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::RdCancelWorkItem
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp63 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!#I64x!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::RdCancelWorkItem
{
RdFdoDevice, ItemPtr -- 10
CreateContext, ItemPtr -- 11
RequestId, ItemLongLongX -- 12
}
#typev  cancel_cpp532 21 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::ClearCancelRoutine
{
cancelCalled, ItemListLong(false,true) -- 10
}
#typev  cancel_cpp505 20 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::ClearCancelRoutine
{
Irp, ItemPtr -- 10
}
#typev  cancel_cpp243 14 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::SendCancelMessage
{
}
#typev  cancel_cpp235 13 "%0%!FUNC!: cancel message for requestID 0x%10!I64x! already sent" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CANCEL FUNC=RdCancelWorkItem::SendCancelMessage
{
m_RequestIdToCancel, ItemLongLongX -- 10
}
#typev  cancel_cpp156 12 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::SendCancelMessage
{
}
#typev  cancel_cpp694 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
}
#typev  cancel_cpp658 26 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
CancelWorkItem, ItemPtr -- 10
}
#typev  cancel_cpp853 31 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::TimerCallback
{
}
#typev  cancel_cpp795 30 "%0%!FUNC!: host failed to cancel request 0x%10!I64x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::TimerCallback
{
cancelWorkItem->m_RequestIdToCancel, ItemLongLongX -- 10
}
#typev  cancel_cpp774 29 "%0%!FUNC!: found cancelWorkItem = 0x%10!p!. state = 0x%11!x!, timeout = %12!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::TimerCallback
{
cancelWorkItem, ItemPtr -- 10
cancelWorkItem->m_State, ItemLong -- 11
cancelWorkItem->m_CancelTimeoutInSec, ItemLong -- 12
}
#typev  cancel_cpp753 28 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::TimerCallback
{
}
#typev  cancel_cpp636 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
}
#typev  cancel_cpp617 24 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  cancel_cpp349 17 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::RdCancelSafeQueue
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp339 16 "%0%!FUNC!: unable to allocate timer callback packet %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::RdCancelSafeQueue
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp319 15 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::RdCancelSafeQueue
{
RdDriver, ItemPtr -- 10
}
#typev  cancel_cpp476 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::SetCancelRoutine
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp409 18 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!#I64x!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::SetCancelRoutine
{
Irp, ItemPtr -- 10
RdFdoDevice, ItemPtr -- 11
HostCreateContext, ItemPtr -- 12
RequestId, ItemLongLongX -- 13
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2008-1-19:5:53:4:843 (UTC) [tracepdb]
ecc0ad9a-2afc-4697-bf92-b7dfbfdd5386 WUDFRd // SRC=Control.cpp MJ= MN=
#typev  Control_cpp145 10 "%0cancelling irp %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDeviceCreateContext::CancelIo
{
irp, ItemPtr -- 10
}
#typev  Control_cpp210 11 "%0cancelling irp %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDeviceCreateContext::CancelSyncIo
{
irp, ItemPtr -- 10
}
#typev  Control_cpp2289 80 "%0%!FUNC!: Failed to allocate LPC message for Dx IRP complete work item %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::AllocateDevicePowerDownCompletionResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2266 79 "%0%!FUNC!: Failed to allocate memory for Dx IRP complete work item %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::AllocateDevicePowerDownCompletionResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2253 78 "%0%!FUNC!: Failed to allocate memory for Dx IRP complete work item context %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::AllocateDevicePowerDownCompletionResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2698 89 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2876 94 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp3094 100 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2612 86 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletionWithIrpTracking
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2606 85 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletionWithIrpTracking
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
CreateContext, ItemPtr -- 12
}
#typev  Control_cpp2630 88 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2626 87 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
RdCtrl, ItemPtr -- 12
}
#typev  Control_cpp2796 91 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletionWithIrpTracking
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2789 90 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletionWithIrpTracking
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
CreateContext, ItemPtr -- 12
}
#typev  Control_cpp2815 93 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2810 92 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
RdCtrl, ItemPtr -- 12
}
#typev  Control_cpp3026 97 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletionWithIrpTracking
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp3019 96 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletionWithIrpTracking
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
CreateContext, ItemPtr -- 12
}
#typev  Control_cpp3045 99 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp3040 98 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
RdCtrl, ItemPtr -- 12
}
#typev  Control_cpp3144 102 "%0%!FUNC!: Invalid symbolic link string size 0x%10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
(ULONG) symStrSz, ItemLong -- 10
}
#typev  Control_cpp3222 106 "%0Max number of symbolic links has been registered: %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
m_NumDeviceSymLinks, ItemLong -- 10
}
#typev  Control_cpp3198 105 "%0%!FUNC!: unable to find/create a object for symbolic link%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
symLnkData->SymbolicLink, ItemWString -- 10
}
#typev  Control_cpp3171 104 "%0%!FUNC!: symoblic. string %10!s! shorter than expected" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
symLnkData->SymbolicLink, ItemWString -- 10
}
#typev  Control_cpp3160 103 "%0%!FUNC!: Symbolic link name string not null terminated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp3135 101 "%0%!FUNC!: Symbolic link data too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp698 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDevice
{
}
#typev  Control_cpp680 24 "%0%!FUNC! created control object %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
GetName(), ItemWString -- 10
}
#typev  Control_cpp668 23 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp654 22 "%0unable to open a handle to self %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp633 21 "%0unable to add new ACL to the new SD %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp593 19 "%0unable to copy ace from pdo ACL to the new ACL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp578 18 "%0unable to get ace #%10!u! out of pdo ACL %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
aceIndex, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  Control_cpp616 20 "%0unable to add localservice ace to the new ACL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp562 17 "%0unable to create new ACL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
}
#typev  Control_cpp531 16 "%0unable to allocate memory security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
}
#typev  Control_cpp475 15 "%0unable to get pdo 0x%10!p! SD ACL %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
m_Pdo, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  Control_cpp452 14 "%0unable to get PDO 0x%10!p! security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
m_Pdo, ItemPtr -- 10
}
#typev  Control_cpp386 13 "%0%!FUNC!: unable to get allocate create context list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
}
#typev  Control_cpp352 12 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDevice
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  Control_cpp1860 67 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp950 32 "%0%!FUNC!: bad ref. string size 0x%10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(ULONG) refStrSize, ItemLong -- 10
}
#typev  Control_cpp1078 37 "%0device interface not registered" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1062 36 "%0max number of interfaces has been registered" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1038 35 "%0%!FUNC!: unable to find/create a object for dev interface (%10!s!, %11!s!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
interfaceGuid, ItemGuid -- 10
refString, ItemWString -- 11
}
#typev  Control_cpp1001 34 "%0%!FUNC!: ref. string %10!s! shorter than expected" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
refString, ItemWString -- 10
}
#typev  Control_cpp992 33 "%0%!FUNC!: ref. string not null terminated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp936 31 "%0%!FUNC!: ioctl data too smaller" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1184 41 "%0%!FUNC!: invalid reg key name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1203 42 "%0%!FUNC!: unable to create sub key %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
keyMsg->KeyName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  Control_cpp1167 40 "%0%!FUNC!: invalid regkey name size %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(ULONG) keyNameSizeMax, ItemLong -- 10
}
#typev  Control_cpp1154 39 "%0%!FUNC!: invalid key type" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1137 38 "%0%!FUNC!: regkey parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1298 44 "%0%!FUNC!: invalid key type" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1311 45 "%0%!FUNC!: invalid regkey/value/data size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1327 46 "%0%!FUNC!: invalid regkey/value/data size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1353 48 "%0%!FUNC!: invalid reg key name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1403 50 "%0%!FUNC!: unable to set value %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(PWSTR) (extraDataBuffer + localMsg->ValueNameOffset), ItemWString -- 10
}
#typev  Control_cpp1379 49 "%0%!FUNC!: unable to create sub key %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(PWSTR) (extraDataBuffer + localMsg->KeyNameOffset), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  Control_cpp1340 47 "%0%!FUNC!: invalid reg key name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1258 43 "%0%!FUNC!: IOCTL_RD_WRITE_VALUE_KEY parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1717 63 "%0%!FUNC!: invalid device state %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
poMsg->PowerState.DeviceState, ItemLong -- 10
}
#typev  Control_cpp1834 66 "%0%!FUNC!: PoRequestPowerIrp failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp1742 65 "%0%!FUNC!: invalid power minor function" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1732 64 "%0%!FUNC!: invalid system state %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
poMsg->PowerState.SystemState, ItemLong -- 10
}
#typev  Control_cpp1704 62 "%0%!FUNC!: IOCTL_RD_REQUEST_POWER_IRP output parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1697 61 "%0%!FUNC!: IOCTL_RD_REQUEST_POWER_IRP input parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1505 54 "%0IOCTL_RD_READ_VALUE_KEY: invalid reg key type 0x%10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
readMsg->WudfRegKeyType, ItemLong -- 10
}
#typev  Control_cpp1520 55 "%0%!FUNC!: invalid regkey/value/data size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1533 56 "%0%!FUNC!: invalid regkey/value/data size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1559 58 "%0%!FUNC!: invalid reg key name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1668 60 "%0%!FUNC!: unable to query value %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(PWSTR) (readMsg->Buffer + readMsg->ValueNameOffset), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  Control_cpp1635 59 "%0%!FUNC!: unable to open sub key %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(PWSTR) (readMsg->Buffer + readMsg->KeyNameOffset), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  Control_cpp1546 57 "%0%!FUNC!: invalid reg key name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1490 53 "%0%!FUNC!: invalid key type" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1467 52 "%0%!FUNC!: IOCTL_RD_READ_VALUE_KEY output parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1452 51 "%0%!FUNC!: IOCTL_RD_READ_VALUE_KEY input parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp873 30 "%0%!FUNC!: unable to allocate TARGET_DEVICE_CUSTOM_NOTIFICATION" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp860 29 "%0%!FUNC!: message data too large 0x%10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(ULONG) targetNotifyDataSize, ItemLong -- 10
}
#typev  Control_cpp848 28 "%0%!FUNC!: message body too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp839 27 "%0%!FUNC!: message header too smaller" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp812 26 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
Irp, ItemPtr -- 10
}
#typev  Control_cpp2116 76 "%0IOCTL_RD_SET_POWER_STATE: invalid device state %10!u! to set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
poStateMsg.DeviceState, ItemLong -- 10
}
#typev  Control_cpp2141 77 "%0IOCTL_RD_SET_POWER_STATE: invalid output buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp2105 75 "%0%!FUNC!: IOCTL_RD_SET_POWER_STATE output parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp2094 74 "%0IOCTL_RD_SET_POWER_STATE: invalid output buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp2079 73 "%0IOCTL_RD_SET_POWER_STATE: invalid input buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp2036 72 "%0IOCTL_RD_CANCEL_IO invalid filehandle" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp2015 71 "%0invalid input buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1969 70 "%0IOCTL_RD_CANCEL_IO invalid filehandle" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1943 69 "%0IOCTL_RD_CANCEL_IO invalid overlapped" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1926 68 "%0invalid input buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp2591 84 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCreate
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2546 83 "%0unable to create control object context" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreate
{
}
#typev  Control_cpp2466 82 "%0%!FUNC!: unexpect process 0x%10!p! trying to open control object ox%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreate
{
PsGetCurrentProcessId(), ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  Control_cpp2461 81 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCreate
{
Irp, ItemPtr -- 10
}
#typev  Control_cpp2913 95 "%0unexpect process 0x%10!p! trying to open send i/o to control object ox%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdReadWriteCleanup
{
PsGetCurrentProcessId(), ItemPtr -- 10
this, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:302 (UTC) [tracepdb]
458c5824-2c1c-3177-07f9-8dbf861062f6 WUDFSvc // SRC=service.cpp MJ= MN=
#typev  service_cpp510 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ReportStatusToSCMgrLockHeld
{
fResult, ItemListLong(false,true) -- 10
}
#typev  service_cpp503 22 "%0service status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ReportStatusToSCMgrLockHeld
{
GetLastError(), ItemWINERROR -- 10
}
#typev  service_cpp483 21 "%0 Entering %!FUNC!(%10!d!, %11!d!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ReportStatusToSCMgrLockHeld
{
CurrentState, ItemLong -- 10
Win32ExitCode, ItemLong -- 11
WaitHint, ItemLong -- 12
}
#typev  service_cpp556 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WaitObjectCallback
{
}
#typev  service_cpp540 26 "%0%!FUNC!: DrvMgrExt 0x%10!p! released " //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WaitObjectCallback
{
drvMgrExt, ItemPtr -- 10
}
#typev  service_cpp530 25 "%0%!FUNC!: releasing DrvMgrExt 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WaitObjectCallback
{
drvMgrExt, ItemPtr -- 10
}
#typev  service_cpp524 24 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WaitObjectCallback
{
DrvMgrExt, ItemPtr -- 10
Timeout, ItemListLong(false,true) -- 11
}
#typev  service_cpp335 20 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ServiceControlHandler
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp309 19 "%0SERVICE_CONTROL_TRY_TO_STOP" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=ServiceControlHandler
{
}
#typev  service_cpp296 18 "%0 Entering %!FUNC!(%10!d!, %11!d!, %12!p!, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ServiceControlHandler
{
ControlCode, ItemLong -- 10
EventType, ItemLong -- 11
EventData, ItemPtr -- 12
Context, ItemPtr -- 13
}
#typev  service_cpp255 17 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfServiceMain
{
Status, ItemNTSTATUS -- 10
}
#typev  service_cpp213 16 "%0%!FUNC!: RegisterWaitForSingleObject failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp189 15 "%0%!FUNC!: Unable to new WdfDriverManager %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  service_cpp179 14 "%0%!FUNC!: Unable to new WdfDriverManager %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp153 13 "%0%!FUNC!: Unable to initialize platform library %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
hr, ItemHRESULT -- 10
}
#typev  service_cpp138 12 "%0%!FUNC!: Unable to allocate termination event %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp124 11 "%0%!FUNC!: Unable to register service control handler %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp99 10 "%0 Entering %!FUNC!(%10!d!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfServiceMain
{
Argc, ItemLong -- 10
Argv, ItemPtr -- 11
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:302 (UTC) [tracepdb]
6b936008-9915-6775-0b2c-7324e4a4495a WUDFSvc // SRC=dll.cpp MJ= MN=
#typev  dll_cpp76 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=MGR_TRACE_MGR FUNC=WdfRegisterStopCallback
{
result, ItemWINERROR -- 10
}
#typev  dll_cpp69 11 "%0%!FUNC!: SvcHostGlobalData->RegisterStopCallback failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfRegisterStopCallback
{
result, ItemWINERROR -- 10
}
#typev  dll_cpp48 10 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!, %13!p!, %14!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=MGR_TRACE_MGR FUNC=WdfRegisterStopCallback
{
CallbackObject, ItemPtr -- 10
ServiceName, ItemWString -- 11
Event, ItemPtr -- 12
Callback, ItemPtr -- 13
Context, ItemPtr -- 14
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:302 (UTC) [tracepdb]
75791ea8-1b31-5064-d945-f9d715e2a17d WUDFSvc // SRC=lpcNotification.cpp MJ= MN=
#typev  lpcNotification_cpp96 11 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::DrvMgrLpcNotification
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcNotification_cpp53 10 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::DrvMgrLpcNotification
{
CmdLineArguments, ItemPtr -- 10
}
#typev  lpcNotification_cpp110 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::~DrvMgrLpcNotification
{
}
#typev  lpcNotification_cpp102 12 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::~DrvMgrLpcNotification
{
}
#typev  lpcNotification_cpp148 15 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::MarkForDelete
{
}
#typev  lpcNotification_cpp121 14 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::MarkForDelete
{
}
#typev  lpcNotification_cpp174 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsClosed
{
}
#typev  lpcNotification_cpp158 16 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsClosed
{
LpcCommPort, ItemPtr -- 10
}
#typev  lpcNotification_cpp248 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsConnected
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcNotification_cpp189 18 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsConnected
{
LpcConnPort, ItemPtr -- 10
LpcCommPort, ItemPtr -- 11
}
#typev  lpcNotification_cpp617 32 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp553 31 "%0%!FUNC!: receive WdfProcMgmt_Message_CloseProcess message" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp508 30 "%0open process is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp466 29 "%0%!FUNC!: receive WdfProcMgmt_Message_OpenProcess %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
pdoName, ItemWString -- 10
}
#typev  lpcNotification_cpp458 28 "%0%!FUNC!: invalide pdo name.  %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
hResult, ItemHRESULT -- 10
}
#typev  lpcNotification_cpp402 27 "%0%!FUNC!: receive WdfProcMgmt_Message_QueryProcess %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
pdoName, ItemWString -- 10
}
#typev  lpcNotification_cpp394 26 "%0%!FUNC!: invalide pdo name.  %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
hResult, ItemHRESULT -- 10
}
#typev  lpcNotification_cpp350 25 "%0%!FUNC!: receive WdfProcMgmt_Message_ControlObjectName %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
controlObjectName, ItemWString -- 10
}
#typev  lpcNotification_cpp342 24 "%0%!FUNC!: invalide control object name.  %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
hResult, ItemHRESULT -- 10
}
#typev  lpcNotification_cpp326 23 "%0%!FUNC!: invalide control object name offset" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp289 22 "%0request not from kernel mode" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp277 21 "%0%!FUNC!: message too small" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp267 20 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!, %13!p!, %14!d!, %15!p!, %16!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::Message
{
LpcPort, ItemPtr -- 10
ImpersonationData, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
Message, ItemPtr -- 13
MessageSize, ItemLong -- 14
DataBuffer, ItemPtr -- 15
DataBufferSize, ItemPtr -- 16
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:302 (UTC) [tracepdb]
7baa3120-d8d3-51d5-67bf-71f6acc8c404 WUDFSvc // SRC=devnode.cpp MJ= MN=
#typev  devnode_cpp631 31 "%0new SD is invalid %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp617 30 "%0unable to set new SD %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp602 29 "%0fail to init new SD %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp587 28 "%0unable to allocate a new SD" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp556 26 "%0unable to set ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp537 25 "%0unable to get ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp572 27 "%0new DACL is invalid %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp518 24 "%0unable to set ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp499 23 "%0unable to init new DACL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp483 22 "%0unable to allocate memory for new DACL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp445 21 "%0desired access already given" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp423 20 "%0unable to get ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp396 19 "%0dacl not present when it is supposed to" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp388 18 "%0unable to get SD DACL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp364 17 "%0unable to get SD control %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp347 16 "%0unable to get device parameter SD %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp331 15 "%0unable to allocate memory for SD" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp321 14 "%0unable to get device parameter key SD size %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp288 13 "%0unable to open sub key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
subKeyName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  devnode_cpp1118 49 "%0SetupDiOpenDevRegKey failed: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::OpenDeviceKey
{
GetLastError(), ItemWINERROR -- 10
}
#typev  devnode_cpp1304 62 "%0Failed to get device location info - %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp1284 61 "%0Failed to get device %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
nameType, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  devnode_cpp1233 60 "%0Failed to get device instance id - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp1217 59 "%0Failed to allocate flattened instance id buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
}
#typev  devnode_cpp1208 58 "%0Failed to allocate instance id buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
}
#typev  devnode_cpp1193 57 "%0unable to get instance id length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
GetLastError(), ItemWINERROR -- 10
}
#typev  devnode_cpp1062 48 "%0%!FUNC!: found devinfo data " //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=WdfDevNode::FindDeviceInfo
{
}
#typev  devnode_cpp1018 47 "%0%!FUNC!: could not allocate %10!I64u!l bytes to copy instance ID %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=WdfDevNode::FindDeviceInfo
{
(otherPdoNameCch * sizeof(WCHAR)), ItemULongLong -- 10
thisPdoName, ItemWString -- 11
}
#typev  devnode_cpp1008 46 "%0%!FUNC!: PdoName is too long" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=WdfDevNode::FindDeviceInfo
{
}
#typev  devnode_cpp1164 56 "%0" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
}
#typev  devnode_cpp1159 55 "%0		image path : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_SubNode.m_ServiceKeys[j]->ImagePath(), ItemWString -- 10
}
#typev  devnode_cpp1155 54 "%0		driver name : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_SubNode.m_ServiceKeys[j]->GetName(), ItemWString -- 10
}
#typev  devnode_cpp1149 53 "%0		host GUID : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_SubNode.m_HostGuid, ItemWString -- 10
}
#typev  devnode_cpp1144 52 "%0	timeout : %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_HostProcessTimeout, ItemLong -- 10
}
#typev  devnode_cpp1140 51 "%0	device name : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
GetName(), ItemWString -- 10
}
#typev  devnode_cpp1136 50 "%0devnode data :" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
}
#typev  devnode_cpp873 42 "%0Invalid configuration for Device group id. reg value type:%10!d!, Length:%11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
type, ItemLong -- 10
size, ItemLong -- 11
}
#typev  devnode_cpp880 43 "%0Device Group Id:%10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
m_DeviceGroupId, ItemWString -- 10
}
#typev  devnode_cpp828 39 "%0Invalid driver list - drivers do not use the same host GUID" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp855 41 "%0device stack too deep 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
m_StackSize, ItemLong -- 10
}
#typev  devnode_cpp837 40 "%0driver node has %10!u! stacks" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
m_StackSize, ItemLong -- 10
}
#typev  devnode_cpp809 38 "%0invalid driver list in registry" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp787 37 "%0unable to load service key : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
driverName, ItemWString -- 10
}
#typev  devnode_cpp768 36 "%0unable to allocate memory for service key object array" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp759 35 "%0invalid driver list in registry" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp743 34 "%0unable to get process timeout value. use default" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_PROCESS FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp722 33 "%0registry entry %10!s! not found" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
WDF_DRIVER_LIST, ItemWString -- 10
}
#typev  devnode_cpp704 32 "%0RegOpenKeyEx %10!s! failed: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
WDF_SUB_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  devnode_cpp957 45 "%0%!FUNC!: RD_IOCTL_SET_PROCESS_ID call failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadProcess
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp935 44 "%0unable to find host process" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadProcess
{
}
#typev  devnode_cpp139 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDevNode::WdfDevNode
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  devnode_cpp82 11 "%0unable to get host process sid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::WdfDevNode
{
}
#typev  devnode_cpp19 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDevNode::WdfDevNode
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:302 (UTC) [tracepdb]
8f776a4b-ad33-5827-9ebe-cf9f99358626 WUDFSvc // SRC=DrvMgr.cpp MJ= MN=
#typev  DrvMgr_cpp1841 62 "%0unable to find driver in system directory %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1825 61 "%0unable to find image path for driver: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
FileName, ItemWString -- 10
}
#typev  DrvMgr_cpp1814 60 "%0unable to get full path length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1798 59 "%0unable to find system directory %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1787 58 "%0unable to allocate system directory buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
}
#typev  DrvMgr_cpp1903 65 "%0driver host guid %10!s! not in {...} format" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
uuidCopy, ItemWString -- 10
}
#typev  DrvMgr_cpp1920 66 "%0invalid host guid: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
uuidCopy, ItemWString -- 10
}
#typev  DrvMgr_cpp1890 64 "%0unable to allocate memory need to validate GUID string" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
}
#typev  DrvMgr_cpp1880 63 "%0guid string too short: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
Guid, ItemWString -- 10
}
#typev  DrvMgr_cpp2081 71 "%0Created activity log." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
}
#typev  DrvMgr_cpp2044 70 "%0Failed to configure activity trace: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
hr, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp2023 69 "%0Failed to create activity log session: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
hr, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp1998 68 "%0Failed to create log directory security descriptor: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1950 67 "%0Starting activity log" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
}
#typev  DrvMgr_cpp2096 72 "%0Stopped activity log." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StopActivityLog
{
}
#typev  DrvMgr_cpp2242 74 "%0unable to enable device %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::EnableDevice
{
cmResult, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp2295 75 "%0unable to disable device %10!s!.  veto type = 0x%11!x!, veto name %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::DisableDevice
{
cmResult, ItemHRESULT -- 10
vetoType, ItemLong -- 11
vetoName, ItemWString -- 12
}
#typev  DrvMgr_cpp235 16 "%0%!FUNC!: unable to get system directory %10!s!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::InitializePlatformLibrary
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1149 39 "%0m_DefaultHostProcessGUID = %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_DefaultHostProcessGUID, ItemWString -- 10
}
#typev  DrvMgr_cpp1136 38 "%0registry entry %10!s! not found" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::LoadRegistrySettings
{
WDF_DEFAULT_HOST_PROCESS_GUID, ItemWString -- 10
}
#typev  DrvMgr_cpp1120 37 "%0invalid max. number of device stacks%10!u!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp1114 36 "%0m_NumDeviceStacksMax = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp1108 35 "%0unable to get process exit timeout value. use default" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
}
#typev  DrvMgr_cpp1069 34 "%0invalid max. number of device stacks%10!u!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp1063 33 "%0m_NumDeviceStacksMax = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp1057 32 "%0unable to get process exit timeout value. use default" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
}
#typev  DrvMgr_cpp1038 31 "%0unable to open reg key %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
WDF_ROOT_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  DrvMgr_cpp1379 42 "%0 Exiting  %!FUNC! => (true)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetControlObject
{
}
#typev  DrvMgr_cpp1376 41 "%0 Exiting  %!FUNC! => (false)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetControlObject
{
}
#typev  DrvMgr_cpp1335 40 "%0 Entering %!FUNC!(%10!s!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetControlObject
{
ControlObjectName, ItemWString -- 10
ControlObjectNameLen, ItemPtr -- 11
}
#typev  DrvMgr_cpp1486 46 "%0waited %10!u! msec before trying to enable device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
DRVMGR_DEVICE_RESTART_MAX_WAIT_MSEC - retryCount * DRVMGR_DEVICE_RESTART_DELAY_100_MSEC, ItemLong -- 10
}
#typev  DrvMgr_cpp1462 45 "%0%!FUNC!: unable to get device status 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
configRet, ItemLong -- 10
}
#typev  DrvMgr_cpp1442 44 "%0%!FUNC!: SetupDiOpenDeviceInfo() failed %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1425 43 "%0%!FUNC!: unable to get devinfoset %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1764 57 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetRdProcessId
{
bResult, ItemListLong(false,true) -- 10
}
#typev  DrvMgr_cpp1748 56 "%0%!FUNC!: RD_IOCTL_SET_PROCESS_ID call failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::SetRdProcessId
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1728 55 "%0%!FUNC!: unable to open control object %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
m_NtControlObjectName, ItemWString -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  DrvMgr_cpp1705 54 "%0%!FUNC!: unable to copy pdo name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
PdoName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1691 53 "%0%!FUNC!: unable to copy system event port name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
SystemEventPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1676 52 "%0%!FUNC!: unable to copy io cancel port name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
IoCancelPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1661 51 "%0%!FUNC!: unable to copy io event port name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
IoEventPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1647 50 "%0%!FUNC!: unable to allocate set pid message 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
(DWORD) messageSize, ItemLong -- 10
}
#typev  DrvMgr_cpp1637 49 "%0%!FUNC!: set pid message too large 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
(DWORD) messageSize, ItemLong -- 10
}
#typev  DrvMgr_cpp1618 48 "%0%!FUNC!: invalid pdo name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
PdoName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1601 47 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!s!, %13!s!, %14!s!, %15!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetRdProcessId
{
ProcessHandle, ItemPtr -- 10
IoEventPortName, ItemWString -- 11
IoCancelPortName, ItemWString -- 12
SystemEventPortName, ItemWString -- 13
PdoName, ItemWString -- 14
ProcessTimeout, ItemLong -- 15
}
#typev  DrvMgr_cpp2593 83 "%0numDeviceSucceeded: %10!u!. numDeviceFailed: %11!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
numDeviceSucceeded, ItemLong -- 10
numDeviceFailed, ItemLong -- 11
}
#typev  DrvMgr_cpp2529 82 "%0found a umdf device: status 0x%10!x! and problem 0x%11!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
deviceStatus, ItemLong -- 10
deviceProblem, ItemLong -- 11
}
#typev  DrvMgr_cpp2435 80 "%0%!FUNC!: unable to get device status 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
configRet, ItemLong -- 10
}
#typev  DrvMgr_cpp2420 79 "%0%!FUNC!: unable to get device detail %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp2399 78 "%0%!FUNC!: unable to get devinfoset %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp2373 77 "%0Disabling all UMDF device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
}
#typev  DrvMgr_cpp2368 76 "%0Enabling all UMDF device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
}
#typev  DrvMgr_cpp2680 84 "%0Unexpected error code when getting device property %10!d! size - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
bResult ? NO_ERROR : winerr, ItemWINERROR -- 11
}
#typev  DrvMgr_cpp2769 88 "%0Error retrieving device property %10!d! - %11!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
winerr, ItemWINERROR -- 11
}
#typev  DrvMgr_cpp2735 87 "%0Error allocating buffer for property %10!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
}
#typev  DrvMgr_cpp2721 86 "%0Integer overflow for property %10!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
}
#typev  DrvMgr_cpp2700 85 "%0Unexpected datatype for device property %10!d! - %11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
dataType, ItemLong -- 11
}
#typev  DrvMgr_cpp173 15 "%0unable to create default imagepath %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
hResult, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp163 14 "%0unable to allocate memory for imagepath" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
}
#typev  DrvMgr_cpp151 13 "%0unable to find image path for driver: %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
GetName(), ItemWString -- 10
}
#typev  DrvMgr_cpp128 12 "%0unable to get host process guid" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
}
#typev  DrvMgr_cpp104 11 "%0unable to open service key %10!s! : %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
GetName(), ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  DrvMgr_cpp85 10 "%0unable to open service root key : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
result, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp749 28 "%0%!FUNC!: about to be done with WdfDriverManager::~WdfDriverManager 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::~WdfDriverManager
{
this, ItemPtr -- 10
}
#typev  DrvMgr_cpp687 27 "%0calling ~WdfDriverManager..." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::~WdfDriverManager
{
}
#typev  DrvMgr_cpp954 30 "%0unable to disable all UMDF Device" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::Stop
{
}
#typev  DrvMgr_cpp2197 73 "%0Unable to queue workitem to restart devices %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::PostRestartDeviceWorkItem
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp588 26 "%0unable to create lpc object directory %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
hostPortNamePrefix, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  DrvMgr_cpp573 25 "%0unable to get lpc interface" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
}
#typev  DrvMgr_cpp526 24 "%0%!FUNC!: unable to convert service SID into a string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp485 23 "%0unable to get local service sid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::WdfDriverManager
{
}
#typev  DrvMgr_cpp474 22 "%0unable to GetTokenInformation %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp457 21 "%0unable to allocate %10!u! bytes for user token info" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
returnLength, ItemLong -- 10
}
#typev  DrvMgr_cpp447 20 "%0GetTokenInformation did not fail with ERROR_INSUFFICIENT_BUFFER" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
}
#typev  DrvMgr_cpp438 19 "%0GetTokenInformation did not fail" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
}
#typev  DrvMgr_cpp422 18 "%0unable to open process token %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp345 17 "%0Calling WdfDriverManager::WdfDriverManager()...1" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
}
#typev  DrvMgr_cpp837 29 "%0Unable to queue workitem to call PrepareToUnload %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::PrepareToStop
{
winerr, ItemWINERROR -- 10
}
// PDB:  o:\rtm.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2008-1-19:5:52:51:302 (UTC) [tracepdb]
ffdded59-0774-0e9e-1e96-0527b7c17e1d WUDFSvc // SRC=process.cpp MJ= MN=
#typev  process_cpp1192 41 "%0host process debugger enabled.  override process timeout" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::QueryProcessTimeout
{
}
#typev  process_cpp1182 40 "%0unable to get host process timeout. use default" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::QueryProcessTimeout
{
}
#typev  process_cpp1164 39 "%0unable to get host process timeout. use default" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::QueryProcessTimeout
{
}
#typev  process_cpp1141 38 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::QueryProcessTimeout
{
HostGuid, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp1124 37 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::QueryProcessTimeout
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp779 35 "%0unable to query %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::LoadRegistrySettings
{
WDF_DRIVER_HOST_IMAGE_PATH, ItemWString -- 10
}
#typev  process_cpp761 34 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::LoadRegistrySettings
{
GetName(), ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp745 33 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::LoadRegistrySettings
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp976 36 "%0::TerminateProcess() failed %10!s!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::TerminateProcess
{
shutdownStatus, ItemWINERROR -- 10
}
#typev  process_cpp544 29 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::WdfProcess
{
NT_SUCCESS(ntStatus), ItemListLong(false,true) -- 10
}
#typev  process_cpp505 28 "%0unable to connect to host process lpc port %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
m_EventPortName[WdfEventPort_System], ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  process_cpp474 27 "%0hostProcess terminated unexpectedly" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp441 26 "%0unable to get host process to start running %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp404 25 "%0unable to generate path to host process log files - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
hResult, ItemHRESULT -- 10
}
#typev  process_cpp380 24 "%0unable to create hostProcess: %10!s!. RunningAsLocalService() = %11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
DrvMgrExt->RunningAsLocalService(), ItemLong -- 11
}
#typev  process_cpp355 23 "%0unable to LogonUser: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp307 22 "%0CreateProcess cmdbuf: imagepath:%10!s! args:%11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
m_HostImagePath, ItemWString -- 10
cmdBuf, ItemWString -- 11
}
#typev  process_cpp297 21 "%0unable to compose create process command %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp222 18 "%0unable to construct server port name HostProcess-%10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
baseName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  process_cpp189 16 "%0unable to allocate memory for server port name %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
portNameIndex, ItemLong -- 10
}
#typev  process_cpp169 15 "%0unable to create server port name string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp159 14 "%0unable to create GUID for server portname %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp275 20 "%0unable to allocate cmdline buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp267 19 "%0createprocess cmd length = 0x%10!I64x! characters" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
(ULONGLONG) cmdBufLen, ItemLongLongX -- 10
}
#typev  process_cpp205 17 "%0unable to construct server port name %10!s!\HostProcess-%11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
hostPortNamePrefix, ItemWString -- 10
baseName, ItemWString -- 11
hResult, ItemHRESULT -- 12
}
#typev  process_cpp142 13 "%0Unable to convert lifetime ID to string: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp126 12 "%0Unable to create lifetime ID for new host process: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp96 11 "%0Unable to allocate memory for copying Device Group Id string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp39 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::WdfProcess
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  process_cpp715 32 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::~WdfProcess
{
}
#typev  process_cpp673 31 "%0process not terminating gracefully: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::~WdfProcess
{
result, ItemWINERROR -- 10
}
#typev  process_cpp590 30 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::~WdfProcess
{
}
