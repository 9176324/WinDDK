// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
5105b425-2425-c7fc-1791-9080d5a9e639 WUDFPlatform // SRC=TraceSession.cpp MJ= MN=
#typev  TraceSession_cpp407 17 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLAGS, ItemWString -- 10
logFlags, ItemLong -- 11
}
#typev  TraceSession_cpp392 16 "%0%10!s! has invalid value %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp385 15 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp366 14 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLUSH_PERIOD_SECONDS, ItemWString -- 10
flushPeriod, ItemLong -- 11
}
#typev  TraceSession_cpp348 13 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_KD, ItemWString -- 10
logKd, ItemLong -- 11
}
#typev  TraceSession_cpp330 12 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_START_NEW_SESSION, ItemWString -- 10
logStartNewSession, ItemLong -- 11
}
#typev  TraceSession_cpp309 11 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_ENABLE, ItemWString -- 10
logEnable, ItemLong -- 11
}
#typev  TraceSession_cpp288 10 "%0Error opening configuration registry key %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
RegistryBase, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  TraceSession_cpp609 18 "%0Caller requested private logger but set no default GUIDs" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_TRACING FUNC=CTraceSession::Start
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
9d7fbdc2-b196-6cfe-6c1c-2b14f637ed3e WUDFPlatform // SRC=PlatformStackTracker.cpp MJ= MN=
#typev  PlatformStackTracker_cpp178 11 "%0Failed to initialize symbols, stack tracking will not work, error: %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::InnerLoadSymbols
{
hr, ItemHRESULT -- 10
}
#typev  PlatformStackTracker_cpp302 15 "%0Unable to load symbols for module %10!s!, error %11!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp291 14 "%0Moduel %10!s! already loaded" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
}
#typev  PlatformStackTracker_cpp247 13 "%0Unable to convert module name to ASCII string, WideCharToMultiByte failed for %10!s!, error %11!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp219 12 "%0GetModuleInformation failed for %10!s!, error %11!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp368 17 "%0SymUnloadModule64 failed for module %10!p!, error %11!s!, unable to unload module symbols" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::UnloadModule
{
hMod, ItemPtr -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp343 16 "%0GetModuleInformation failed for module %10!p!, error %11!s!, unable to unload module symbols" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::UnloadModule
{
hMod, ItemPtr -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp124 10 "%0Failed to load imports for dbghelp.dll, stack tracking will not work, error: %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::Configure
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
b6e0b5b1-cc16-ab1e-38f1-9673e8920e44 WUDFPlatform // SRC=platform.cpp MJ= MN=
#typev  platform_cpp1484 21 "%0unable to get userSid. err = %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
err, ItemWINERROR -- 10
}
#typev  platform_cpp1466 20 "%0unable to get domainName buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1459 19 "%0unable to get userSid buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1428 18 "%0username: %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
userName, ItemWString -- 10
}
#typev  platform_cpp1420 17 "%0unable to get username. err = %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
err, ItemWINERROR -- 10
}
#typev  platform_cpp1408 16 "%0unable to get username buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1573 23 "%0Error reading registry value %10!s!.  er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  platform_cpp1545 22 "%0Registry value %10!s! was expected to be a REG_DWORD." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
}
#typev  platform_cpp2239 26 "%0MiniDumpWriteDump succeeded" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
}
#typev  platform_cpp2226 25 "%0MiniDumpWriteDump failed with error %10!x!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
result, ItemLong -- 10
}
#typev  platform_cpp375 11 "%0Error %10!s! trying to open root registry key %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
result, ItemWINERROR -- 10
WDF_ROOT_KEY, ItemWString -- 11
}
#typev  platform_cpp363 10 "%0Minidump flags set to %10!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
g_MiniDumpType, ItemLong -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
b6e0b5b1-cc16-ab1e-38f1-9673e8920e44 WUDFPlatform // SRC=platform.cpp MJ= MN=
#typev  platform_cpp601 15 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp589 14 "%0Failed to allocate %10!I64u! bytes for directory path string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
(logPathCch * sizeof(WCHAR)), ItemULongLong -- 10
}
#typev  platform_cpp577 13 "%0Log directory path is too long (%10!I64u!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
logPathCch, ItemULongLong -- 10
}
#typev  platform_cpp564 12 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp2106 24 "%0Create dump file %10!s! failed with error %11!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcess
{
m_ProcessInfo.FullDumpFileName, ItemWString -- 10
GetLastError(), ItemLong -- 11
}
#typev  platform_cpp3200 30 "%0WUDF Host Problem %10!s! (pid %11!#x!) detected by %12!s! - exit code is %13!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::ReportHostProblem
{
Problem->ProblemCode, ItemEnum(WudfOperationType) -- 10
GetProcessId(HostProcess), ItemLong -- 11
Problem->Detector, ItemEnum(WdfComponentType) -- 12
Problem->ExitCode, ItemLong -- 13
}
#typev  platform_cpp3464 31 "%0Unexpected error code when getting device property %10!d! size - %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
bResult ? NO_ERROR : winerr, ItemWINERROR -- 11
}
#typev  platform_cpp3553 35 "%0Error retrieving device property %10!d! - %11!s!." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
winerr, ItemWINERROR -- 11
}
#typev  platform_cpp3519 34 "%0Error allocating buffer for property %10!d!." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
}
#typev  platform_cpp3505 33 "%0Integer overflow for property %10!d!." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
}
#typev  platform_cpp3484 32 "%0Unexpected datatype for device property %10!d! - %11!d!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
dataType, ItemLong -- 11
}
#typev  platform_cpp3708 38 "%0Canonicalization: Path %10!s! ends with trailing . or space." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3724 39 "%0Canonicalization: Path %10!s! does not start with [a-z]:\." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3853 46 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3840 45 "%0Canonicalization: Error allocating %10!Iu! characters for long path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
longPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3820 44 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3799 43 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3786 42 "%0Canonicalization: Error allocating %10!Iu! characters for path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3766 41 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3746 40 "%0Canonicalization: Found invalid character %10!hd! at position %11!Iu! in path %12!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path[invalidCharacterIndex], ItemShort -- 10
invalidCharacterIndex, ItemPtr -- 11
Path, ItemWString -- 12
}
#typev  platform_cpp3694 37 "%0Canonicalization: File name is too short." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp3674 36 "%0Canonicalization: File name is an invalid length. (too long or not null terminated - unsafe to print" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp2688 27 "%0WUDF DriverStop %10!s! error %11!#I64x! component %12!s!
	@ %13!s!:
%14!s! Context Record: 0x%15!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::InnerDriverStop
{
g_pwszErrorTypeNames[Type], ItemWString -- 10
ErrorNumber, ItemLongLongX -- 11
g_pwszComponentNames[Platform->m_ProcessInfo.Component], ItemWString -- 12
Location, ItemWString -- 13
Message ? Message : '', ItemString -- 14
ContextRecord, ItemPtr -- 15
}
#typev  platform_cpp2870 29 "%0Parameter %10!d!: %11!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
parameterNumber, ItemLong -- 10
(PVOID) exception->ExceptionInformation[parameterNumber], ItemPtr -- 11
}
#typev  platform_cpp2847 28 "%0WUDF Unhandled Exception %10!#x! @ %11!p!. %12!d! parameters, Exception Record: 0x%13!p!, Context Record: 0x%14!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
exception->ExceptionCode, ItemLong -- 10
exception->ExceptionAddress, ItemPtr -- 11
exception->NumberParameters, ItemLong -- 12
exception, ItemPtr -- 13
ExceptionInfo->ContextRecord, ItemPtr -- 14
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
5f07402d-39e7-6bcd-6bdb-a171c9ee1c2b WUDFPlatform // SRC=host.cpp MJ= MN=
#typev  host_cpp476 14 "%0No kernel-mode debugger found." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp427 11 "%0User-mode debugger found - breaking in." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp464 13 "%0Breaking into kernel debugger." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp449 12 "%0No user-mode debugger found." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp416 10 "%0Waiting %10!d! seconds for debugger to attach." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
TimeoutSeconds, ItemLong -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp807 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp770 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp791 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp779 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp759 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp754 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp884 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp828 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp870 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp858 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp849 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp837 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp821 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp403 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp435 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp411 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp370 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp320 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp311 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp300 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp291 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp264 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp254 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp215 10 "%0 Entering %!FUNC!(%10!d!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
}
#typev  lpc_cpp561 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp483 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp461 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp443 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp635 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
e3d371a0-5422-d400-cdb7-07a576e6a4f2 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp262 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp250 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp486 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp466 30 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp446 29 "%0Unable to allocate reply callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp430 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp376 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp335 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp717 43 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp858 47 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp832 46 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp813 45 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp740 44 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp994 53 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp944 51 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp973 52 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp934 50 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp891 48 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1079 58 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1049 56 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1062 57 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp1021 55 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 54 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1104 60 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1093 59 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1194 64 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1169 63 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp686 42 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp560 33 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp579 35 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp660 41 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp649 40 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp635 39 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp613 38 "%0attribute size must be at least as large as the header size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp605 37 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp586 36 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp567 34 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp548 32 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
#typev  lpcmsg_cpp1157 62 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1116 61 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
147907a8-e922-8ed0-8ea6-9976b6b58652 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp118 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp104 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp91 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp78 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp56 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp48 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp22 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
#typev  lpcport_cpp133 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp124 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp338 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp178 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp213 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp306 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp317 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp234 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp328 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp164 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
fbcfe4f1-9b5a-9a2c-9f9c-e8a9d6e3f6b2 lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp289 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp269 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp900 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp436 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp487 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp461 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp420 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp794 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp808 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp749 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp690 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp552 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp643 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp632 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp613 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp223 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp203 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp109 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp94 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp81 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp61 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp24 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
22e1f7fa-2125-1c07-1b43-521f9bd0000a lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp85 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp66 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp36 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp20 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp199 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp181 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp154 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
8f605a8c-fa48-c180-a420-4572073665c3 lpc // SRC=lpc_xp.cpp MJ= MN=
#typev  lpc_xp_cpp225 10 "%0lpcport got a message!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WorkerThread
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:400 (UTC) [tracepdb]
4fe201c1-70dd-3f9f-78a6-f2dc2be72eb9 LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp166 12 "%0I/O operation (GetOverlappedResult) failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCoreSendWaitIoctl
{
dwResult, ItemWINERROR -- 10
}
#typev  lpccore_cpp155 11 "%0I/O operation (DeviceIoControl) failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCoreSendWaitIoctl
{
dwResult, ItemWINERROR -- 10
}
#typev  lpccore_cpp128 10 "%0unable to create an event for I/O operation %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCoreSendWaitIoctl
{
dwResult, ItemWINERROR -- 10
}
#typev  lpccore_cpp269 14 "%0%!FUNC!: unable to create listen object %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfLpcCorePortInterface::Listen
{
listenDeviceName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp240 13 "%0unable to construct server port name %10!s!\%11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Listen
{
WUDFLPC_DEVICE_DOSNAME, ItemWString -- 10
ServerPortName, ItemWString -- 11
hResult, ItemHRESULT -- 12
}
#typev  lpccore_cpp365 16 "%0%!FUNC!: unable to connect to %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfLpcCorePortInterface::Connect
{
serverDeviceFullName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp337 15 "%0unable to construct server port name \\.\%10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Connect
{
ServerPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  lpccore_cpp417 17 "%0WUDFLPC_CLOSE_COMM_PORT_HANDLE_INPUT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DeletePort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp533 18 "%0IOCTL_LPC_SEND_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SendMessageW
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp697 20 "%0bytesReturned (0x%10!x!) not same as expected (0x%11!x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::CreateResourceReserve
{
bytesReturned, ItemLong -- 10
sizeof(output), ItemLong -- 11
}
#typev  lpccore_cpp686 19 "%0IOCTL_LPC_RESERVE_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::CreateResourceReserve
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp746 21 "%0IOCTL_LPC_RELEASE_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DeleteResourceReserve
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp897 24 "%0IOCTL_LPC_IMPERSONATE_CLIENT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ImpersonateClientOfPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp883 23 "%0waiting for IOCTL_LPC_IMPERSONATE_CLIENT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ImpersonateClientOfPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp850 22 "%0unable to create an event for IOCTL_LPC_IMPERSONATE_CLIENT %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ImpersonateClientOfPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp976 25 "%0unable to duplicate connection handle for communication handle %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::AcceptConnectPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp1093 26 "%0IOCTL_LPC_SEND_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SendWaitReceivePort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp1181 27 "%0WUDFLPC_CLOSE_COMM_PORT_HANDLE_INPUT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DisconnectPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp1294 28 "%0CWdfLpcCorePortInterface::SetAccessControl failure with %10!s! & %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SetAccessControl
{
ntStatus, ItemNTSTATUS -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp1365 29 "%0IOCTL_LPC_CLEAR_ACCESS_CONTROL failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ClearAccessControl
{
winerr, ItemWINERROR -- 10
}
b6e0b5b1-cc16-ab1e-38f1-9673e8920e44 e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
#enumv WudfOperationType
{
WudfOperation_Invalid,0x0
WudfOperation_Init,0x1
WudfOperation_HostShutdown,0x2
WudfOperation_Pnp,0x3
WudfOperation_Cleanup,0x4
WudfOperation_Close,0x5
WudfOperation_Cancel,0x6
WudfOperation_IO,0x7
WudfOperation_Other,0x8
WudfOperation_Max,0x9
}
#enumv WdfComponentType
{
WdfComponentInvalid,0x0
WdfComponentPlatform,0x1
WdfComponentReflector,0x2
WdfComponentDriverManager,0x3
WdfComponentHost,0x4
WdfComponentFramework,0x5
WdfComponentTest,0x6
WdfComponentMax,0x7
}
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\xp\objfre\i386\WUDFPlatform.pdb
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_CREATE_DEVICE_STACK,0x3
WudfMsg_ADD_DEVICE,0x4
WudfMsg_CREATE,0x5
WudfMsg_CLOSE,0x6
WudfMsg_CLEANUP,0x7
WudfMsg_READ,0x8
WudfMsg_WRITE,0x9
WudfMsg_IOCONTROL,0xA
WudfMsg_FLUSH,0xB
WudfMsg_QUERY_INFORMATION_FILE,0xC
WudfMsg_SET_INFORMATION_FILE,0xD
WudfMsg_Cancel,0xE
WudfMsg_POWER_IRP_COMPLETE,0xF
WudfMsg_USB_SS_EVENT,0x10
WudfMsg_CLOSE_DEVICE_STACK,0x11
WudfMsg_REMOTE_INTERFACE_ARRIVAL,0x12
WudfMsg_REMOTE_INTERFACE_REMOVAL,0x13
WudfMsg_TARGET_DEVICE_NOTIFICATION,0x14
WudfMsg_TRANSPORT_QUERY_ID,0x15
WudfMsg_FramworkMax,0x16
WudfMsg_ExitProcess,0x17
WdfProcMgmt_Message_Reserved,0x18
WdfProcMgmt_Message_ControlObjectName,0x19
WdfProcMgmt_Message_QueryProcess,0x1A
WdfProcMgmt_Message_OpenProcess,0x1B
WdfProcMgmt_Message_CloseProcess,0x1C
WudfMsg_Connect,0x1D
WudfMsg_WMI_POWER_DATA,0x1E
WudfMsg_Max,0x1F
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
8b6af58f-6b5c-0c7c-ecf0-2a259db58e55 WUDFPlatform // SRC=WerReport.cpp MJ= MN=
#typev  WerReport_cpp546 10 "%0%!FUNC!: Error %10!s! adding dump to report." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::AddDump
{
hr, ItemHRESULT -- 10
}
#typev  WerReport_cpp599 11 "%0%!FUNC!: Error %10!s! generating dump for report." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::GenerateAndAddDump
{
hr, ItemHRESULT -- 10
}
#typev  WerReport_cpp650 13 "%0%!FUNC!: Result of submitting incident report is %10!d!." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::Submit
{
result, ItemLong -- 10
}
#typev  WerReport_cpp643 12 "%0%!FUNC!: Error %10!s! submitting report." //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_ERROR_REPORTING FUNC=CWerReport::Submit
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
7db16af6-89c3-d366-cffd-08e8cf51554b WUDFPlatform // SRC=platform_lh.cpp MJ= MN=
#typev  platform_lh_cpp99 12 "%0%!FUNC!: unable to get service sid size %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=CPlatform::AllocateServiceSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  platform_lh_cpp86 11 "%0%!FUNC!: unable to allocate allocate sid buffer of %10!u! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=CPlatform::AllocateServiceSid
{
serviceSidSize, ItemLong -- 10
}
#typev  platform_lh_cpp76 10 "%0%!FUNC!: unable to get service sid size %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=CPlatform::AllocateServiceSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  platform_lh_cpp827 22 "%0%!FUNC!: Successfully adjusted token default DACL to include Host SID" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
}
#typev  platform_lh_cpp817 21 "%0%!FUNC!: Unable to set TokenDefaultDacl, status %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp806 20 "%0%!FUNC!: Unable to set TokenDefaultDacl due to space issues, don't adjust DACL, status %10!d!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp777 19 "%0%!FUNC!: Unable to add service SID ACE to DACL, status %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp762 18 "%0%!FUNC!: Unable to add OWNER ACE to DACL, status %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp747 17 "%0%!FUNC!: Unable to add SYSTEM ACE to DACL, status %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp732 16 "%0%!FUNC!: Unable to allocate initialize DACL, status %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp719 15 "%0%!FUNC!: Unable to allocate default DACL buffer, status %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp702 14 "%0%!FUNC!: Unable to create Owner SID - %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
#typev  platform_lh_cpp689 13 "%0%!FUNC!: Unable to create LocalSytem SID - %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=AdjustTokenDefaultDacl
{
status, ItemLong -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
5105b425-2425-c7fc-1791-9080d5a9e639 WUDFPlatform // SRC=TraceSession.cpp MJ= MN=
#typev  TraceSession_cpp407 17 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLAGS, ItemWString -- 10
logFlags, ItemLong -- 11
}
#typev  TraceSession_cpp392 16 "%0%10!s! has invalid value %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp385 15 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_LEVEL, ItemWString -- 10
logLevel, ItemLong -- 11
}
#typev  TraceSession_cpp366 14 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_FLUSH_PERIOD_SECONDS, ItemWString -- 10
flushPeriod, ItemLong -- 11
}
#typev  TraceSession_cpp348 13 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_KD, ItemWString -- 10
logKd, ItemLong -- 11
}
#typev  TraceSession_cpp330 12 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_START_NEW_SESSION, ItemWString -- 10
logStartNewSession, ItemLong -- 11
}
#typev  TraceSession_cpp309 11 "%0%10!s! = %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
WDF_LOG_ENABLE, ItemWString -- 10
logEnable, ItemLong -- 11
}
#typev  TraceSession_cpp288 10 "%0Error opening configuration registry key %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CTraceSession::ConfigureSessionFromRegistry
{
RegistryBase, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  TraceSession_cpp609 18 "%0Caller requested private logger but set no default GUIDs" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_TRACING FUNC=CTraceSession::Start
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
9d7fbdc2-b196-6cfe-6c1c-2b14f637ed3e WUDFPlatform // SRC=PlatformStackTracker.cpp MJ= MN=
#typev  PlatformStackTracker_cpp178 11 "%0Failed to initialize symbols, stack tracking will not work, error: %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::InnerLoadSymbols
{
hr, ItemHRESULT -- 10
}
#typev  PlatformStackTracker_cpp302 15 "%0Unable to load symbols for module %10!s!, error %11!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp291 14 "%0Moduel %10!s! already loaded" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
}
#typev  PlatformStackTracker_cpp247 13 "%0Unable to convert module name to ASCII string, WideCharToMultiByte failed for %10!s!, error %11!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp219 12 "%0GetModuleInformation failed for %10!s!, error %11!s!, stack tracking may not work reliably" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::LoadModule
{
ModuleName, ItemWString -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp368 17 "%0SymUnloadModule64 failed for module %10!p!, error %11!s!, unable to unload module symbols" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::UnloadModule
{
hMod, ItemPtr -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp343 16 "%0GetModuleInformation failed for module %10!p!, error %11!s!, unable to unload module symbols" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::UnloadModule
{
hMod, ItemPtr -- 10
dwErr, ItemWINERROR -- 11
}
#typev  PlatformStackTracker_cpp124 10 "%0Failed to load imports for dbghelp.dll, stack tracking will not work, error: %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatformStackTracker::Configure
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
b6e0b5b1-cc16-ab1e-38f1-9673e8920e44 WUDFPlatform // SRC=platform.cpp MJ= MN=
#typev  platform_cpp1484 21 "%0unable to get userSid. err = %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
err, ItemWINERROR -- 10
}
#typev  platform_cpp1466 20 "%0unable to get domainName buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1459 19 "%0unable to get userSid buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1428 18 "%0username: %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
userName, ItemWString -- 10
}
#typev  platform_cpp1420 17 "%0unable to get username. err = %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
err, ItemWINERROR -- 10
}
#typev  platform_cpp1408 16 "%0unable to get username buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_SECURITY FUNC=CPlatform::AllocateMySid
{
}
#typev  platform_cpp1573 23 "%0Error reading registry value %10!s!.  er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  platform_cpp1545 22 "%0Registry value %10!s! was expected to be a REG_DWORD." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_CONFIG FUNC=CPlatform::s_ReadRegistryDword
{
ValueName, ItemWString -- 10
}
#typev  platform_cpp2239 26 "%0MiniDumpWriteDump succeeded" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
}
#typev  platform_cpp2226 25 "%0MiniDumpWriteDump failed with error %10!x!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcessWorker
{
result, ItemLong -- 10
}
#typev  platform_cpp375 11 "%0Error %10!s! trying to open root registry key %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
result, ItemWINERROR -- 10
WDF_ROOT_KEY, ItemWString -- 11
}
#typev  platform_cpp363 10 "%0Minidump flags set to %10!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeClass
{
g_MiniDumpType, ItemLong -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
b6e0b5b1-cc16-ab1e-38f1-9673e8920e44 WUDFPlatform // SRC=platform.cpp MJ= MN=
#typev  platform_cpp601 15 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp589 14 "%0Failed to allocate %10!I64u! bytes for directory path string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
(logPathCch * sizeof(WCHAR)), ItemULongLong -- 10
}
#typev  platform_cpp577 13 "%0Log directory path is too long (%10!I64u!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
logPathCch, ItemULongLong -- 10
}
#typev  platform_cpp564 12 "%0Failed to retrieve windows directory name: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=PLATFORM_TRACE_INIT FUNC=CPlatform::InitializeInstance
{
GetLastError(), ItemWINERROR -- 10
}
#typev  platform_cpp2106 24 "%0Create dump file %10!s! failed with error %11!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::DumpProcess
{
m_ProcessInfo.FullDumpFileName, ItemWString -- 10
GetLastError(), ItemLong -- 11
}
#typev  platform_cpp3200 30 "%0WUDF Host Problem %10!s! (pid %11!#x!) detected by %12!s! - exit code is %13!d!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::ReportHostProblem
{
Problem->ProblemCode, ItemEnum(WudfOperationType) -- 10
GetProcessId(HostProcess), ItemLong -- 11
Problem->Detector, ItemEnum(WdfComponentType) -- 12
Problem->ExitCode, ItemLong -- 13
}
#typev  platform_cpp3464 31 "%0Unexpected error code when getting device property %10!d! size - %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
bResult ? NO_ERROR : winerr, ItemWINERROR -- 11
}
#typev  platform_cpp3553 35 "%0Error retrieving device property %10!d! - %11!s!." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
winerr, ItemWINERROR -- 11
}
#typev  platform_cpp3519 34 "%0Error allocating buffer for property %10!d!." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
}
#typev  platform_cpp3505 33 "%0Integer overflow for property %10!d!." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
}
#typev  platform_cpp3484 32 "%0Unexpected datatype for device property %10!d! - %11!d!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=CPlatform::GetDeviceRegistryPropertyString
{
Property, ItemLong -- 10
dataType, ItemLong -- 11
}
#typev  platform_cpp3708 38 "%0Canonicalization: Path %10!s! ends with trailing . or space." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3724 39 "%0Canonicalization: Path %10!s! does not start with [a-z]:\." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
}
#typev  platform_cpp3853 46 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3840 45 "%0Canonicalization: Error allocating %10!Iu! characters for long path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
longPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3820 44 "%0Canonicalization: Error converting path %10!s! to long path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPath, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3799 43 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3786 42 "%0Canonicalization: Error allocating %10!Iu! characters for path." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
fullPathCch + 1, ItemPtr -- 10
}
#typev  platform_cpp3766 41 "%0Canonicalization: Error converting path %10!s! to full path - %11!d!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path, ItemWString -- 10
error, ItemLong -- 11
}
#typev  platform_cpp3746 40 "%0Canonicalization: Found invalid character %10!hd! at position %11!Iu! in path %12!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
Path[invalidCharacterIndex], ItemShort -- 10
invalidCharacterIndex, ItemPtr -- 11
Path, ItemWString -- 12
}
#typev  platform_cpp3694 37 "%0Canonicalization: File name is too short." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp3674 36 "%0Canonicalization: File name is an invalid length. (too long or not null terminated - unsafe to print" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CPlatform::CanonicalizePath
{
}
#typev  platform_cpp2688 27 "%0WUDF DriverStop %10!s! error %11!#I64x! component %12!s!
	@ %13!s!:
%14!s! Context Record: 0x%15!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::InnerDriverStop
{
g_pwszErrorTypeNames[Type], ItemWString -- 10
ErrorNumber, ItemLongLongX -- 11
g_pwszComponentNames[Platform->m_ProcessInfo.Component], ItemWString -- 12
Location, ItemWString -- 13
Message ? Message : '', ItemString -- 14
ContextRecord, ItemPtr -- 15
}
#typev  platform_cpp2870 29 "%0Parameter %10!d!: %11!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
parameterNumber, ItemLong -- 10
(PVOID) exception->ExceptionInformation[parameterNumber], ItemPtr -- 11
}
#typev  platform_cpp2847 28 "%0WUDF Unhandled Exception %10!#x! @ %11!p!. %12!d! parameters, Exception Record: 0x%13!p!, Context Record: 0x%14!p!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=PLATFORM_TRACE_DRIVERSTOP FUNC=CPlatform::UnhandledExceptionFilter
{
exception->ExceptionCode, ItemLong -- 10
exception->ExceptionAddress, ItemPtr -- 11
exception->NumberParameters, ItemLong -- 12
exception, ItemPtr -- 13
ExceptionInfo->ContextRecord, ItemPtr -- 14
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
5f07402d-39e7-6bcd-6bdb-a171c9ee1c2b WUDFPlatform // SRC=host.cpp MJ= MN=
#typev  host_cpp476 14 "%0No kernel-mode debugger found." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp427 11 "%0User-mode debugger found - breaking in." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp464 13 "%0Breaking into kernel debugger." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp449 12 "%0No user-mode debugger found." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
}
#typev  host_cpp416 10 "%0Waiting %10!d! seconds for debugger to attach." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=PLATFORM_TRACE_INIT FUNC=WudfWaitForDebugger
{
TimeoutSeconds, ItemLong -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp807 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp770 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp791 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp779 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp759 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp754 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp884 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp828 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp870 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp858 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp849 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp837 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp821 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp403 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp435 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp411 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp370 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp320 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp311 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp300 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp291 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp264 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp254 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp215 10 "%0 Entering %!FUNC!(%10!d!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
}
#typev  lpc_cpp561 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp483 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp461 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp443 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp635 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
e3d371a0-5422-d400-cdb7-07a576e6a4f2 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp262 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp250 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp486 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp466 30 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp446 29 "%0Unable to allocate reply callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp430 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp376 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp335 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp717 43 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp858 47 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp832 46 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp813 45 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp740 44 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp994 53 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp944 51 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp973 52 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp934 50 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp891 48 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1079 58 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1049 56 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1062 57 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp1021 55 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 54 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1104 60 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1093 59 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1194 64 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1169 63 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp686 42 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp560 33 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp579 35 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp660 41 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp649 40 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp635 39 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp613 38 "%0attribute size must be at least as large as the header size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp605 37 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp586 36 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp567 34 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp548 32 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
#typev  lpcmsg_cpp1157 62 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1116 61 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
147907a8-e922-8ed0-8ea6-9976b6b58652 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp118 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp104 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp91 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp78 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp56 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp48 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp22 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
#typev  lpcport_cpp133 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp124 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp338 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp178 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp213 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp306 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp317 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp234 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp328 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp164 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
fbcfe4f1-9b5a-9a2c-9f9c-e8a9d6e3f6b2 lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp289 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp269 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp900 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp436 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp487 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp461 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp420 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp794 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp808 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp749 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp690 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp552 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp643 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp632 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp613 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp223 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp203 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp109 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp94 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp81 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp61 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp24 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
22e1f7fa-2125-1c07-1b43-521f9bd0000a lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp85 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp66 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp36 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp20 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp199 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp181 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp154 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
8f605a8c-fa48-c180-a420-4572073665c3 lpc // SRC=lpc_xp.cpp MJ= MN=
#typev  lpc_xp_cpp225 10 "%0lpcport got a message!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WorkerThread
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:65 (UTC) [tracepdb]
4fe201c1-70dd-3f9f-78a6-f2dc2be72eb9 LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp166 12 "%0I/O operation (GetOverlappedResult) failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCoreSendWaitIoctl
{
dwResult, ItemWINERROR -- 10
}
#typev  lpccore_cpp155 11 "%0I/O operation (DeviceIoControl) failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCoreSendWaitIoctl
{
dwResult, ItemWINERROR -- 10
}
#typev  lpccore_cpp128 10 "%0unable to create an event for I/O operation %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCoreSendWaitIoctl
{
dwResult, ItemWINERROR -- 10
}
#typev  lpccore_cpp269 14 "%0%!FUNC!: unable to create listen object %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfLpcCorePortInterface::Listen
{
listenDeviceName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp240 13 "%0unable to construct server port name %10!s!\%11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Listen
{
WUDFLPC_DEVICE_DOSNAME, ItemWString -- 10
ServerPortName, ItemWString -- 11
hResult, ItemHRESULT -- 12
}
#typev  lpccore_cpp365 16 "%0%!FUNC!: unable to connect to %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfLpcCorePortInterface::Connect
{
serverDeviceFullName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp337 15 "%0unable to construct server port name \\.\%10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::Connect
{
ServerPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  lpccore_cpp417 17 "%0WUDFLPC_CLOSE_COMM_PORT_HANDLE_INPUT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DeletePort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp533 18 "%0IOCTL_LPC_SEND_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SendMessageW
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp697 20 "%0bytesReturned (0x%10!x!) not same as expected (0x%11!x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::CreateResourceReserve
{
bytesReturned, ItemLong -- 10
sizeof(output), ItemLong -- 11
}
#typev  lpccore_cpp686 19 "%0IOCTL_LPC_RESERVE_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::CreateResourceReserve
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp746 21 "%0IOCTL_LPC_RELEASE_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DeleteResourceReserve
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp897 24 "%0IOCTL_LPC_IMPERSONATE_CLIENT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ImpersonateClientOfPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp883 23 "%0waiting for IOCTL_LPC_IMPERSONATE_CLIENT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ImpersonateClientOfPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp850 22 "%0unable to create an event for IOCTL_LPC_IMPERSONATE_CLIENT %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ImpersonateClientOfPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp976 25 "%0unable to duplicate connection handle for communication handle %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::AcceptConnectPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp1093 26 "%0IOCTL_LPC_SEND_MESSAGE failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SendWaitReceivePort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp1181 27 "%0WUDFLPC_CLOSE_COMM_PORT_HANDLE_INPUT failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::DisconnectPort
{
winerr, ItemWINERROR -- 10
}
#typev  lpccore_cpp1294 28 "%0CWdfLpcCorePortInterface::SetAccessControl failure with %10!s! & %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::SetAccessControl
{
ntStatus, ItemNTSTATUS -- 10
winerr, ItemWINERROR -- 11
}
#typev  lpccore_cpp1365 29 "%0IOCTL_LPC_CLEAR_ACCESS_CONTROL failed %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortInterface::ClearAccessControl
{
winerr, ItemWINERROR -- 10
}
b6e0b5b1-cc16-ab1e-38f1-9673e8920e44 e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
#enumv WudfOperationType
{
WudfOperation_Invalid,0x0
WudfOperation_Init,0x1
WudfOperation_HostShutdown,0x2
WudfOperation_Pnp,0x3
WudfOperation_Cleanup,0x4
WudfOperation_Close,0x5
WudfOperation_Cancel,0x6
WudfOperation_IO,0x7
WudfOperation_Other,0x8
WudfOperation_Max,0x9
}
#enumv WdfComponentType
{
WdfComponentInvalid,0x0
WdfComponentPlatform,0x1
WdfComponentReflector,0x2
WdfComponentDriverManager,0x3
WdfComponentHost,0x4
WdfComponentFramework,0x5
WdfComponentTest,0x6
WdfComponentMax,0x7
}
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\user\core\longhorn\objfre\i386\WUDFPlatform.pdb
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_CREATE_DEVICE_STACK,0x3
WudfMsg_ADD_DEVICE,0x4
WudfMsg_CREATE,0x5
WudfMsg_CLOSE,0x6
WudfMsg_CLEANUP,0x7
WudfMsg_READ,0x8
WudfMsg_WRITE,0x9
WudfMsg_IOCONTROL,0xA
WudfMsg_FLUSH,0xB
WudfMsg_QUERY_INFORMATION_FILE,0xC
WudfMsg_SET_INFORMATION_FILE,0xD
WudfMsg_Cancel,0xE
WudfMsg_POWER_IRP_COMPLETE,0xF
WudfMsg_USB_SS_EVENT,0x10
WudfMsg_CLOSE_DEVICE_STACK,0x11
WudfMsg_REMOTE_INTERFACE_ARRIVAL,0x12
WudfMsg_REMOTE_INTERFACE_REMOVAL,0x13
WudfMsg_TARGET_DEVICE_NOTIFICATION,0x14
WudfMsg_TRANSPORT_QUERY_ID,0x15
WudfMsg_FramworkMax,0x16
WudfMsg_ExitProcess,0x17
WdfProcMgmt_Message_Reserved,0x18
WdfProcMgmt_Message_ControlObjectName,0x19
WdfProcMgmt_Message_QueryProcess,0x1A
WdfProcMgmt_Message_OpenProcess,0x1B
WdfProcMgmt_Message_CloseProcess,0x1C
WudfMsg_Connect,0x1D
WudfMsg_WMI_POWER_DATA,0x1E
WudfMsg_Max,0x1F
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp807 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp770 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp791 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp779 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp759 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp754 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp884 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp828 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp870 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp858 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp849 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp837 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp821 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp561 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp483 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp461 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp443 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp403 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp435 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp411 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp370 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp320 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp311 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp300 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp291 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp264 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp254 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp215 10 "%0 Entering %!FUNC!(%10!d!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
}
#typev  lpc_cpp635 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
e3d371a0-5422-d400-cdb7-07a576e6a4f2 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp262 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp250 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp486 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp466 30 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp446 29 "%0Unable to allocate reply callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp430 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp376 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp335 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp717 43 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp858 47 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp832 46 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp813 45 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp740 44 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp994 53 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp944 51 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp973 52 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp934 50 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp891 48 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1079 58 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1049 56 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1062 57 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp1021 55 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 54 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1104 60 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1093 59 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1194 64 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1169 63 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp686 42 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp560 33 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp579 35 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp660 41 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp649 40 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp635 39 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp613 38 "%0attribute size must be at least as large as the header size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp605 37 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp586 36 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp567 34 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp548 32 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
#typev  lpcmsg_cpp1157 62 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1116 61 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
147907a8-e922-8ed0-8ea6-9976b6b58652 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp133 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp124 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp338 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp178 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp213 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp306 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp317 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp234 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp328 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp164 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcport_cpp118 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp104 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp91 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp78 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp56 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp48 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp22 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
fbcfe4f1-9b5a-9a2c-9f9c-e8a9d6e3f6b2 lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp289 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp269 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp900 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp436 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp487 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp461 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp420 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp794 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp808 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp749 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp690 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp552 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp643 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp632 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp613 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp223 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp203 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp109 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp94 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp81 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp61 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp24 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
22e1f7fa-2125-1c07-1b43-521f9bd0000a lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp85 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp66 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp36 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp20 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp199 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp181 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp154 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
8f605a8c-fa48-c180-a420-4572073665c3 lpc // SRC=lpc_xp.cpp MJ= MN=
#typev  lpc_xp_cpp225 10 "%0lpcport got a message!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WorkerThread
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
ec0879e8-08ef-8648-ceaa-4f22d3d1b5e9 LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp239 14 "%0IOCTL_LPC_QUERY_INTERFACE failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp215 13 "%0unable to create IOCTL_LPC_QUERY_INTERFACE irp %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp186 12 "%0unable to connect to %10!s!. %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ServerPortName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccore_cpp149 11 "%0unable to allocate server port full name buffer %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
serverPortFullNameLen * sizeof(serverPortFullName[0]), ItemLong -- 10
}
#typev  lpccore_cpp139 10 "%0ServerPortName with prefix is longer than maximum UNICODE_STRING length" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
4a89af9a-40d3-ebb9-3ff9-c2d96c0b9ddb LpcCore // SRC=driver.cpp MJ= MN=
#typev  driver_cpp129 15 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Unload
{
}
#typev  driver_cpp116 14 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Unload
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp235 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Dispatch
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp211 18 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Dispatch
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  driver_cpp299 21 "%0 Exiting  %!FUNC! => (fastio completed:%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_FastIoDeviceDispatch
{
requestCompleted, ItemLong -- 10
}
#typev  driver_cpp271 20 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_FastIoDeviceDispatch
{
DeviceObject, ItemPtr -- 10
FileObject, ItemPtr -- 11
}
#typev  driver_cpp365 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::~LpcDriver
{
}
#typev  driver_cpp362 24 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::~LpcDriver
{
}
#typev  driver_cpp356 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::LpcDriver
{
NT_SUCCESS(ntStatus), ItemListLong(false,true) -- 10
}
#typev  driver_cpp312 22 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::LpcDriver
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp160 17 "%0Unable to init LpcDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriver::s_CreateInstance
{
}
#typev  driver_cpp151 16 "%0Unable to allocate LpcDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriver::s_CreateInstance
{
}
#typev  driver_cpp103 13 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriverEntry
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp75 12 "%0Unable to allocate driver object extension" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriverEntry
{
}
#typev  driver_cpp62 11 "%0WUDF LPC Driver is loading" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriverEntry
{
}
#typev  driver_cpp60 10 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriverEntry
{
DriverObject, ItemPtr -- 10
RegistryPath, ItemPWString -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
ceb8313e-c0a9-fce2-b9c4-fc0335d3b4f0 LpcCore // SRC=device.cpp MJ= MN=
#typev  device_cpp394 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::~LpcDevice
{
}
#typev  device_cpp376 26 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::~LpcDevice
{
}
#typev  device_cpp408 29 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::s_WdmDeviceObject2LpcDevice
{
deviceExtension->LpcDevice, ItemPtr -- 10
}
#typev  device_cpp404 28 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::s_WdmDeviceObject2LpcDevice
{
DeviceObject, ItemPtr -- 10
}
#typev  device_cpp907 41 "%0output buffer too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::ValidateDeviceIoControlBufferSizes
{
}
#typev  device_cpp896 40 "%0input buffer too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::ValidateDeviceIoControlBufferSizes
{
}
#typev  device_cpp359 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp126 13 "%0%!FUNC!: unsupported device type %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
DeviceType, ItemLong -- 10
}
#typev  device_cpp311 24 "%0%!FUNC!: unable to create symbolic link %10!s! for %11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
m_DosDeviceName.Buffer, ItemWString -- 10
ntDeviceNameUnicode.Buffer, ItemWString -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  device_cpp294 23 "%0%!FUNC!: unable to build dos device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp280 22 "%0%!FUNC!: unable to allocate memory for dos device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp270 21 "%0%!FUNC!: dos device name length >= MAXUSHORT." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp243 20 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp229 19 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp212 18 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp196 17 "%0%!FUNC!: unable to create device object. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp171 16 "%0%!FUNC!: unable to build nt device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp157 15 "%0%!FUNC!: unable to allocate memory for nt device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp144 14 "%0%!FUNC!: invalid device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp88 12 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!s!, %13!d!, %14!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::LpcDevice
{
LpcDriver, ItemPtr -- 10
LpcDeviceName, ItemWString -- 11
WdmDeviceName, ItemWString -- 12
DeviceType, ItemLong -- 13
Parent, ItemPtr -- 14
}
#typev  device_cpp459 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::ProcessIrp
{
status, ItemNTSTATUS -- 10
}
#typev  device_cpp424 30 "%0 Entering %!FUNC!(%10!p! (%11!d!))" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::ProcessIrp
{
Irp, ItemPtr -- 10
majorFunc, ItemLong -- 11
}
#typev  device_cpp767 39 "%0%!FUNC!: invalid user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp730 38 "%0%!FUNC!: invalid user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp683 37 "%0%!FUNC!: invalid output user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp670 36 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp655 35 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp604 34 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp559 33 "%0%!FUNC!: invalid output user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp546 32 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
7560cd86-d8c6-fd8e-aae9-185c5c809891 LpcCore // SRC=control.cpp MJ= MN=
#typev  control_cpp225 15 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp210 14 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp180 12 "%0%!FUNC!: unable to allocate sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
}
#typev  control_cpp193 13 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
}
#typev  control_cpp646 23 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp614 22 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp571 21 "%0control object ioctl sent from unexpected pid 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
PsGetCurrentProcessId(), ItemPtr -- 10
}
#typev  control_cpp1723 35 "%0unable to GetTokenInformation %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1708 34 "%0unable to allocate %10!u! bytes for user groups info" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
returnLength, ItemLong -- 10
}
#typev  control_cpp1698 33 "%0NtQueryInformationToken did not fail with STATUS_BUFFER_TOO_SMALL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1675 32 "%0unable to get driver manager sid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
}
#typev  control_cpp1665 31 "%0unable to GetTokenInformation %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1650 30 "%0unable to allocate %10!u! bytes for user token info" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
returnLength, ItemLong -- 10
}
#typev  control_cpp1640 29 "%0NtQueryInformationToken did not fail with STATUS_BUFFER_TOO_SMALL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1622 28 "%0unable to open process token %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1605 27 "%0unable to open process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp80 11 "%0Unable to init LpcControlDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::s_CreateInstance
{
}
#typev  control_cpp72 10 "%0Unable to allocate Lpc Control Device object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::s_CreateInstance
{
}
#typev  control_cpp402 20 "%0unable to allocate listening device %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp385 19 "%0process has no permission to create listen object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
}
#typev  control_cpp358 18 "%0create listening object not allowed until driver manager is loaded %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp342 17 "%0calling process is not driver manager process" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
}
#typev  control_cpp308 16 "%0opening control device not allowed from user mode %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp976 26 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=LpcControlDevice::DeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp823 25 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=LpcControlDevice::DeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp732 24 "%0control object ioctl sent from unexpected pid 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::DeviceIoControl
{
PsGetCurrentProcessId(), ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
3dc35813-9134-c578-842d-9da79385fd97 LpcCore // SRC=listen.cpp MJ= MN=
#typev  listen_cpp233 16 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  listen_cpp218 15 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  listen_cpp188 13 "%0%!FUNC!: unable to allocate sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
}
#typev  listen_cpp201 14 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
}
#typev  listen_cpp84 12 "%0Unable to init LpcListenDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
}
#typev  listen_cpp76 11 "%0Unable to allocate Lpc listen Device object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
}
#typev  listen_cpp63 10 "%0creating listen device %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
ListenDeviceName, ItemWString -- 10
}
#typev  listen_cpp475 18 "%0connection not accepted" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::Create
{
}
#typev  listen_cpp431 17 "%0LpcListenDevice 0x%10!p! not ready for accepting connection" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::Create
{
this, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
b1c640a1-ae60-c376-8f8b-489970752d04 LpcCore // SRC=communication.cpp MJ= MN=
#typev  communication_cpp2336 19 "%0Unable to find reserved message 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::FindAndRemoveMessage
{
MessageId, ItemLong -- 10
}
#typev  communication_cpp226 12 "%0Unable to init lpcCommContext object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::MessageQueues
{
}
#typev  communication_cpp170 11 "%0Unable to init messageQueues object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::s_CreateInstance
{
}
#typev  communication_cpp162 10 "%0Unable to allocate messageQueues object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::s_CreateInstance
{
}
#typev  communication_cpp405 16 "%0%!FUNC!: unable to initialize se client object list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::LpcCommContext
{
}
#typev  communication_cpp396 15 "%0%!FUNC!: unable to get allocate se client object list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::LpcCommContext
{
}
#typev  communication_cpp2238 18 "%0unable to retrieve sync message reply" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::SendMessageSync
{
}
#typev  communication_cpp2192 17 "%0Unable to send sync message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::SendMessageSync
{
}
#typev  communication_cpp315 14 "%0Unable to init lpcCommContext object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::s_CreateInstance
{
}
#typev  communication_cpp307 13 "%0Unable to allocate lpc communication object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::s_CreateInstance
{
}
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\xp\objfre\i386\WUDFPf.pdb
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_CREATE_DEVICE_STACK,0x3
WudfMsg_ADD_DEVICE,0x4
WudfMsg_CREATE,0x5
WudfMsg_CLOSE,0x6
WudfMsg_CLEANUP,0x7
WudfMsg_READ,0x8
WudfMsg_WRITE,0x9
WudfMsg_IOCONTROL,0xA
WudfMsg_FLUSH,0xB
WudfMsg_QUERY_INFORMATION_FILE,0xC
WudfMsg_SET_INFORMATION_FILE,0xD
WudfMsg_Cancel,0xE
WudfMsg_POWER_IRP_COMPLETE,0xF
WudfMsg_USB_SS_EVENT,0x10
WudfMsg_CLOSE_DEVICE_STACK,0x11
WudfMsg_REMOTE_INTERFACE_ARRIVAL,0x12
WudfMsg_REMOTE_INTERFACE_REMOVAL,0x13
WudfMsg_TARGET_DEVICE_NOTIFICATION,0x14
WudfMsg_TRANSPORT_QUERY_ID,0x15
WudfMsg_FramworkMax,0x16
WudfMsg_ExitProcess,0x17
WdfProcMgmt_Message_Reserved,0x18
WdfProcMgmt_Message_ControlObjectName,0x19
WdfProcMgmt_Message_QueryProcess,0x1A
WdfProcMgmt_Message_OpenProcess,0x1B
WdfProcMgmt_Message_CloseProcess,0x1C
WudfMsg_Connect,0x1D
WudfMsg_WMI_POWER_DATA,0x1E
WudfMsg_Max,0x1F
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
4a89af9a-40d3-ebb9-3ff9-c2d96c0b9ddb LpcCore // SRC=driver.cpp MJ= MN=
#typev  driver_cpp129 15 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Unload
{
}
#typev  driver_cpp116 14 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Unload
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp235 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Dispatch
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp211 18 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_Dispatch
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  driver_cpp299 21 "%0 Exiting  %!FUNC! => (fastio completed:%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_FastIoDeviceDispatch
{
requestCompleted, ItemLong -- 10
}
#typev  driver_cpp271 20 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::s_FastIoDeviceDispatch
{
DeviceObject, ItemPtr -- 10
FileObject, ItemPtr -- 11
}
#typev  driver_cpp365 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::~LpcDriver
{
}
#typev  driver_cpp362 24 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::~LpcDriver
{
}
#typev  driver_cpp356 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::LpcDriver
{
NT_SUCCESS(ntStatus), ItemListLong(false,true) -- 10
}
#typev  driver_cpp312 22 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriver::LpcDriver
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp160 17 "%0Unable to init LpcDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriver::s_CreateInstance
{
}
#typev  driver_cpp151 16 "%0Unable to allocate LpcDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriver::s_CreateInstance
{
}
#typev  driver_cpp103 13 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriverEntry
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp75 12 "%0Unable to allocate driver object extension" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriverEntry
{
}
#typev  driver_cpp62 11 "%0WUDF LPC Driver is loading" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DRIVER FUNC=LpcDriverEntry
{
}
#typev  driver_cpp60 10 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDriverEntry
{
DriverObject, ItemPtr -- 10
RegistryPath, ItemPWString -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
ceb8313e-c0a9-fce2-b9c4-fc0335d3b4f0 LpcCore // SRC=device.cpp MJ= MN=
#typev  device_cpp394 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::~LpcDevice
{
}
#typev  device_cpp376 26 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::~LpcDevice
{
}
#typev  device_cpp408 29 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::s_WdmDeviceObject2LpcDevice
{
deviceExtension->LpcDevice, ItemPtr -- 10
}
#typev  device_cpp404 28 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::s_WdmDeviceObject2LpcDevice
{
DeviceObject, ItemPtr -- 10
}
#typev  device_cpp907 41 "%0output buffer too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::ValidateDeviceIoControlBufferSizes
{
}
#typev  device_cpp896 40 "%0input buffer too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::ValidateDeviceIoControlBufferSizes
{
}
#typev  device_cpp359 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp126 13 "%0%!FUNC!: unsupported device type %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
DeviceType, ItemLong -- 10
}
#typev  device_cpp311 24 "%0%!FUNC!: unable to create symbolic link %10!s! for %11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
m_DosDeviceName.Buffer, ItemWString -- 10
ntDeviceNameUnicode.Buffer, ItemWString -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  device_cpp294 23 "%0%!FUNC!: unable to build dos device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp280 22 "%0%!FUNC!: unable to allocate memory for dos device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp270 21 "%0%!FUNC!: dos device name length >= MAXUSHORT." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp243 20 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp229 19 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp212 18 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp196 17 "%0%!FUNC!: unable to create device object. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp171 16 "%0%!FUNC!: unable to build nt device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp157 15 "%0%!FUNC!: unable to allocate memory for nt device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
}
#typev  device_cpp144 14 "%0%!FUNC!: invalid device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::LpcDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp88 12 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!s!, %13!d!, %14!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::LpcDevice
{
LpcDriver, ItemPtr -- 10
LpcDeviceName, ItemWString -- 11
WdmDeviceName, ItemWString -- 12
DeviceType, ItemLong -- 13
Parent, ItemPtr -- 14
}
#typev  device_cpp459 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::ProcessIrp
{
status, ItemNTSTATUS -- 10
}
#typev  device_cpp424 30 "%0 Entering %!FUNC!(%10!p! (%11!d!))" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=LpcDevice::ProcessIrp
{
Irp, ItemPtr -- 10
majorFunc, ItemLong -- 11
}
#typev  device_cpp767 39 "%0%!FUNC!: invalid user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp730 38 "%0%!FUNC!: invalid user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp683 37 "%0%!FUNC!: invalid output user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp670 36 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp655 35 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp604 34 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp559 33 "%0%!FUNC!: invalid output user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp546 32 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
7560cd86-d8c6-fd8e-aae9-185c5c809891 LpcCore // SRC=control.cpp MJ= MN=
#typev  control_cpp225 15 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp210 14 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp180 12 "%0%!FUNC!: unable to allocate sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
}
#typev  control_cpp193 13 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcControlDevice::LpcControlDevice
{
}
#typev  control_cpp646 23 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp614 22 "%0%!FUNC!: invalid input user buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp571 21 "%0control object ioctl sent from unexpected pid 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::FastIoDeviceIoControl
{
PsGetCurrentProcessId(), ItemPtr -- 10
}
#typev  control_cpp1723 35 "%0unable to GetTokenInformation %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1708 34 "%0unable to allocate %10!u! bytes for user groups info" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
returnLength, ItemLong -- 10
}
#typev  control_cpp1698 33 "%0NtQueryInformationToken did not fail with STATUS_BUFFER_TOO_SMALL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1675 32 "%0unable to get driver manager sid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
}
#typev  control_cpp1665 31 "%0unable to GetTokenInformation %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1650 30 "%0unable to allocate %10!u! bytes for user token info" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
returnLength, ItemLong -- 10
}
#typev  control_cpp1640 29 "%0NtQueryInformationToken did not fail with STATUS_BUFFER_TOO_SMALL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1622 28 "%0unable to open process token %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp1605 27 "%0unable to open process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::IsProcessUserSidSameAsDriverManagerSid
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp80 11 "%0Unable to init LpcControlDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::s_CreateInstance
{
}
#typev  control_cpp72 10 "%0Unable to allocate Lpc Control Device object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::s_CreateInstance
{
}
#typev  control_cpp402 20 "%0unable to allocate listening device %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp385 19 "%0process has no permission to create listen object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
}
#typev  control_cpp358 18 "%0create listening object not allowed until driver manager is loaded %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp342 17 "%0calling process is not driver manager process" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
}
#typev  control_cpp308 16 "%0opening control device not allowed from user mode %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::Create
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp976 26 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=LpcControlDevice::DeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp823 25 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=LpcControlDevice::DeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  control_cpp732 24 "%0control object ioctl sent from unexpected pid 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcControlDevice::DeviceIoControl
{
PsGetCurrentProcessId(), ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
3dc35813-9134-c578-842d-9da79385fd97 LpcCore // SRC=listen.cpp MJ= MN=
#typev  listen_cpp233 16 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  listen_cpp218 15 "%0unable to open a handle to self devobj %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  listen_cpp188 13 "%0%!FUNC!: unable to allocate sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
}
#typev  listen_cpp201 14 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=LpcListenDevice::LpcListenDevice
{
}
#typev  listen_cpp84 12 "%0Unable to init LpcListenDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
}
#typev  listen_cpp76 11 "%0Unable to allocate Lpc listen Device object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
}
#typev  listen_cpp63 10 "%0creating listen device %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::s_CreateInstance
{
ListenDeviceName, ItemWString -- 10
}
#typev  listen_cpp475 18 "%0connection not accepted" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::Create
{
}
#typev  listen_cpp431 17 "%0LpcListenDevice 0x%10!p! not ready for accepting connection" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcListenDevice::Create
{
this, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
b1c640a1-ae60-c376-8f8b-489970752d04 LpcCore // SRC=communication.cpp MJ= MN=
#typev  communication_cpp2336 19 "%0Unable to find reserved message 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::FindAndRemoveMessage
{
MessageId, ItemLong -- 10
}
#typev  communication_cpp226 12 "%0Unable to init lpcCommContext object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::MessageQueues
{
}
#typev  communication_cpp170 11 "%0Unable to init messageQueues object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::s_CreateInstance
{
}
#typev  communication_cpp162 10 "%0Unable to allocate messageQueues object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=MessageQueues::s_CreateInstance
{
}
#typev  communication_cpp405 16 "%0%!FUNC!: unable to initialize se client object list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::LpcCommContext
{
}
#typev  communication_cpp396 15 "%0%!FUNC!: unable to get allocate se client object list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::LpcCommContext
{
}
#typev  communication_cpp2238 18 "%0unable to retrieve sync message reply" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::SendMessageSync
{
}
#typev  communication_cpp2192 17 "%0Unable to send sync message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::SendMessageSync
{
}
#typev  communication_cpp315 14 "%0Unable to init lpcCommContext object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::s_CreateInstance
{
}
#typev  communication_cpp307 13 "%0Unable to allocate lpc communication object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=LpcCommContext::s_CreateInstance
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 lpc // SRC=lpc.cpp MJ= MN=
#typev  lpc_cpp807 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp770 28 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
messageId, ItemLong -- 10
}
#typev  lpc_cpp791 30 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MaxInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp779 29 "%0%!FUNC!: message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
MessageHeader->Message, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[messageId].MinInputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp759 27 "%0%!FUNC!: message 0x%10!p! too small 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(ULONG) MessageSize, ItemLong -- 11
}
#typev  lpc_cpp754 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateMessage
{
MessageHeader, ItemPtr -- 10
(PVOID) MessageSize, ItemPtr -- 11
}
#typev  lpc_cpp884 38 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
bResult, ItemListLong(false,true) -- 10
}
#typev  lpc_cpp828 33 "%0%!FUNC!: invalid message id 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageId, ItemLong -- 10
}
#typev  lpc_cpp870 37 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too large 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MaxOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp858 36 "%0%!FUNC!: reply message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) WudfMessageSizeTable[MessageId].MinOutputMessageSize, ItemLong -- 13
}
#typev  lpc_cpp849 35 "%0invalid reply status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  lpc_cpp837 34 "%0%!FUNC!: repy message 0x%10!p! id 0x%11!x! too small 0x%12!x!.  expected at least 0x%13!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemLong -- 11
(ULONG) MessageSize, ItemLong -- 12
(ULONG) sizeof(WUDFMESSAGE_REPLY_HEADER), ItemLong -- 13
}
#typev  lpc_cpp821 32 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::ValidateReplyMessage
{
MessageHeader, ItemPtr -- 10
MessageId, ItemEnum(_WUDFMESSAGE) -- 11
(PVOID) MessageSize, ItemPtr -- 12
}
#typev  lpc_cpp561 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp483 23 "%0%!FUNC!: failed to wait for lpc thread to terminate" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp461 22 "%0%!FUNC!: failed to wait for lpc thread to unwind out of worker thread code" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp443 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::~WdfLpc
{
}
#typev  lpc_cpp403 18 "%0unable to get create worker thread" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp435 20 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp411 19 "%0thread %10!d! created (0x%11!p!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
i, ItemLong -- 10
m_Threads[i].Value, ItemPtr -- 11
}
#typev  lpc_cpp370 17 "%0%!FUNC!: unable to allocate memory for thread handle table" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp320 16 "%0%!FUNC!: unable to get initialize communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp311 15 "%0%!FUNC!: unable to get allocate memory for communication port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp300 14 "%0%!FUNC!: unable to get initialize connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp291 13 "%0%!FUNC!: unable to get allocate memory for connection port list" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp264 12 "%0unable to allocate thread done event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp254 11 "%0unable to allocate thread shutdown event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WdfLpc
{
}
#typev  lpc_cpp215 10 "%0 Entering %!FUNC!(%10!d!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpc::WdfLpc
{
NumWorkerThreads, ItemLong -- 10
PeriodicTimer, ItemPtr -- 11
}
#typev  lpc_cpp635 25 "%0Connection Port %10!s! already exist" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_CONNECTION FUNC=WdfLpc::Listen
{
connPort->GetName(), ItemWString -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
e3d371a0-5422-d400-cdb7-07a576e6a4f2 lpc // SRC=lpcmsg.cpp MJ= MN=
#typev  lpcmsg_cpp179 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp174 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::~WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp239 23 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp230 22 "%0%!FUNC!: unable to send reply message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp200 21 "%0%!FUNC!: message id not set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::Reply
{
}
#typev  lpcmsg_cpp191 20 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::Reply
{
ReplyMessageId, ItemLong -- 10
}
#typev  lpcmsg_cpp262 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
msgBody, ItemPtr -- 10
}
#typev  lpcmsg_cpp250 24 "%0 Entering %!FUNC!(%10!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::MessageBody
{
NewMessageBodySize, ItemPtr -- 10
}
#typev  lpcmsg_cpp486 31 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcmsg_cpp466 30 "%0unable to allocate data buffer %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp446 29 "%0Unable to allocate reply callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp430 28 "%0%!FUNC!: unable to reserve alpc resource %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp376 27 "%0%!FUNC!: invalid alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcpMessage
{
}
#typev  lpcmsg_cpp335 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::WudfLpcpMessage
{
LpcCommPort, ItemPtr -- 10
View, ItemPtr -- 11
Security, ItemPtr -- 12
DataLength, ItemPtr -- 13
ReplyDataLength, ItemPtr -- 14
}
#typev  lpcmsg_cpp717 43 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::WudfLpcMessagePreCtor
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp858 47 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp832 46 "%0%!FUNC!: unable to allocate section view, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp813 45 "%0%!FUNC!: unable to allocate section size 0x%10!x!, %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::ResetDataBuffer
{
(ULONG) maxDataSize, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcmsg_cpp740 44 "%0 Entering %!FUNC!(%10!Id!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ResetDataBuffer
{
DataLength, ItemPtr -- 10
ReplyDataLength, ItemPtr -- 11
}
#typev  lpcmsg_cpp994 53 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp944 51 "%0%!FUNC!: 0x%10!p! lpc message cannot have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp973 52 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp934 50 "%0%!FUNC!: 0x%10!p! cannot have reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp910 49 "%0%!FUNC!: 0x%10!p! requires reply callback" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::Send
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp891 48 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::Send
{
ReplyMessageCall, ItemPtr -- 10
ReplyContext, ItemPtr -- 11
TimeoutInSeconds, ItemLong -- 12
}
#typev  lpcmsg_cpp1079 58 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
reply, ItemPtr -- 10
}
#typev  lpcmsg_cpp1049 56 "%0%!FUNC!: unable to send message %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp1062 57 "%0%!FUNC!: reply message smaller than expected" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
}
#typev  lpcmsg_cpp1021 55 "%0%!FUNC!: 0x%10!p! lpc message must have timeout" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::SendWait
{
this, ItemPtr -- 10
}
#typev  lpcmsg_cpp1010 54 "%0 Entering %!FUNC!(%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::SendWait
{
TimeoutInSeconds, ItemLong -- 10
}
#typev  lpcmsg_cpp1104 60 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1093 59 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::TimeoutCallback
{
}
#typev  lpcmsg_cpp1194 64 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
}
#typev  lpcmsg_cpp1169 63 "%0 Entering %!FUNC!(%10!p!, %11!Ix!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::CopyMessageData
{
DataBuffer, ItemPtr -- 10
DataLength, ItemPtr -- 11
CopyToSection, ItemListLong(false,true) -- 12
}
#typev  lpcmsg_cpp167 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp75 11 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp152 16 "%0%!FUNC!: unable to allocate alpc reply message 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) replyTotalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp131 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp116 14 "%0%!FUNC!: unable to get allocate memory for alpc attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
}
#typev  lpcmsg_cpp104 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp83 12 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!Id!, %12!d!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcReplyMessage::WudfLpcReplyMessage
{
LpcPort, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
UnmapView, ItemListLong(false,true) -- 13
}
#typev  lpcmsg_cpp686 42 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
ptr, ItemPtr -- 10
}
#typev  lpcmsg_cpp560 33 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp579 35 "%0%!FUNC!: integer overflows" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp660 41 "%0%!FUNC!: unable to allocate 0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) totalSize, ItemLong -- 10
}
#typev  lpcmsg_cpp649 40 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) totalSize, ItemULongLong -- 10
(ULONGLONG) maxAlpcMessageSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp635 39 "%0%!FUNC!: RtlSizeTAdd(%10!I64u!, %11!I64u!) failed %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONGLONG) actualObjectSize, ItemULongLong -- 10
(ULONGLONG) allAttributeSize, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  lpcmsg_cpp613 38 "%0attribute size must be at least as large as the header size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
}
#typev  lpcmsg_cpp605 37 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcmsg_cpp586 36 "%0%!FUNC!: lpc reply message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) ReplyMessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp567 34 "%0%!FUNC!: lpc message body too long.  0x%10!x! bytes" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WudfLpcMessage::operator new
{
(ULONG) MessageBodyLength, ItemLong -- 10
}
#typev  lpcmsg_cpp548 32 "%0 Entering %!FUNC!(%10!Id!, %11!Id!, %12!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::operator new
{
Size, ItemPtr -- 10
MessageBodyLength, ItemPtr -- 11
ReplyMessageBodyLength, ItemPtr -- 12
}
#typev  lpcmsg_cpp1157 62 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
}
#typev  lpcmsg_cpp1116 61 "%0 Entering %!FUNC!(%10!p!, %11!Ix!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfLpcMessage::ReplyMessage
{
ReplyHeader, ItemPtr -- 10
ReplyHeaderSize, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
147907a8-e922-8ed0-8ea6-9976b6b58652 lpc // SRC=lpcport.cpp MJ= MN=
#typev  lpcport_cpp133 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp124 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::~WdfLpcPort
{
}
#typev  lpcport_cpp338 26 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcport_cpp178 20 "%0lpc handle 0x%10!p! received msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp213 21 "%0lpc handle %10!p! received reply msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp306 23 "%0lpc handle %10!p! received LPC_PORT_CLOSED msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp317 24 "%0lpc handle %10!p! received LPC_CONNECTION_REPLY msg" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
contextAttr->PortContext, ItemPtr -- 10
}
#typev  lpcport_cpp234 22 "%0lpc handle %10!p! received LPC_CANCELED msg" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
m_PortHandle, ItemPtr -- 10
}
#typev  lpcport_cpp328 25 "%0LPC Message type 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::ProcessMessage
{
ALPC_GET_MESSAGE_TYPE(ReceiveMessage), ItemLong -- 10
}
#typev  lpcport_cpp164 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcport_cpp118 16 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  lpcport_cpp104 15 "%0%!FUNC!: unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp91 14 "%0%!FUNC!: unable to allocate buffer for ALPC_FLG_MSG_CONTEXT_ATTR" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp78 13 "%0%!FUNC!: unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcport_cpp56 12 "%0%!FUNC!: message notification callback object is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp48 11 "%0%!FUNC!: server port name is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_PORT FUNC=WdfLpcPort::WdfLpcPort
{
}
#typev  lpcport_cpp22 10 "%0 Entering %!FUNC!({%10!s!, %11!p!, %12!p!}, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcPort::WdfLpcPort
{
Parameters->m_ServerPortName, ItemWString -- 10
Parameters->m_Notification, ItemPtr -- 11
Parameters->m_PortHandle, ItemPtr -- 12
Parent, ItemPtr -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
fbcfe4f1-9b5a-9a2c-9f9c-e8a9d6e3f6b2 lpc // SRC=lpccomm.cpp MJ= MN=
#typev  lpccomm_cpp289 18 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp269 17 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::~WdfLpcCommPort
{
}
#typev  lpccomm_cpp900 31 "%0send reply message (id=0x%10!x!) failed %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_PORT FUNC=WdfLpcCommPort::FastReply
{
ReplyMessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp436 20 "%0LPC ReceiveMessage 0x%10!p! sender pid 0x%11!p! does not match expected pid 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
ReceiveMessage->ClientId.UniqueProcess, ItemPtr -- 11
m_PeerProcessId, ItemPtr -- 12
}
#typev  lpccomm_cpp487 22 "%0%!FUNC!: LPC Message %10!p! not found on list - assuming it has already been cancelled or completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp461 21 "%0%!FUNC!: LpcMsg (%10!p!,%11!p!) was cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
lpcMsg, ItemPtr -- 11
}
#typev  lpccomm_cpp420 19 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpccomm_cpp794 29 "%0%!FUNC!: unable to cancel WudfLpcMessage 0x%10!p!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
this, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp808 30 "%0%!FUNC!: number of alpc messages cancelled %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
numCancelledMessages, ItemLong -- 10
}
#typev  lpccomm_cpp749 28 "%0%!FUNC!: lpcMsg has been cancelled 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp690 27 "%0%!FUNC!: m_PendingMessages has lpcmsg 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfSearchTimeoutMessagesWithLockHeld
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp552 23 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::Disconnect
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp643 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
}
#typev  lpccomm_cpp632 25 "%0%!FUNC!: lpcMsg has timeout 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=LPC_TRACE_API FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
lpcMsg, ItemPtr -- 10
}
#typev  lpccomm_cpp613 24 "%0 Entering %!FUNC!(this = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WudfPeriodicTimerCallback
{
this, ItemPtr -- 10
}
#typev  lpccomm_cpp223 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp203 15 "%0%!FUNC!: unable to connect to server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccomm_cpp109 14 "%0unable to initialize ALPC_FLG_MSG_CONTEXT_ATTR buffer. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp94 13 "%0unable to get allocate memory for fast reply attributes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_MSG FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp81 12 "%0unable to get ALPC_FLG_MSG_CONTEXT_ATTR size.  status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccomm_cpp61 11 "%0unable to allocate fastreply port message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcCommPort::WdfLpcCommPort
{
}
#typev  lpccomm_cpp24 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcCommPort::WdfLpcCommPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
22e1f7fa-2125-1c07-1b43-521f9bd0000a lpc // SRC=lpcconn.cpp MJ= MN=
#typev  lpcconn_cpp85 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp66 12 "%0%!FUNC!: unable to create server port %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
GetName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpcconn_cpp36 11 "%0%!FUNC!: required CommPortList is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::WdfLpcConnPort
{
}
#typev  lpcconn_cpp20 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::WdfLpcConnPort
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  lpcconn_cpp287 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp272 18 "%0%!FUNC!: unable to accept connection. er = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcconn_cpp232 17 "%0%!FUNC!: unable to create comm lpc port object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPC_TRACE_COMMUNICATION FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
}
#typev  lpcconn_cpp199 16 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage_Connect
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
#typev  lpcconn_cpp181 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
processed, ItemListLong(false,true) -- 10
}
#typev  lpcconn_cpp154 14 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfLpcConnPort::ProcessMessage
{
ReceiveMessage, ItemPtr -- 10
MsgAttr, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
8f605a8c-fa48-c180-a420-4572073665c3 lpc // SRC=lpc_xp.cpp MJ= MN=
#typev  lpc_xp_cpp225 10 "%0lpcport got a message!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=LPC_TRACE_LPC FUNC=WdfLpc::WorkerThread
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
// PDB:  Last Updated :2010-2-9:4:5:26:849 (UTC) [tracepdb]
ec0879e8-08ef-8648-ceaa-4f22d3d1b5e9 LpcCoreClient // SRC=lpccore.cpp MJ= MN=
#typev  lpccore_cpp239 14 "%0IOCTL_LPC_QUERY_INTERFACE failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp215 13 "%0unable to create IOCTL_LPC_QUERY_INTERFACE irp %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpccore_cpp186 12 "%0unable to connect to %10!s!. %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
ServerPortName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  lpccore_cpp149 11 "%0unable to allocate server port full name buffer %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
serverPortFullNameLen * sizeof(serverPortFullName[0]), ItemLong -- 10
}
#typev  lpccore_cpp139 10 "%0ServerPortName with prefix is longer than maximum UNICODE_STRING length" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfLpcCorePortKernelInterface::Connect
{
}
7eb3f376-bc81-4ff6-bbe0-330438b82fa4 e:\5359.obj.x86fre\drivers\wdf\umdf\common\platform\kernel\longhorn\objfre\i386\WUDFPf.pdb
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_CREATE_DEVICE_STACK,0x3
WudfMsg_ADD_DEVICE,0x4
WudfMsg_CREATE,0x5
WudfMsg_CLOSE,0x6
WudfMsg_CLEANUP,0x7
WudfMsg_READ,0x8
WudfMsg_WRITE,0x9
WudfMsg_IOCONTROL,0xA
WudfMsg_FLUSH,0xB
WudfMsg_QUERY_INFORMATION_FILE,0xC
WudfMsg_SET_INFORMATION_FILE,0xD
WudfMsg_Cancel,0xE
WudfMsg_POWER_IRP_COMPLETE,0xF
WudfMsg_USB_SS_EVENT,0x10
WudfMsg_CLOSE_DEVICE_STACK,0x11
WudfMsg_REMOTE_INTERFACE_ARRIVAL,0x12
WudfMsg_REMOTE_INTERFACE_REMOVAL,0x13
WudfMsg_TARGET_DEVICE_NOTIFICATION,0x14
WudfMsg_TRANSPORT_QUERY_ID,0x15
WudfMsg_FramworkMax,0x16
WudfMsg_ExitProcess,0x17
WdfProcMgmt_Message_Reserved,0x18
WdfProcMgmt_Message_ControlObjectName,0x19
WdfProcMgmt_Message_QueryProcess,0x1A
WdfProcMgmt_Message_OpenProcess,0x1B
WdfProcMgmt_Message_CloseProcess,0x1C
WudfMsg_Connect,0x1D
WudfMsg_WMI_POWER_DATA,0x1E
WudfMsg_Max,0x1F
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
8c8509b0-a91d-06b3-5ae0-739e8c1359b9 WUDFx // SRC=WudfObjectEx.cpp MJ= MN=
#typev  WudfObjectEx_cpp173 11 "%0%!FUNC!: Could not assign object context, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWudfObjectEx::AssignObjectContext
{
hr, ItemHRESULT -- 10
}
#typev  WudfObjectEx_cpp190 12 "%0%!FUNC!: NULL is an invalid input parameter" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWudfObjectEx::RetrieveObjectContext
{
}
#typev  WudfObjectEx_cpp88 10 "%0%!FUNC!: 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_OBJECT FUNC=CWudfObjectEx::OnDispose
{
this, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
9921154d-aa04-2161-70b8-3bfce48a0e21 WUDFx // SRC=WdfRemoteTarget.cpp MJ= MN=
#typev  WdfRemoteTarget_cpp652 17 "%0QueryRemoveCanceled callback was for an old registration, ignoring." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnRemoveCanceled
{
}
#typev  WdfRemoteTarget_cpp646 16 "%0OnRemoveCanceled() !wudfiotarget 0x%10!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnRemoveCanceled
{
static_cast<IWDFIoTarget*>(static_cast<CWdfIoTarget*>(this)), ItemPtr -- 10
}
#typev  WdfRemoteTarget_cpp700 19 "%0QueryRemoveComplete callback was for an old registration, ignoring." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnRemoveComplete
{
}
#typev  WdfRemoteTarget_cpp694 18 "%0OnRemoveComplete() !wudfiotarget 0x%10!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnRemoveComplete
{
static_cast<IWDFIoTarget*>(static_cast<CWdfIoTarget*>(this)), ItemPtr -- 10
}
#typev  WdfRemoteTarget_cpp758 21 "%0CustomEvent callback was for an old registration, ignoring." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnCustomEvent
{
}
#typev  WdfRemoteTarget_cpp751 20 "%0OnCustomEvent(%10!s!) !wudfiotarget 0x%11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnCustomEvent
{
&Event, ItemGuid -- 10
static_cast<IWDFIoTarget*>(static_cast<CWdfIoTarget*>(this)), ItemPtr -- 11
}
#typev  WdfRemoteTarget_cpp302 13 "%0CreateFile() failed, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OpenTargetHandle
{
hr, ItemHRESULT -- 10
}
#typev  WdfRemoteTarget_cpp585 15 "%0QueryRemove callback was for an old registration, ignoring." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnQueryRemove
{
}
#typev  WdfRemoteTarget_cpp579 14 "%0OnRemoteTargetQueryRemove() !wudfiotarget 0x%10!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OnQueryRemove
{
static_cast<IWDFIoTarget*>(static_cast<CWdfIoTarget*>(this)), ItemPtr -- 10
}
#typev  WdfRemoteTarget_cpp909 23 "%0Unable to allocate memory for file name string, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OpenRemoteInterface
{
hr, ItemHRESULT -- 10
}
#typev  WdfRemoteTarget_cpp833 22 "%0OpenRemoteInterface(...) !wudfiotarget 0x%10!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OpenRemoteInterface
{
static_cast<IWDFIoTarget*>(static_cast<CWdfIoTarget*>(this)), ItemPtr -- 10
}
#typev  WdfRemoteTarget_cpp995 25 "%0Unable to allocate memory for file name string, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OpenFileByName
{
hr, ItemHRESULT -- 10
}
#typev  WdfRemoteTarget_cpp969 24 "%0OpenFileByName('%10!s!') !wudfiotarget 0x%11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_REMOTE_IOTARGET FUNC=CWdfRemoteTarget::OpenFileByName
{
pcwszFullPath, ItemWString -- 10
static_cast<IWDFIoTarget*>(static_cast<CWdfIoTarget*>(this)), ItemPtr -- 11
}
#typev  WdfRemoteTarget_cpp193 12 "%0RemoteTarget object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfRemoteTarget::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfRemoteTarget_cpp161 11 "%0%!FUNC!: CWdfRemoteTarget creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfRemoteTarget::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfRemoteTarget_cpp142 10 "%0%!FUNC!: FxObject creation failed for RemoteTarget object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfRemoteTarget::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
2eb33d1e-addf-642e-88f6-3592f71e8151 WUDFx // SRC=WdfRemoteInterfaceList.cpp MJ= MN=
#typev  WdfRemoteInterfaceList_cpp253 11 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfRemoteInterfaceList::DispatchArrival
{
}
#typev  WdfRemoteInterfaceList_cpp182 10 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfRemoteInterfaceList::DispatchArrival
{
}
#typev  WdfRemoteInterfaceList_cpp334 14 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfRemoteInterfaceList::DispatchRemoval
{
}
#typev  WdfRemoteInterfaceList_cpp302 13 "%0%!FUNC!: Interface removal notification refers to unknown interface, RemoteInterfaceID: %10!I64u!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_INIT FUNC=CWdfRemoteInterfaceList::DispatchRemoval
{
RemoteInterfaceID, ItemULongLong -- 10
}
#typev  WdfRemoteInterfaceList_cpp280 12 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfRemoteInterfaceList::DispatchRemoval
{
}
#typev  WdfRemoteInterfaceList_cpp481 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfRemoteInterfaceList::Remove
{
}
#typev  WdfRemoteInterfaceList_cpp458 16 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfRemoteInterfaceList::Remove
{
}
#typev  WdfRemoteInterfaceList_cpp392 15 "%0%!FUNC!: failed creating RemoteInterface %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DEVICE FUNC=CWdfRemoteInterfaceList::CreateRemoteInterface
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
ac276f9d-36fb-c28d-b90f-7b84e40b3727 WUDFx // SRC=WdfRemoteInterface.cpp MJ= MN=
#typev  WdfRemoteInterface_cpp360 13 "%0QueryRemove callback was from an old registration, ignoring." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_INTERFACE FUNC=CWdfRemoteInterface::OnQueryRemove
{
}
#typev  WdfRemoteInterface_cpp464 14 "%0RemoveCanceled callback was from an old registration, ignoring." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_INTERFACE FUNC=CWdfRemoteInterface::OnRemoveCanceled
{
}
#typev  WdfRemoteInterface_cpp539 15 "%0RemoveComplete callback was from an old registration, ignoring." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_INTERFACE FUNC=CWdfRemoteInterface::OnRemoveComplete
{
}
#typev  WdfRemoteInterface_cpp166 12 "%0RemoteInterface object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfRemoteInterface::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfRemoteInterface_cpp133 11 "%0%!FUNC!: CWdfRemoteInterface creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfRemoteInterface::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfRemoteInterface_cpp112 10 "%0%!FUNC!: FxObject creation failed for RemoteInterface object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfRemoteInterface::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  WdfRemoteInterface_cpp618 16 "%0CustomEvent was from an old registration, ignoring." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REMOTE_INTERFACE FUNC=CWdfRemoteInterface::OnCustomEvent
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
3bdbbc7b-7021-3901-6827-88210a1ca302 WUDFx // SRC=WdfRemoteInterfaceInit.cpp MJ= MN=
#typev  WdfRemoteInterfaceInit_cpp163 12 "%0%!FUNC!:Unable to copy SymbolicLink hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfRemoteInterfaceInit::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfRemoteInterfaceInit_cpp148 11 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for SymbolicLink" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfRemoteInterfaceInit::CreateAndInitialize
{
}
#typev  WdfRemoteInterfaceInit_cpp127 10 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for CWdfRemoteInterfaceInit" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfRemoteInterfaceInit::CreateAndInitialize
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
22366aa2-25c9-8eb2-979f-30b07cbcc758 WUDFx // SRC=WdfUsbPipe.cpp MJ= MN=
#typev  WdfUsbPipe_cpp464 15 "%0IWDFUsbPipe* %10!p! continuous reader not queueing work item,WorkItemQueued = %11!d!, target state %12!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::QueueWorkItemLocked
{
m_pIUsbTargetPipe, ItemPtr -- 10
m_ReadFailureHandled, ItemLong -- 11
m_Pipe->m_State, ItemEnum(_WDF_IO_TARGET_STATE) -- 12
}
#typev  WdfUsbPipe_cpp421 14 "%0IWDFUsbPipe* %10!p! continuous reader queueing work item to recover from failed allocation" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::QueueWorkItemLocked
{
m_pIUsbTargetPipe, ItemPtr -- 10
}
#typev  WdfUsbPipe_cpp1140 23 "%0IWDFUsbPipe: %10!p! Waiting for error read event to complete Thread id 0x%11!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::CancelRepeaters
{
m_pIUsbTargetPipe, ItemPtr -- 10
GetCurrentThreadId(), ItemLong -- 11
}
#typev  WdfUsbPipe_cpp2033 28 "%0IWDFUsbPipe* %10!p! converting stop action 0x%11!x! to 0x%12!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::GotoStopState
{
this, ItemPtr -- 10
Action, ItemLong -- 11
WdfIoTargetCancelSentIo, ItemLong -- 12
}
#typev  WdfUsbPipe_cpp2083 29 "%0IWDFUsbPipe* %10!p! Continuous Reader should be stopped on D0Exit" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::GotoCloseState
{
this, ItemPtr -- 10
}
#typev  WdfUsbPipe_cpp2150 32 "%0IWDFUsbPipe* %10!p!  waiting for all i/o to complete" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::WaitForSentIoToComplete
{
this, ItemPtr -- 10
}
#typev  WdfUsbPipe_cpp2135 31 "%0IWDFUsbPipe* %10!p! cancelling for continuous reader (max of %11!d!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::WaitForSentIoToComplete
{
this, ItemPtr -- 10
m_Reader->m_NumReaders, ItemLong -- 11
}
#typev  WdfUsbPipe_cpp2124 30 "%0IWDFUsbPipe* %10!p! waiting for continuous reader work item to complete Thread id 0x%11!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::WaitForSentIoToComplete
{
this, ItemPtr -- 10
GetCurrentThreadId(), ItemLong -- 11
}
#typev  WdfUsbPipe_cpp1712 27 "%0Falied to allocate pipe transfer context, returning hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::FormatTransferRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbPipe_cpp1398 26 "%0UsbPipe object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbTargetPipe::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfUsbPipe_cpp1367 25 "%0%!FUNC!: CWdfUsbTargetPipe creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbTargetPipe::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbPipe_cpp1346 24 "%0%!FUNC!: FxObject creation failed for UsbPipe object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbTargetPipe::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  WdfUsbPipe_cpp328 12 "%0IWDFUsbPipe: %10!p! Falied to allocate event for repeat reader %11!d!, error = %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::Config
{
m_pIUsbTargetPipe, ItemPtr -- 10
i, ItemLong -- 11
dwErr, ItemWINERROR -- 12
}
#typev  WdfUsbPipe_cpp346 13 "%0IWDFUsbPipe: %10!p! Could not allocate Read workitem: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::Config
{
m_pIUsbTargetPipe, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfUsbPipe_cpp278 11 "%0IWDFUsbPipe: %10!p! Falied to allocate event for workitem error = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::Config
{
m_pIUsbTargetPipe, ItemPtr -- 10
dwErr, ItemWINERROR -- 11
}
#typev  WdfUsbPipe_cpp266 10 "%0IWDFUsbPipe: %10!p! Could not allocate workitem: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::Config
{
m_pIUsbTargetPipe, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfUsbPipe_cpp609 19 "%0IWDFUsbPipe* %10!p! continuous reader buffer alloc failed but not in started state" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::ResubmitRepeater
{
m_pIUsbTargetPipe, ItemPtr -- 10
}
#typev  WdfUsbPipe_cpp596 18 "%0IWDFUsbPipe* %10!p! continuous reader, buffer alloc failed, but there are %11!d! readers left out of a max of %12!d!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::ResubmitRepeater
{
m_pIUsbTargetPipe, ItemPtr -- 10
m_NumReaders - m_NumFailedReaders, ItemLong -- 11
m_NumReaders, ItemLong -- 12
}
#typev  WdfUsbPipe_cpp567 17 "%0IWDFUsbPipe* %10!p! continuous reader format failed, %11!s!, repeater %12!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::ResubmitRepeater
{
m_pIUsbTargetPipe, ItemPtr -- 10
hr, ItemHRESULT -- 11
Repeater, ItemPtr -- 12
}
#typev  WdfUsbPipe_cpp512 16 "%0IWDFUsbPipe* %10!p! is being reset, continuous reader %11!p! IWDFIoRequest* %12!p! is deferred for later." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::ResubmitRepeater
{
m_pIUsbTargetPipe, ItemPtr -- 10
Repeater, ItemPtr -- 11
Repeater->Request, ItemPtr -- 12
}
#typev  WdfUsbPipe_cpp748 22 "%0IWDFUsbPipe* %10!p! continuous reader %11!p! IWDFIoRequest* %12!p! got asynchronously canceled" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::OnCompletion
{
m_pIUsbTargetPipe, ItemPtr -- 10
pRepeater, ItemPtr -- 11
pRepeater->Request, ItemPtr -- 12
}
#typev  WdfUsbPipe_cpp711 21 "%0IWDFUsbPipe* %10!p! continuous reader cancelled IWDFIoRequest* %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::OnCompletion
{
m_pIUsbTargetPipe, ItemPtr -- 10
pRepeater->Request, ItemPtr -- 11
}
#typev  WdfUsbPipe_cpp679 20 "%0IWDFUsbPipe* %10!p! continuous reader IWDFIoRequest* %11!p! returned with %12!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbPipeContinuousReader::OnCompletion
{
pContReader->m_pIUsbTargetPipe, ItemPtr -- 10
pRepeater->Request, ItemPtr -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfUsbPipe_cpp2337 37 "%0HeaderLength + TransferLength + TrailerLength overflow%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::ConfigureContinuousReader
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbPipe_cpp2323 36 "%0HeaderLength + TransferLength overflow%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::ConfigureContinuousReader
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbPipe_cpp2308 35 "%0  wrong direction for continuous reader,%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::ConfigureContinuousReader
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbPipe_cpp2295 34 "%0IWDFUsbPipe* %10!p! type 0x%11!x!, only bulk or interruptpipes can be configured for continuous readers, %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::ConfigureContinuousReader
{
this, ItemPtr -- 10
m_PipeInfo.PipeType, ItemLong -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfUsbPipe_cpp2275 33 "%0Continuous reader already initialized on IWDFUsbPipe* %10!p! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetPipe::ConfigureContinuousReader
{
this, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
3945abe3-5aa6-209b-2638-286a0d17af91 WUDFx // SRC=WdfUsbInterface.cpp MJ= MN=
#typev  WdfUsbInterface_cpp406 15 "%0%!FUNC!: RetrieveAssociatedInterfaceHandle failed for USB Interface: %10!c! (associated interface: %11!c!), %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfUsbInterface::RetrieveAssociatedInterfaceHandle
{
AssociatedInterfaceIndex + 1, ItemChar -- 10
AssociatedInterfaceIndex, ItemChar -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfUsbInterface_cpp393 14 "%0%!FUNC!: USB Interface: %10!c! (associated interface: %11!c!) has already been retrieved.Currently multiple retrievals of same interface are not supported, %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfUsbInterface::RetrieveAssociatedInterfaceHandle
{
AssociatedInterfaceIndex + 1, ItemChar -- 10
AssociatedInterfaceIndex, ItemChar -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfUsbInterface_cpp548 16 "%0%!FUNC!: RetrieveInterfaceDescriptor failed for USB Interface %10!p!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfUsbInterface::RetrieveInterfaceDescriptor
{
static_cast<IWDFUsbInterface*>(this), ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfUsbInterface_cpp600 17 "%0%!FUNC!: SelectSetting %10!c! failed for USB Interface %11!p!, %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfUsbInterface::SelectSetting
{
SettingNumber, ItemChar -- 10
static_cast<IWDFUsbInterface*>(this), ItemPtr -- 11
hr, ItemHRESULT -- 12
}
#typev  WdfUsbInterface_cpp252 13 "%0%!FUNC!: Creating preallocated request for USB Interface failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfUsbInterface::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbInterface_cpp191 12 "%0UsbInterface object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbInterface::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfUsbInterface_cpp160 11 "%0%!FUNC!: CWdfUsbInterface creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbInterface::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbInterface_cpp140 10 "%0%!FUNC!: FxObject creation failed for UsbInterface object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbInterface::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
61f7c2d4-de0b-aee2-0759-88f548893707 WUDFx // SRC=WdfUsbTargetDevice.cpp MJ= MN=
#typev  WdfUsbTargetDevice_cpp695 14 "%0failed to retrieve config descriptor for config %10!d!, error = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetDevice::RetrieveNumInterfaces
{
ConfigIndex, ItemLong -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfUsbTargetDevice_cpp248 12 "%0UsbTargetDevice object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbTargetDevice::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfUsbTargetDevice_cpp216 11 "%0%!FUNC!: CWdfUsbTargetDevice creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbTargetDevice::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfUsbTargetDevice_cpp201 10 "%0%!FUNC!: FxObject creation failed for UsbTargetDevice object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUsbTargetDevice::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  WdfUsbTargetDevice_cpp393 13 "%0unable to allocate USB device control context returning, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfUsbTargetDevice::FormatControlRequest
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
62fd7511-0ee2-d9f4-a551-34705b4c6286 WUDFx // SRC=WdfDriverCreatedFile.cpp MJ= MN=
#typev  WdfDriverCreatedFile_cpp165 12 "%0DriverCreatedFile object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriverCreatedFile::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfDriverCreatedFile_cpp134 11 "%0%!FUNC!: CWdfDriverCreatedFile creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriverCreatedFile::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfDriverCreatedFile_cpp118 10 "%0%!FUNC!: FxObject creation failed for DriverCreatedFile object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriverCreatedFile::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
bdb80e21-101e-e8d4-99c4-1b28e0ababdd WUDFx // SRC=WdfRegPropertyStore.cpp MJ= MN=
#typev  WdfRegPropertyStore_cpp69 10 "%0%!FUNC!: ppvObject is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::QueryInterface
{
}
#typev  WdfRegPropertyStore_cpp177 12 "%0%!FUNC!: RegQueryInfoKey failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameCount
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp149 11 "%0pdwCount is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameCount
{
}
#typev  WdfRegPropertyStore_cpp295 15 "%0Index %10!d! is out of range" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
iProp, ItemLong -- 10
}
#typev  WdfRegPropertyStore_cpp304 16 "%0RegEnumValue failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp259 14 "%0%!FUNC!: RegQueryInfoKey failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp224 13 "%0ppwszName is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNameAt
{
}
#typev  WdfRegPropertyStore_cpp422 20 "%0RegQueryValueEx failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfRegPropertyStore_cpp401 19 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfRegPropertyStore_cpp372 18 "%0%!FUNC!: pwszName is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp361 17 "%0%!FUNC!: pv is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::GetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp490 22 "%0%!FUNC!: pwszName is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::SetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp478 21 "%0%!FUNC!: pv is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::SetNamedValue
{
}
#typev  WdfRegPropertyStore_cpp546 23 "%0%!FUNC!: pwszName is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::DeleteNamedValue
{
}
#typev  WdfRegPropertyStore_cpp772 34 "%0%!FUNC!: Error storing registry path %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
hr, ItemHRESULT -- 10
}
#typev  WdfRegPropertyStore_cpp758 33 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
#typev  WdfRegPropertyStore_cpp742 32 "%0%!FUNC!: Invalid subkey path length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
hr, ItemHRESULT -- 10
}
#typev  WdfRegPropertyStore_cpp725 31 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
#typev  WdfRegPropertyStore_cpp707 30 "%0%!FUNC!: Error creating registry entry %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
hr, ItemHRESULT -- 10
}
#typev  WdfRegPropertyStore_cpp676 29 "%0%!FUNC!: Invalid value for flag(s)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
#typev  WdfRegPropertyStore_cpp661 28 "%0%!FUNC!: LengthCb is not initialized to the size of WDF_PROPERTY_STORE_ROOT" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
#typev  WdfRegPropertyStore_cpp652 27 "%0%!FUNC!: ppPropStore is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
#typev  WdfRegPropertyStore_cpp643 26 "%0%!FUNC!: RootSpecifier is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
#typev  WdfRegPropertyStore_cpp634 25 "%0%!FUNC!: pDeviceStack is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
#typev  WdfRegPropertyStore_cpp625 24 "%0%!FUNC!: pDrvGlobals is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfRegPropertyStore::CreateDevicePropertyStore
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
d161f478-e52c-798a-91d5-055b3def65e8 WUDFx // SRC=WdfUtilRegPropVariantConv.cpp MJ= MN=
#typev  WdfUtilRegPropVariantConv_cpp961 42 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::NumberToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp570 28 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp558 27 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp543 26 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp530 25 "%0%!FUNC!: Registry value expansion failed for value %10!s!, hr = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
pwszExpandSz, ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfUtilRegPropVariantConv_cpp513 24 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp494 23 "%0%!FUNC!: ppwszValue is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
}
#typev  WdfUtilRegPropVariantConv_cpp484 22 "%0%!FUNC!: cbDataLen is non-zero but pwszExpandSz is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::ExpandSzToWstr
{
}
#typev  WdfUtilRegPropVariantConv_cpp903 41 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp888 40 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp876 39 "%0%!FUNC!: SizeTToInt failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1100 48 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1088 47 "%0%!FUNC!: StringCchCopy failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
}
#typev  WdfUtilRegPropVariantConv_cpp1069 46 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1056 45 "%0%!FUNC!: Data length 0x%10!I64x! is longer than MAX_INT" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
cb, ItemLongLongX -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1034 44 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp1012 43 "%0%!FUNC!: string array is NULL while count is non-zero: %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::WstrArrayToByteArray
{
cElems, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp348 19 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp335 18 "%0%!FUNC!: Data length 0x%10!I64x! is longer than MAX_INT" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
cb, ItemLongLongX -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp321 17 "%0%!FUNC!: StringCchLengthA failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp292 16 "%0%!FUNC!: StringCchLength failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp398 20 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp419 21 "%0%!FUNC!: Unsupported variant type %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
{
propvar.vt, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp653 30 "%0%!FUNC!: OUT args are not non-NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
}
#typev  WdfUtilRegPropVariantConv_cpp759 37 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp747 36 "%0%!FUNC!: Number of elements is too high %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
cElements, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp728 35 "%0%!FUNC!: CWdfDynamicArray<LPWSTR>::Add failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp713 34 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp701 33 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp686 32 "%0%!FUNC!: StringCchLength failed for %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
pwszMultiSz, ItemWString -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp662 31 "%0%!FUNC!: Data is not WCHAR aligned" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
}
#typev  WdfUtilRegPropVariantConv_cpp644 29 "%0%!FUNC!: arg pwszMultiSz is NULL while cbDataLen is %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::MultiSzToWstrArray
{
cbDataLen, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp139 13 "%0%!FUNC!: StringCchCopy failed with hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp124 12 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp110 11 "%0%!FUNC!: StringCchLength failed with hr = %10!s! data in the registy may be missing NULL terminator" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp215 15 "%0%!FUNC!: hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
hr, ItemHRESULT -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp204 14 "%0%!FUNC!: Unrecognized registry data type %10!d! converting to BLOB" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
dwRegType, ItemLong -- 10
}
#typev  WdfUtilRegPropVariantConv_cpp87 10 "%0%!FUNC!: pValue is NULL while cbDataLen is %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
{
cbDataLen, ItemLong -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0e31a2ea-d5c9-0694-c255-bad8d587a852 WUDFx // SRC=WdfMemoryBuffer.cpp MJ= MN=
#typev  WdfMemoryBuffer_cpp212 13 "%0%!FUNC!: SourceMemory is smaller than the requested number of bytes to be copied, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp195 12 "%0%!FUNC!: DestinationMemory is not large enough to contain the number of bytes requested to be copied" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
}
#typev  WdfMemoryBuffer_cpp169 11 "%0%!FUNC!: DestinationMemory is not large enough to contain the number of bytes requested to be copied" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
}
#typev  WdfMemoryBuffer_cpp142 10 "%0%!FUNC!: SourceMemory is smaller than the requested number of bytes to be copied, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWdfMemoryBuffer::CopyPtrToPtr
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp236 14 "%0%!FUNC!: Wdf Internal Error: Caller attempting to clobber preallocated memory" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::SetBufferInternal
{
}
#typev  WdfMemoryBuffer_cpp415 18 "%0%!FUNC!: Memory allocation failure %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp457 19 "%0%!FUNC!: Copying zero bytes is not allowed, 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CopyToBuffer
{
hr, ItemLong -- 10
}
#typev  WdfMemoryBuffer_cpp514 20 "%0%!FUNC!: Copying zero bytes is not allowed, 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CopyFromBuffer
{
hr, ItemLong -- 10
}
#typev  WdfMemoryBuffer_cpp585 21 "%0%!FUNC!: Zero buffer size is not allowed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::SetBuffer
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp358 17 "%0Memory object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CreateAndInitalize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfMemoryBuffer_cpp327 16 "%0%!FUNC!: CWdfMemoryBuffer creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CreateAndInitalize
{
hr, ItemHRESULT -- 10
}
#typev  WdfMemoryBuffer_cpp308 15 "%0%!FUNC!: FxObject creation failed for Device object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfMemoryBuffer::CreateAndInitalize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
a83391a4-a2bf-3a9d-9733-646829a5e052 WUDFx // SRC=WdfRequestQueue.cpp MJ= MN=
#typev  WdfRequestQueue_cpp610 11 "%0Request obj 0x%10!p! on RequestQueue 0x%11!p! cancelled" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfRequestQueue::CancelRoutineInternal
{
pRequestObj, ItemPtr -- 10
p, ItemPtr -- 11
}
#typev  WdfRequestQueue_cpp245 10 "%0%!FUNC!:Invalid tag context, 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfRequestQueue::GetNextRequest
{
TagContext, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
aa4bd4d7-06d0-4d2b-c198-cb8d515ebb65 WUDFx // SRC=Framework.cpp MJ= MN=
#typev  Framework_cpp40 10 "%0%!FUNC!: Unable to initialize the global driver tracking table, %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=DllMain
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
182a1eb6-a384-276a-89fa-2f208a4e42f5 WUDFx // SRC=WdfFile.cpp MJ= MN=
#typev  WdfFile_cpp144 12 "%0File object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfFile::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfFile_cpp113 11 "%0%!FUNC!: CWdfFile creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfFile::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfFile_cpp98 10 "%0%!FUNC!: FxObject creation failed for File object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfFile::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
ac202e92-7376-8232-f4f5-aae8b05ea6ca WUDFx // SRC=WudfOneShotTimer.h MJ= MN=
#typev  WudfOneShotTimer_h213 11 "%0CreateTimerQueueTimer Allocation failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfOneShotTimer::Initialize
{
dwErr, ItemWINERROR -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
da5d90ef-2149-d099-918f-4b418e38277f WUDFx // SRC=WdfIoRequest.cpp MJ= MN=
#typev  WdfIoRequest_cpp967 17 "%0%!FUNC!:WDFRequest 0x%10!p! doesn't belong to any queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::MarkCancelable
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp959 16 "%0%!FUNC!: Cancel callback cannot be NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::MarkCancelable
{
}
#typev  WdfIoRequest_cpp989 18 "%0%!FUNC!:WDFRequest 0x%10!p! doesn't belong to any queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::UnmarkCancelable
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1038 21 "%0Invalid parameter: The supplied destination queue 0x%10!p! is invalid, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoRequest::ForwardToIoQueue
{
pDestination, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp1027 20 "%0Invalid parameter: The supplied destination queue (IWDFIoQueue:0x%10!p!) cannot be NULL, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoRequest::ForwardToIoQueue
{
pDestination, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp1014 19 "%0Invalid operation: The request 0x%10!p! doesn't belong any queue, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoRequest::ForwardToIoQueue
{
this, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp1206 24 "%0Sending request %10!p!, Irp %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoRequest::AsyncSend
{
this, ItemPtr -- 10
this->GetSubmitIrp(), ItemPtr -- 11
}
#typev  WdfIoRequest_cpp1196 23 "%0action 0x%10!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoRequest::AsyncSend
{
Action, ItemLong -- 10
}
#typev  WdfIoRequest_cpp1179 22 "%0%!FUNC!: IoTarget %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoRequest::AsyncSend
{
pTarget, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoRequest_cpp1329 26 "%0Request 0x%10!p! already completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::InsertTailRequestQueue
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1302 25 "%0INTERNAL_ERROR: Already in Queue 0x%10!p! CWdfRequest 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::InsertTailRequestQueue
{
m_pRequestQueue, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoRequest_cpp1398 28 "%0Request 0x%10!p! already completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::InsertHeadRequestQueue
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1371 27 "%0INTERNAL_ERROR: Already in Queue 0x%10!p! CWdfRequest 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::InsertHeadRequestQueue
{
m_pRequestQueue, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoRequest_cpp1546 29 "%0Request 0x%10!p! has already been completed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_REQUEST FUNC=CWdfIoRequest::SetCompletionEvent
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp1915 30 "%0%!FUNC!: Host canceling request(0x%10!p!) ID:0%11!I64x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::_CancelRoutine
{
pReqObj, ItemPtr -- 10
pCanceledIrp->GetId(), ItemLongLongX -- 11
}
#typev  WdfIoRequest_cpp1983 31 "%0CWdfIoRequest 0x%10!p! not on CWdfRequestQueue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::RemoveFromRequestQueue
{
this, ItemPtr -- 10
m_pRequestQueue, ItemPtr -- 11
}
#typev  WdfIoRequest_cpp2103 35 "%0Could not cancel request %10!p!, already completed" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp2093 34 "%0Request %10!p!, PIRP %11!p!, completed synchronously in cancel call, completing request on target %12!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
pHostIrp, ItemPtr -- 11
m_Target, ItemPtr -- 12
}
#typev  WdfIoRequest_cpp2074 33 "%0Request %10!p!, PIRP %11!p!, cancel result %12!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
pHostIrp, ItemPtr -- 11
result, ItemLong -- 12
}
#typev  WdfIoRequest_cpp2032 32 "%0Request %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CancelSentRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoRequest_cpp2143 36 "%0%!FUNC!: Could not impersonate, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::Impersonate
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoRequest_cpp2685 37 "%0Invalid operation: IWDFIoRequest 0x%10!p! doesn't belong to queue, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoRequest::Requeue
{
static_cast<IWDFIoRequest *>(this), ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp2800 39 "%0IWDFIoRequest 0x%10!p! has been as a TagRequest in WdfIoQueuePeekNextRequest. A TagRequest can not be used until its been returned by WdfIoQueueRetrieveRequest." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::VerifierVerifyRequestIsDriverOwned
{
static_cast<IWDFIoRequest *>(this), ItemPtr -- 10
}
#typev  WdfIoRequest_cpp2792 38 "%0%!FUNC!: IWDFIoRequest 0x%10!p! is not owned by the driver, , %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::VerifierVerifyRequestIsDriverOwned
{
static_cast<IWDFIoRequest *>(this), ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp2826 40 "%0%!FUNC!: IWDFIoRequest 0x%10!p! should be unmarked cancelable by calling IWDFRequest::UnmarkCancelable, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::VerifierVerifyRequestIsNotCancelable
{
static_cast<IWDFIoRequest *>(this), ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoRequest_cpp2851 41 "%0%!FUNC!: This call is valid only in IQueueCallbackIoStop callback, IWDFIoRequest 0x%10!p!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::VerifierVerifyRequestIsInIQueueCallbackIoStopContext
{
static_cast<IWDFIoRequest *>(this), ItemPtr -- 10
hr, ItemHRESULT -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
ac202e92-7376-8232-f4f5-aae8b05ea6ca WUDFx // SRC=WudfOneShotTimer.h MJ= MN=
#typev  WudfOneShotTimer_h161 10 "%0CWudfOneShotTimer Allocation failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfOneShotTimer::CreateAndInitialize
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
da5d90ef-2149-d099-918f-4b418e38277f WUDFx // SRC=WdfIoRequest.cpp MJ= MN=
#typev  WdfIoRequest_cpp620 15 "%0Unknown WDF NTSTATUS 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CompleteWithInformation
{
status, ItemLong -- 10
}
#typev  WdfIoRequest_cpp547 14 "%0%!FUNC!:This type of request (0x%10!d!) have must information parameter set to zero" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfIoRequest::CompleteWithInformation
{
m_RequestType, ItemLong -- 10
}
#typev  WdfIoRequest_cpp524 13 "%0%!FUNC!: Completing a cancelable request IWDFIoRequest 0x%10!p!. This can result in a race condition that causes double completion. Call IWDFIoRequest::UnMarkCancelable before IWDFIoRequest::Complete. If UmarkCancelable fails, do not complete request until OnCancel is invoked." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoRequest::CompleteWithInformation
{
static_cast<IWDFIoRequest *> (this), ItemPtr -- 10
}
#typev  WdfIoRequest_cpp160 12 "%0Request object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoRequest::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfIoRequest_cpp125 11 "%0%!FUNC!: CWdfIoRequest creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoRequest::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoRequest_cpp110 10 "%0%!FUNC!: FxObject creation failed for Request object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoRequest::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0d6489d3-a45d-b62c-763f-8c36979bc8db WUDFx // SRC=FxRequestBuffer.h MJ= MN=
#typev  FxRequestBuffer_h241 11 "%0%!FUNC!: BufferOffset or length too big" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=FxRequestBuffer::ValidateMemoryOffsets
{
}
#typev  FxRequestBuffer_h231 10 "%0%!FUNC!: BufferOffset too big" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=FxRequestBuffer::ValidateMemoryOffsets
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
fe572e86-56b5-fa49-4c7d-34cf864cec8b WUDFx // SRC=wdfiotarget.cpp MJ= MN=
#typev  wdfiotarget_cpp636 16 "%0IoTarget %10!p!, Request %11!p! is being canceled on another thread, allowing other thread to complete request, not resending" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::DrainPendedRequestsLocked
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  wdfiotarget_cpp874 17 "%0IoTarget %10!p! stopped, but is current in the %11!d! state, not started or stopped" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::GotoStopState
{
this, ItemPtr -- 10
m_State, ItemLong -- 11
}
#typev  wdfiotarget_cpp1002 18 "%0GotoCloseState(%10!s!) !wudfiotarget 0x%11!p! : PriorState: %12!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::GotoCloseState
{
NewState, ItemEnum(_WDF_IO_TARGET_STATE) -- 10
static_cast<IWDFIoTarget*>(this), ItemPtr -- 11
m_State, ItemEnum(_WDF_IO_TARGET_STATE) -- 12
}
#typev  wdfiotarget_cpp1081 19 "%0CWdfIoTarget %10!p!, Waiting on Dispose event %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::WaitForDisposeEvent
{
this, ItemPtr -- 10
m_DisposeEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp1174 20 "%0%!FUNC!:WDFIOTARGET %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RemoveCompletedRequestLocked
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp2350 37 "%0Target %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::TimerCallback
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp490 15 "%0GotoStartState() !wudfiotarget 0x%10!p! : PriorState: %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::GotoStartState
{
static_cast<IWDFIoTarget*>(this), ItemPtr -- 10
m_State, ItemEnum(_WDF_IO_TARGET_STATE) -- 11
}
#typev  wdfiotarget_cpp3030 45 "%0WDFIOTARGET %10!p!, setting Dispose event %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RequestCompletionRoutine
{
this, ItemPtr -- 10
m_DisposeEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp1378 23 "%0Target %10!p!, setting stop event %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RequestCompletionRoutine
{
this, ItemPtr -- 10
m_SentIoEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp1368 22 "%0Request %10!p! completed in completion routine" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RequestCompletionRoutine
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp1311 21 "%0%!FUNC!:WDFIOTARGET %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::RequestCompletionRoutine
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp3030 45 "%0WDFIOTARGET %10!p!, setting Dispose event %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::HandleFailedResubmit
{
this, ItemPtr -- 10
m_DisposeEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp2471 40 "%0Target %10!p!, setting stop event %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::HandleFailedResubmit
{
this, ItemPtr -- 10
m_SentIoEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp2459 39 "%0Request %10!p! completed in completion routine" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::HandleFailedResubmit
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp2413 38 "%0%!FUNC!:WDFIOTARGET %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::HandleFailedResubmit
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp3030 45 "%0WDFIOTARGET %10!p!, setting Dispose event %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::CompleteCanceledRequest
{
this, ItemPtr -- 10
m_DisposeEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp2577 42 "%0Target %10!p!, setting stop event %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::CompleteCanceledRequest
{
this, ItemPtr -- 10
m_SentIoEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp2569 41 "%0Request %10!p! completed in from cancel" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::CompleteCanceledRequest
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp2720 43 "%0unable to allocate request context returning, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfIoTarget::_FormatIoRequest
{
hr, ItemHRESULT -- 10
}
#typev  wdfiotarget_cpp2942 44 "%0unable to allocate request context returning, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::_FormatIoctlRequest
{
hr, ItemHRESULT -- 10
}
#typev  wdfiotarget_cpp3129 46 "%0unable to allocate request context returning, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWdfIoTarget::_FormatGetSetInformationRequest
{
hr, ItemHRESULT -- 10
}
#typev  wdfiotarget_cpp3030 45 "%0WDFIOTARGET %10!p!, setting Dispose event %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
this, ItemPtr -- 10
m_DisposeEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp1911 29 "%0Starting timer on request %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp1859 28 "%0Pending request %10!p!, target %11!p! is paused, %12!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
this, ItemPtr -- 11
hr, ItemNTSTATUS -- 12
}
#typev  wdfiotarget_cpp1727 27 "%0failing request %10!p!, target %11!p! not accepting requests, state %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
this, ItemPtr -- 11
m_State, ItemLong -- 12
}
#typev  wdfiotarget_cpp1693 26 "%0ignoring WDFIOTARGET %10!p! state, sending request %11!p!, state %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
m_State, ItemLong -- 12
}
#typev  wdfiotarget_cpp1662 25 "%0Request %10!p!, could not create timer, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  wdfiotarget_cpp1619 24 "%0WDFREQUEST %10!p! already sent to a target" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitLocked
{
Request, ItemPtr -- 10
}
#typev  wdfiotarget_cpp2083 33 "%0Sending request %10!p!, Irp %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
Request, ItemPtr -- 10
Request->GetSubmitIrp(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp2067 32 "%0action 0x%10!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
action, ItemLong -- 10
}
#typev  wdfiotarget_cpp1994 31 "%0Failed to allocate wait event for sync request, Target %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp1976 30 "%0Target %10!p!, Request %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitSync
{
this, ItemPtr -- 10
Request, ItemPtr -- 11
}
#typev  wdfiotarget_cpp3030 45 "%0WDFIOTARGET %10!p!, setting Dispose event %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitPendedRequest
{
this, ItemPtr -- 10
m_DisposeEvent->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp374 14 "%0Completing Pended CWdfIoRequest* %10!p!, Irp %11!p!, %12!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitPendedRequest
{
Request, ItemPtr -- 10
irp, ItemPtr -- 11
irp->GetStatus(), ItemHRESULT -- 12
}
#typev  wdfiotarget_cpp357 13 "%0Sending request %10!p!, Irp %11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::SubmitPendedRequest
{
Request, ItemPtr -- 10
Request->GetSubmitIrp(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp316 12 "%0IoTarget object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoTarget::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  wdfiotarget_cpp283 11 "%0%!FUNC!: CWdfIoTarget creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoTarget::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  wdfiotarget_cpp262 10 "%0%!FUNC!: FxObject creation failed for IoTarget object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoTarget::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
20c096cb-3b21-a8bf-7f52-f786f36469e7 WUDFx // SRC=WdfIoQueue.cpp MJ= MN=
#typev  WdfIoQueue_cpp3139 73 "%0%!FUNC!: Acquiring the presentation lock for IoQueue (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3133 72 "%0%!FUNC!: Invalid operation. The IoQueue (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3162 75 "%0%!FUNC!: Releasing the presentation lock for IoQueue (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3156 74 "%0%!FUNC!: Invalid operation. The IoQueue (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfIoQueue::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1390 38 "%0Could not get the request type, completing with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1354 35 "%0%!FUNC!: Driver hasn't registered for OnClose notification.Framework is automatically completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1381 37 "%0Request 0x%10!p! of type 0x%11!x! dispatched to Driver" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
pRequestObj, ItemPtr -- 10
RequestType, ItemLong -- 11
}
#typev  WdfIoQueue_cpp1229 31 "%0%!FUNC!: Driver hasn't registered for OnRead notification.Framework completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1260 32 "%0%!FUNC!: Driver hasn't registered for OnWrite notification.Framework completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1297 33 "%0%!FUNC!: Driver hasn't registered for OnDeviceIoControl notification.Framework completing the request with %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1368 36 "%0%!FUNC!: Unknown request type(0x%10!x!), not delivered to driver" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
RequestType, ItemLong -- 10
}
#typev  WdfIoQueue_cpp1320 34 "%0%!FUNC!: Driver hasn't registered for OnDefaultIo notification.Framework completing %10!s! request with %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
RequestType, ItemEnum(_WDF_REQUEST_TYPE) -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoQueue_cpp1195 30 "%0%!FUNC!: INTERNAL ERROR: unable to QI IWDFIoRequest interface" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
}
#typev  WdfIoQueue_cpp1185 29 "%0%!FUNC!: INTERNAL ERROR: unable to QI IWDFIoQueue interface" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SubmitRequest
{
}
#typev  WdfIoQueue_cpp1467 42 "%0FxIoQueue::RequestCompleteEvent Request 0x%10!p! is on a cancellation list for Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
RequestObj, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1446 41 "%0FxIoQueue::RequestCompleteEvent Request 0x%10!p! Has been used as a TagRequest in WdfIoQueuePeekNextRequest. A TagRequest can not be used until its been returned by WdfIoQueueRetrieveRequest." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
RequestObj, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1437 40 "%0FxIoQueue::RequestCompleteEvent Request 0x%10!p! not Driver owned! It is an error to call IWDFIoRequest::Complete on a non driver owned request." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
RequestObj, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1425 39 "%0Fired, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCompleteEvent
{
this, ItemPtr -- 10
RequestObj, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1658 46 "%0ProcessCancelledRequests: Calling Driver for Request 0x%10!p!, queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessCancelledRequests
{
pReqObj, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1731 47 "%0ProcessCancelledRequestsOnQueue: Calling Driver for Request 0x%10!p!, queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessCancelledRequestsOnQueue
{
pReqObj, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1789 48 "%0Executing work item, Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue_WorkItemThunk
{
pWdfQueueObj, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1815 50 "%0%!FUNC!:The queue 0x%10!p! is being rundown" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::EnqueueWorkItem
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp1807 49 "%0%!FUNC!:Work item pending for queue 0x%10!p!, no need to queue another one" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::EnqueueWorkItem
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2882 69 "%0pRequest->SetCompletionEvent() was already set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CancelForQueue
{
}
#typev  WdfIoQueue_cpp2843 68 "%0%!FUNC!:Request 0x%10!p! (ID:0x%11!I64x!) was cancelled while on queue 0x%12!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CancelForQueue
{
pRequest, ItemPtr -- 10
pRequest->GetHostIrpId(), ItemLongLongX -- 11
this, ItemPtr -- 12
}
#typev  WdfIoQueue_cpp3538 80 "%0%!FUNC!:  status 0x%10!x! is invalid, Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::SetState
{
NewStatus, ItemLong -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3645 82 "%0%!FUNC!: Can not delete Queue 0x%10!p! because it has %11!d! Queued Requests and %12!d! Driver Pending Requests" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DeleteWdfObject
{
this, ItemPtr -- 10
queuedCount, ItemLong -- 11
pendingCount, ItemLong -- 12
}
#typev  WdfIoQueue_cpp3629 81 "%0%!FUNC!: Queue 0x%10!p! State 0x%11!x! incorrect for deleting. Must clear WdfIoQueueAcceptRequests" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DeleteWdfObject
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
}
#typev  WdfIoQueue_cpp4161 94 "%0pRequest->SetCompletionEvent() was already set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
}
#typev  WdfIoQueue_cpp4098 93 "%0%!FUNC!: Queue 0x%10!p! is paused" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4087 92 "%0%!FUNC!:Queue 0x%10!p! is powered off" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4075 91 "%0%!FUNC!:Can not be called on a parallel Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4051 90 "%0%!FUNC!: Driver called IWDFIoQueue::RetrieveNextRequest on a sequential queue with no outstanding requests, Queue 0x%10!p!. This can cause a race with automatically dispatched requests. Call IWDFIoQueue::RetrieveNextRequest before completing the current request(s)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4030 89 "%0%!FUNC!: TagRequest 0x%10!p! is not referenced or owned by driver" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::GetRequest
{
TagRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp5072 114 "%0%!FUNC!: Acknowledging IWDFIoRequest 0x%10!p! on IWDFIoQueue 0x%11!p! %12!s! requeue option" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessAcknowledgedRequests
{
static_cast<IWDFIoRequest *>(Request), ItemPtr -- 10
static_cast<IWDFIoQueue *>(this), ItemPtr -- 11
(requeue ? 'with' : 'without'), ItemString -- 12
}
#typev  WdfIoQueue_cpp606 18 "%0%!FUNC!: Invalid IWDFFile param:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RetrieveNextRequestByFileObject
{
pFile, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp5038 113 "%0%!FUNC!:Invalid power state 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
m_PowerState, ItemLong -- 10
}
#typev  WdfIoQueue_cpp5025 112 "%0Power Resume: Queue 0x%10!p! is now powered on and I/O has resumed" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp5010 111 "%0Power Resume: Driver has no callback for EvtIoResume registered on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4995 110 "%0Power Resume, Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4942 109 "%0Power Resume: Driver has no power paused requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4921 108 "%0Power Resume: Driver has power paused requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4898 107 "%0Power Stop: Driver has acknowledged all in-flight requests, but Queue 0x%10!p! has outstanding callbacks" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4879 106 "%0Power Stop: Queue 0x%10!p! is now powered off with no in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4863 105 "%0Power Stop: Waiting for Driver to complete or acknowledge in-flight requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4791 104 "%0Power Purge Notifying Driver, Driver has no EvtIoStop callback registered Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4766 103 "%0Power Purge Notifying Driver, Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4747 102 "%0Power Purge Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4696 101 "%0Power Stop, Driver has no IQueueCallbackIoStop callback registered Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4672 100 "%0Power Stop Notifying Driver, Queue 0x%10!p!, Request 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
pRequest, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp4611 99 "%0Power purge: Queue 0x%10!p! is purging without in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4591 98 "%0%!FUNC!: Queue 0x%10!p! is purging with in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4568 97 "%0%!FUNC!: Queue 0x%10!p! is powering off without in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4545 96 "%0%!FUNC!: Queue 0x%10!p! is powering off with in-flight requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPowerEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp211 11 "%0Queue is idle, calling driver callback" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessStopComplete
{
}
#typev  WdfIoQueue_cpp891 25 "%0%!FUNC!: For manual queues each of the following callbacks must be NULL -     Create:0x%10!p!, Read:0x%11!p!, Write:0x%12!p!, DevIoCtrl:0x%13!p!, Driver's IUnknown:0x%14!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
pCreateCallback, ItemPtr -- 10
pReadCallback, ItemPtr -- 11
pWriteCallback, ItemPtr -- 12
pDevIoControlCallback, ItemPtr -- 13
pCallbackInterface, ItemPtr -- 14
}
#typev  WdfIoQueue_cpp864 24 "%0%!FUNC!: No valid callbacks on the non-manual queue. IUnknown:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
pCallbackInterface, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp715 23 "%0%!FUNC!: Unable to create the poweridle event, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
err, ItemWINERROR -- 10
}
#typev  WdfIoQueue_cpp701 22 "%0%!FUNC!: Unable to create an event, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
err, ItemWINERROR -- 10
}
#typev  WdfIoQueue_cpp684 21 "%0%!FUNC!: Unable to create the work-item , %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
status, ItemNTSTATUS -- 10
}
#typev  WdfIoQueue_cpp673 20 "%0%!FUNC!: Invalid input. pCallbackInterface:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
pCallbackInterface, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp662 19 "%0%!FUNC!: Invalid dispatch mode(0x%10!x!) specified for queue:0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Initialize
{
DispatchType, ItemLong -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3987 88 "%0Queue is purged, calling driver callback" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessPurgeComplete
{
}
#typev  WdfIoQueue_cpp3416 79 "%0%!FUNC!: notify method == NULL on WdfIoQueue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ProcessReadyNotify
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2170 58 "%0No requests on Queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2146 57 "%0Driver has %10!d! requests and WdfIoQueueDispatchSequential, waiting... Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
m_DriverIoCount, ItemLong -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp2131 56 "%0Driver has configured Queue 0x%10!p! for WdfIoQueueDispatchManual" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2101 55 "%0Queue not in Dispatching state, queue 0x%10!p!, State 0x%11!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
}
#typev  WdfIoQueue_cpp2062 54 "%0Queue 0x%10!p! Power Transition State %11!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
m_PowerState, ItemLong -- 11
}
#typev  WdfIoQueue_cpp1967 53 "%0In Thread (ID:%10!d!), processing requests" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
GetCurrentThreadId(), ItemLong -- 10
}
#typev  WdfIoQueue_cpp1948 52 "%0Presentation lock for Queue 0x%10!p! already held, deferring to workitem" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DispatchEvents
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2378 60 "%0Queuing Request 0x%10!p! on Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequestFromForward
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp2365 59 "%0Queue 0x%10!p! is not accepting requests State 0x%11!x!, request 0x%12!p!. Returning error" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequestFromForward
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
pRequest, ItemPtr -- 12
}
#typev  WdfIoQueue_cpp2623 65 "%0pRequest->SetCompletionEvent() was already set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
}
#typev  WdfIoQueue_cpp2527 64 "%0%!FUNC!: Request 0x%10!p! is cancelable. Call IWDFRequest::UnmarkCancelable before Forwarding to another Queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2511 63 "%0%!FUNC!: Request 0x%10!p! Has been used as a TagRequest in WdfIoQueueFindRequest. A TagRequest can not be used until its been retrieved by WdfIoQueueRetrieveFoundRequest" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2504 62 "%0%!FUNC!: Request 0x%10!p! not owned by driver! Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp2473 61 "%0FxIoQueue::ForwardRequest Cannot forward a request to the same queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::ForwardRequest
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2759 67 "%0IWDFIoRequest 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequeueRequest
{
static_cast<IWDFIoRequest *>(pRequest), ItemPtr -- 10
}
#typev  WdfIoQueue_cpp2718 66 "%0Invalid operation: Requeue is allowed only for a manual queue, IWDFIoRequest 0x%10!p!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequeueRequest
{
static_cast<IWDFIoRequest *>(pRequest), ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfIoQueue_cpp3008 71 "%0%!FUNC!: CWdfIoRequest 0x%10!p! (ID:0x%11!I64x!) is already on list, CWdfIoRequest::m_OwnerListEntry is busy!, Queue 0x%12!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CancelForDriver
{
pRequest, ItemPtr -- 10
pRequest->GetHostIrpId(), ItemLongLongX -- 11
this, ItemPtr -- 12
}
#typev  WdfIoQueue_cpp2998 70 "%0%!FUNC!: Host has canceled Request 0x%10!p! in driver for queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::CancelForDriver
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3229 78 "%0%!FUNC! Request 0x%10!p! is already not cancelable" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCancelable
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3214 77 "%0%!FUNC!: Request 0x%10!p! is already cancelable" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCancelable
{
pRequest, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3189 76 "%0%!FUNC!: Request 0x%10!p! not owned by driver! Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::RequestCancelable
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3895 87 "%0%!FUNC!: queue 0x%10!p! all driver cancellable requests cancelled" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3858 85 "%0%!FUNC!: WdfIoQueue 0x%10!p! all Queued requests cancelled" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp3867 86 "%0%!FUNC!: Cancelling Request 0x%10!p!, Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
pRequest, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3829 84 "%0%!FUNC!:Queue 0x%10!p! already has a PurgeComplete callback registered 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
m_PurgeCompleteCallback.m_spCallback.p, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp3801 83 "%0%!FUNC!:Queue 0x%10!p! already has a SynchronousPurgeComplete registered" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueuePurge
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp4226 95 "%0%!FUNC!: Waiting for all threads to stop dispatching requests so that IWDFIoQueue 0x%10!p! can be powered off" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::StartPowerTransitionOff
{
static_cast<IWDFIoQueue *>(this), ItemPtr -- 10
}
#typev  WdfIoQueue_cpp153 10 "%0Starting !wudfqueue 0x%10!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::Start
{
static_cast<IWDFIoQueue*>(this), ItemPtr -- 10
}
#typev  WdfIoQueue_cpp287 14 "%0Queue 0x%10!p! already has a IdleComplete callback registered 0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueStop
{
this, ItemPtr -- 10
m_StopCompleteCallback.m_spCallback.p, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp258 13 "%0%!FUNC!:Queue 0x%10!p! already has a SynchronousPurgeComplete registered" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueStop
{
this, ItemPtr -- 10
}
#typev  WdfIoQueue_cpp250 12 "%0Stopping !wudfqueue 0x%10!p! : IsSynchronous(%11!s!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueStop
{
static_cast<IWDFIoQueue*>(this), ItemPtr -- 10
IsSynchronous, ItemListLong(false,true) -- 11
}
#typev  WdfIoQueue_cpp374 15 "%0%!FUNC!: Failed (%10!s!) for queue:0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::StopSynchronously
{
err, ItemWINERROR -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp431 16 "%0%!FUNC!: Failed (%10!s!) for queue:0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::DrainSynchronously
{
err, ItemWINERROR -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp476 17 "%0%!FUNC!: Failed (%10!s!) for for queue:0x%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::PurgeSynchronously
{
err, ItemWINERROR -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1142 28 "%0Queue object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoQueue::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1105 27 "%0%!FUNC!: CWdfIoQueue creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoQueue::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfIoQueue_cpp1090 26 "%0%!FUNC!: FxObject creation failed for Queue object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfIoQueue::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  WdfIoQueue_cpp1585 45 "%0Queuing Request 0x%10!p! on Queue 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequest
{
pReqObj, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  WdfIoQueue_cpp1574 44 "%0Queue is configured to automatically complete zero-length request" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequest
{
}
#typev  WdfIoQueue_cpp1526 43 "%0Queue 0x%10!p! is not accepting requests status %11!d! cancelling request 0x%12!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfIoQueue::QueueRequest
{
this, ItemPtr -- 10
m_Status, ItemLong -- 11
pReqObj, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
5f180421-81b9-e547-4edd-bbe500038fdd WUDFx // SRC=WdfTransportSettings.cpp MJ= MN=
#typev  WdfTransportSettings_cpp338 10 "%0%!FUNC!:CStringID::CreateAndInitialize() failure: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfTransportSettings::AddID
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
714fbb97-ff19-c791-26b1-76cb06ba775a WUDFx // SRC=wdfiotarget.h MJ= MN=
#typev  wdfiotarget_h690 12 "%0CreateTimerQueue failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::Initialize
{
dwErr, ItemWINERROR -- 10
}
#typev  wdfiotarget_h673 11 "%0AllocateEvent for m_DisposeEvent failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::Initialize
{
hr, ItemWINERROR -- 10
}
#typev  wdfiotarget_h661 10 "%0AllocateEvent for m_SentIoEvent failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IOTARGET FUNC=CWdfIoTarget::Initialize
{
hr, ItemWINERROR -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
e355825c-b149-7941-ff2e-346e2ff24d1b WUDFx // SRC=WdfDevice.cpp MJ= MN=
#typev  WdfDevice_cpp689 12 "%0%!FUNC!: No default queue for this device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::GetDefaultIoQueue
{
}
#typev  WdfDevice_cpp1904 29 "%0%!FUNC!: Framework device object was created, but IWDFDriver::OnDeviceAdd returned hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::DeleteDeviceFromFailedCreateNoDelete
{
FailedHResult, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2516 36 "%0%!FUNC!: Invalid request type,%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::DispatchRequest
{
requestType, ItemLong -- 10
}
#typev  WdfDevice_cpp2539 37 "%0%!FUNC!: Invalid operation. The device queues are not configured" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::DispatchRequest
{
}
#typev  WdfDevice_cpp2890 41 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::ReadFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2874 40 "%0%!FUNC!: Read message, IWudfIoIrp:0x%10!p!, Context:0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::ReadFile
{
pReadIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp2949 43 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::WriteFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2933 42 "%0%!FUNC!: Write message, IWudfIoIrp 0x%10!p!, Context 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::WriteFile
{
pWriteIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp3007 45 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::DeviceControl
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2991 44 "%0%!FUNC!: DeviceControl message, IWudfIoIrp 0x%10!p!, Context: 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::DeviceControl
{
pDevCntrlIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp3065 47 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::FlushBuffers
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp3049 46 "%0%!FUNC!: Flush message, IWudfIoIrp 0x%10!p!, Context 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::FlushBuffers
{
pFlushIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp3121 49 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::QueryInformationFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp3105 48 "%0%!FUNC!: QueryInformation message, IWudfIoIrp 0x%10!p!, Context 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::QueryInformationFile
{
pIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp3177 51 "%0%!FUNC!: Could not QI for file objec. Internal error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::SetInformationFile
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp3161 50 "%0%!FUNC!: SetInformation message, IWudfIoIrp 0x%10!p!, Context 0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::SetInformationFile
{
pIrp, ItemPtr -- 10
pFxContext, ItemPtr -- 11
}
#typev  WdfDevice_cpp3217 52 "%0%!FUNC!: DeviceInterfaceArrival message, Interface %10!s!, SymbolicLink: %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::RemoteInterfaceArrival
{
pDeviceInterfaceGuid, ItemGuid -- 10
pSymbolicLink, ItemWString -- 11
}
#typev  WdfDevice_cpp3239 53 "%0%!FUNC!: DeviceInterfaceRemoval message. RemoteInterfaceID: %10!I64u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_IO FUNC=CWdfDevice::RemoteInterfaceRemoval
{
RemoteInterfaceID, ItemULongLong -- 10
}
#typev  WdfDevice_cpp3342 59 "%0The queue parameter (0x%10!p!) passed to ConfigureRequestDispatching doesn't match the queue (0x%11!p!) previously registered with the framwork" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
pQueueObj, ItemPtr -- 10
m_DispatchTable[RequestType], ItemPtr -- 11
}
#typev  WdfDevice_cpp3329 58 "%0The device is NOT configured for this request type (0x%10!d!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
RequestType, ItemLong -- 10
}
#typev  WdfDevice_cpp3306 57 "%0The device is already configured for this request type (0x%10!d!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
RequestType, ItemLong -- 10
}
#typev  WdfDevice_cpp3294 56 "%0IWDFIoQueue argument is the default queue. It is not valid to change request dispatching on the default queue" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
}
#typev  WdfDevice_cpp3282 55 "%0The queue parameter (0x%10!p!) passed to ConfigureRequestDispatching doesn't belong to this device" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
pQueueObj, ItemPtr -- 10
}
#typev  WdfDevice_cpp3267 54 "%0Invalid operation. The driver must either have IQueueCallbackDefaultIoHandler or handler for request type %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ConfigureForwarding
{
RequestType, ItemLong -- 10
}
#typev  WdfDevice_cpp3678 61 "%0%!FUNC!: Acquiring the presentation lock for device (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp3668 60 "%0%!FUNC!: Invalid operation. The device (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AcquireLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp3704 63 "%0%!FUNC!: Releasing the presentation lock for device (0x%10!p!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp3695 62 "%0%!FUNC!: Invalid operation. The device (0x%10!p!) is not configured to have callback lock" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ReleaseLock
{
this, ItemPtr -- 10
}
#typev  WdfDevice_cpp4619 74 "%0IWDFDevice::ResumeIdle does nothing if you are not the power policy owner for the stack" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::ResumeIdle
{
}
#typev  WdfDevice_cpp194 10 "%0%!FUNC!: Releasing resources in CWdfDevice" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::~CWdfDevice
{
}
#typev  WdfDevice_cpp309 11 "%0Can't delete default queue 0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWdfDevice::RemoveQueueReferences
{
pQueue, ItemPtr -- 10
}
#typev  WdfDevice_cpp790 16 "%0%!FUNC!: Attempting to create a default queue, when one is already present, %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp762 15 "%0%!FUNC!: failed creating queue %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp742 14 "%0%!FUNC!: Invalid parameter: The IUnknown* parameter is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
}
#typev  WdfDevice_cpp728 13 "%0%!FUNC!: Invalid paramater: IWDFIoQueue parameter is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateIoQueue
{
}
#typev  WdfDevice_cpp1165 19 "%0%!FUNC!: Error hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AssignDeviceInterfaceState
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1288 20 "%0%!FUNC!: NULL is an invalid value for paramater pdwDeviceNameLength" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::RetrieveDeviceName
{
}
#typev  WdfDevice_cpp1359 21 "%0%!FUNC!: NULL is an invalid value for paramater pdwDevInstLength" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::RetrieveDeviceInstanceId
{
}
#typev  WdfDevice_cpp1422 22 "%0%!FUNC!: NULL is an invalid paramater" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::RetrieveDevicePropertyStore
{
}
#typev  WdfDevice_cpp1499 24 "%0%!FUNC!: PostEvent failure - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::PostEvent
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1488 23 "%0%!FUNC!: Invalid event type, %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::PostEvent
{
WdfEventType, ItemLong -- 10
}
#typev  WdfDevice_cpp2154 34 "%0%!FUNC!:Unable to copy kernel device name hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2141 33 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for device key path" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
}
#typev  WdfDevice_cpp2119 32 "%0%!FUNC!:Registry key open failed for the PDO key, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
lRetVal, ItemWINERROR -- 10
}
#typev  WdfDevice_cpp2100 31 "%0%!FUNC!:Unable to copy kernel device name hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2087 30 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for kernel device name" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDevice::Initialize
{
}
#typev  WdfDevice_cpp2272 35 "%0%!FUNC!: FxPkgFdo creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDevice::FdoInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp2852 39 "%0%!FUNC!: Could not QI 0x%10!p! for file object. Internal error %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::CloseFile
{
pFxContext, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfDevice_cpp4196 65 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfDevice::CreateRemoteTarget
{
}
#typev  WdfDevice_cpp4138 64 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfDevice::CreateRemoteTarget
{
}
#typev  WdfDevice_cpp4262 67 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfDevice::CreateRemoteInterface
{
}
#typev  WdfDevice_cpp4240 66 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWdfDevice::CreateRemoteInterface
{
}
#typev  WdfDevice_cpp4481 69 "%0a parameter (DxState, IdleCaps, Enabled, or UserControlOfIdleSettings) is out range, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AssignS0IdleSettings
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp4454 68 "%0IWDFDevice::AssignS0IdleSettings cannot be called if you are not the power policy owner for the stack, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AssignS0IdleSettings
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp4547 71 "%0a parameter (DxState, Enabled, or UserControlOfWakeSettings) is out range, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AssignSxWakeSettings
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp4523 70 "%0IWDFDevice::AssignSxWakeSettings cannot be called if you are not the power policy owner for the stack, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::AssignSxWakeSettings
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp4601 73 "%0IWDFDevice::StopIdle, WaitForD0 %10!d! %11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::StopIdle
{
WaitForD0, ItemLong -- 10
hr, ItemHRESULT -- 11
}
#typev  WdfDevice_cpp4585 72 "%0IWDFDevice::StopIdle does nothing if you are not the power policy owner for the stack, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::StopIdle
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp920 18 "%0%!FUNC!: Error hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateDeviceInterface
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp904 17 "%0%!FUNC!: Error allocating device interface object - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDevice::CreateDeviceInterface
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1851 28 "%0Device object created, IWDFDevice: %10!p!, Fx object: %11!p!, WDFOBJECT %12!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::CreateAndInitialize
{
*ppIWdfDevice, ItemPtr -- 10
ufxObject, ItemPtr -- 11
fxUserObject->GetHandle(), ItemPtr -- 12
}
#typev  WdfDevice_cpp1780 27 "%0%!FUNC!: CWdfDevice creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfDevice_cpp1765 26 "%0%!FUNC!: FxObject creation failed for Device object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  WdfDevice_cpp1720 25 "%0%!FUNC!: Event initialization failed while creating Device object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWdfDevice::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  WdfDevice_cpp2738 38 "%0%!FUNC!: Could not QI 0x%10!p! for file object. Internal error %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDevice::CleanupFile
{
pFxContext, ItemPtr -- 10
hr, ItemHRESULT -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0bdf5fbf-8170-57fc-0425-6548a52a3781 WUDFx // SRC=WdfWin32Target.h MJ= MN=
#typev  WdfWin32Target_h391 12 "%0UserObject created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfWin32Target::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  WdfWin32Target_h360 11 "%0%!FUNC!: CWdfWin32Target creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfWin32Target::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfWin32Target_h341 10 "%0%!FUNC!: FxObject creation failed for Device object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfWin32Target::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
7aa04d47-3431-0e4a-3228-08e479586cd5 WUDFx // SRC=WdfDeviceInterface.cpp MJ= MN=
#typev  WdfDeviceInterface_cpp142 10 "%0%!FUNC!: Error allocating new device interface object." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DEVICE FUNC=CWdfDeviceInterface::CreateAndInitialize
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
936abc1a-a5a4-6626-0338-44f0855b635b WUDFx // SRC=WdfDeviceInit.cpp MJ= MN=
#typev  WdfDeviceInit_cpp334 11 "%0%!FUNC!: RetrievalMode %10!d! ReadWriteMode %11!d! IoctlMode %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDeviceInit::SetIoTypePreference
{
RetrievalMode, ItemLong -- 10
ReadWritePreference, ItemLong -- 11
IoControlPreference, ItemLong -- 12
}
#typev  WdfDeviceInit_cpp158 10 "%0%!FUNC!: NULL is an invalid paramater" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDeviceInit::RetrieveDevicePropertyStore
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
87eda55b-613f-d064-fc42-060a97950094 WUDFx // SRC=UfxObject.h MJ= MN=
#typev  UfxObject_h532 10 "%0%!FUNC!: Ref count of Object 0x%10!p! transitioning from 0 to 1. This is typically caused by incorrect manipulation of object reference count" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=UfxObject::AddRef
{
this, ItemPtr -- 10
}
#typev  UfxObject_h588 11 "%0%!FUNC!: Ref count of Object 0x%10!p!, transitioning from 0 to -1. This is typically caused by incorrect manipulation of object reference count" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=UfxObject::Release
{
this, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
1ecbbe93-7bb0-313c-3d71-feb288f7ecaa WUDFx // SRC=WdfUserObject.h MJ= MN=
#typev  WdfUserObject_h266 12 "%0UserObject created, IWDFObject: %10!p!, Fx object: %11!p!, WDFOBJECT %12!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfUserObject::CreateAndInitialize
{
*ppObject, ItemPtr -- 10
ufxObject, ItemPtr -- 11
fxUserObject->GetHandle(), ItemPtr -- 12
}
#typev  WdfUserObject_h233 11 "%0%!FUNC!: CWdfUserObject creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUserObject::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WdfUserObject_h214 10 "%0%!FUNC!: FxObject creation failed for UserObject %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfUserObject::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
b5029802-8407-885a-8a24-8dce10eb7d6e WUDFx // SRC=wdfdriver.cpp MJ= MN=
#typev  wdfdriver_cpp64 11 "%0%!FUNC!: Releasing UMD's IDriverEntry interface" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDriver::~CWdfDriver
{
}
#typev  wdfdriver_cpp59 10 "%0%!FUNC!: Cleaning up CWUDFDEvice" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWdfDriver::~CWdfDriver
{
}
#typev  wdfdriver_cpp590 29 "%0%!FUNC!: Invalid parameter: pDeviceInit, pDeviceQueryInterface or ppDevice is NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWdfDriver::CreateDevice
{
}
#typev  wdfdriver_cpp660 30 "%0%!FUNC!: User object creation failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreateWdfObject
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp520 28 "%0%!FUNC!:Filter driver returned hr=%10!s!: withoutcreating a WDFDEVICE, converting to S_OK" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp509 27 "%0%!FUNC!:Driver did not create a device in OnDeviceAdd, hr=%10!s!:" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp470 26 "%0%!FUNC!:Unable to copy kernel device name hr=%10!s!:" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp453 25 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for kernel device name" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
}
#typev  wdfdriver_cpp438 24 "%0%!FUNC!:Unable to determine KernelDeviceName length %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp419 23 "%0%!FUNC!:Unable to copy the configuration path %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp406 22 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
}
#typev  wdfdriver_cpp391 21 "%0%!FUNC!:Device Instance ID string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp373 20 "%0%!FUNC!:Unable to copy the configuration path %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp359 19 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
}
#typev  wdfdriver_cpp342 18 "%0%!FUNC!:Registry path string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp327 17 "%0%!FUNC!:Registry key open failed for the PDO key, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
lRetVal, ItemWINERROR -- 10
}
#typev  wdfdriver_cpp304 16 "%0%!FUNC!: Could not allocate resource, hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_INIT FUNC=CWdfDriver::OnAddDevice
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp286 15 "%0%!FUNC!: UndoEvent initialization failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWdfDriver::OnAddDevice
{
status, ItemNTSTATUS -- 10
}
#typev  wdfdriver_cpp749 31 "%0%!FUNC!: Invalid arguments passed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreatePreallocatedWdfMemory
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp818 32 "%0%!FUNC!: Invalid arguments passed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreateWdfMemory
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp207 14 "%0Driver object created, Fx object: %10!p!, WDFOBJECT %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreateAndInitialize
{
ufxObject, ItemPtr -- 10
fxUserObject->GetHandle(), ItemPtr -- 11
}
#typev  wdfdriver_cpp176 13 "%0%!FUNC!: CWdfDriver creation failed, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  wdfdriver_cpp161 12 "%0%!FUNC!: FxObject creation failed for Driver object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_OBJECT FUNC=CWdfDriver::CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
8ce315db-4508-3f1f-c953-2c16d7cfc657 WUDFx // SRC=WdfGlobals.cpp MJ= MN=
#typev  WdfGlobals_cpp137 10 "%0%!FUNC!: %10!s! 0x%11!p!, WaitForSingleObject on event (0x%12!p!) failed (%13!s!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWudfDriverGlobals::WaitForSignal
{
ReasonForWaiting, ItemString -- 10
WaitContext, ItemPtr -- 11
Event, ItemPtr -- 12
GetLastError(), ItemWINERROR -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
77cd79f1-dbd1-7e35-3d66-d01fc146e908 WUDFx // SRC=WUDF.cpp MJ= MN=
#typev  WUDF_cpp295 17 "%0LibraryDriverEntry failed with status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWudfDriverTable::_FxLibraryLoad
{
status, ItemNTSTATUS -- 10
}
#typev  WUDF_cpp541 21 "%0Global device stack table is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDriverTable::Remove
{
pDrvGlobal, ItemPtr -- 10
}
#typev  WUDF_cpp523 20 "%0Device Stack not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDriverTable::Remove
{
pDrvGlobal, ItemPtr -- 10
}
#typev  WUDF_cpp237 16 "%0Allocation of driver name service key buffer failed hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::_BuildDriverServiceKeyName
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp225 15 "%0Obtaining total length of driver service key failed, potenitally driver name is too long. hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::_BuildDriverServiceKeyName
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp210 14 "%0Obtaining total length of driver service key failed, potenitally driver name is too long. hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::_BuildDriverServiceKeyName
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp200 13 "%0Obtaining WDF_ROOT_SERVICE_KEY length failed, hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::_BuildDriverServiceKeyName
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp388 19 "%0FxInitialize failed with status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::_FxDriverLoad
{
status, ItemNTSTATUS -- 10
}
#typev  WUDF_cpp348 18 "%0FxDriverEntry failed with status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::_FxDriverLoad
{
status, ItemNTSTATUS -- 10
}
#typev  WUDF_cpp711 25 "%0%!FUNC!: IDriverEntry::OnInitialize invoked, %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp693 24 "%0%!FUNC!: Load driver failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp677 23 "%0%!FUNC!: Unable to create object tracker while tracking is enabled, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WUDF_cpp646 22 "%0%!FUNC!: Not able to create driver global object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=CWUDF::Initialize
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
77b4c3be-52fa-8c40-55e0-346388396044 FxDeviceUm // SRC=UmToMx.cpp MJ= MN=
#typev  UmToMx_cpp170 10 "%0%!FUNC!: Failed to set Registry value for S0Idle/SxWake error %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=UmToMx::WriteStateToRegistry
{
err, ItemLong -- 10
}
#typev  UmToMx_cpp253 12 "%0%!FUNC!: failed to read registry, RegQueryValueEx returned error %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PNP FUNC=UmToMx::ReadStateFromRegistry
{
Err, ItemLong -- 10
}
#typev  UmToMx_cpp236 11 "%0%!FUNC!: RegOpenKeyEx returned error %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PNP FUNC=UmToMx::ReadStateFromRegistry
{
Err, ItemLong -- 10
}
#typev  UmToMx_cpp335 13 "%0%!FUNC!: failed to send ioctl to update S0Idle wmi instance %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=UmToMx::UpdateWmiInstanceForS0Idle
{
status, ItemNTSTATUS -- 10
}
#typev  UmToMx_cpp389 14 "%0%!FUNC!: failed to send ioctl to update SxWake wmi instance %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_PNP FUNC=UmToMx::UpdateWmiInstanceForSxWake
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
a70a6fd8-1ff2-3eff-1c83-ac1029cad038 FxIrpUm // SRC=FxIrpUm.cpp MJ= MN=
#typev  FxIrpUm_cpp182 10 "%0Failed to create event, error: %10!s!, returning %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=FxIrp::SendIrpSynchronously
{
err, ItemWINERROR -- 10
status, ItemNTSTATUS -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0cb05f64-1305-ad9b-046c-8d30905d67c5     WdfCore // SRC=fxpkgfdo.cpp MJ= MN=
#typev  fxpkgfdo_cpp488 12     "%0Exiting QueryDeviceRelations handler, status %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::PnpQueryDeviceRelations
{
status, ItemNTSTATUS -- 10
}
#typev  fxpkgfdo_cpp434 11     "%0Entering QueryDeviceRelations handler, type %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::PnpQueryDeviceRelations
{
type, ItemEnum(_DEVICE_RELATION_TYPE) -- 10
}
#typev  fxpkgfdo_cpp530 14     "%0Exiting QueryInterface handler, %10!s!"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::_PnpQueryInterface
{
status, ItemNTSTATUS -- 10
}
#typev  fxpkgfdo_cpp525 13     "%0Entering QueryInterface handler"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::_PnpQueryInterface
{
}
#typev  fxpkgfdo_cpp606 16     "%0Exiting QueryCapabilities handler"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::HandleQueryCapabilities
{
}
#typev  fxpkgfdo_cpp586 15     "%0Entering QueryCapabilities handler"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::HandleQueryCapabilities
{
}
#typev  fxpkgfdo_cpp739 18     "%0Exiting QueryCapabilities completion handler"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::HandleQueryCapabilitiesCompletion
{
}
#typev  fxpkgfdo_cpp620 17     "%0Entering QueryCapabilities completion handler"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::HandleQueryCapabilitiesCompletion
{
}
#typev  fxpkgfdo_cpp786 21     "%0Exiting QueryPnpDeviceState completion handler"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::HandleQueryPnpDeviceStateCompletion
{
}
#typev  fxpkgfdo_cpp778 20     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! returning PNP_DEVICE_STATE 0x%12!d! IRP 0x%13!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgFdo::HandleQueryPnpDeviceStateCompletion
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
pnpDeviceState, ItemLong -- 12
Irp->GetIrp(), ItemPtr -- 13
}
#typev  fxpkgfdo_cpp768 19     "%0Entering QueryPnpDeviceState completion handler"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgFdo::HandleQueryPnpDeviceStateCompletion
{
}
#typev  fxpkgfdo_cpp1500 24     "%0PNP start failed with %10!s!"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgFdo::_PnpStartDeviceCompletionRoutine
{
irp.GetStatus(), ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
93e3bbd9-4cb1-98ec-87f5-2a9969f32e39     WdfCore // SRC=FxNonPagedObject.hpp MJ= MN=
#typev  FxNonPagedObject_hpp112 10     "%0Unable to initialize non-paged lock for object 0x%10!p! (raw object %11!p!) status %12!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGOBJECT FUNC=FxPkgFdo::_Create
{
GetObjectHandleUnchecked(), ItemPtr -- 10
this, ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0cb05f64-1305-ad9b-046c-8d30905d67c5     WdfCore // SRC=fxpkgfdo.cpp MJ= MN=
#typev  fxpkgfdo_cpp205 10     "%0Memory allocation failed: %10!s!"      //   GLOBALS=DriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGIO FUNC=FxPkgFdo::_Create
{
status, ItemNTSTATUS -- 10
}
#typev  fxpkgfdo_cpp1062 23     "%0PNP start preprocessing failed with %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgFdo::PnpSendStartDeviceDownTheStackOverload
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
f50060b6-3b77-0b0a-4d8b-d71ff471ef61     WdfCore // SRC=fdopower.cpp MJ= MN=
#typev  fdopower_cpp313 10     "%0Received set device power irp 0x%10!p! on WDFDEVICE 0x%11!p! !devobj 0x%12!p!, but the irp was not requested by the device (the power policy owner)"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgFdo::DispatchDeviceSetPower
{
Irp->GetIrp(), ItemPtr -- 10
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0e4262ce-cb72-a804-9052-51b6ae699889     WdfCore // SRC=FxPkgPdo.cpp MJ= MN=
#typev  FxPkgPdo_cpp508 11     "%0WDFDEVICE %10!p! failing TargetDeviceRelations, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPdo::PnpQueryDeviceRelations
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPdo_cpp948 12     "%0WDFDEVICE %10!p! failing Query Device Text, type %11!d!, %12!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPdo::_PnpQueryDeviceText
{
FxDeviceToMx::GetHandle(pThis->m_Device), ItemPtr -- 10
Irp->GetParameterQueryDeviceTextType(), ItemLong -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPdo_cpp1453 20     "%0WDFDEVICE %10!p! could not alloc string for PnP query IdType %11!s!, %12!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPdo::_PnpQueryId
{
FxDeviceToMx::GetHandle(pThis->m_Device), ItemPtr -- 10
queryIdType, ItemEnum(BUS_QUERY_ID_TYPE) -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPdo_cpp1445 19     "%0WDFDEVICE %10!p! does not have a string for PnP query IdType %11!s!, %12!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPdo::_PnpQueryId
{
FxDeviceToMx::GetHandle(pThis->m_Device), ItemPtr -- 10
queryIdType, ItemEnum(BUS_QUERY_ID_TYPE) -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPdo_cpp1505 23     "%0Exiting QueryPnpDeviceState handler"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPdo::_PnpQueryPnpDeviceState
{
}
#typev  FxPkgPdo_cpp1497 22     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! returning PNP_DEVICE_STATE 0x%12!d! IRP 0x%13!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPdo::_PnpQueryPnpDeviceState
{
FxDeviceToMx::GetHandle(This->GetDevice()), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->GetDevice()), ItemPtr -- 11
pnpDeviceState, ItemLong -- 12
Irp->GetIrp(), ItemPtr -- 13
}
#typev  FxPkgPdo_cpp1489 21     "%0Entering QueryPnpDeviceState handler"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPdo::_PnpQueryPnpDeviceState
{
}
#typev  FxPkgPdo_cpp1002 13     "%0Event allocation failed while processing eject for WDFDEVICE %10!p!, %11!s!"      //   GLOBALS=pdoPkg->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPdo::_PnpEject
{
FxDeviceToMx::GetHandle(pdoPkg->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
377b226f-3f5b-4338-a870-94c38101cb33     WdfCore // SRC=PdoPower.cpp MJ= MN=
#typev  PdoPower_cpp169 10     "%0Received set device power irp 0x%10!p! on WDFDEVICE 0x%11!p! !devobj 0x%12!p!, but the irp was not requested by the device (the power policy owner)"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPdo::DispatchDeviceSetPower
{
Irp->GetIrp(), ItemPtr -- 10
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
df2a3420-3e68-6b1f-e452-606e9c85bab9     WdfCore // SRC=FxVerifierLock.hpp MJ= MN=
#typev  FxVerifierLock_hpp497 14     "%0Lock 0x%10!p! is being destroyed while owned by thread 0x%11!p!, Owning Object 0x%12!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::~FxVerifierLock
{
this, ItemPtr -- 10
m_OwningThread, ItemPtr -- 11
m_ParentObject, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
d816b6e3-c6ba-363d-54b4-3533d1de16bb     WdfCore // SRC=FxPkgPnp.cpp MJ= MN=
#typev  FxPkgPnp_cpp588 18     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! IRP_MJ_POWER, %12!s! IRP 0x%13!p! for %14!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::Dispatch
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
irp.GetMinorFunction(), ItemListByte(IRP_MN_WAIT_WAKE,IRP_MN_POWER_SEQUENCE,IRP_MN_SET_POWER,IRP_MN_QUERY_POWER) -- 12
irp.GetIrp(), ItemPtr -- 13
irp.GetParameterPowerStateDeviceState(), ItemEnum(_DEVICE_POWER_STATE) -- 14
}
#typev  FxPkgPnp_cpp577 17     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! IRP_MJ_POWER, %12!s! IRP 0x%13!p! for %14!s! (S%15!d!)"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::Dispatch
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
irp.GetMinorFunction(), ItemListByte(IRP_MN_WAIT_WAKE,IRP_MN_POWER_SEQUENCE,IRP_MN_SET_POWER,IRP_MN_QUERY_POWER) -- 12
irp.GetIrp(), ItemPtr -- 13
irp.GetParameterPowerStateSystemState(), ItemEnum(_SYSTEM_POWER_STATE) -- 14
irp.GetParameterPowerStateSystemState() - 1, ItemLong -- 15
}
#typev  FxPkgPnp_cpp600 19     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! IRP_MJ_POWER, %12!s! IRP 0x%13!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::Dispatch
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
irp.GetMinorFunction(), ItemListByte(IRP_MN_WAIT_WAKE,IRP_MN_POWER_SEQUENCE,IRP_MN_SET_POWER,IRP_MN_QUERY_POWER) -- 12
irp.GetIrp(), ItemPtr -- 13
}
#typev  FxPkgPnp_cpp530 14     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p!, IRP_MJ_PNP, %12!s! IRP 0x%13!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::Dispatch
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
irp.GetMinorFunction(), ItemListByte(IRP_MN_START_DEVICE,IRP_MN_QUERY_REMOVE_DEVICE,IRP_MN_REMOVE_DEVICE,IRP_MN_CANCEL_REMOVE_DEVICE,IRP_MN_STOP_DEVICE,IRP_MN_QUERY_STOP_DEVICE,IRP_MN_CANCEL_STOP_DEVICE,IRP_MN_QUERY_DEVICE_RELATIONS,IRP_MN_QUERY_INTERFACE,IRP_MN_QUERY_CAPABILITIES,IRP_MN_QUERY_RESOURCES,IRP_MN_QUERY_RESOURCE_REQUIREMENTS,IRP_MN_QUERY_DEVICE_TEXT,IRP_MN_FILTER_RESOURCE_REQUIREMENTS,IRP_MN_PNP_14,IRP_MN_READ_CONFIG,IRP_MN_WRITE_CONFIG,IRP_MN_EJECT,IRP_MN_SET_LOCK,IRP_MN_QUERY_ID,IRP_MN_QUERY_PNP_DEVICE_STATE,IRP_MN_QUERY_BUS_INFORMATION,IRP_MN_DEVICE_USAGE_NOTIFICATION,IRP_MN_SURPRISE_REMOVAL) -- 12
irp.GetIrp(), ItemPtr -- 13
}
#typev  FxPkgPnp_cpp539 15     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p!, IRP_MJ_PNP, %12!s! type %13!s! IRP 0x%14!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::Dispatch
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
irp.GetMinorFunction(), ItemListByte(IRP_MN_START_DEVICE,IRP_MN_QUERY_REMOVE_DEVICE,IRP_MN_REMOVE_DEVICE,IRP_MN_CANCEL_REMOVE_DEVICE,IRP_MN_STOP_DEVICE,IRP_MN_QUERY_STOP_DEVICE,IRP_MN_CANCEL_STOP_DEVICE,IRP_MN_QUERY_DEVICE_RELATIONS,IRP_MN_QUERY_INTERFACE,IRP_MN_QUERY_CAPABILITIES,IRP_MN_QUERY_RESOURCES,IRP_MN_QUERY_RESOURCE_REQUIREMENTS,IRP_MN_QUERY_DEVICE_TEXT,IRP_MN_FILTER_RESOURCE_REQUIREMENTS,IRP_MN_PNP_14,IRP_MN_READ_CONFIG,IRP_MN_WRITE_CONFIG,IRP_MN_EJECT,IRP_MN_SET_LOCK,IRP_MN_QUERY_ID,IRP_MN_QUERY_PNP_DEVICE_STATE,IRP_MN_QUERY_BUS_INFORMATION,IRP_MN_DEVICE_USAGE_NOTIFICATION,IRP_MN_SURPRISE_REMOVAL) -- 12
irp.GetParameterQDRType(), ItemEnum(_DEVICE_RELATION_TYPE) -- 13
irp.GetIrp(), ItemPtr -- 14
}
#typev  FxPkgPnp_cpp550 16     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p!, IRP_MJ_PNP, %12!s! IRP 0x%13!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::Dispatch
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
irp.GetMinorFunction(), ItemListByte(IRP_MN_START_DEVICE,IRP_MN_QUERY_REMOVE_DEVICE,IRP_MN_REMOVE_DEVICE,IRP_MN_CANCEL_REMOVE_DEVICE,IRP_MN_STOP_DEVICE,IRP_MN_QUERY_STOP_DEVICE,IRP_MN_CANCEL_STOP_DEVICE,IRP_MN_QUERY_DEVICE_RELATIONS,IRP_MN_QUERY_INTERFACE,IRP_MN_QUERY_CAPABILITIES,IRP_MN_QUERY_RESOURCES,IRP_MN_QUERY_RESOURCE_REQUIREMENTS,IRP_MN_QUERY_DEVICE_TEXT,IRP_MN_FILTER_RESOURCE_REQUIREMENTS,IRP_MN_PNP_14,IRP_MN_READ_CONFIG,IRP_MN_WRITE_CONFIG,IRP_MN_EJECT,IRP_MN_SET_LOCK,IRP_MN_QUERY_ID,IRP_MN_QUERY_PNP_DEVICE_STATE,IRP_MN_QUERY_BUS_INFORMATION,IRP_MN_DEVICE_USAGE_NOTIFICATION,IRP_MN_SURPRISE_REMOVAL) -- 12
irp.GetIrp(), ItemPtr -- 13
}
#typev  FxPkgPnp_cpp924 27     "%0WDFDEVICE %10!p! could not allocate PNP_BUS_INFORMATION string,  %11!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusInformation
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp1059 28     "%0WDFDEVICE %10!p! could not allocate device relations for type %11!d! string,  %12!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryDeviceRelations
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
type, ItemLong -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPnp_cpp1173 31     "%0Power Policy State Machine init failed, %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PostCreateDeviceInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  FxPkgPnp_cpp1165 30     "%0Power State Machine init failed, %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PostCreateDeviceInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  FxPkgPnp_cpp1157 29     "%0PnP State Machine init failed, %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PostCreateDeviceInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  FxPkgPnp_cpp1366 34     "%0WDFDEVICE %10!p! could not allocate IRP to send QI to parent !devobj %11!p!, %12!s!"      //   GLOBALS=FxDeviceToMx::GetDriverGlobals(Device) LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=PnpPassThroughQI
{
FxDeviceToMx::GetHandle(Device), ItemPtr -- 10
pTopOfStack.GetObject(), ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPnp_cpp2147 38     "%0WDFDEVICE %10!p!, !devobj %11!p! waiting for remove event to finish processing"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::_PnpRemoveDevice
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
}
#typev  FxPkgPnp_cpp3993 63     "%0Before:  type %10!d!, in path %11!d!, special count %12!d!, flags 0x%13!x!, device %14!p! (WDFDEVICE %15!p!), is pageable capable %16!d!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::SetUsageNotificationFlags
{
Type, ItemLong -- 10
InPath, ItemLong -- 11
GetUsageCount(Type), ItemLong -- 12
oldFlags, ItemLong -- 13
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 14
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 15
FxDeviceToMx::IsPowerPageableCapable(m_Device), ItemLong -- 16
}
#typev  FxPkgPnp_cpp4143 64     "%0After:  special count %10!d!, flags 0x%11!x!, device %12!p! (WDFDEVICE %13!p!)"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::CommitUsageNotification
{
GetUsageCount(Type), ItemLong -- 10
newFlags, ItemLong -- 11
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 12
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 13
}
#typev  FxPkgPnp_cpp4364 67     "%0A new state changing pnp irp %10!s! IRP %11!p! arrived while another pnp irp %12!s! IRP %13!p! is still pending WDFDEVICE %14!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::SetPendingPnpIrp
{
Irp->GetMinorFunction(), ItemListByte(IRP_MN_START_DEVICE,IRP_MN_QUERY_REMOVE_DEVICE,IRP_MN_REMOVE_DEVICE,IRP_MN_CANCEL_REMOVE_DEVICE,IRP_MN_STOP_DEVICE,IRP_MN_QUERY_STOP_DEVICE,IRP_MN_CANCEL_STOP_DEVICE,IRP_MN_QUERY_DEVICE_RELATIONS,IRP_MN_QUERY_INTERFACE,IRP_MN_QUERY_CAPABILITIES,IRP_MN_QUERY_RESOURCES,IRP_MN_QUERY_RESOURCE_REQUIREMENTS,IRP_MN_QUERY_DEVICE_TEXT,IRP_MN_FILTER_RESOURCE_REQUIREMENTS,IRP_MN_PNP_14,IRP_MN_READ_CONFIG,IRP_MN_WRITE_CONFIG,IRP_MN_EJECT,IRP_MN_SET_LOCK,IRP_MN_QUERY_ID,IRP_MN_QUERY_PNP_DEVICE_STATE,IRP_MN_QUERY_BUS_INFORMATION,IRP_MN_DEVICE_USAGE_NOTIFICATION,IRP_MN_SURPRISE_REMOVAL) -- 10
Irp->GetIrp(), ItemPtr -- 11
pendingIrp.GetMinorFunction(), ItemListByte(IRP_MN_START_DEVICE,IRP_MN_QUERY_REMOVE_DEVICE,IRP_MN_REMOVE_DEVICE,IRP_MN_CANCEL_REMOVE_DEVICE,IRP_MN_STOP_DEVICE,IRP_MN_QUERY_STOP_DEVICE,IRP_MN_CANCEL_STOP_DEVICE,IRP_MN_QUERY_DEVICE_RELATIONS,IRP_MN_QUERY_INTERFACE,IRP_MN_QUERY_CAPABILITIES,IRP_MN_QUERY_RESOURCES,IRP_MN_QUERY_RESOURCE_REQUIREMENTS,IRP_MN_QUERY_DEVICE_TEXT,IRP_MN_FILTER_RESOURCE_REQUIREMENTS,IRP_MN_PNP_14,IRP_MN_READ_CONFIG,IRP_MN_WRITE_CONFIG,IRP_MN_EJECT,IRP_MN_SET_LOCK,IRP_MN_QUERY_ID,IRP_MN_QUERY_PNP_DEVICE_STATE,IRP_MN_QUERY_BUS_INFORMATION,IRP_MN_DEVICE_USAGE_NOTIFICATION,IRP_MN_SURPRISE_REMOVAL) -- 12
pendingIrp.GetIrp(), ItemPtr -- 13
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 14
}
#typev  FxPkgPnp_cpp4571 72     "%0The driver failed to return from a callback routine in a reasonable period of time.  This prevented the machine from going to sleep or from hibernating.  The machine crashed because that was the best way to get data about the cause of the crash into a minidump file."      //   GLOBALS=FxDeviceToMx::GetDriverGlobals(pDevice) LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxWatchdog::_WatchdogDpc
{
}
#typev  FxPkgPnp_cpp5328 73     "%0Not saving wake settings for WDFDEVICE %10!p! due to system power transition"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::SaveState
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
93e3bbd9-4cb1-98ec-87f5-2a9969f32e39     WdfCore // SRC=FxNonPagedObject.hpp MJ= MN=
#typev  FxNonPagedObject_hpp112 10     "%0Unable to initialize non-paged lock for object 0x%10!p! (raw object %11!p!) status %12!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGOBJECT FUNC=FxResourceCollection::Initialize
{
GetObjectHandleUnchecked(), ItemPtr -- 10
this, ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
da4a0a10-d2dd-364f-e436-3dc54956d3ab     WdfCore // SRC=FxResource.hpp MJ= MN=
#typev  FxResource_hpp210 10     "%0FxCmResList initialize failed, %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxCmResList::Initialize
{
status, ItemNTSTATUS -- 10
}
#typev  FxResource_hpp248 11     "%0Failed to allocate FxCmResList, returning %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxCmResList::_CreateAndInit
{
ntStatus, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
d816b6e3-c6ba-363d-54b4-3533d1de16bb     WdfCore // SRC=FxPkgPnp.cpp MJ= MN=
#typev  FxPkgPnp_cpp391 13     "%0Could not initialize remove event for WDFDEVICE %10!p!, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::Initialize
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp381 12     "%0Could not initialize cleanup event for WDFDEVICE %10!p!, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::Initialize
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp364 11     "%0Could not initialize DeviceInterfaceLock for WDFDEVICE %10!p!, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::Initialize
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp354 10     "%0Could not initialize QueryInterfaceLock for WDFDEVICE %10!p!, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::Initialize
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp876 26     "%0PDO %10!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusRelations
{
pRelations->Objects[i], ItemPtr -- 10
}
#typev  FxPkgPnp_cpp868 25     "%0PDO %10!p! PDO %11!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusRelations
{
pRelations->Objects[i], ItemPtr -- 10
pRelations->Objects[i+1], ItemPtr -- 11
}
#typev  FxPkgPnp_cpp859 24     "%0PDO %10!p! PDO %11!p! PDO %12!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusRelations
{
pRelations->Objects[i], ItemPtr -- 10
pRelations->Objects[i+1], ItemPtr -- 11
pRelations->Objects[i+2], ItemPtr -- 12
}
#typev  FxPkgPnp_cpp849 23     "%0PDO %10!p! PDO %11!p! PDO %12!p! PDO %13!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusRelations
{
pRelations->Objects[i], ItemPtr -- 10
pRelations->Objects[i+1], ItemPtr -- 11
pRelations->Objects[i+2], ItemPtr -- 12
pRelations->Objects[i+3], ItemPtr -- 13
}
#typev  FxPkgPnp_cpp837 22     "%0WDFDEVICE %10!p! returning %11!d! devices in relations %12!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusRelations
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
pRelations->Count, ItemLong -- 11
pRelations, ItemPtr -- 12
}
#typev  FxPkgPnp_cpp828 21     "%0WDFDEVICE %10!p!, returning %11!s! from processing bus relations"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusRelations
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp794 20     "%0WDFDEVICE %10!p!, WDFCHILDLIST %11!p! returned %12!s! from processing bus relations"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::HandleQueryBusRelations
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
pChildList->GetHandle(), ItemPtr -- 11
listStatus, ItemNTSTATUS -- 12
}
#typev  FxPkgPnp_cpp2451 42     "%0already have a ww irp %10!p!, failing new ww irp %11!p! with %12!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::DispatchWaitWake
{
oldIrp, ItemPtr -- 10
Irp->GetIrp(), ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPnp_cpp2333 41     "%0wait wake irp %10!p! already canceled"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::DispatchWaitWake
{
Irp->GetIrp(), ItemPtr -- 10
}
#typev  FxPkgPnp_cpp2304 40     "%0Failing wait wake irp %10!p! with %11!s! because wait wake irp %12!p! already pended"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::DispatchWaitWake
{
Irp->GetIrp(), ItemPtr -- 10
status, ItemNTSTATUS -- 11
m_SharedPower.m_WaitWakeIrp, ItemPtr -- 12
}
#typev  FxPkgPnp_cpp2264 39     "%0Received wait wake power irp %10!p! on device %11!p!, but the irp was not requested by the device (the power policy owner)"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::DispatchWaitWake
{
Irp->GetIrp(), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
}
#typev  FxPkgPnp_cpp2769 50     "%0Driver turned on S0Idle optimization. Device will remain powered off if idle when resuming from Sx"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetS0IdleSettings
{
}
#typev  FxPkgPnp_cpp2762 49     "%0Driver turned off S0Idle optimization. Device will be powered up on resume from Sx even when it is idle"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetS0IdleSettings
{
}
#typev  FxPkgPnp_cpp2725 48     "%0Failed to initialize USB selective suspend %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetS0IdleSettings
{
status, ItemNTSTATUS -- 10
}
#typev  FxPkgPnp_cpp2711 47     "%0DxState specified by driver %10!s! cannot be lighter than PowerDeviceD2 for USB selective suspend %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetS0IdleSettings
{
dxState, ItemEnum(_DEVICE_POWER_STATE) -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp2695 46     "%0DxState specified by driver %10!s! cannot be lighter than lightest available device wake state %11!s!, %12!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetS0IdleSettings
{
dxState, ItemEnum(_DEVICE_POWER_STATE) -- 10
PowerPolicyGetDeviceDeepestDeviceWakeState(), ItemEnum(_DEVICE_POWER_STATE) -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPnp_cpp2680 45     "%0DeviceWake power state reported in device capabilities %10!s! indicates that device can not signal a wake event, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetS0IdleSettings
{
dxState, ItemEnum(_DEVICE_POWER_STATE) -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp3339 55     "%0succeeding system query power even though the device cannot wake the machine from S%10!d!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyHandleSystemQueryPower
{
QueryState - 1, ItemLong -- 10
}
#typev  FxPkgPnp_cpp3321 54     "%0failing system query power because the device cannot wake the machine from S%10!d!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyHandleSystemQueryPower
{
QueryState - 1, ItemLong -- 10
}
#typev  FxPkgPnp_cpp3954 62     "%0Exit %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpDeviceUsageNotification
{
status, ItemNTSTATUS -- 10
}
#typev  FxPkgPnp_cpp3696 61     "%0WDFDEVICE %10!p! could not allocate IRP to send usage notifications to related stacks, type %11!d!, inpath %12!d!, status %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpDeviceUsageNotification
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
type, ItemLong -- 11
inPath, ItemLong -- 12
status, ItemNTSTATUS -- 13
}
#typev  FxPkgPnp_cpp3608 60     "%0Exit %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpDeviceUsageNotification
{
status, ItemNTSTATUS -- 10
}
#typev  FxPkgPnp_cpp3597 59     "%0WDFDEVICE %10!p! could not allocate PIRP for parent !devobj %11!p! to send usage notification type %12!d!, inpath %13!d!, %14!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpDeviceUsageNotification
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
topOfParentStack.GetObject(), ItemPtr -- 11
type, ItemLong -- 12
inPath, ItemLong -- 13
status, ItemNTSTATUS -- 14
}
#typev  FxPkgPnp_cpp3549 58     "%0Usage type %10!x! not supported, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpDeviceUsageNotification
{
type, ItemLong -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp3517 57     "%0type %10!x!, in path %11!x!, can support paging %12!x!, dump file %13!x!, hiber file %14!x!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpDeviceUsageNotification
{
type, ItemLong -- 10
inPath, ItemLong -- 11
IsUsageSupported(_SpecialTypeToUsage(WdfSpecialFilePaging)), ItemLong -- 12
IsUsageSupported(_SpecialTypeToUsage(WdfSpecialFileDump)), ItemLong -- 13
IsUsageSupported(_SpecialTypeToUsage(WdfSpecialFileHibernation)), ItemLong -- 14
}
#typev  FxPkgPnp_cpp3508 56     "%0Entering DeviceUsageNotification handler"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpDeviceUsageNotification
{
}
#typev  FxPkgPnp_cpp4454 71     "%0Removing FxChildList %10!p!, WDFCHILDLIST %11!p!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::RemoveChildList
{
List, ItemPtr -- 10
List->GetHandle(), ItemPtr -- 11
}
#typev  FxPkgPnp_cpp1967 37     "%0WDFDEVICE %10!p!, !devobj %11!p! waiting for pwr state machine to finish"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::CleanupStateMachines
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
}
#typev  FxPkgPnp_cpp1953 36     "%0WDFDEVICE %10!p!, !devobj %11!p! waiting for pwr pol state machine to finish"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::CleanupStateMachines
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
}
#typev  FxPkgPnp_cpp1932 35     "%0WDFDEVICE %10!p!, !devobj %11!p! waiting for pnp state machine to finish"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::CleanupStateMachines
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
}
#typev  FxPkgPnp_cpp2987 53     "%0DxState specified by driver %10!s! cannot be lighter than lightest available device wake state %11!s!, %12!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetSxWakeSettings
{
dxState, ItemEnum(_DEVICE_POWER_STATE) -- 10
PowerPolicyGetDeviceDeepestDeviceWakeState(), ItemEnum(_DEVICE_POWER_STATE) -- 11
status, ItemNTSTATUS -- 12
}
#typev  FxPkgPnp_cpp2973 52     "%0DeviceWake power state reported in device capabilities %10!s! indicates that device can not signal a wake event, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySetSxWakeSettings
{
dxState, ItemEnum(_DEVICE_POWER_STATE) -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp4420 69     "%0Could not allocate enum info for WDFDEVICE %10!p!, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::AllocateEnumInfo
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp4409 68     "%0Could not initialize PowerStateLock for enum info for WDFDEVICE %10!p!, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::AllocateEnumInfo
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxPkgPnp_cpp1240 32     "%0WDFDEVICE %10!p!, !devobj %11!p! processing delayed deletion from pnp state machine"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::ProcessDelayedDeletion
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
31f474a8-23f3-c270-e156-7b455a6f635c     WdfCore // SRC=PnpStateMachine.cpp MJ= MN=
#typev  PnpStateMachine_cpp1167 14     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! entering PnP State %12!s! from %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNPPOWERSTATES FUNC=FxPkgPnp::PnpEnterNewState
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
newState, ItemEnum(_WDF_DEVICE_PNP_STATE) -- 12
currentState, ItemEnum(_WDF_DEVICE_PNP_STATE) -- 13
}
#typev  PnpStateMachine_cpp1548 16     "%0EvtDeviceQueryRemove failed, %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryRemoveAskDriver
{
status, ItemNTSTATUS -- 10
}
#typev  PnpStateMachine_cpp1600 17     "%0StopIdle on WDFDEVICE %10!p! failed, %11!s!, failing query remove"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryRemoveEnsureDeviceAwake
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PnpStateMachine_cpp1679 19     "%0Failing QueryRemoveDevice due to open special file counts (paging %10!d!, hiber %11!d!, dump %12!d!)"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryRemoveStaticCheck
{
This->GetUsageCount(WdfSpecialFilePaging), ItemLong -- 10
This->GetUsageCount(WdfSpecialFileHibernation), ItemLong -- 11
This->GetUsageCount(WdfSpecialFileDump), ItemLong -- 12
}
#typev  PnpStateMachine_cpp1670 18     "%0Failing QueryRemoveDevice because the driver has indicated that it cannot be stopped, count %10!d!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryRemoveStaticCheck
{
This->m_DeviceStopCount, ItemLong -- 10
}
#typev  PnpStateMachine_cpp1782 20     "%0EvtDeviceQueryStop failed, %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryStopAskDriver
{
status, ItemNTSTATUS -- 10
}
#typev  PnpStateMachine_cpp1836 21     "%0StopIdle on WDFDEVICE %10!p! failed, %11!s!, failing query stop"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryStopEnsureDeviceAwake
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PnpStateMachine_cpp1913 23     "%0Failing QueryStopDevice due to open special file counts (paging %10!d!, hiber %11!d!, dump %12!d!)"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryStopStaticCheck
{
This->GetUsageCount(WdfSpecialFilePaging), ItemLong -- 10
This->GetUsageCount(WdfSpecialFileHibernation), ItemLong -- 11
This->GetUsageCount(WdfSpecialFileDump), ItemLong -- 12
}
#typev  PnpStateMachine_cpp1904 22     "%0Failing QueryStopDevice because the driver has indicated that it cannot be stopped, count %10!d!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventQueryStopStaticCheck
{
This->m_DeviceStopCount, ItemLong -- 10
}
#typev  PnpStateMachine_cpp1087 13     "%0WDFDEVICE 0x%10!p! !devobj %11!p! current state %12!s!, policy event %13!s! is not a known dropped event, known dropped events are %14!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpProcessEventInner
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePnpState(m_Device), ItemEnum(_WDF_DEVICE_PNP_STATE) -- 12
event, ItemEnum(FxPnpEvent) -- 13
entry->StateInfo.Bits.KnownDroppedEvents, ItemEnum(FxPnpEvent) -- 14
}
#typev  PnpStateMachine_cpp1075 12     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pnp state %12!s! dropping event %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpProcessEventInner
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePnpState(m_Device), ItemEnum(_WDF_DEVICE_PNP_STATE) -- 12
event, ItemEnum(FxPnpEvent) -- 13
}
#typev  PnpStateMachine_cpp2315 24     "%0EvtDeviceReleaseHardware %10!p! failed, %11!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventRemovingDisableInterfaces
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PnpStateMachine_cpp2527 25     "%0EvtDeviceReleaseHardware failed - %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventStopped
{
status, ItemNTSTATUS -- 10
}
#typev  PnpStateMachine_cpp3108 26     "%0EvtDeviceReleaseHardware failed with %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventRestartReleaseHardware
{
status, ItemNTSTATUS -- 10
}
#typev  PnpStateMachine_cpp3468 27     "%0EvtDevicePrepareHardware failed %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpPrepareHardware
{
status, ItemNTSTATUS -- 10
}
#typev  PnpStateMachine_cpp858 11     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pnp state %12!s! dropping event %13!s! because of a closed queue"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpProcessEvent
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePnpState(m_Device), ItemEnum(_WDF_DEVICE_PNP_STATE) -- 12
Event, ItemEnum(FxPnpEvent) -- 13
}
#typev  PnpStateMachine_cpp839 10     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pnp state %12!s! dropping event %13!s! because of a full queue"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpProcessEvent
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePnpState(m_Device), ItemEnum(_WDF_DEVICE_PNP_STATE) -- 12
Event, ItemEnum(FxPnpEvent) -- 13
}
#typev  PnpStateMachine_cpp1427 15     "%0could not query caps for stack, %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PnpEventHardwareAvailable
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
a06c4939-ec03-9e2b-f095-211ff9a6d5e5     WdfCore // SRC=PowerIdleStateMachine.cpp MJ= MN=
#typev  PowerIdleStateMachine_cpp704 10     "%0WDFDEVICE %10!p! idle (in D0) not sending io present event (already sent)"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPowerIdleMachine::TimedOutIoIncrement
{
FxDeviceToMx::GetHandle(pPkgPnp->GetDevice()), ItemPtr -- 10
}
#typev  PowerIdleStateMachine_cpp849 11     "%0WDFDEVICE %10!p! idle (in Dx) not sending io present event (already sent)"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPowerIdleMachine::InDxIoIncrement
{
FxDeviceToMx::GetHandle(pPkgPnp->GetDevice()), ItemPtr -- 10
}
#typev  PowerIdleStateMachine_cpp1883 16     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! entering power idle state %12!s! from %13!s!"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNPPOWERSTATES FUNC=FxPowerIdleMachine::ProcessEventLocked
{
FxDeviceToMx::GetHandle(pPkgPnp->GetDevice()), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(pPkgPnp->GetDevice()), ItemPtr -- 11
newState, ItemEnum(FxPowerIdleStates) -- 12
m_CurrentIdleState, ItemEnum(FxPowerIdleStates) -- 13
}
#typev  PowerIdleStateMachine_cpp1869 15     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! power idle state %12!s! dropping event %13!s!"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPowerIdleMachine::ProcessEventLocked
{
FxDeviceToMx::GetHandle(pPkgPnp->GetDevice()), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(pPkgPnp->GetDevice()), ItemPtr -- 11
m_CurrentIdleState, ItemEnum(FxPowerIdleStates) -- 12
Event, ItemEnum(FxPowerIdleEvents) -- 13
}
#typev  PowerIdleStateMachine_cpp1538 14     "%0WDFDEVICE %10!p! waiting for D0 in thread %11!p! failed because of invalid state , %12!s!"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPowerIdleMachine::PowerReferenceWorker
{
FxDeviceToMx::GetHandle(pPkgPnp->GetDevice()), ItemPtr -- 10
Mx::MxGetCurrentThread(), ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  PowerIdleStateMachine_cpp1528 13     "%0WDFDEVICE %10!p! waiting for D0 in thread %11!p! failed because of power failure, %12!s!"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPowerIdleMachine::PowerReferenceWorker
{
FxDeviceToMx::GetHandle(pPkgPnp->GetDevice()), ItemPtr -- 10
Mx::MxGetCurrentThread(), ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  PowerIdleStateMachine_cpp1497 12     "%0WDFDEVICE %10!p! in thread %11!p! waiting synchronously for Dx to D0 transition"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPowerIdleMachine::PowerReferenceWorker
{
FxDeviceToMx::GetHandle(pPkgPnp->GetDevice()), ItemPtr -- 10
Mx::MxGetCurrentThread(), ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
1c6af04a-8c20-a063-1976-7299d70a2744     WdfCore // SRC=PowerPolicyStateMachine.cpp MJ= MN=
#typev  PowerPolicyStateMachine_cpp3170 17     "%0WDFDEVICE %10!p! Failed to Enable Wake at Bus, %11!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleepingWakeWakeArrived
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerPolicyStateMachine_cpp3155 16     "%0WDFDEVICE %10!p! Failed to arm for wake from Sx, %11!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleepingWakeWakeArrived
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerPolicyStateMachine_cpp3374 20     "%0WDFDEVICE %10!p! Failed to Enable Wake at Bus, %11!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleepingWakeWakeArrivedNP
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerPolicyStateMachine_cpp3359 19     "%0WDFDEVICE %10!p! Failed to arm for wake from Sx, %11!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleepingWakeWakeArrivedNP
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerPolicyStateMachine_cpp4130 25     "%0WDFDEVICE %10!p! Failed to Enable Wake at Bus, %11!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolTimerExpiredWakeCapableWakeArrived
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerPolicyStateMachine_cpp6051 31     "%0Completing system power irp %10!p! (S%11!d!), %12!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyCompleteSystemPowerIrp
{
m_PendingSystemPowerIrp, ItemPtr -- 10
irp.GetParameterPowerStateSystemState()-1, ItemLong -- 11
status, ItemNTSTATUS -- 12
}
#typev  PowerPolicyStateMachine_cpp6121 34     "%0No WaitWake irp to cancel"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyCancelWaitWake
{
}
#typev  PowerPolicyStateMachine_cpp6102 33     "%0Cancel of irp %10!p! returned %11!d!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyCancelWaitWake
{
wwIrp, ItemPtr -- 10
result, ItemLong -- 11
}
#typev  PowerPolicyStateMachine_cpp6097 32     "%0Successfully got WaitWake irp %10!p! for cancelling"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyCancelWaitWake
{
wwIrp, ItemPtr -- 10
}
#typev  PowerPolicyStateMachine_cpp6173 36     "%0Completion of WaitWake irp %10!p!"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::_PowerPolicyWaitWakeCompletionRoutine
{
originalIrp.GetIrp(), ItemPtr -- 10
}
#typev  PowerPolicyStateMachine_cpp6188 37     "%0Not completing WaitWake irp %10!p! in completion routine"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::_PowerPolicyWaitWakeCompletionRoutine
{
originalIrp.GetIrp(), ItemPtr -- 10
}
#typev  PowerPolicyStateMachine_cpp6150 35     "%0WDFDEVICE %10!p! !devobj %11!p! Completion of WaitWake irp %12!p!, %13!s!"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::_PowerPolicyWaitWakeCompletionRoutine
{
FxDeviceToMx::GetHandle(pThis->m_Device), ItemPtr -- 10
DeviceObject, ItemPtr -- 11
originalIrp.GetIrp(), ItemPtr -- 12
originalIrp.GetStatus(), ItemNTSTATUS -- 13
}
#typev  PowerPolicyStateMachine_cpp2539 14     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! entering power policy state %12!s! from %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNPPOWERSTATES FUNC=FxPkgPnp::PowerPolicyEnterNewState
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
newState, ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 12
currentState, ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 13
}
#typev  PowerPolicyStateMachine_cpp3191 18     "%0reverting arm for wake from Sx due to failure to allocate wait wake request or wait wake request completed immeidately.  Device will *NOT* be armed for wake from Sx"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleepingWakeRevertArmWake
{
}
#typev  PowerPolicyStateMachine_cpp3395 21     "%0reverting arm for wake from Sx due to failure to allocate wait wake request or wait wake request completed immeidately.  Device will *NOT* be armed for wake from Sx"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleepingWakeRevertArmWakeNP
{
}
#typev  PowerPolicyStateMachine_cpp3634 22     "%0WDFDEVICE %10!p! powering down before child devices have powered down. This usually indicates a faulty child device that completed the Sx irp before sending the Dx irp"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleeping
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
}
#typev  PowerPolicyStateMachine_cpp2372 13     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current state %12!s!, policy event %13!s! is not a known dropped event, known dropped events are %14!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyProcessEventInner
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerPolicyState(m_Device), ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 12
event, ItemEnum(FxPowerPolicyEvent) -- 13
entry->StateInfo.Bits.KnownDroppedEvents, ItemEnum(FxPowerPolicyEvent) -- 14
}
#typev  PowerPolicyStateMachine_cpp2361 12     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pwr pol state %12!s! dropping event %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyProcessEventInner
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerPolicyState(m_Device), ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 12
event, ItemEnum(FxPowerPolicyEvent) -- 13
}
#typev  PowerPolicyStateMachine_cpp2105 10     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pwr pol state %12!s! dropping event %13!s! because the Event is already enqueued."      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyProcessEvent
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerPolicyState(m_Device), ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 12
Event, ItemEnum(FxPowerPolicyEvent) -- 13
}
#typev  PowerPolicyStateMachine_cpp2130 11     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pwr pol state %12!s! dropping event %13!s! because of a closed queue"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyProcessEvent
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerPolicyState(m_Device), ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 12
Event, ItemEnum(FxPowerPolicyEvent) -- 13
}
#typev  PowerPolicyStateMachine_cpp5858 26     "%0PowerDeviceD0 requested by WDFDEVICE 0x%10!p! !devobj 0x%11!p!, is being completed by upper driver without sending it to driver that requested it"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::_PowerPolDevicePowerUpComplete
{
FxDeviceToMx::GetHandle(pThis->GetDevice()), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(pThis->GetDevice()), ItemPtr -- 11
}
#typev  PowerPolicyStateMachine_cpp5992 28     "%0Requesting D%10!d! irp, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySendDevicePowerRequest
{
DeviceState-1, ItemLong -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerPolicyStateMachine_cpp5983 27     "%0Could not request D%10!d! irp for device %11!p! (WDFDEVICE %12!p!), %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySendDevicePowerRequest
{
DeviceState-1, ItemLong -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerPolicyStateMachine_cpp6026 30     "%0Requesting wait wake irp for S%10!d! failed, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySendWaitWakeRequest
{
SystemState-1, ItemLong -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerPolicyStateMachine_cpp6016 29     "%0Requesting wait wake irp for S%10!d!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicySendWaitWakeRequest
{
SystemState-1, ItemLong -- 10
}
#typev  PowerPolicyStateMachine_cpp6236 39     "%0WDFDEVICE %10!p!, !devobj %11!p! Completion of UsbSS irp"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::_PowerPolicyUsbSelectiveSuspendCompletionRoutine
{
This->m_Device, ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
}
#typev  PowerPolicyStateMachine_cpp6292 40     "%0WDFDEVICE %10!p! !devobj 0x%11!p! not idling out because there are %12!d! children who are powered up"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyCanIdlePowerDown
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
m_PowerPolicyMachine.m_Owner->m_ChildrenPoweredOnCount, ItemLong -- 12
}
#typev  PowerPolicyStateMachine_cpp3013 15     "%0Failed to allocate D0 request to disarm from wake from S0 to allow arm for wake from Sx, %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSystemSleepNeedWake
{
status, ItemNTSTATUS -- 10
}
#typev  PowerPolicyStateMachine_cpp3829 23     "%0Attempting to send wait wake request for EvtDeviceArmWakeFromSx() failed, %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolSleepingSendWake
{
status, ItemNTSTATUS -- 10
}
#typev  PowerPolicyStateMachine_cpp4054 24     "%0Could not allocate wake request for wake from S0, revert arming, %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolTimerExpiredWakeCapableSendWake
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0f1627e4-9104-3b5b-0ee6-1d7b7b807395     WdfCore // SRC=NotPowerPolicyOwnerStateMachine.cpp MJ= MN=
#typev  NotPowerPolicyOwnerStateMachine_cpp261 10     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! entering not power policy owner state %12!s! from %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNPPOWERSTATES FUNC=FxPkgPnp::NotPowerPolicyOwnerEnterNewState
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
newState, ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 12
currentState, ItemEnum(_WDF_DEVICE_POWER_POLICY_STATE) -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
9fad61e3-68ff-f42e-15fe-7a3fb252225e     WdfCore // SRC=PowerStateMachine.cpp MJ= MN=
#typev  PowerStateMachine_cpp977 10     "%0Initializing WaitWakeLock failed for PowerMachine 0x%10!p!, status %11!s!"      //   GLOBALS=Pnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPowerMachine::Init
{
this, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerStateMachine_cpp2041 16     "%0EvtDeviceD0Entry WDFDEVICE 0x%10!p! !devobj 0x%11!p!,  old state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerD0Starting
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
This->m_DevicePowerState, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp2094 17     "%0EvtDeviceD0EntryPostInterruptsEnabed WDFDEVICE 0x%10!p! !devobj 0x%11!p!, old state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerD0StartingConnectInterrupt
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
This->m_DevicePowerState, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp2407 21     "%0PowerReference on parent WDFDEVICE %10!p! for child WDFDEVICE %11!p! failed, %12!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerStartingChild
{
FxDeviceToMx::GetHandle(                  FxDeviceToMx::GetParentDevicePnpPkg(This->m_Device)->m_Device), ItemPtr -- 10
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  PowerStateMachine_cpp2579 22     "%0Force disconnecting interups on !devobj 0x%10!p!, WDFDEVICE %11!p!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoDxNPFailed
{
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 11
}
#typev  PowerStateMachine_cpp2619 23     "%0EvtDeviceSelfManagedIoStop failed %10!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoDx
{
status, ItemNTSTATUS -- 10
}
#typev  PowerStateMachine_cpp3314 30     "%0EvtDeviceD0Entry WDFDEVICE 0x%10!p! !devobj 0x%11!p!, old state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerWaking
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
This->m_DevicePowerState, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp3359 31     "%0EvtDeviceD0Entry WDFDEVICE 0x%10!p! !devobj 0x%11!p!, old state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerWakingNP
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
This->m_DevicePowerState, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp3408 32     "%0EvtDeviceD0EntryPostInterruptsEnabed WDFDEVICE 0x%10!p! !devobj 0x%11!p!, old state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerWakingConnectInterrupt
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
This->m_DevicePowerState, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp3457 33     "%0EvtDeviceD0EntryPostInterruptsEnabed WDFDEVICE 0x%10!p! !devobj 0x%11!p!, old state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerWakingConnectInterruptNP
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
This->m_DevicePowerState, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp3647 35     "%0EvtDeviceD0ExitPreInterruptsDisabled WDFDEVICE 0x%10!p! !devobj 0x%11!p! new state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerWakingDmaEnableFailed
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
WdfPowerDeviceD3Final, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp3692 36     "%0EvtDeviceD0ExitPreInterruptsDisabled WDFDEVICE 0x%10!p! !devobj 0x%11!p! new state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerWakingDmaEnableFailedNP
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
WdfPowerDeviceD3Final, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp3871 37     "%0EvtDeviceD0ExitPreInterruptsDisabled WDFDEVICE 0x%10!p! !devobj 0x%11!p! new state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerInitialDmaEnableFailed
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
WdfPowerDeviceD3Final, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp4497 38     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! WW !irp 0x%12!p! is a source of wake"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerMakeWakeRequestNonCancelable
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
m_SharedPower.m_WaitWakeIrp, ItemPtr -- 12
}
#typev  PowerStateMachine_cpp4839 40     "%0EvtDeviceD0Exit WDFDEVICE 0x%10!p! !devobj 0x%11!p! failed, %12!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerConnectInterruptFailed
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  PowerStateMachine_cpp4826 39     "%0Interrupt(s) disconnect on WDFDEVICE %10!p! failed, %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerConnectInterruptFailed
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  PowerStateMachine_cpp1453 15     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! entering Power State %12!s! from %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNPPOWERSTATES FUNC=FxPkgPnp::PowerEnterNewState
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
newState, ItemEnum(_WDF_DEVICE_POWER_STATE) -- 12
currentState, ItemEnum(_WDF_DEVICE_POWER_STATE) -- 13
}
#typev  PowerStateMachine_cpp2325 20     "%0EvtDeviceD0Exit WDFDEVICE 0x%10!p! !devobj 0x%11!p!, new state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoD3Stopped
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
WdfPowerDeviceD3Final, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp2296 19     "%0EvtDeviceD0ExitPreInterruptsDisabled WDFDEVICE 0x%10!p! !devobj 0x%11!p!, new state %12!s! failed, %13!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoD3Stopped
{
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 11
WdfPowerDeviceD3Final, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp2269 18     "%0EvtDeviceSelfManagedIoStop failed %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoD3Stopped
{
status, ItemNTSTATUS -- 10
}
#typev  PowerStateMachine_cpp2734 25     "%0EvtDeviceD0Exit WDFEVICE 0x%10!p! !devobj 0x%11!p!, new state %12!s! failed, %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoDxIoStopped
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
state, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp2707 24     "%0EvtDeviceD0ExitPreInterruptsDisabled WDFDEVICE 0x%10!p! !devobj 0x%11!p!, new state %12!s! failed, %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoDxIoStopped
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
state, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp2873 27     "%0EvtDeviceD0Exit WDFDEVICE 0x%10!p! !devobj 0x%11!p!, new state %12!s! failed, %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoDxIoStoppedNP
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
state, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp2845 26     "%0EvtDeviceD0ExitPreInterruptsDisabled WDFDEVICE 0x%10!p! !devobj 0x%11!p!, new state %12!s! failed, %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerGotoDxIoStoppedNP
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
state, ItemEnum(_WDF_POWER_DEVICE_STATE) -- 12
status, ItemNTSTATUS -- 13
}
#typev  PowerStateMachine_cpp3097 28     "%0EvtDeviceSelfManagedIoRestart failed - %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerStartSelfManagedIo
{
status, ItemNTSTATUS -- 10
}
#typev  PowerStateMachine_cpp3157 29     "%0EvtDeviceSelfManagedIoRestart failed - %10!s!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerStartSelfManagedIoNP
{
status, ItemNTSTATUS -- 10
}
#typev  PowerStateMachine_cpp3517 34     "%0Force disconnecting interupts on !devobj %10!p!, WDFDEVICE %11!p!"      //   GLOBALS=This->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerWakingConnectInterruptFailedNP
{
FxDeviceToMx::GetDeviceObject(This->m_Device), ItemPtr -- 10
FxDeviceToMx::GetHandle(This->m_Device), ItemPtr -- 11
}
#typev  PowerStateMachine_cpp1375 14     "%0WDFDEVICE %10!p! !devobj 0x%11!p! current state %12!s! event %13!s! is not a known dropped event, known dropped events are %14!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerProcessEventInner
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerState(m_Device), ItemEnum(_WDF_DEVICE_POWER_STATE) -- 12
event, ItemEnum(FxPowerEvent) -- 13
entry->StateInfo.Bits.KnownDroppedEvents, ItemEnum(FxPowerEvent) -- 14
}
#typev  PowerStateMachine_cpp1360 13     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current power state %12!s! dropping event %13!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerProcessEventInner
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerState(m_Device), ItemEnum(_WDF_DEVICE_POWER_STATE) -- 12
event, ItemEnum(FxPowerEvent) -- 13
}
#typev  PowerStateMachine_cpp1115 11     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pwr pol state %12!s! dropping event %13!s! because the Event is already enqueued."      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerProcessEvent
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerState(m_Device), ItemEnum(_WDF_DEVICE_POWER_STATE) -- 12
Event, ItemEnum(FxPowerEvent) -- 13
}
#typev  PowerStateMachine_cpp1140 12     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! current pwr pol state %12!s! dropping event %13!s! because of a closed queue"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerProcessEvent
{
FxDeviceToMx::GetHandle(m_Device), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_Device), ItemPtr -- 11
FxDeviceToMx::GetDevicePowerState(m_Device), ItemEnum(_WDF_DEVICE_POWER_STATE) -- 12
Event, ItemEnum(FxPowerEvent) -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
950bd909-4e9f-8c00-5d83-948120fba76d     WdfCore // SRC=SelfManagedIoStateMachine.cpp MJ= MN=
#typev  SelfManagedIoStateMachine_cpp299 12     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! entering self managed io state %12!s! from %13!s!"      //   GLOBALS=m_PkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxSelfManagedIoMachine::ProcessEvent
{
FxDeviceToMx::GetHandle(m_PkgPnp->GetDevice()), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_PkgPnp->GetDevice()), ItemPtr -- 11
newState, ItemEnum(FxSelfManagedIoStates) -- 12
m_CurrentState, ItemEnum(FxSelfManagedIoStates) -- 13
}
#typev  SelfManagedIoStateMachine_cpp196 11     "%0Self managed I/O state machine lock initialization failed for WDFDEVICE 0x%10!p!, %11!s!"      //   GLOBALS=PkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxSelfManagedIoMachine::_CreateAndInit
{
FxDeviceToMx::GetHandle(PkgPnp->GetDevice()), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  SelfManagedIoStateMachine_cpp185 10     "%0Self managed I/O state machine allocation failed for WDFDEVICE 0x%10!p!"      //   GLOBALS=PkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxSelfManagedIoMachine::_CreateAndInit
{
FxDeviceToMx::GetHandle(PkgPnp->GetDevice()), ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
fb68f822-d5e9-8807-4631-1362e6e35862     WdfCore // SRC=EventQueue.cpp MJ= MN=
#typev  EventQueue_cpp84 11     "%0Initializing state machine lock failed for EventQueue 0x%10!p!, status %11!s!"      //   GLOBALS=DriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxEventQueue::Initialize
{
this, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  EventQueue_cpp73 10     "%0Initializing lock failed for EventQueue 0x%10!p!, status %11!s!"      //   GLOBALS=DriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxEventQueue::Initialize
{
this, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  EventQueue_cpp157 12     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! delaying deletion to outside state machine"      //   GLOBALS=m_PkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxEventQueue::SetDelayedDeletion
{
FxDeviceToMx::GetHandle(m_PkgPnp->GetDevice()), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_PkgPnp->GetDevice()), ItemPtr -- 11
}
#typev  EventQueue_cpp222 13     "%0WDFDEVICE 0x%10!p! !devobj 0x%11!p! not queueing work item to process event queue"      //   GLOBALS=m_PkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGPNP FUNC=FxEventQueue::QueueToThreadWorker
{
FxDeviceToMx::GetHandle(m_PkgPnp->GetDevice()), ItemPtr -- 10
FxDeviceToMx::GetDeviceObject(m_PkgPnp->GetDevice()), ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
0c685e21-eb4f-f201-26a9-6ce05aa1f15a     WdfCore // SRC=FxPkgFdoUm.cpp MJ= MN=
#typev  FxPkgFdoUm_cpp220 10     "%0Lower stack returned error for query pnp device state, %10!s!"      //   GLOBALS=pThis->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgFdo::_PnpQueryPnpDeviceStateCompletionRoutine
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
31825cc9-fdb7-8848-0c63-cee491ccd4fb     WdfCore // SRC=PowerPolicyStateMachineUM.cpp MJ= MN=
#typev  PowerPolicyStateMachineUM_cpp55 10     "%0For PDOs, FxPkgPnp::PowerPolicyUpdateSystemWakeSource should NOT be a no-op!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPNP FUNC=FxPkgPnp::PowerPolicyUpdateSystemWakeSource
{
}
#typev  PowerPolicyStateMachineUM_cpp179 11     "%0Entering USB Selective Suspend Idle callback"      //   GLOBALS=pPkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxUsbIdleInfo::_UsbIdleCallback
{
}
#typev  PowerPolicyStateMachineUM_cpp192 12     "%0USB Selective Suspend Idle callback processing is complete"      //   GLOBALS=m_PkgPnp->GetDriverGlobals() LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPNP FUNC=FxPowerPolicyMachine::UsbSSCallbackProcessingComplete
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
df2a3420-3e68-6b1f-e452-606e9c85bab9     WdfCore // SRC=FxVerifierLock.hpp MJ= MN=
#typev  FxVerifierLock_hpp364 11     "%0Unable to initialize lock for VerifierLock 0x%10!p! status %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxNonPagedObject::FxNonPagedObject
{
this, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxVerifierLock_hpp353 10     "%0Unable to initialize paged lock for VerifierLock 0x%10!p! status %11!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxNonPagedObject::FxNonPagedObject
{
this, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxVerifierLock_hpp474 13     "%0Failed to allocate verifier lock, returning %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxNonPagedObject::FxNonPagedObject
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
862af6b1-6a3a-4bdb-9ec4-dc7220a42d39     WdfCore // SRC=FxTagTracker.hpp MJ= MN=
#typev  FxTagTracker_hpp131 10     "%0Lock initialization failed for tagtracker %10!p!, %11!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxObject::AllocateTagTracker
{
this, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  FxTagTracker_hpp161 11     "%0Failed to allocate tag tracker, returning %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxObject::AllocateTagTracker
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
47f60883-01f9-85a5-fc9d-1be7dcd4b026     WdfCore // SRC=FxObject.hpp MJ= MN=
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::AddChildObjectInternal
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::RemoveChildObjectInternal
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
4171e494-5123-2f62-df84-0b36226c2e4c     WdfCore // SRC=FxObject.cpp MJ= MN=
#typev  FxObject_cpp139 10     "%0Handle %10!s! %11!p! (raw object %12!p!) was freed using WdfObjectDereference(), not WdfObjectDelete()"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_FATAL FLAGS=TRACINGOBJECT FUNC=FxObject::~FxObject
{
pHandleName, ItemString -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
this, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
47f60883-01f9-85a5-fc9d-1be7dcd4b026     WdfCore // SRC=FxObject.hpp MJ= MN=
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::~FxObject
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::FinalRelease
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::AssignParentObject
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::QueueDeferredDisposeLocked
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::DeletedAndDisposedWorkerLocked
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::ParentDeleteEvent
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::PerformDisposingDisposeChildrenLocked
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::PerformDisposingDisposeChildrenLocked
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::PerformEarlyDisposeWorkerAndUnlock
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::EarlyDispose
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::PerformEarlyDispose
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::PerformEarlyDispose
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::DisposeChildrenWorker
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::DisposeChildrenWorker
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::DisposeChildrenWorker
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::DeleteWorkerAndUnlock
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::DeleteObject
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp401 10     "%0Object %10!p!, WDFOBJECT %11!p! transitioning from %12!s! to %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGOBJECT FUNC=FxObject::DeleteObject
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
NewState, ItemEnum(FxObjectState) -- 13
}
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::DeleteObject
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
#typev  FxObject_hpp972 11     "%0Object %10!p!, WDFOBJECT %11!p!, state %12!s! dropping event %13!s!"      //   GLOBALS=m_Globals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGOBJECT FUNC=FxObject::DeleteObject
{
this, ItemPtr -- 10
GetObjectHandleUnchecked(), ItemPtr -- 11
m_ObjectState, ItemEnum(FxObjectState) -- 12
Event, ItemEnum(FxObjectDroppedEvent) -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
b106fc70-6ae2-f3af-294a-abb65913fa8e     WdfCore // SRC=FxObjectAPI.cpp MJ= MN=
#typev  FxObjectAPI_cpp205 10     "%0Invalid to call on WDFOBJECT 0x%10!p!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=imp_WdfObjectAcquireLock
{
Object, ItemPtr -- 10
}
#typev  FxObjectAPI_cpp260 11     "%0Invalid to call on WDFOBJECT 0x%10!p!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=imp_WdfObjectReleaseLock
{
Object, ItemPtr -- 10
}
#typev  FxObjectAPI_cpp299 12     "%0Attempt to Delete an Object Which does not allow WdfDeleteObject Handle 0x%10!p!, %11!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=imp_WdfObjectDelete
{
Object, ItemPtr -- 10
STATUS_CANNOT_DELETE, ItemNTSTATUS -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
baec2b6c-16e6-c04f-395a-51b9f2ce4da2     WdfCore // SRC=fxtagtracker.cpp MJ= MN=
#typev  fxtagtracker_cpp182 10     "%0releasing tag %10!p! on object %11!p! that was not acquired, !wdftagtracker %12!p!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxTagTracker::UpdateTagHistory
{
Tag, ItemPtr -- 10
m_OwningObject, ItemPtr -- 11
this, ItemPtr -- 12
}
#typev  fxtagtracker_cpp279 13     "%0Possibly Abandonded ref on object %10!p! tag %11!p! (%12!s! @ %13!d!).  Is benign unless there are other outstanding leaked references."      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGDEVICE FUNC=FxTagTracker::CheckForAbandondedTags
{
m_OwningObject, ItemPtr -- 10
current->Tag, ItemPtr -- 11
current->File, ItemString -- 12
current->Line, ItemLong -- 13
}
#typev  fxtagtracker_cpp259 12     "%0Abandonded ref on object %10!p! tag %11!p! (%12!s! @ %13!d!)"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxTagTracker::CheckForAbandondedTags
{
m_OwningObject, ItemPtr -- 10
current->Tag, ItemPtr -- 11
current->File, ItemString -- 12
current->Line, ItemLong -- 13
}
#typev  fxtagtracker_cpp234 11     "%0Dropped references on a tag tracker, show references with: !wdftagtracker %10!p!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxTagTracker::CheckForAbandondedTags
{
this, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
10dd18a7-c4b7-4923-5428-7fab669f24ae     WdfCore // SRC=HandleAPI.cpp MJ= MN=
#typev  HandleAPI_cpp111 10     "%0Size overflow, Object size 0x%10!x!, extra object size 0x%11!x!, ContextTypeInfo size 0x%12!I64x!, ContextSizeOverride 0x%13!I64x!, %14!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGOBJECT FUNC=FxCalculateObjectTotalSize
{
RawObjectSize, ItemLong -- 10
ExtraSize, ItemLong -- 11
(Attributes != NULL) ? Attributes->ContextTypeInfo->ContextSize : 0, ItemLongLongX -- 12
(Attributes != NULL) ? Attributes->ContextSizeOverride : 0, ItemLongLongX -- 13
status, ItemNTSTATUS -- 14
}
#typev  HandleAPI_cpp340 11     "%0Object Type Mismatch, Handle 0x%10!p!, Type 0x%11!x!, Obj 0x%12!p!, SB 0x%13!x!"      //   GLOBALS=Object->GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxObjectHandleGetPtrQI
{
Handle, ItemPtr -- 10
Type, ItemLong -- 11
Object, ItemPtr -- 12
Object->GetType(), ItemLong -- 13
}
#typev  HandleAPI_cpp433 13     "%0Attributes %10!p! ContextTypeInfo is NULL, %11!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGHANDLE FUNC=imp_WdfObjectAllocateContext
{
Attributes, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  HandleAPI_cpp414 12     "%0WDFHANDLE %10!p! cannot have contexts added to it, %11!s!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGHANDLE FUNC=imp_WdfObjectAllocateContext
{
Handle, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  HandleAPI_cpp549 14     "%0Attempting to get context type %10!s! from WDFOBJECT 0x%11!p!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_WARNING FLAGS=TRACINGHANDLE FUNC=imp_WdfObjectGetTypedContextWorker
{
pGivenName, ItemString -- 10
Handle, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
49dea60a-b6c1-cf53-a4a8-d80dfa589515     WdfCore // SRC=wdfpool.cpp MJ= MN=
#typev  wdfpool_cpp304 13     "%0overflow: header + pool request (%10!I64d!)"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPOOL FUNC=FxPoolAllocator
{
Size, ItemLongLong -- 10
}
#typev  wdfpool_cpp215 12     "%0overflow: allocation tracker (%10!d!) + header (%11!d!) + pool request (%12!I64d!)"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPOOL FUNC=FxPoolAllocator
{
sizeof(FX_POOL_TRACKER), ItemLong -- 10
FX_POOL_HEADER_SIZE, ItemLong -- 11
Size, ItemLongLong -- 12
}
#typev  wdfpool_cpp163 11     "%0Allocation Fail Count exceeded"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPOOL FUNC=FxPoolAllocator
{
}
#typev  wdfpool_cpp144 10     "%0Invalid Allocation Size of 0 requested"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPOOL FUNC=FxPoolAllocator
{
}
#typev  wdfpool_cpp535 16     "%0FX_POOL 0x%10!p! leaked non-paged memory alloc 0x%11!p! (tracking block %12!p!)"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxPoolDump
{
Pool, ItemPtr -- 10
pTracker+1, ItemPtr -- 11
pTracker, ItemPtr -- 12
}
#typev  wdfpool_cpp513 15     "%0FX_POOL 0x%10!p! leaked paged memory alloc 0x%11!p! (tracking block %12!p!)"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxPoolDump
{
Pool, ItemPtr -- 10
pTracker + 1, ItemPtr -- 11
pTracker, ItemPtr -- 12
}
#typev  wdfpool_cpp487 14     "%0FxPoolDump: NonPagedBytes %10!I64d!, PagedBytes %11!I64d!, NonPagedAllocations %12!d!, PagedAllocations %13!d!,PeakNonPagedBytes %14!I64d!, PeakPagedBytes %15!I64d!,FxPoolDump: PeakNonPagedAllocations %16!d!, PeakPagedAllocations %17!d!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxPoolDump
{
Pool->NonPagedBytes, ItemLongLong -- 10
Pool->PagedBytes, ItemLongLong -- 11
Pool->NonPagedAllocations, ItemLong -- 12
Pool->PagedAllocations, ItemLong -- 13
Pool->PeakNonPagedBytes, ItemLongLong -- 14
Pool->PeakPagedBytes, ItemLongLong -- 15
Pool->PeakNonPagedAllocations, ItemLong -- 16
Pool->PeakPagedAllocations, ItemLong -- 17
}
#typev  wdfpool_cpp590 19     "%0Initializing paged lock failed for Pool 0x%10!p!, status %11!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPOOL FUNC=FxPoolInitialize
{
Pool, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  wdfpool_cpp579 18     "%0Initializing non-paged lock failed for Pool 0x%10!p!, status %11!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGPOOL FUNC=FxPoolInitialize
{
Pool, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  wdfpool_cpp573 17     "%0Initializing Pool 0x%10!p!, Tracking %11!d!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPOOL FUNC=FxPoolInitialize
{
Pool, ItemPtr -- 10
FxDriverGlobals->IsPoolTrackingOn(), ItemLong -- 11
}
#typev  wdfpool_cpp651 20     "%0Destroying Pool 0x%10!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGPOOL FUNC=FxPoolDestroy
{
Pool, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
b46ba98b-c9f9-ccca-6294-131d92fd9cd8     WdfCore // SRC=FxVerifierBugcheck.cpp MJ= MN=
#typev  FxVerifierBugcheck_cpp95 10     "%0NULL Required Parameter Passed to a DDI
FxDriverGlobals 0x%10!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_FATAL FLAGS=TRACINGERROR FUNC=FxVerifierNullBugCheck
{
FxDriverGlobals, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
6627d29a-147c-7a09-6323-d8009611c7f7     WdfCore // SRC=globals.cpp MJ= MN=
#typev  globals_cpp271 10     "%0AllocatedTagTrackersLock initialization failed: %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDRIVER FUNC=FxDriverGlobalsInitializeDebugExtension
{
status, ItemNTSTATUS -- 10
}
#typev  globals_cpp810 11     "%0Initialize globals for %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGDRIVER FUNC=FxInitialize
{
RegistryPath, ItemPWString -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
26e648ec-e877-f028-5c1d-a4ba8ba90098     WdfCore // SRC=FxUserObject.cpp MJ= MN=
#typev  FxUserObject_cpp79 11     "%0FxObject::Commit failed %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGOBJECT FUNC=FxUserObject::_Create
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
ae13d884-d5c3-2634-a7ca-b20dafcc4109     WdfCore // SRC=FxNonPagedObject.hpp MJ= MN=
#typev  FxNonPagedObject_hpp112 10     "%0Unable to initialize non-paged lock for object 0x%10!p! (raw object %11!p!) status %12!s!"      //   GLOBALS=GetDriverGlobals() LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGOBJECT FUNC=FxUserObject::_Create
{
GetObjectHandleUnchecked(), ItemPtr -- 10
this, ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
26e648ec-e877-f028-5c1d-a4ba8ba90098     WdfCore // SRC=FxUserObject.cpp MJ= MN=
#typev  FxUserObject_cpp68 10     "%0Memory allocation failed"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGOBJECT FUNC=FxUserObject::_Create
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
9b51dd29-c0e5-200b-ef41-8d41eecb59c3     WdfCore // SRC=FxUserObjectApi.cpp MJ= MN=
#typev  FxUserObjectApi_cpp134 10     "%0Created UserObject Handle 0x%10!p!"      //   GLOBALS=pFxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGUSEROBJECT FUNC=imp_WdfObjectCreate
{
handle, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
06256c0f-48e3-6f74-feed-af811f9a4e95     WdfCore // SRC=FxValidateFunctions.hpp MJ= MN=
#typev  FxValidateFunctions_hpp90 11     "%0Attributes %10!p! Size incorrect, expected %11!d!, got %12!d!, %13!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=imp_WdfObjectCreate
{
Attributes, ItemPtr -- 10
sizeof(WDF_OBJECT_ATTRIBUTES), ItemLong -- 11
Attributes->Size, ItemLong -- 12
STATUS_INFO_LENGTH_MISMATCH, ItemNTSTATUS -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
9ed819dd-608f-8090-156b-6e2994e343ad     WdfCore // SRC=FxVerifierLock.cpp MJ= MN=
#typev  FxVerifierLock_cpp647 20     "%0Object Type 0x%10!x! does not have a lock order defined in fx\inc\FxVerifierLock.hpp"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::InitializeLockOrder
{
ObjectType, ItemLong -- 10
}
#typev  FxVerifierLock_cpp721 21     "%0Thread 0x%10!p! does not have an entry"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::GetThreadTableEntry
{
curThread, ItemPtr -- 10
}
#typev  FxVerifierLock_cpp889 25     "%0OldEntry Thread 0x%10!p! not Current! 0x%11!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::ReleaseOrReplaceThreadTableEntry
{
pLock, ItemPtr -- 10
curThread, ItemPtr -- 11
}
#typev  FxVerifierLock_cpp976 26     "%0No Memory to allocate thread table"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::AllocateThreadTable
{
}
#typev  FxVerifierLock_cpp1049 30     "%0Object 0x%10!p!, ObjectType 0x%11!x!, LockLevel 0x%12!x!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::DumpDetails
{
next->m_ParentObject, ItemPtr -- 10
next->m_ParentObject->GetType(), ItemLong -- 11
next->m_Order, ItemLong -- 12
}
#typev  FxVerifierLock_cpp1044 29     "%0List of Already Acquired Locks and Objects:"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::DumpDetails
{
}
#typev  FxVerifierLock_cpp1037 28     "%0Highest Lock Currently held is level 0x%10!x! for Object 0x%11!p!, ObjectType 0x%12!x!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::DumpDetails
{
next->m_Order, ItemLong -- 10
next->m_ParentObject, ItemPtr -- 11
next->m_ParentObject->GetType(), ItemLong -- 12
}
#typev  FxVerifierLock_cpp1028 27     "%0Thread 0x%10!p! Attempted to acquire lock on Object 0x%11!p!, ObjectType 0x%12!x!, at Level 0x%13!x! out of sequence."      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::DumpDetails
{
curThread, ItemPtr -- 10
Lock->m_ParentObject, ItemPtr -- 11
Lock->m_ParentObject->GetType(), ItemLong -- 12
Lock->m_Order, ItemLong -- 13
}
#typev  FxVerifierLock_cpp129 10     "%0Initialize failed for ThreadTableLock, status: %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLockInitialize
{
status, ItemNTSTATUS -- 10
}
#typev  FxVerifierLock_cpp191 11     "%0Thread 0x%10!p! already owns lock 0x%11!p! for object 0x%12!p!, WDFOBJECT 0x%13!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_FATAL FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Lock
{
curThread, ItemPtr -- 10
this, ItemPtr -- 11
m_ParentObject, ItemPtr -- 12
m_ParentObject->GetObjectHandle(), ItemPtr -- 13
}
#typev  FxVerifierLock_cpp578 19     "%0Record entry for VerifierLock 0x%10!p! is missing on list 0x%11!p! for Thread 0x%12!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
this, ItemPtr -- 10
perThreadList, ItemPtr -- 11
m_OwningThread, ItemPtr -- 12
}
#typev  FxVerifierLock_cpp501 18     "%0Record entry for VerifierLock 0x%10!p! is missing on list 0x%11!p! for Thread 0x%12!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
this, ItemPtr -- 10
perThreadList, ItemPtr -- 11
m_OwningThread, ItemPtr -- 12
}
#typev  FxVerifierLock_cpp404 17     "%0this 0x%10!p!, perThreadList 0x%11!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
this, ItemPtr -- 10
perThreadList, ItemPtr -- 11
}
#typev  FxVerifierLock_cpp401 16     "%0Thread has entry, but no locks recorded as held for dispatch!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
}
#typev  FxVerifierLock_cpp383 15     "%0this 0x%10!p!, perThreadList 0x%11!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
this, ItemPtr -- 10
perThreadList, ItemPtr -- 11
}
#typev  FxVerifierLock_cpp380 14     "%0Thread has entry, but no locks recorded as held for passive!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
}
#typev  FxVerifierLock_cpp348 13     "%0Unlock:  Can't get per thread entry for thread %10!p!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
curThread, ItemPtr -- 10
}
#typev  FxVerifierLock_cpp332 12     "%0Thread 0x%10!p! Is Attempting to release a Lock 0x%11!p! for Object 0x%12!p! it does not own!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxVerifierLock::Unlock
{
curThread, ItemPtr -- 10
this, ItemPtr -- 11
m_ParentObject, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
4a25592a-8cae-c35c-6091-a285ae14baaa     WdfCore // SRC=FxValidateFunctions.cpp MJ= MN=
#typev  FxValidateFunctions_cpp162 18     "%0Attributes %10!p! execution level set to %11!d!, out of range, %12!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->ExecutionLevel, ItemLong -- 11
STATUS_WDF_OBJECT_ATTRIBUTES_INVALID, ItemNTSTATUS -- 12
}
#typev  FxValidateFunctions_cpp172 19     "%0Attributes %10!p! synchronization scope set to %11!d!, out of range, %12!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->SynchronizationScope, ItemLong -- 11
STATUS_WDF_OBJECT_ATTRIBUTES_INVALID, ItemNTSTATUS -- 12
}
#typev  FxValidateFunctions_cpp207 21     "%0Attributes %10!p! does not allow execution level to be set, but was set to %11!s!, %12!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->ExecutionLevel, ItemEnum(_WDF_EXECUTION_LEVEL) -- 11
STATUS_WDF_EXECUTION_LEVEL_INVALID, ItemNTSTATUS -- 12
}
#typev  FxValidateFunctions_cpp189 20     "%0Attributes %10!p! does not allow synchronization scope too be set, but was set to %11!s!, %12!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->SynchronizationScope, ItemEnum(_WDF_SYNCHRONIZATION_SCOPE) -- 11
STATUS_WDF_SYNCHRONIZATION_SCOPE_INVALID, ItemNTSTATUS -- 12
}
#typev  FxValidateFunctions_cpp151 17     "%0ParentObject required in WDF_OBJECT_ATTRIBUTES %10!p!, %11!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
STATUS_WDF_PARENT_NOT_SPECIFIED, ItemNTSTATUS -- 11
}
#typev  FxValidateFunctions_cpp140 16     "%0Attributes %10!p! does not allow a parent object to be set, set to %11!p!, %12!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->ParentObject, ItemPtr -- 11
STATUS_WDF_PARENT_ASSIGNMENT_NOT_ALLOWED, ItemNTSTATUS -- 12
}
#typev  FxValidateFunctions_cpp126 15     "%0Attributes %10!p! ContextSizeOverride %11!I64d! < ContextTypeInfo->ContextSize %12!I64d!, %13!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->ContextSizeOverride, ItemLongLong -- 11
Attributes->ContextTypeInfo->ContextSize, ItemLongLong -- 12
STATUS_WDF_OBJECT_ATTRIBUTES_INVALID, ItemNTSTATUS -- 13
}
#typev  FxValidateFunctions_cpp115 14     "%0Attributes %10!p! ContextSizeOverride of %11!I64d! specified, but no type information, %12!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->ContextSizeOverride, ItemLongLong -- 11
STATUS_WDF_OBJECT_ATTRIBUTES_INVALID, ItemNTSTATUS -- 12
}
#typev  FxValidateFunctions_cpp98 13     "%0Attributes %10!p! ContextTypeInfo %11!p! ContextSize %12!I64d! is not zero, but ContextName is NULL, %13!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->ContextTypeInfo, ItemPtr -- 11
Attributes->ContextTypeInfo->ContextSize, ItemLongLong -- 12
STATUS_WDF_OBJECT_ATTRIBUTES_INVALID, ItemNTSTATUS -- 13
}
#typev  FxValidateFunctions_cpp82 12     "%0Attributes %10!p! ContextTypeInfo %11!p! Size %12!d! incorrect, expected %13!d!, %14!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
Attributes->ContextTypeInfo, ItemPtr -- 11
Attributes->ContextTypeInfo->Size, ItemLong -- 12
sizeof(WDF_OBJECT_CONTEXT_TYPE_INFO), ItemLong -- 13
STATUS_INFO_LENGTH_MISMATCH, ItemNTSTATUS -- 14
}
#typev  FxValidateFunctions_cpp68 11     "%0Attributes %10!p! Size incorrect, expected %11!d!, got %12!d!, %13!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGAPIERROR FUNC=FxValidateObjectAttributes
{
Attributes, ItemPtr -- 10
sizeof(WDF_OBJECT_ATTRIBUTES), ItemLong -- 11
Attributes->Size, ItemLong -- 12
STATUS_INFO_LENGTH_MISMATCH, ItemNTSTATUS -- 13
}
#typev  FxValidateFunctions_cpp52 10     "%0WDF_OBJECT_ATTRIBUTES required, %10!s!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGDEVICE FUNC=FxValidateObjectAttributes
{
(ULONG) STATUS_WDF_PARENT_NOT_SPECIFIED, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
78e7bed2-0a0f-3a6f-6d69-d10c8f4438e3     WdfCore // SRC=FxRegKey.cpp MJ= MN=
#typev  FxRegKey_cpp54 11     "%0Red value name %10!s!, DataLength %11!d!, Data buffer from registry does not have double NULL terminal chars, STATUS_OBJECT_TYPE_MISMATCH"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGERROR FUNC=FxRegKey::_VerifyMultiSzString
{
RegValueName, ItemPWString -- 10
DataLength, ItemLong -- 11
}
#typev  FxRegKey_cpp41 10     "%0Reg value name %10!s!, DataLength %11!d!, Data buffer length is invalid, STATUS_OBJECT_TYPE_MISMATCH"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_ERROR FLAGS=TRACINGERROR FUNC=FxRegKey::_VerifyMultiSzString
{
RegValueName, ItemPWString -- 10
DataLength, ItemLong -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
// PDB:  Last Updated :2010-2-9:4:5:34:369 (UTC) [tracepdb]
4bb88da3-053e-d257-1664-a9382d34b21c     WdfCore // SRC=TracingUM.cpp MJ= MN=
#typev  TracingUM_cpp487 11     "%0FxIFR has been started with a size override:  size 0x%10!x! bytes, # Pages %11!d!.  An extended IFR size may not be written to a minidump!"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_INFORMATION FLAGS=TRACINGDRIVER FUNC=FxIFRStart
{
size, ItemLong -- 10
size/PAGE_SIZE, ItemLong -- 11
}
#typev  TracingUM_cpp483 10     "%0FxIFR logging started"      //   GLOBALS=FxDriverGlobals LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACINGDRIVER FUNC=FxIFRStart
{
}
22366aa2-25c9-8eb2-979f-30b07cbcc758 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_IO_TARGET_STATE
{
WdfIoTargetStateUndefined,0x0
WdfIoTargetStarted,0x1
WdfIoTargetStopped,0x2
WdfIoTargetClosedForQueryRemove,0x3
WdfIoTargetClosed,0x4
WdfIoTargetDeleted,0x5
WdfIoTargetStateMaximum,0x6
}
fe572e86-56b5-fa49-4c7d-34cf864cec8b e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_IO_TARGET_STATE
{
WdfIoTargetStateUndefined,0x0
WdfIoTargetStarted,0x1
WdfIoTargetStopped,0x2
WdfIoTargetClosedForQueryRemove,0x3
WdfIoTargetClosed,0x4
WdfIoTargetDeleted,0x5
WdfIoTargetStateMaximum,0x6
}
20c096cb-3b21-a8bf-7f52-f786f36469e7 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_REQUEST_TYPE
{
WdfRequestUndefined,0x0
WdfRequestCreate,0x1
WdfRequestCleanup,0x2
WdfRequestRead,0x3
WdfRequestWrite,0x4
WdfRequestDeviceIoControl,0x5
WdfRequestClose,0x6
WdfRequestUsb,0x7
WdfRequestOther,0x8
WdfRequestInternalIoctl,0x9
WdfRequestTypeNoFormat,0xA
WdfRequestFlushBuffers,0xB
WdfRequestQueryInformation,0xC
WdfRequestSetInformation,0xD
WdfRequestMaximum,0xE
}
0cb05f64-1305-ad9b-046c-8d30905d67c5 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _DEVICE_RELATION_TYPE
{
BusRelations,0x0
EjectionRelations,0x1
PowerRelations,0x2
RemovalRelations,0x3
TargetDeviceRelation,0x4
SingleBusRelations,0x5
}
0e4262ce-cb72-a804-9052-51b6ae699889 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv BUS_QUERY_ID_TYPE
{
BusQueryDeviceID,0x0
BusQueryHardwareIDs,0x1
BusQueryCompatibleIDs,0x2
BusQueryInstanceID,0x3
BusQueryDeviceSerialNumber,0x4
BusQueryContainerID,0x5
}
d816b6e3-c6ba-363d-54b4-3533d1de16bb e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _DEVICE_POWER_STATE
{
PowerDeviceUnspecified,0x0
PowerDeviceD0,0x1
PowerDeviceD1,0x2
PowerDeviceD2,0x3
PowerDeviceD3,0x4
PowerDeviceMaximum,0x5
}
#enumv _SYSTEM_POWER_STATE
{
PowerSystemUnspecified,0x0
PowerSystemWorking,0x1
PowerSystemSleeping1,0x2
PowerSystemSleeping2,0x3
PowerSystemSleeping3,0x4
PowerSystemHibernate,0x5
PowerSystemShutdown,0x6
PowerSystemMaximum,0x7
}
#enumv _DEVICE_RELATION_TYPE
{
BusRelations,0x0
EjectionRelations,0x1
PowerRelations,0x2
RemovalRelations,0x3
TargetDeviceRelation,0x4
SingleBusRelations,0x5
}
31f474a8-23f3-c270-e156-7b455a6f635c e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_DEVICE_PNP_STATE
{
WdfDevStatePnpInvalid,0x0
WdfDevStatePnpObjectCreated,0x100
WdfDevStatePnpCheckForDevicePresence,0x101
WdfDevStatePnpEjectFailed,0x102
WdfDevStatePnpEjectHardware,0x103
WdfDevStatePnpEjectedWaitingForRemove,0x104
WdfDevStatePnpInit,0x105
WdfDevStatePnpInitStarting,0x106
WdfDevStatePnpInitSurpriseRemoved,0x107
WdfDevStatePnpHardwareAvailable,0x108
WdfDevStatePnpEnableInterfaces,0x109
WdfDevStatePnpHardwareAvailablePowerPolicyFailed,0x10A
WdfDevStatePnpQueryRemoveAskDriver,0x10B
WdfDevStatePnpQueryRemovePending,0x10C
WdfDevStatePnpQueryRemoveStaticCheck,0x10D
WdfDevStatePnpQueriedRemoving,0x10E
WdfDevStatePnpQueryStopAskDriver,0x10F
WdfDevStatePnpQueryStopPending,0x110
WdfDevStatePnpQueryStopStaticCheck,0x111
WdfDevStatePnpQueryCanceled,0x112
WdfDevStatePnpRemoved,0x113
WdfDevStatePnpPdoRemoved,0x114
WdfDevStatePnpRemovedPdoWait,0x115
WdfDevStatePnpRemovedPdoSurpriseRemoved,0x116
WdfDevStatePnpRemovingDisableInterfaces,0x117
WdfDevStatePnpRestarting,0x118
WdfDevStatePnpStarted,0x119
WdfDevStatePnpStartedCancelStop,0x11A
WdfDevStatePnpStartedCancelRemove,0x11B
WdfDevStatePnpStartedRemoving,0x11C
WdfDevStatePnpStartingFromStopped,0x11D
WdfDevStatePnpStopped,0x11E
WdfDevStatePnpStoppedWaitForStartCompletion,0x11F
WdfDevStatePnpStartedStopping,0x120
WdfDevStatePnpSurpriseRemove,0x121
WdfDevStatePnpInitQueryRemove,0x122
WdfDevStatePnpInitQueryRemoveCanceled,0x123
WdfDevStatePnpFdoRemoved,0x124
WdfDevStatePnpRemovedWaitForChildren,0x125
WdfDevStatePnpQueriedSurpriseRemove,0x126
WdfDevStatePnpSurpriseRemoveIoStarted,0x127
WdfDevStatePnpFailedPowerDown,0x128
WdfDevStatePnpFailedIoStarting,0x129
WdfDevStatePnpFailedOwnHardware,0x12A
WdfDevStatePnpFailed,0x12B
WdfDevStatePnpFailedSurpriseRemoved,0x12C
WdfDevStatePnpFailedStarted,0x12D
WdfDevStatePnpFailedWaitForRemove,0x12E
WdfDevStatePnpFailedInit,0x12F
WdfDevStatePnpPdoInitFailed,0x130
WdfDevStatePnpRestart,0x131
WdfDevStatePnpRestartReleaseHardware,0x132
WdfDevStatePnpRestartHardwareAvailable,0x133
WdfDevStatePnpPdoRestart,0x134
WdfDevStatePnpFinal,0x135
WdfDevStatePnpRemovedChildrenRemoved,0x136
WdfDevStatePnpQueryRemoveEnsureDeviceAwake,0x137
WdfDevStatePnpQueryStopEnsureDeviceAwake,0x138
WdfDevStatePnpNull,0x139
}
#enumv FxPnpEvent
{
PnpEventInvalid,0x0
PnpEventAddDevice,0x1
PnpEventStartDevice,0x2
PnpEventStartDeviceComplete,0x4
PnpEventStartDeviceFailed,0x8
PnpEventQueryRemove,0x10
PnpEventQueryStop,0x20
PnpEventCancelRemove,0x40
PnpEventCancelStop,0x80
PnpEventStop,0x100
PnpEventRemove,0x200
PnpEventSurpriseRemove,0x400
PnpEventEject,0x800
PnpEventPwrPolStopped,0x1000
PnpEventPwrPolStopFailed,0x2000
PnpEventPowerUpFailed,0x4000
PnpEventPowerDownFailed,0x8000
PnpEventParentRemoved,0x10000
PnpEventChildrenRemovalComplete,0x20000
PnpEventPwrPolStarted,0x40000
PnpEventPwrPolStartFailed,0x80000
PnpEventDeviceInD0,0x100000
PnpEventPending,0xDF4
PnpPriorityEventsMask,0x1C3000
PnpEventNull,0xFF
}
a06c4939-ec03-9e2b-f095-211ff9a6d5e5 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv FxPowerIdleStates
{
FxIdleStopped,0x1
FxIdleStarted,0x2
FxIdleStartedPowerUp,0x3
FxIdleStartedPowerFailed,0x4
FxIdleDisabled,0x5
FxIdleCheckIoCount,0x6
FxIdleBusy,0x7
FxIdleDecrementIo,0x8
FxIdleStartTimer,0x9
FxIdleTimerRunning,0xA
FxIdleTimingOut,0xB
FxIdleTimedOut,0xC
FxIdleTimedOutIoIncrement,0xD
FxIdleTimedOutPowerDown,0xE
FxIdleTimedOutPowerDownFailed,0xF
FxIdleGoingToDx,0x10
FxIdleInDx,0x11
FxIdleInDxIoIncrement,0x12
FxIdleInDxPowerUpFailure,0x13
FxIdleInDxStopped,0x14
FxIdleInDxDisabled,0x15
FxIdleInDxEnabled,0x16
FxIdlePowerUp,0x17
FxIdlePowerUpComplete,0x18
FxIdleTimedOutDisabled,0x19
FxIdleTimedOutEnabled,0x1A
FxIdleCancelTimer,0x1B
FxIdleWaitForTimeout,0x1C
FxIdleTimerExpired,0x1D
FxIdleDisabling,0x1E
FxIdleDisablingWaitForTimeout,0x1F
FxIdleDisablingTimerExpired,0x20
FxIdlePowerFailedWaitForTimeout,0x21
FxIdlePowerFailed,0x22
FxIdleMax,0x23
}
#enumv FxPowerIdleEvents
{
PowerIdleEventPowerUpFailed,0x2
PowerIdleEventPowerUpComplete,0x4
PowerIdleEventPowerDown,0x8
PowerIdleEventPowerDownFailed,0x10
PowerIdleEventTimerExpired,0x20
PowerIdleEventEnabled,0x40
PowerIdleEventDisabled,0x80
PowerIdleEventIoDecrement,0x100
PowerIdleEventIoIncrement,0x200
PowerIdleEventStart,0x400
PowerIdleEventStop,0x800
PowerIdleNull,0x0
}
1c6af04a-8c20-a063-1976-7299d70a2744 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_DEVICE_POWER_POLICY_STATE
{
WdfDevStatePwrPolInvalid,0x0
WdfDevStatePwrPolObjectCreated,0x500
WdfDevStatePwrPolStarting,0x501
WdfDevStatePwrPolStartingSucceeded,0x502
WdfDevStatePwrPolStartingFailed,0x503
WdfDevStatePwrPolStartingDecideS0Wake,0x504
WdfDevStatePwrPolStartedIdleCapable,0x505
WdfDevStatePwrPolTimerExpiredNoWake,0x506
WdfDevStatePwrPolTimerExpiredNoWakeCompletePowerDown,0x507
WdfDevStatePwrPolWaitingUnarmed,0x508
WdfDevStatePwrPolWaitingUnarmedQueryIdle,0x509
WdfDevStatePwrPolS0NoWakePowerUp,0x50A
WdfDevStatePwrPolS0NoWakeCompletePowerUp,0x50B
WdfDevStatePwrPolSystemSleepFromDeviceWaitingUnarmed,0x50C
WdfDevStatePwrPolSystemSleepNeedWake,0x50D
WdfDevStatePwrPolSystemSleepNeedWakeCompletePowerUp,0x50E
WdfDevStatePwrPolSystemSleepPowerRequestFailed,0x50F
WdfDevStatePwrPolCheckPowerPageable,0x510
WdfDevStatePwrPolSleepingWakeWakeArrived,0x511
WdfDevStatePwrPolSleepingWakeRevertArmWake,0x512
WdfDevStatePwrPolSystemAsleepWakeArmed,0x513
WdfDevStatePwrPolSystemWakeDeviceWakeEnabled,0x514
WdfDevStatePwrPolSystemWakeDeviceWakeEnabledWakeCanceled,0x515
WdfDevStatePwrPolSystemWakeDeviceWakeDisarm,0x516
WdfDevStatePwrPolSystemWakeDeviceWakeTriggered,0x517
WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredS0,0x518
WdfDevStatePwrPolSystemWakeDeviceWokeDisarm,0x519
WdfDevStatePwrPolSleepingWakeWakeArrivedNP,0x851A
WdfDevStatePwrPolSleepingWakeRevertArmWakeNP,0x851B
WdfDevStatePwrPolSleepingWakePowerDownFailed,0x51C
WdfDevStatePwrPolSleepingWakePowerDownFailedWakeCanceled,0x51D
WdfDevStatePwrPolSystemAsleepWakeArmedNP,0x851E
WdfDevStatePwrPolSystemWakeDeviceWakeEnabledNP,0x851F
WdfDevStatePwrPolSystemWakeDeviceWakeEnabledWakeCanceledNP,0x8520
WdfDevStatePwrPolSystemWakeDeviceWakeDisarmNP,0x8521
WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredNP,0x8522
WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredS0NP,0x8523
WdfDevStatePwrPolSystemWakeDeviceWokeDisarmNP,0x8524
WdfDevStatePwrPolSystemWakeDeviceWakeCompletePowerUp,0x525
WdfDevStatePwrPolSleeping,0x526
WdfDevStatePwrPolSleepingNoWakePowerDown,0x527
WdfDevStatePwrPolSleepingNoWakeCompletePowerDown,0x528
WdfDevStatePwrPolSleepingNoWakeDxRequestFailed,0x529
WdfDevStatePwrPolSleepingWakePowerDown,0x52A
WdfDevStatePwrPolSleepingSendWake,0x52B
WdfDevStatePwrPolSystemAsleepNoWake,0x52C
WdfDevStatePwrPolSystemWakeDeviceWakeDisabled,0x52D
WdfDevStatePwrPolSystemWakeDeviceToD0,0x52E
WdfDevStatePwrPolSystemWakeDeviceToD0CompletePowerUp,0x52F
WdfDevStatePwrPolSystemWakeQueryIdle,0x530
WdfDevStatePwrPolStartedWakeCapable,0x531
WdfDevStatePwrPolTimerExpiredDecideUsbSS,0x532
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDown,0x533
WdfDevStatePwrPolTimerExpiredWakeCapableSendWake,0x534
WdfDevStatePwrPolTimerExpiredWakeCapableUsbSS,0x535
WdfDevStatePwrPolTimerExpiredWakeCapableWakeArrived,0x536
WdfDevStatePwrPolTimerExpiredWakeCapableCancelWake,0x537
WdfDevStatePwrPolTimerExpiredWakeCapableWakeCanceled,0x538
WdfDevStatePwrPolTimerExpiredWakeCapableCleanup,0x539
WdfDevStatePwrPolTimerExpiredWakeCapableDxAllocFailed,0x53A
WdfDevStatePwrPolTimerExpiredWakeCompletedPowerDown,0x53B
WdfDevStatePwrPolTimerExpiredWakeCompletedPowerUp,0x53C
WdfDevStatePwrPolWaitingArmedUsbSS,0x53D
WdfDevStatePwrPolWaitingArmed,0x53E
WdfDevStatePwrPolWaitingArmedQueryIdle,0x53F
WdfDevStatePwrPolIoPresentArmed,0x540
WdfDevStatePwrPolIoPresentArmedWakeCanceled,0x541
WdfDevStatePwrPolS0WakeDisarm,0x542
WdfDevStatePwrPolS0WakeCompletePowerUp,0x543
WdfDevStatePwrPolTimerExpiredWakeSucceeded,0x544
WdfDevStatePwrPolTimerExpiredWakeCompletedDisarm,0x545
WdfDevStatePwrPolTimerExpiredWakeCapableWakeSucceeded,0x546
WdfDevStatePwrPolTimerExpiredWakeCapableWakeFailed,0x547
WdfDevStatePwrPolWakeFailedUsbSS,0x548
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedCancelWake,0x549
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedWakeCanceled,0x54A
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedUsbSS,0x54B
WdfDevStatePwrPolCancelingWakeForSystemSleep,0x54C
WdfDevStatePwrPolCancelingWakeForSystemSleepWakeCanceled,0x54D
WdfDevStatePwrPolDisarmingWakeForSystemSleepCompletePowerUp,0x54E
WdfDevStatePwrPolPowerUpForSystemSleepFailed,0x54F
WdfDevStatePwrPolWokeFromS0UsbSS,0x550
WdfDevStatePwrPolWokeFromS0,0x551
WdfDevStatePwrPolWokeFromS0NotifyDriver,0x552
WdfDevStatePwrPolStoppingResetDevice,0x553
WdfDevStatePwrPolStoppingResetDeviceCompletePowerUp,0x554
WdfDevStatePwrPolStoppingResetDeviceFailed,0x555
WdfDevStatePwrPolStoppingD0,0x556
WdfDevStatePwrPolStoppingD0Failed,0x557
WdfDevStatePwrPolStoppingDisarmWake,0x558
WdfDevStatePwrPolStoppingDisarmWakeCancelWake,0x559
WdfDevStatePwrPolStoppingDisarmWakeWakeCanceled,0x55A
WdfDevStatePwrPolStopping,0x55B
WdfDevStatePwrPolStoppingFailed,0x55C
WdfDevStatePwrPolStoppingSendStatus,0x55D
WdfDevStatePwrPolStoppingCancelTimer,0x55E
WdfDevStatePwrPolStoppingWaitForIdleTimeout,0x55F
WdfDevStatePwrPolStoppingCancelUsbSS,0x560
WdfDevStatePwrPolStoppingWaitForUsbSSCompletion,0x561
WdfDevStatePwrPolStoppingCancelWake,0x562
WdfDevStatePwrPolStopped,0x563
WdfDevStatePwrPolCancelUsbSS,0x564
WdfDevStatePwrPolStarted,0x565
WdfDevStatePwrPolStartedCancelTimer,0x566
WdfDevStatePwrPolStartedWaitForIdleTimeout,0x567
WdfDevStatePwrPolStartedWakeCapableCancelTimerForSleep,0x568
WdfDevStatePwrPolStartedWakeCapableWaitForIdleTimeout,0x569
WdfDevStatePwrPolStartedWakeCapableSleepingUsbSS,0x56A
WdfDevStatePwrPolStartedIdleCapableCancelTimerForSleep,0x56B
WdfDevStatePwrPolStartedIdleCapableWaitForIdleTimeout,0x56C
WdfDevStatePwrPolDeviceD0PowerRequestFailed,0x56D
WdfDevStatePwrPolDevicePowerRequestFailed,0x56E
WdfDevStatePwrPolGotoDx,0x56F
WdfDevStatePwrPolGotoDxInDx,0x570
WdfDevStatePwrPolDx,0x571
WdfDevStatePwrPolGotoD0,0x572
WdfDevStatePwrPolGotoD0InD0,0x573
WdfDevStatePwrPolFinal,0x574
WdfDevStatePwrPolSleepingPowerDownNotProcessed,0x575
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownNotProcessed,0x576
WdfDevStatePwrPolTimerExpiredNoWakePowerDownNotProcessed,0x577
WdfDevStatePwrPolTimerExpiredNoWakePoweredDownDisableIdleTimer,0x578
WdfDevStatePwrPolStoppingWaitingForImplicitPowerDown,0x579
WdfDevStatePwrPolStoppingPoweringUp,0x57A
WdfDevStatePwrPolStoppingPoweringDown,0x57B
WdfDevStatePwrPolPowerUpForSystemSleepNotSeen,0x57C
WdfDevStatePwrPolWaitingArmedStoppingCancelUsbSS,0x57D
WdfDevStatePwrPolWaitingArmedWakeFailedCancelUsbSS,0x57E
WdfDevStatePwrPolWaitingArmedIoPresentCancelUsbSS,0x57F
WdfDevStatePwrPolWaitingArmedWakeSucceededCancelUsbSS,0x580
WdfDevStatePwrPolCancelingUsbSSForSystemSleep,0x581
WdfDevStatePwrPolStoppingD0CancelUsbSS,0x582
WdfDevStatePwrPolNull,0x583
}
#enumv FxPowerPolicyEvent
{
PwrPolInvalid,0x0
PwrPolStart,0x1
PwrPolStop,0x2
PwrPolSx,0x4
PwrPolS0,0x8
PwrPolPowerDown,0x10
PwrPolPowerUp,0x20
PwrPolPowerDownIoStopped,0x40
PwrPolPowerUpHwStarted,0x80
PwrPolWakeArrived,0x100
PwrPolWakeSuccess,0x200
PwrPolWakeFailed,0x400
PwrPolIoPresent,0x800
PwrPolPowerTimeoutExpired,0x1000
PwrPolS0IdlePolicyChanged,0x2000
PwrPolSurpriseRemove,0x4000
PwrPolUsbSelectiveSuspendCallback,0x8000
PwrPolUsbSelectiveSuspendCompleted,0x10000
PwrPolPowerDownFailed,0x20000
PwrPolPowerUpFailed,0x40000
PwrPolImplicitPowerDown,0x80000
PwrPolImplicitPowerDownFailed,0x100000
PwrPolPowerUpNotSeen,0x200000
PwrPolPriorityEventsMask,0x3F07F0
PwrPolNotOwnerPriorityEventsMask,0x60030
PowerPolSingularEventMask,0x2000
PwrPolNull,0xFF
}
0f1627e4-9104-3b5b-0ee6-1d7b7b807395 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_DEVICE_POWER_POLICY_STATE
{
WdfDevStatePwrPolInvalid,0x0
WdfDevStatePwrPolObjectCreated,0x500
WdfDevStatePwrPolStarting,0x501
WdfDevStatePwrPolStartingSucceeded,0x502
WdfDevStatePwrPolStartingFailed,0x503
WdfDevStatePwrPolStartingDecideS0Wake,0x504
WdfDevStatePwrPolStartedIdleCapable,0x505
WdfDevStatePwrPolTimerExpiredNoWake,0x506
WdfDevStatePwrPolTimerExpiredNoWakeCompletePowerDown,0x507
WdfDevStatePwrPolWaitingUnarmed,0x508
WdfDevStatePwrPolWaitingUnarmedQueryIdle,0x509
WdfDevStatePwrPolS0NoWakePowerUp,0x50A
WdfDevStatePwrPolS0NoWakeCompletePowerUp,0x50B
WdfDevStatePwrPolSystemSleepFromDeviceWaitingUnarmed,0x50C
WdfDevStatePwrPolSystemSleepNeedWake,0x50D
WdfDevStatePwrPolSystemSleepNeedWakeCompletePowerUp,0x50E
WdfDevStatePwrPolSystemSleepPowerRequestFailed,0x50F
WdfDevStatePwrPolCheckPowerPageable,0x510
WdfDevStatePwrPolSleepingWakeWakeArrived,0x511
WdfDevStatePwrPolSleepingWakeRevertArmWake,0x512
WdfDevStatePwrPolSystemAsleepWakeArmed,0x513
WdfDevStatePwrPolSystemWakeDeviceWakeEnabled,0x514
WdfDevStatePwrPolSystemWakeDeviceWakeEnabledWakeCanceled,0x515
WdfDevStatePwrPolSystemWakeDeviceWakeDisarm,0x516
WdfDevStatePwrPolSystemWakeDeviceWakeTriggered,0x517
WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredS0,0x518
WdfDevStatePwrPolSystemWakeDeviceWokeDisarm,0x519
WdfDevStatePwrPolSleepingWakeWakeArrivedNP,0x851A
WdfDevStatePwrPolSleepingWakeRevertArmWakeNP,0x851B
WdfDevStatePwrPolSleepingWakePowerDownFailed,0x51C
WdfDevStatePwrPolSleepingWakePowerDownFailedWakeCanceled,0x51D
WdfDevStatePwrPolSystemAsleepWakeArmedNP,0x851E
WdfDevStatePwrPolSystemWakeDeviceWakeEnabledNP,0x851F
WdfDevStatePwrPolSystemWakeDeviceWakeEnabledWakeCanceledNP,0x8520
WdfDevStatePwrPolSystemWakeDeviceWakeDisarmNP,0x8521
WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredNP,0x8522
WdfDevStatePwrPolSystemWakeDeviceWakeTriggeredS0NP,0x8523
WdfDevStatePwrPolSystemWakeDeviceWokeDisarmNP,0x8524
WdfDevStatePwrPolSystemWakeDeviceWakeCompletePowerUp,0x525
WdfDevStatePwrPolSleeping,0x526
WdfDevStatePwrPolSleepingNoWakePowerDown,0x527
WdfDevStatePwrPolSleepingNoWakeCompletePowerDown,0x528
WdfDevStatePwrPolSleepingNoWakeDxRequestFailed,0x529
WdfDevStatePwrPolSleepingWakePowerDown,0x52A
WdfDevStatePwrPolSleepingSendWake,0x52B
WdfDevStatePwrPolSystemAsleepNoWake,0x52C
WdfDevStatePwrPolSystemWakeDeviceWakeDisabled,0x52D
WdfDevStatePwrPolSystemWakeDeviceToD0,0x52E
WdfDevStatePwrPolSystemWakeDeviceToD0CompletePowerUp,0x52F
WdfDevStatePwrPolSystemWakeQueryIdle,0x530
WdfDevStatePwrPolStartedWakeCapable,0x531
WdfDevStatePwrPolTimerExpiredDecideUsbSS,0x532
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDown,0x533
WdfDevStatePwrPolTimerExpiredWakeCapableSendWake,0x534
WdfDevStatePwrPolTimerExpiredWakeCapableUsbSS,0x535
WdfDevStatePwrPolTimerExpiredWakeCapableWakeArrived,0x536
WdfDevStatePwrPolTimerExpiredWakeCapableCancelWake,0x537
WdfDevStatePwrPolTimerExpiredWakeCapableWakeCanceled,0x538
WdfDevStatePwrPolTimerExpiredWakeCapableCleanup,0x539
WdfDevStatePwrPolTimerExpiredWakeCapableDxAllocFailed,0x53A
WdfDevStatePwrPolTimerExpiredWakeCompletedPowerDown,0x53B
WdfDevStatePwrPolTimerExpiredWakeCompletedPowerUp,0x53C
WdfDevStatePwrPolWaitingArmedUsbSS,0x53D
WdfDevStatePwrPolWaitingArmed,0x53E
WdfDevStatePwrPolWaitingArmedQueryIdle,0x53F
WdfDevStatePwrPolIoPresentArmed,0x540
WdfDevStatePwrPolIoPresentArmedWakeCanceled,0x541
WdfDevStatePwrPolS0WakeDisarm,0x542
WdfDevStatePwrPolS0WakeCompletePowerUp,0x543
WdfDevStatePwrPolTimerExpiredWakeSucceeded,0x544
WdfDevStatePwrPolTimerExpiredWakeCompletedDisarm,0x545
WdfDevStatePwrPolTimerExpiredWakeCapableWakeSucceeded,0x546
WdfDevStatePwrPolTimerExpiredWakeCapableWakeFailed,0x547
WdfDevStatePwrPolWakeFailedUsbSS,0x548
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedCancelWake,0x549
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedWakeCanceled,0x54A
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownFailedUsbSS,0x54B
WdfDevStatePwrPolCancelingWakeForSystemSleep,0x54C
WdfDevStatePwrPolCancelingWakeForSystemSleepWakeCanceled,0x54D
WdfDevStatePwrPolDisarmingWakeForSystemSleepCompletePowerUp,0x54E
WdfDevStatePwrPolPowerUpForSystemSleepFailed,0x54F
WdfDevStatePwrPolWokeFromS0UsbSS,0x550
WdfDevStatePwrPolWokeFromS0,0x551
WdfDevStatePwrPolWokeFromS0NotifyDriver,0x552
WdfDevStatePwrPolStoppingResetDevice,0x553
WdfDevStatePwrPolStoppingResetDeviceCompletePowerUp,0x554
WdfDevStatePwrPolStoppingResetDeviceFailed,0x555
WdfDevStatePwrPolStoppingD0,0x556
WdfDevStatePwrPolStoppingD0Failed,0x557
WdfDevStatePwrPolStoppingDisarmWake,0x558
WdfDevStatePwrPolStoppingDisarmWakeCancelWake,0x559
WdfDevStatePwrPolStoppingDisarmWakeWakeCanceled,0x55A
WdfDevStatePwrPolStopping,0x55B
WdfDevStatePwrPolStoppingFailed,0x55C
WdfDevStatePwrPolStoppingSendStatus,0x55D
WdfDevStatePwrPolStoppingCancelTimer,0x55E
WdfDevStatePwrPolStoppingWaitForIdleTimeout,0x55F
WdfDevStatePwrPolStoppingCancelUsbSS,0x560
WdfDevStatePwrPolStoppingWaitForUsbSSCompletion,0x561
WdfDevStatePwrPolStoppingCancelWake,0x562
WdfDevStatePwrPolStopped,0x563
WdfDevStatePwrPolCancelUsbSS,0x564
WdfDevStatePwrPolStarted,0x565
WdfDevStatePwrPolStartedCancelTimer,0x566
WdfDevStatePwrPolStartedWaitForIdleTimeout,0x567
WdfDevStatePwrPolStartedWakeCapableCancelTimerForSleep,0x568
WdfDevStatePwrPolStartedWakeCapableWaitForIdleTimeout,0x569
WdfDevStatePwrPolStartedWakeCapableSleepingUsbSS,0x56A
WdfDevStatePwrPolStartedIdleCapableCancelTimerForSleep,0x56B
WdfDevStatePwrPolStartedIdleCapableWaitForIdleTimeout,0x56C
WdfDevStatePwrPolDeviceD0PowerRequestFailed,0x56D
WdfDevStatePwrPolDevicePowerRequestFailed,0x56E
WdfDevStatePwrPolGotoDx,0x56F
WdfDevStatePwrPolGotoDxInDx,0x570
WdfDevStatePwrPolDx,0x571
WdfDevStatePwrPolGotoD0,0x572
WdfDevStatePwrPolGotoD0InD0,0x573
WdfDevStatePwrPolFinal,0x574
WdfDevStatePwrPolSleepingPowerDownNotProcessed,0x575
WdfDevStatePwrPolTimerExpiredWakeCapablePowerDownNotProcessed,0x576
WdfDevStatePwrPolTimerExpiredNoWakePowerDownNotProcessed,0x577
WdfDevStatePwrPolTimerExpiredNoWakePoweredDownDisableIdleTimer,0x578
WdfDevStatePwrPolStoppingWaitingForImplicitPowerDown,0x579
WdfDevStatePwrPolStoppingPoweringUp,0x57A
WdfDevStatePwrPolStoppingPoweringDown,0x57B
WdfDevStatePwrPolPowerUpForSystemSleepNotSeen,0x57C
WdfDevStatePwrPolWaitingArmedStoppingCancelUsbSS,0x57D
WdfDevStatePwrPolWaitingArmedWakeFailedCancelUsbSS,0x57E
WdfDevStatePwrPolWaitingArmedIoPresentCancelUsbSS,0x57F
WdfDevStatePwrPolWaitingArmedWakeSucceededCancelUsbSS,0x580
WdfDevStatePwrPolCancelingUsbSSForSystemSleep,0x581
WdfDevStatePwrPolStoppingD0CancelUsbSS,0x582
WdfDevStatePwrPolNull,0x583
}
9fad61e3-68ff-f42e-15fe-7a3fb252225e e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_POWER_DEVICE_STATE
{
WdfPowerDeviceInvalid,0x0
WdfPowerDeviceD0,0x1
WdfPowerDeviceD1,0x2
WdfPowerDeviceD2,0x3
WdfPowerDeviceD3,0x4
WdfPowerDeviceD3Final,0x5
WdfPowerDevicePrepareForHibernation,0x6
WdfPowerDeviceMaximum,0x7
}
#enumv _WDF_DEVICE_POWER_STATE
{
WdfDevStatePowerInvalid,0x0
WdfDevStatePowerObjectCreated,0x300
WdfDevStatePowerCheckDeviceType,0x301
WdfDevStatePowerCheckDeviceTypeNP,0x8302
WdfDevStatePowerCheckParentState,0x303
WdfDevStatePowerCheckParentStateNP,0x8304
WdfDevStatePowerEnablingWakeAtBus,0x305
WdfDevStatePowerEnablingWakeAtBusNP,0x8306
WdfDevStatePowerD0,0x307
WdfDevStatePowerD0NP,0x8308
WdfDevStatePowerD0BusWakeOwner,0x309
WdfDevStatePowerD0BusWakeOwnerNP,0x830A
WdfDevStatePowerD0ArmedForWake,0x30B
WdfDevStatePowerD0ArmedForWakeNP,0x830C
WdfDevStatePowerD0DisarmingWakeAtBus,0x30D
WdfDevStatePowerD0DisarmingWakeAtBusNP,0x830E
WdfDevStatePowerD0Starting,0x30F
WdfDevStatePowerD0StartingConnectInterrupt,0x310
WdfDevStatePowerD0StartingDmaEnable,0x311
WdfDevStatePowerD0StartingStartSelfManagedIo,0x312
WdfDevStatePowerDecideD0State,0x313
WdfDevStatePowerGotoD3Stopped,0x314
WdfDevStatePowerStopped,0x315
WdfDevStatePowerStartingCheckDeviceType,0x316
WdfDevStatePowerStartingChild,0x317
WdfDevStatePowerDxDisablingWakeAtBus,0x318
WdfDevStatePowerDxDisablingWakeAtBusNP,0x8319
WdfDevStatePowerGotoDx,0x31A
WdfDevStatePowerGotoDxNP,0x831B
WdfDevStatePowerGotoDxIoStopped,0x31C
WdfDevStatePowerGotoDxIoStoppedNP,0x831D
WdfDevStatePowerGotoDxNPFailed,0x831E
WdfDevStatePowerDx,0x31F
WdfDevStatePowerDxNP,0x8320
WdfDevStatePowerGotoDxArmedForWake,0x321
WdfDevStatePowerGotoDxArmedForWakeNP,0x8322
WdfDevStatePowerGotoDxIoStoppedArmedForWake,0x323
WdfDevStatePowerGotoDxIoStoppedArmedForWakeNP,0x8324
WdfDevStatePowerDxArmedForWake,0x325
WdfDevStatePowerDxArmedForWakeNP,0x8326
WdfDevStatePowerCheckParentStateArmedForWake,0x327
WdfDevStatePowerCheckParentStateArmedForWakeNP,0x8328
WdfDevStatePowerWaitForParentArmedForWake,0x329
WdfDevStatePowerWaitForParentArmedForWakeNP,0x832A
WdfDevStatePowerStartSelfManagedIo,0x32B
WdfDevStatePowerStartSelfManagedIoNP,0x832C
WdfDevStatePowerStartSelfManagedIoFailed,0x32D
WdfDevStatePowerStartSelfManagedIoFailedNP,0x832E
WdfDevStatePowerWaitForParent,0x32F
WdfDevStatePowerWaitForParentNP,0x8330
WdfDevStatePowerWakePending,0x331
WdfDevStatePowerWakePendingNP,0x8332
WdfDevStatePowerWaking,0x333
WdfDevStatePowerWakingNP,0x8334
WdfDevStatePowerWakingConnectInterrupt,0x335
WdfDevStatePowerWakingConnectInterruptNP,0x8336
WdfDevStatePowerWakingConnectInterruptFailed,0x337
WdfDevStatePowerWakingConnectInterruptFailedNP,0x8338
WdfDevStatePowerWakingDmaEnable,0x339
WdfDevStatePowerWakingDmaEnableNP,0x833A
WdfDevStatePowerWakingDmaEnableFailed,0x33B
WdfDevStatePowerWakingDmaEnableFailedNP,0x833C
WdfDevStatePowerReportPowerUpFailedDerefParent,0x33D
WdfDevStatePowerReportPowerUpFailed,0x33E
WdfDevStatePowerPowerFailedPowerDown,0x33F
WdfDevStatePowerReportPowerDownFailed,0x340
WdfDevStatePowerInitialConnectInterruptFailed,0x341
WdfDevStatePowerInitialDmaEnableFailed,0x342
WdfDevStatePowerInitialSelfManagedIoFailed,0x343
WdfDevStatePowerInitialPowerUpFailedDerefParent,0x344
WdfDevStatePowerInitialPowerUpFailed,0x345
WdfDevStatePowerDxStoppedDisarmWake,0x346
WdfDevStatePowerDxStoppedDisarmWakeNP,0x8347
WdfDevStatePowerGotoDxStoppedDisableInterruptNP,0x8348
WdfDevStatePowerGotoDxStopped,0x349
WdfDevStatePowerDxStopped,0x34A
WdfDevStatePowerGotoStopped,0x34B
WdfDevStatePowerStoppedCompleteDx,0x34C
WdfDevStatePowerDxStoppedDecideDxState,0x34D
WdfDevStatePowerDxStoppedArmForWake,0x34E
WdfDevStatePowerDxStoppedArmForWakeNP,0x834F
WdfDevStatePowerFinalPowerDownFailed,0x350
WdfDevStatePowerFinal,0x351
WdfDevStatePowerNull,0x352
}
#enumv FxPowerEvent
{
PowerEventInvalid,0x0
PowerD0,0x1
PowerDx,0x2
PowerWakeArrival,0x4
PowerWakeSucceeded,0x8
PowerWakeFailed,0x10
PowerWakeCanceled,0x20
PowerImplicitD0,0x40
PowerImplicitD3,0x80
PowerParentToD0,0x100
PowerMarkPageable,0x200
PowerMarkNonpageable,0x400
PowerCompleteD0,0x800
PowerCompleteDx,0x1000
PowerPriorityEventsMask,0x1900
PowerSingularEventMask,0x100
PowerEventMaximum,0xFF
}
950bd909-4e9f-8c00-5d83-948120fba76d e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv FxSelfManagedIoStates
{
FxSelfManagedIoInvalid,0x0
FxSelfManagedIoCreated,0x1
FxSelfManagedIoInit,0x2
FxSelfManagedIoInitFailed,0x3
FxSelfManagedIoStarted,0x4
FxSelfManagedIoSuspending,0x5
FxSelfManagedIoStopped,0x6
FxSelfManagedIoRestarting,0x7
FxSelfManagedIoFailed,0x8
FxSelfManagedIoFlushing,0x9
FxSelfManagedIoFlushed,0xA
FxSelfManagedIoCleanup,0xB
FxSelfManagedIoFinal,0xC
FxSelfManagedIoMax,0xD
}
47f60883-01f9-85a5-fc9d-1be7dcd4b026 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv FxObjectState
{
FxObjectStateInvalid,0x0
FxObjectStateCreated,0x1
FxObjectStateDisposed,0x2
FxObjectStateDisposingEarly,0x3
FxObjectStateDisposingDisposeChildren,0x4
FxObjectStateDeferedDisposing,0x5
FxObjectStateDeferedDeleting,0x6
FxObjectStateWaitingForEarlyDispose,0x7
FxObjectStateWaitingForParentDeleteAndDisposed,0x8
FxObjectStateDeletedDisposing,0x9
FxObjectStateDeletedAndDisposed,0xA
FxObjectStateDeferedDestroy,0xB
FxObjectStateDestroyed,0xC
FxObjectStateMaximum,0xD
}
#enumv FxObjectDroppedEvent
{
FxObjectDroppedEventAssignParentObject,0x0
FxObjectDroppedEventAddChildObjectInternal,0x1
FxObjectDroppedEventRemoveChildObjectInternal,0x2
FxObjectDroppedEventDeleteObject,0x3
FxObjectDroppedEventPerformEarlyDispose,0x4
FxObjectDroppedEventRemoveParentAssignment,0x5
FxObjectDroppedEventParentDeleteEvent,0x6
}
4a25592a-8cae-c35c-6091-a285ae14baaa e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\framework\wudf\objfre\i386\WUDFx.pdb
#enumv _WDF_EXECUTION_LEVEL
{
WdfExecutionLevelInvalid,0x0
WdfExecutionLevelInheritFromParent,0x1
WdfExecutionLevelPassive,0x2
WdfExecutionLevelDispatch,0x3
}
#enumv _WDF_SYNCHRONIZATION_SCOPE
{
WdfSynchronizationScopeInvalid,0x0
WdfSynchronizationScopeInheritFromParent,0x1
WdfSynchronizationScopeDevice,0x2
WdfSynchronizationScopeQueue,0x3
WdfSynchronizationScopeNone,0x4
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
d737543b-3120-76ca-26e9-b02a8f35f36c WUDFHost // SRC=WudfRemoteDispatcher.cpp MJ= MN=
#typev  WudfRemoteDispatcher_cpp282 13 "%0%!FUNC!: Canceling umirp %10!p! failed. %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfRemoteDispatcher::CancelIo
{
static_cast<CWudfIoIrp*>(pCanceledIrp), ItemPtr -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  WudfRemoteDispatcher_cpp266 12 "%0%!FUNC!: Canceling umirp %10!p! failed.Please note that remote target I/O cancellation has no effect on XP/Srv03. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfRemoteDispatcher::CancelIo
{
static_cast<CWudfIoIrp*>(pCanceledIrp), ItemPtr -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  WudfRemoteDispatcher_cpp117 11 "%0BindIoCompletionCallback failed, hr=%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_REMOTE_DISPATCHER FUNC=CWudfRemoteDispatcher::BindToHandle
{
hr, ItemHRESULT -- 10
}
#typev  WudfRemoteDispatcher_cpp81 10 "%0%!FUNC!: Could not create Remote dispatcher object, hr=%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_REMOTE_DISPATCHER FUNC=CWudfRemoteDispatcher::Create
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
469832e4-3784-254b-aea4-3257adb41a4c WUDFHost // SRC=WudfDevice.cpp MJ= MN=
#typev  WudfDevice_cpp63 10 "%0%!FUNC!:Memory allocation failure. Cannot create host process device object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDevice::_CreateAndInitialize
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
00671aa1-26d2-4ff7-7348-adc81ecca27c WUDFHost // SRC=WudfWin32Dispatcher.cpp MJ= MN=
#typev  WudfWin32Dispatcher_cpp59 10 "%0%!FUNC!: Could not create Win32 dispatcher object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfWin32Dispatcher::Create
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
42568c4e-26c2-e6fd-3e8f-c58c60852cba WUDFHost // SRC=WudfUsbDispatcher.cpp MJ= MN=
#typev  WudfUsbDispatcher_cpp93 11 "%0%!FUNC!: Could not create Win32 dispatcher object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_USB_DISPATCHER FUNC=CWudfUsbDispatcher::CreateUsbDispatcher
{
hr, ItemHRESULT -- 10
}
#typev  WudfUsbDispatcher_cpp78 10 "%0%!FUNC!: Error loading WINUSB.DLL - %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_USB_DISPATCHER FUNC=CWudfUsbDispatcher::CreateUsbDispatcher
{
hr, ItemHRESULT -- 10
}
#typev  WudfUsbDispatcher_cpp626 13 "%0WinUsb async operation failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfUsbDispatcher::SubmitUsbIo
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfUsbDispatcher_cpp185 12 "%0WinUsb_Initialize failed, error = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_USB_IOTARGET FUNC=CWudfUsbDispatcher::SubmitIo
{
dwErr, ItemWINERROR -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
4f9b3fe9-e3f9-4efc-3e84-5253065791ba WUDFHost // SRC=WudfDefaultDispatcher.cpp MJ= MN=
#typev  WudfDefaultDispatcher_cpp848 22 "%0NativeFlushFileBuffers failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoFlushBuffers
{
error, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp401 11 "%0%!FUNC!: Canceling request %10!p! failed %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfDefaultDispatcher::CancelIo
{
pCanceledIrp, ItemPtr -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  WudfDefaultDispatcher_cpp635 17 "%0ReadFile failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoRead
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp593 16 "%0RetrieveBuffers failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoRead
{
hr, ItemHRESULT -- 10
}
#typev  WudfDefaultDispatcher_cpp725 19 "%0WriteFile failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoWrite
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp684 18 "%0RetrieveBuffers failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoWrite
{
hr, ItemHRESULT -- 10
}
#typev  WudfDefaultDispatcher_cpp815 21 "%0DeviceIoControl failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoIoctl
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp776 20 "%0RetrieveBuffers failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoIoctl
{
hr, ItemHRESULT -- 10
}
#typev  WudfDefaultDispatcher_cpp945 25 "%0%10!s!InformationFile failed, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::SubmitQuerySetInformation
{
(Type == WdfRequestQueryInformation ? L'Query' : L'Set'), ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  WudfDefaultDispatcher_cpp923 24 "%0RetrieveBuffers failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::SubmitQuerySetInformation
{
hr, ItemHRESULT -- 10
}
#typev  WudfDefaultDispatcher_cpp899 23 "%0RetrieveBuffers failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::SubmitQuerySetInformation
{
hr, ItemHRESULT -- 10
}
#typev  WudfDefaultDispatcher_cpp526 15 "%0BindIoCompletionCallback failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp509 14 "%0CreateFile failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDefaultDispatcher_cpp474 13 "%0Calling win32 CreateFile with file name %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
pwszFileNameFullPath, ItemWString -- 10
}
#typev  WudfDefaultDispatcher_cpp452 12 "%0Allocating file name full path failed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::DoCreate
{
}
#typev  WudfDefaultDispatcher_cpp81 10 "%0%!FUNC!: Could not create Win32 dispatcher object, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfDefaultDispatcher::Create
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
200d0beb-aeeb-f837-3cfd-2a59d2119e0b WUDFHost // SRC=WudfIoDispatcher.cpp MJ= MN=
#typev  WudfIoDispatcher_cpp122 11 "%0%!FUNC!: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfIoDispatcher::QueryInterface
{
hr, ItemHRESULT -- 10
}
#typev  WudfIoDispatcher_cpp357 12 "%0%!FUNC!: Canceling request %10!p! failed %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=HandleCancelationDefault
{
pCanceledIrp, ItemPtr -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  WudfIoDispatcher_cpp73 10 "%0%!FUNC!: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfIoDispatcher::Create
{
hr, ItemHRESULT -- 10
}
#typev  WudfIoDispatcher_cpp398 13 "%0%!FUNC!: I/O Dispatcher _CancelRoutine invoked for !umirp 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_WIN32_DISPATCHER FUNC=CWudfIoDispatcher::_CancelRoutine
{
pIrp, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
91bed55e-0c9b-1689-6c05-5c8cbb319268 WUDFHost // SRC=WudfIrp.cpp MJ= MN=
#typev  WudfIrp_cpp222 12 "%0Global Irp list is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::Remove
{
pIrp, ItemPtr -- 10
}
#typev  WudfIrp_cpp203 11 "%0Irp not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::Remove
{
pIrp, ItemPtr -- 10
}
#typev  WudfIrp_cpp257 13 "%0%!FUNC!: Could not find IRP ID:0x%10!I64x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::MarkCancel
{
RequestToCancel, ItemLongLongX -- 10
}
#typev  WudfIrp_cpp310 15 "%0%!FUNC!: IRP ID:0x%10!I64x!, Cancel flag set, Fx cancel routine 0x%11!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::GetAndSetCancelRoutine
{
RequestToCancel, ItemLongLongX -- 10
pCancelRoutine, ItemPtr -- 11
}
#typev  WudfIrp_cpp304 14 "%0%!FUNC!: Could not find IRP ID:0x%10!I64x!. May have completed" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpTable::GetAndSetCancelRoutine
{
RequestToCancel, ItemLongLongX -- 10
}
#typev  WudfIrp_cpp346 16 "%0%!FUNC!: RevertToSelf failed, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_IO FUNC=CWudfIrp::RevertImpersonation
{
hr, ItemHRESULT -- 10
}
#typev  WudfIrp_cpp1124 17 "%0Copying output buffer for request id %10!d! (0x%11!I64x! bytes) failed with status %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfIoIrp::CompleteHandlerPreAlpcReply
{
m_AlpcReplyId, ItemLong -- 10
m_IoStatus.Information, ItemLongLongX -- 11
copyHr, ItemHRESULT -- 12
}
#typev  WudfIrp_cpp1455 21 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPnpIrp::ForwardToRedirector
{
}
#typev  WudfIrp_cpp1368 20 "%0%!FUNC!: Irp type 0x%10!x! (WITHOUT completion callbacks)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfPnpIrp::ForwardToRedirector
{
GetMinorFunction(), ItemLong -- 10
}
#typev  WudfIrp_cpp1343 19 "%0%!FUNC!: Irp type 0x%10!x! (WITH completion callbacks)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfPnpIrp::ForwardToRedirector
{
GetMinorFunction(), ItemLong -- 10
}
#typev  WudfIrp_cpp1294 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=CWudfPnpIrp::ForwardToRedirector
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
6c4de544-1155-47e9-d0e6-ed3cc4fb8895 WUDFHost // SRC=WudfDriverCreatedFile.cpp MJ= MN=
#typev  WudfDriverCreatedFile_cpp465 12 "%0%!FUNC!:Memory allocation failure. Cannot create host process file object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDriverCreatedFile::CreateAndInitialize
{
}
#typev  WudfDriverCreatedFile_cpp153 10 "%0Sending Close irp for driver created file %10!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDriverCreatedFile::SendCloseIrp
{
this, ItemPtr -- 10
}
#typev  WudfDriverCreatedFile_cpp425 11 "%0Driver created file %10!p! has I/Os queued, deferring sending Close irp" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDriverCreatedFile::Close
{
this, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
2ce62dd0-d39b-d89a-695d-dbd1304bc299 WUDFHost // SRC=WudfFileObj.cpp MJ= MN=
#typev  WudfFileObj_cpp233 13 "%0%!FUNC!:Memory allocation failure, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfFileObj::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfFileObj_cpp214 12 "%0%!FUNC!:File name too long, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfFileObj::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfFileObj_cpp194 11 "%0%!FUNC!:Memory allocation failure. Cannot allocate framework fileobject array" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfFileObj::Initialize
{
}
#typev  WudfFileObj_cpp105 10 "%0%!FUNC!:Memory allocation failure. Cannot create host process file object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfFileObj::CreateAndInitialize
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
8db21bbd-1c6a-4175-6845-9500d1b26399 WUDFHost // SRC=WudfIoStack.cpp MJ= MN=
#typev  WudfIoStack_cpp83 10 "%0hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIoStack::Initialize
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
bf847eef-4eab-4613-51e5-27eb538a94e9 WUDFHost // SRC=wudfloader.cpp MJ= MN=
#typev  wudfloader_cpp608 18 "%0Global module table is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleTable::Remove
{
pModInfo, ItemPtr -- 10
}
#typev  wudfloader_cpp590 17 "%0Module not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleTable::Remove
{
pModInfo, ItemPtr -- 10
}
#typev  wudfloader_cpp183 13 "%0Malformed module image path %10!s!, returning hr: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleInfo::_GetModuleNameFromImagePath
{
ModuleImagePath, ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfloader_cpp133 12 "%0Malformed module image path %10!s!, returning hr: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleInfo::_GetModuleNameFromImagePath
{
ModuleImagePath, ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfloader_cpp113 11 "%0Moudle image path is blank. Returning hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleInfo::_GetModuleNameFromImagePath
{
hr, ItemHRESULT -- 10
}
#typev  wudfloader_cpp101 10 "%0Obtaining module image path length failed, potentially module name is too long. hr: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfModuleInfo::_GetModuleNameFromImagePath
{
hr, ItemHRESULT -- 10
}
#typev  wudfloader_cpp298 16 "%0Failed to copy module name %10!s!, hr: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleInfo::Initialize
{
Name, ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfloader_cpp286 15 "%0Failed to allocate buffer for module name, returning %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleInfo::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  wudfloader_cpp268 14 "%0Obtaining length of module name failed, possibly due to name being too long or not being null terminated, max allowable length: %10!d!, hr: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleInfo::Initialize
{
MAX_NAME_LEN, ItemLong -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfloader_cpp1084 27 "%0%!FUNC!: version mismatch. Component version = %10!d!.%11!d!, Max allowable version = %12!d!.%13!d! hr = %14!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
umdfVersion->MajorNumber, ItemLong -- 10
umdfVersion->MinorNumber, ItemLong -- 11
MaxAllowableVersion.MajorNumber, ItemLong -- 12
MaxAllowableVersion.MinorNumber, ItemLong -- 13
hr, ItemHRESULT -- 14
}
#typev  wudfloader_cpp1205 31 "%0%!FUNC!: Your driver is not compatible with this framework.  To fix: recompile using the latest framework headers." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
}
#typev  wudfloader_cpp1213 32 "%0%!FUNC!:Failed to load driver binary %10!s! with clsid %11!s!. hr = %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
&ClassId, ItemGuid -- 11
hr, ItemHRESULT -- 12
}
#typev  wudfloader_cpp1148 30 "%0Error %10!s! - Could not create requested interface from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
hr, ItemHRESULT -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp1130 29 "%0Error %10!s! - Could not get class factory interface from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
hr, ItemHRESULT -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp1109 28 "%0Error %10!s! - Could not get DllGetClassObject function from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
error, ItemWINERROR -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp1064 26 "%0Error %10!s! - Could not get umdf version from %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
error, ItemWINERROR -- 10
canonicalFileName, ItemWString -- 11
}
#typev  wudfloader_cpp1026 25 "%0Load module %10!s! failed - error %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
error, ItemWINERROR -- 11
}
#typev  wudfloader_cpp1015 24 "%0Loading module %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
}
#typev  wudfloader_cpp988 23 "%0Error - driver path %10!s! is not located under required driver root %11!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
canonicalFileName, ItemWString -- 10
g_wszDriverRootPath, ItemWString -- 11
}
#typev  wudfloader_cpp963 22 "%0Error canonicalizing driver path %10!s!: %11!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstance
{
LibraryFileName, ItemWString -- 10
hr, ItemHRESULT -- 11
}
#typev  wudfloader_cpp847 21 "%0Failed to allocate CWudfModuleInfo" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadComponentAndCreateInstanceEx
{
}
#typev  wudfloader_cpp744 20 "%0%!FUNC!:Failed to load driver binary %10!s! with clsid %11!s!. hr = %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadFrameworkAndDriver
{
pcwszDriverFileName, ItemWString -- 10
&clsidDriver, ItemGuid -- 11
hr, ItemHRESULT -- 12
}
#typev  wudfloader_cpp711 19 "%0%!FUNC!:Failed to load framework binary %10!s!. hr = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfModuleTable::LoadFrameworkAndDriver
{
pcwszFrameworkFileName, ItemWString -- 10
hr, ItemHRESULT -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
d9844565-5331-a630-12a3-9841d10fcc1f WUDFHost // SRC=WudfDevStack.cpp MJ= MN=
#typev  WudfDevStack_cpp2269 30 "%0%!FUNC!: Memory allocation failure" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::PostEvent
{
}
#typev  WudfDevStack_cpp2970 47 "%0%!FUNC!: Failed to set Value" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWudfDeviceStack::SaveIdleState
{
}
#typev  WudfDevStack_cpp466 11 "%0AllocateEvent failed, error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::ForwardSynchoronously
{
dwErr, ItemWINERROR -- 10
}
#typev  WudfDevStack_cpp1693 28 "%0Creating I/O Dispatcher failed : 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfDeviceStack::LoadIoDispatcher
{
hr, ItemLong -- 10
}
#typev  WudfDevStack_cpp1683 27 "%0Unsupported I/O Dispatcher specified : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CWudfDeviceStack::LoadIoDispatcher
{
m_pwszIoDispatcher, ItemWString -- 10
}
#typev  WudfDevStack_cpp3172 48 "%0%!FUNC!: Cannot allocate Target Device Registration" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::RegisterTargetDeviceNotification
{
}
#typev  WudfDevStack_cpp3680 50 "%0Global device stack table is empty:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfDevStackTable::Remove
{
pDevStack, ItemPtr -- 10
}
#typev  WudfDevStack_cpp3660 49 "%0Device Stack not in list:0x%10!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfDevStackTable::Remove
{
pDevStack, ItemPtr -- 10
}
#typev  WudfDevStack_cpp4711 80 "%0%!FUNC!: Error opening diagnostic key - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::WasTransferModeConflictEventAlreadyLogged
{
err, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp184 10 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Create
{
}
#typev  WudfDevStack_cpp1619 26 "%0%!FUNC!:Cannot open kernel control object: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1593 25 "%0%!FUNC! hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1576 24 "%0%!FUNC!: Unable to copy control device name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1556 23 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1539 22 "%0%!FUNC!:Unable to copy PDO name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1526 21 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1501 20 "%0%!FUNC!:Trailing name string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1488 19 "%0%!FUNC!:Unable to copy kernel device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1476 18 "%0%!FUNC!:Unable to copy device path name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1463 17 "%0%!FUNC!:Memory allocation failure. Cannot allocate memory for kernel device name" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1439 16 "%0%!FUNC!:Kernel device Name string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1426 15 "%0%!FUNC!:Unable to copy PDO name, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp1413 14 "%0%!FUNC!:Memory allocation failure. Cannot allocate device stack object" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
}
#typev  WudfDevStack_cpp1397 13 "%0%!FUNC!:PDO Name string too long or badly formed path. Invalid configuration %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::Initialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2218 29 "%0%!FUNC!: Cannot allocate set device interface message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::AllocateSetDeviceInterfaceMsg
{
}
#typev  WudfDevStack_cpp2551 31 "%0%!FUNC!: Invalid parameter for symbolic link, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2765 46 "%0%!FUNC!: Out of memory, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2739 44 "%0%!FUNC!: Problem, while copying the reference string, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2716 42 "%0%!FUNC!: Overflow, while copying the symbolic link length, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2703 41 "%0%!FUNC!: Problem, while copying the symbolic link, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2667 39 "%0%!FUNC!: Overflow, while calculating the size of the internal structure, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2653 38 "%0%!FUNC!: Overflow, while adding the sizes of the symbolic link and the reference string, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2638 37 "%0%!FUNC!: Overflow, while processing the size of the reference string, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2629 36 "%0%!FUNC!: Overflow, while processing the size of the reference string, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2612 35 "%0%!FUNC!: Overflow, while processing the size of the symbolic link, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2595 34 "%0%!FUNC!: Reference string is not null terminated, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2577 33 "%0%!FUNC!: Invalid parameter for reference string, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp2564 32 "%0%!FUNC!: Symbolic link is not null terminated, hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CWudfDeviceStack::CreateSymbolicLink
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp3822 52 "%0Error %10!s! assigning device list in environment block" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfDevStackTable::UpdateEnvironmentBlock
{
GetLastError(), ItemWINERROR -- 10
}
#typev  WudfDevStack_cpp3784 51 "%0Error allocating %10!d! character string to hold device interface ids.  Host's environment block will not contain a full set of running devices." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfDevStackTable::UpdateEnvironmentBlock
{
(ULONG) totalLength, ItemLong -- 10
}
#typev  WudfDevStack_cpp4300 75 "%0%!FUNC!: Failed to send msg to reflector %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp4273 74 "%0%!FUNC!: Error creating secondary string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp4250 73 "%0%!FUNC!: Error creating main string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp4205 70 "%0%!FUNC!: Invalid value for Flags" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp4155 68 "%0%!FUNC!: Error copying reference string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp4124 66 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp4108 65 "%0%!FUNC!: Error calculating struct size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp4093 64 "%0%!FUNC!: Error calculating struct size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp4081 63 "%0%!FUNC!: Invalid device interface length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp4066 62 "%0%!FUNC!: Invalid device interface length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp4038 61 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp4024 60 "%0%!FUNC!: Error calculating struct size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp4009 59 "%0%!FUNC!: Error calculating struct size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp3997 58 "%0%!FUNC!: Invalid full subkey string length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp3963 57 "%0%!FUNC!: Invalid length for secondary string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp3934 56 "%0%!FUNC!: Invalid length for main string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_GENERAL FUNC=CWudfDeviceStack::CreateRegistryEntry
{
hr, ItemHRESULT -- 10
}
#typev  WudfDevStack_cpp3919 55 "%0%!FUNC!: Invalid value for key name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp3886 54 "%0%!FUNC!: Invalid value for RootSpecifier->RootClass" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp3877 53 "%0%!FUNC!: The value of DesiredAccess is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=FX_TRACE_DDI FUNC=CWudfDeviceStack::CreateRegistryEntry
{
}
#typev  WudfDevStack_cpp4418 77 "%0%!FUNC!: Incompatible preferred transfer mode for device stack.  Device start will fail.  Previous mode for RW/Ioctl was (%10!d!,%11!d!).  New incompatible mode is (%12!d!/%13!d!) requested by driver %14!s! (level %15!d!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::VerifyAndAssignPreferredTransferMode
{
m_RWPreferredTransferMode, ItemLong -- 10
m_IoctlPreferredTransferMode, ItemLong -- 11
newReadWritePTM, ItemLong -- 12
newIoctlPTM, ItemLong -- 13
deviceInfo->pDriverModInfo->m_ImagePath, ItemWString -- 14
DeviceStackIndex, ItemLong -- 15
}
#typev  WudfDevStack_cpp4467 79 "%0%!FUNC!: Device stack Ioctl i/o type preference changed to %10!d! (from %11!d!) by driver %12!s! (level %13!d!)" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::VerifyAndAssignPreferredTransferMode
{
newIoctlPTM, ItemLong -- 10
m_IoctlPreferredTransferMode, ItemLong -- 11
deviceInfo->pDriverModInfo->m_ImagePath, ItemWString -- 12
DeviceStackIndex, ItemLong -- 13
}
#typev  WudfDevStack_cpp4451 78 "%0%!FUNC!: Device stack Read/Write i/o type preference changed to %10!d! (from %11!d!) by driver %12!s! (level %13!d!)" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::VerifyAndAssignPreferredTransferMode
{
newReadWritePTM, ItemLong -- 10
m_RWPreferredTransferMode, ItemLong -- 11
deviceInfo->pDriverModInfo->m_ImagePath, ItemWString -- 12
DeviceStackIndex, ItemLong -- 13
}
#typev  WudfDevStack_cpp4390 76 "%0%!FUNC!:Device stack retrieval mode reduced to %10!d! by driver %11!s! (level %12!d!)" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfDeviceStack::VerifyAndAssignPreferredTransferMode
{
retrievalMode, ItemLong -- 10
deviceInfo->pDriverModInfo->m_ImagePath, ItemWString -- 11
DeviceStackIndex, ItemLong -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
a9994e99-950b-03be-86f8-abdd0ba489e4 WUDFHost // SRC=WudfIrp.h MJ= MN=
#typev  WudfIrp_h1038 11 "%0%!FUNC!:Memory allocation failure %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfIoIrp,IWudfIoIrp,_WUDFMESSAGE_IO_HEADER *,_WUDFMESSAGE_REPLY_HEADER *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfIrp_h1010 10 "%0hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfIoIrp,IWudfIoIrp,_WUDFMESSAGE_IO_HEADER *,_WUDFMESSAGE_REPLY_HEADER *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
d9844565-5331-a630-12a3-9841d10fcc1f WUDFHost // SRC=WudfDevStack.cpp MJ= MN=
#typev  WudfDevStack_cpp989 12 "%0%!FUNC!: BindIoCompletionCallback failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_DISPATCHER FUNC=CWudfDeviceStack::CreateWdfFileForOpenHandle
{
dwErr, ItemWINERROR -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
87825377-fcbd-c799-3d83-9c45d559032b WUDFHost // SRC=wudflpc.cpp MJ= MN=
#typev  wudflpc_cpp285 17 "%0%!FUNC!: Abnormal host shutdown: There is an active device stack in the host" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::PortIsClosed
{
}
#typev  wudflpc_cpp2559 63 "%0%!FUNC!: Could not get device hardware id?? %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndPropertiesHelper
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp2536 62 "%0%!FUNC!: instance id = %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndPropertiesHelper
{
instanceID, ItemWString -- 10
}
#typev  wudflpc_cpp2512 61 "%0%!FUNC!: Out of memory" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndPropertiesHelper
{
}
#typev  wudflpc_cpp2489 60 "%0%!FUNC!: SetupDiGetDeviceInstance failed %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceHwKeyAndPropertiesHelper
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp2481 59 "%0%!FUNC!: SetupDiGetDeviceInstance misbehaving?? %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceHwKeyAndPropertiesHelper
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp3003 69 "%0%!FUNC!: Thread exiting" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=LpcWorkerThreadThunk
{
}
#typev  wudflpc_cpp2991 68 "%0%!FUNC!: Cannot initialize COM runtime: 0x%10!X!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=LpcWorkerThreadThunk
{
hr, ItemLong -- 10
}
#typev  wudflpc_cpp3184 74 "%0%!FUNC! UMDF does not recognize safe boot mode %10!d!.  Driver %11!s! will not be loaded." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::IsDriverEnabledInSafeMode
{
(ULONG) BootMode, ItemLong -- 10
DriverName, ItemWString -- 11
}
#typev  wudflpc_cpp3267 78 "%0%!FUNC!: Driver %10!s! is enabled for safe-mode %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::IsDriverEnabledInSafeMode
{
DriverName, ItemWString -- 10
BootMode, ItemEnum(_WUDF_BOOT_MODE) -- 11
}
#typev  wudflpc_cpp3249 77 "%0%!FUNC!: Error opening SafeBoot key %10!s!\%11!s! - %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::IsDriverEnabledInSafeMode
{
safeBootRootPath, ItemWString -- 10
DriverName, ItemWString -- 11
error, ItemWINERROR -- 12
}
#typev  wudflpc_cpp3237 76 "%0%!FUNC!: Driver %10!s! is not listed for SafeBoot mode %11!s!.  The driver will not be loaded and the device stack will not start." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::IsDriverEnabledInSafeMode
{
DriverName, ItemWString -- 10
BootMode, ItemEnum(_WUDF_BOOT_MODE) -- 11
}
#typev  wudflpc_cpp3206 75 "%0%!FUNC!: Error opening SafeBoot key HKLM\%10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::IsDriverEnabledInSafeMode
{
safeBootRootPath, ItemWString -- 10
error, ItemWINERROR -- 11
}
#typev  wudflpc_cpp1654 38 "%0%!FUNC!: Main thread exiting. Win32 status:0x%10!x!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::Run
{
status, ItemLong -- 10
}
#typev  wudflpc_cpp1647 37 "%0%!FUNC!: Event wait failed: Win32 err: %10!d!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Run
{
status, ItemLong -- 10
}
#typev  wudflpc_cpp1853 41 "%0%!FUNC!: unable to allocate memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetStringFromRegistry
{
}
#typev  wudflpc_cpp1841 40 "%0%!FUNC!: Invalid registry configuration: %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetStringFromRegistry
{
type, ItemLong -- 10
}
#typev  wudflpc_cpp3083 73 "%0%!FUNC!:failed to create LPC worker thread, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::CreateLPCAndThreads
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp3065 72 "%0%!FUNC!:Failed to get LPC worker object for system messages, NTSTATUS:0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::CreateLPCAndThreads
{
ntStatus, ItemLong -- 10
}
#typev  wudflpc_cpp3049 71 "%0Fail to get LPC object for system messages, NTSTATUS:0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::CreateLPCAndThreads
{
ntStatus, ItemLong -- 10
}
#typev  wudflpc_cpp3034 70 "%0Out of memory, not able to allcoate array for thread handles" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::CreateLPCAndThreads
{
}
#typev  wudflpc_cpp258 16 "%0%!FUNC!:Unable to connect to create system event server port %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_SysEventName, ItemWString -- 10
}
#typev  wudflpc_cpp236 15 "%0%!FUNC!: Could not create event. %10!s!=, %11!s!=" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
error, ItemWINERROR -- 10
hr, ItemHRESULT -- 11
}
#typev  wudflpc_cpp216 14 "%0%!FUNC!:Unable to connect to create non-state-changing event server port %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_NonStateChangingEventName, ItemWString -- 10
}
#typev  wudflpc_cpp194 13 "%0%!FUNC!:Unable to connect to create iocancelevent server port %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_IoCancelEventName, ItemWString -- 10
}
#typev  wudflpc_cpp171 12 "%0%!FUNC!:Unable to connect to create ioevent server port %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_IoEventName, ItemWString -- 10
}
#typev  wudflpc_cpp148 11 "%0%!FUNC! ConvertStringSidToSid(%10!s!) failed %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Initialize
{
pParams->m_ServiceSid, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  wudflpc_cpp2210 53 "%0%!FUNC!:String operation failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp2192 52 "%0%!FUNC!:Out of memory. Not able to copy driver configuration path. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
err, ItemHRESULT -- 10
}
#typev  wudflpc_cpp2164 51 "%0Configuration error: Failed to read %10!s! value for driver %11!s!, err %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
WDF_DRIVER_IMAGE_PATH, ItemWString -- 10
driverName, ItemWString -- 11
err, ItemLong -- 12
}
#typev  wudflpc_cpp2138 50 "%0Configuration error: Invalid CLSID %10!s! for %11!s!, hr=0x%12!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
pwszClsid, ItemWString -- 10
driverName, ItemWString -- 11
hr, ItemLong -- 12
}
#typev  wudflpc_cpp2119 49 "%0Configuration error: CLSID not a REG_SZ type for %10!s!, Win32 err=%11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
driverName, ItemWString -- 10
err, ItemLong -- 11
}
#typev  wudflpc_cpp2102 48 "%0Unable to read CLSID from registry for %10!s!, err=%11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
driverName, ItemWString -- 10
err, ItemLong -- 11
}
#typev  wudflpc_cpp2079 47 "%0Unable to open driver Service key %10!s! : %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
driverName, ItemWString -- 10
err, ItemWINERROR -- 11
}
#typev  wudflpc_cpp2056 46 "%0Unable to load driver %10!s! in boot mode %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
driverName, ItemWString -- 10
g_WudfHostGlobals.GetUmdfBootMode(), ItemEnum(_WUDF_BOOT_MODE) -- 11
}
#typev  wudflpc_cpp2013 45 "%0Invalid configuration. DriverList key is empty." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
}
#typev  wudflpc_cpp1990 44 "%0Invalid configuration. Registry entry %10!s! could not be read, err %11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
WDF_DRIVER_LIST, ItemWString -- 10
err, ItemLong -- 11
}
#typev  wudflpc_cpp1947 43 "%0Unable to open service root key : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp1927 42 "%0%!FUNC!: RegOpenKeyEx %10!s! failed: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::GetDeviceStackConfiguration
{
WUDF_SUB_KEY, ItemWString -- 10
err, ItemWINERROR -- 11
}
#typev  wudflpc_cpp2429 58 "%0%!FUNC!: Could not find an correct match for PDO. Error=%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndProperties
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp2416 57 "%0%!FUNC!: GetDeviceHwKeyHelper failed, PDO name. Error=%10!s!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndProperties
{
err, ItemWINERROR -- 10
pwszPdoName, ItemWString -- 11
}
#typev  wudflpc_cpp2358 56 "%0%!FUNC!: SetupDiGetClassDevs failed Error=%10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndProperties
{
err, ItemWINERROR -- 10
}
#typev  wudflpc_cpp2332 55 "%0%!FUNC!: Memory allocation failure. hr = 0x%10!x!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndProperties
{
hr, ItemLong -- 10
}
#typev  wudflpc_cpp2315 54 "%0%!FUNC!: Invalid Pdo name. hr = 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_INIT FUNC=CLpcNotification::GetDeviceHwKeyAndProperties
{
hr, ItemLong -- 10
}
#typev  wudflpc_cpp2666 65 "%0%!FUNC!: Invalid IRP! (mj/mn)=(0x%10!x!, 0x%11!x!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::ProcessPnpPowerIrp
{
pMsg->MajorCode, ItemLong -- 10
pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp2620 64 "%0%!FUNC!: Received IRP (major/minor) = (0x%10!x!/0x%11!x!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::ProcessPnpPowerIrp
{
(ULONG)pMsg->MajorCode, ItemLong -- 10
(ULONG)pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp1687 39 "%0%!FUNC!: Error loading SetupApi.dll - %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_LOADER FUNC=CLpcNotification::InitializeDeviceStack
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
a9994e99-950b-03be-86f8-abdd0ba489e4 WUDFHost // SRC=WudfIrp.h MJ= MN=
#typev  WudfIrp_h1038 11 "%0%!FUNC!:Memory allocation failure %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfPnpIrp,IWudfPnpIrp,_WUDFMESSAGE_IRP *,_WUDFMESSAGE_PNP_REPLY_ALL *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
#typev  WudfIrp_h1010 10 "%0hr = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CWudfIrpT<CWudfPnpIrp,IWudfPnpIrp,_WUDFMESSAGE_IRP *,_WUDFMESSAGE_PNP_REPLY_ALL *>::CreateAndInitialize
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
87825377-fcbd-c799-3d83-9c45d559032b WUDFHost // SRC=wudflpc.cpp MJ= MN=
#typev  wudflpc_cpp1629 36 "%0Leaving %!FUNC!..." //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp1477 32 "%0%!FUNC!: LPC message(0x%10!x!) format is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp1519 33 "%0%!FUNC!: pnp message: WudfMsg_ExitProcess" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp1584 34 "%0%!FUNC!: Failing WmiPowerData Message - error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_PNP FUNC=CLpcNotification::Message
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  wudflpc_cpp1605 35 "%0%!FUNC!: pnp message: WudfMsg_UNKNOWN" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp1406 31 "%0%!FUNC!: LPC message(0x%10!x!) format is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp1270 30 "%0%!FUNC!: LPC message(0x%10!x!) format is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp1013 28 "%0%!FUNC!: Builidng I/O Irp (%10!s!) failed: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
header->Message, ItemEnum(_WUDFMESSAGE) -- 10
hr, ItemHRESULT -- 11
}
#typev  wudflpc_cpp995 27 "%0%!FUNC!: Message %10!d! for host file obj:0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
pIoMsg->Header.Message, ItemLong -- 10
pFileObj, ItemPtr -- 11
}
#typev  wudflpc_cpp855 26 "%0%!FUNC!: Builidng create Irp failed: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp838 25 "%0%!FUNC!: WudfMsg_CREATE for host file obj:0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
pHostFileObj, ItemPtr -- 10
}
#typev  wudflpc_cpp815 24 "%0%!FUNC!: LPC message(0x%10!x!) format is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp803 23 "%0%!FUNC!: Create message %10!d! with host related file obj:0x%11!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_IO FUNC=CLpcNotification::Message
{
pCreateMsg->Header.Message, ItemLong -- 10
pRelatedFileObj, ItemPtr -- 11
}
#typev  wudflpc_cpp1103 29 "%0%!FUNC!: Completion irp (code 0x%10!x!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
pPnpIrp->GetMinorFunction(), ItemLong -- 10
}
#typev  wudflpc_cpp579 19 "%0%!FUNC!: Failing Create Device Stack - error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_PNP FUNC=CLpcNotification::Message
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp761 22 "%0%!FUNC!: Failing Add Device - error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_PNP FUNC=CLpcNotification::Message
{
hr, ItemHRESULT -- 10
}
#typev  wudflpc_cpp671 21 "%0%!FUNC!:Failed Add Device, could not preallocate PnP UM irp" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_PNP FUNC=CLpcNotification::Message
{
}
#typev  wudflpc_cpp617 20 "%0%!FUNC!: LPC message(0x%10!x!) format is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp539 18 "%0%!FUNC!: Host process receives message: 0x%10!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::Message
{
header->Message, ItemLong -- 10
}
#typev  wudflpc_cpp2926 67 "%0%!FUNC!:  PnP UM irp allocation failed((mj/mn)=(0x%10!x!, 0x%11!x!). Using fast reply" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::WudfPnpHandler
{
pMsg->MajorCode, ItemLong -- 10
pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp2829 66 "%0%!FUNC!: Using preallocted IRP ((mj/mn)=(0x%10!x!, 0x%11!x!)" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::WudfPnpHandler
{
pMsg->MajorCode, ItemLong -- 10
pMsg->MinorCode, ItemLong -- 11
}
#typev  wudflpc_cpp92 10 "%0%!FUNC! Not able to allocate CLpcNotification object %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=CLpcNotification::CreateInstance
{
hr, ItemHRESULT -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
58267e06-4c6c-0ea7-4c7c-9f706d4be41e WUDFHost // SRC=wudfmain.cpp MJ= MN=
#typev  wudfmain_cpp205 10 "%0%!FUNC!: Exit: argc:%10!d!, %11!s! %12!s! %13!s! %14!s! %15!s! %16!s! %17!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfCmdLineParams::CWudfCmdLineParams
{
argc, ItemLong -- 10
m_HostProcessGuid, ItemWString -- 11
m_IoEventName, ItemWString -- 12
m_SysEventName, ItemWString -- 13
m_IoCancelEventName, ItemWString -- 14
m_NonStateChangingEventName, ItemWString -- 15
m_ServiceSid, ItemWString -- 16
m_LifetimeId, ItemWString -- 17
}
#typev  wudfmain_cpp292 14 "%0Host setting %10!s! not found" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=GetDwordHostSetting
{
ValueName, ItemWString -- 10
}
#typev  wudfmain_cpp268 13 "%0unable to open reg key %10!s!\%11!s! %12!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=GetDwordHostSetting
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
RegistrySubPath, ItemWString -- 11
result, ItemWINERROR -- 12
}
#typev  wudfmain_cpp255 12 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=GetDwordHostSetting
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  wudfmain_cpp235 11 "%0RegistrySubPath is NULL" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_GENERAL FUNC=GetDwordHostSetting
{
}
#typev  wudfmain_cpp373 16 "%0NOT waiting for debugger connection at host process start" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=WdfHostProcDbgBreakOnStart
{
}
#typev  wudfmain_cpp361 15 "%0%!FUNC!: Host process waiting for %10!s! debugger to connect, Timeout:%11!d! secs" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=HOSTPROC_TRACE_INIT FUNC=WdfHostProcDbgBreakOnStart
{
(WudfUserDebugger == DbgBreakOnStartSettings.DebuggerType) ? L'user-mode' : L'user or kernel-mode', ItemWString -- 10
DbgBreakOnStartSettings.Timeout, ItemLong -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
8961212a-0a16-744e-8224-6d3e578f7e47 WUDFHost // SRC=WudfHostGlobals.h MJ= MN=
#typev  WudfHostGlobals_h100 10 "%0System boot mode is %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=CWudfHostGlobals::Initialize
{
m_BootMode, ItemEnum(_WUDF_BOOT_MODE) -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
// PDB:  Last Updated :2010-2-9:4:5:28:784 (UTC) [tracepdb]
58267e06-4c6c-0ea7-4c7c-9f706d4be41e WUDFHost // SRC=wudfmain.cpp MJ= MN=
#typev  wudfmain_cpp799 24 "%0%!FUNC!: Leaving host process" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
}
#typev  wudfmain_cpp680 23 "%0%!FUNC!: Cannot initialize COM runtime: 0x%10!X!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=wmain
{
hr, ItemLong -- 10
}
#typev  wudfmain_cpp656 22 "%0%!FUNC!: Cannot allocate space to hold driver root - %10!d!." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_GENERAL FUNC=wmain
{
err, ItemLong -- 10
}
#typev  wudfmain_cpp617 21 "%0Failed to get LPC interface %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
hr, ItemHRESULT -- 10
}
#typev  wudfmain_cpp564 20 "%0%!FUNC!: Error %10!s! building root directory name." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
hr, ItemHRESULT -- 10
}
#typev  wudfmain_cpp544 19 "%0%!FUNC!: Failed to get windows directory name: %10!s!." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
err, ItemWINERROR -- 10
}
#typev  wudfmain_cpp522 18 "%0Error converting Lifetime ID %10!s! to guid: %11!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
params.m_LifetimeId, ItemWString -- 10
rpcStatus, ItemWINERROR -- 11
}
#typev  wudfmain_cpp470 17 "%0%!FUNC!: Entering host process" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=HOSTPROC_TRACE_INIT FUNC=wmain
{
}
87825377-fcbd-c799-3d83-9c45d559032b e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
#enumv _WUDF_BOOT_MODE
{
WUDF_BOOT_MODE_NORMAL,0x0
WUDF_BOOT_MODE_SAFE_MODE,0x1
WUDF_BOOT_MODE_SAFE_MODE_WITH_NETWORKING,0x2
}
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_CREATE_DEVICE_STACK,0x3
WudfMsg_ADD_DEVICE,0x4
WudfMsg_CREATE,0x5
WudfMsg_CLOSE,0x6
WudfMsg_CLEANUP,0x7
WudfMsg_READ,0x8
WudfMsg_WRITE,0x9
WudfMsg_IOCONTROL,0xA
WudfMsg_FLUSH,0xB
WudfMsg_QUERY_INFORMATION_FILE,0xC
WudfMsg_SET_INFORMATION_FILE,0xD
WudfMsg_Cancel,0xE
WudfMsg_POWER_IRP_COMPLETE,0xF
WudfMsg_USB_SS_EVENT,0x10
WudfMsg_CLOSE_DEVICE_STACK,0x11
WudfMsg_REMOTE_INTERFACE_ARRIVAL,0x12
WudfMsg_REMOTE_INTERFACE_REMOVAL,0x13
WudfMsg_TARGET_DEVICE_NOTIFICATION,0x14
WudfMsg_TRANSPORT_QUERY_ID,0x15
WudfMsg_FramworkMax,0x16
WudfMsg_ExitProcess,0x17
WdfProcMgmt_Message_Reserved,0x18
WdfProcMgmt_Message_ControlObjectName,0x19
WdfProcMgmt_Message_QueryProcess,0x1A
WdfProcMgmt_Message_OpenProcess,0x1B
WdfProcMgmt_Message_CloseProcess,0x1C
WudfMsg_Connect,0x1D
WudfMsg_WMI_POWER_DATA,0x1E
WudfMsg_Max,0x1F
}
8961212a-0a16-744e-8224-6d3e578f7e47 e:\5359.obj.x86fre\drivers\wdf\umdf\driverhost\wudfhost\objfre\i386\WUDFHost.pdb
#enumv _WUDF_BOOT_MODE
{
WUDF_BOOT_MODE_NORMAL,0x0
WUDF_BOOT_MODE_SAFE_MODE,0x1
WUDF_BOOT_MODE_SAFE_MODE_WITH_NETWORKING,0x2
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
3e5741aa-1ce4-f8f8-ac32-c445bc9c5246 WUDFRd // SRC=support.cpp MJ= MN=
#typev  support_cpp45 10 "%0%!FUNC!: KeWaitForSingleObjectFailed with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdEventBasedLock::AcquireLockInUserContext
{
status, ItemNTSTATUS -- 10
}
#typev  support_cpp126 11 "%0%!FUNC!: KeWaitForSingleObjectFailed with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdEventBasedLock::AcquireLockInSystemContext
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
45f98ceb-d5c4-70f9-7af5-06067b81d760 WUDFRd // SRC=wmi.cpp MJ= MN=
#typev  wmi_cpp82 10 "%0%!FUNC!: WMI registration failed devobj %10!p! status %11!s! " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdWmiRegister
{
m_FdoDevice->DeviceObject(), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  wmi_cpp137 11 "%0%!FUNC!: IoWMIRegistrationControl failed Devobj %10!p! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdWmiDeregister
{
m_FdoDevice->DeviceObject(), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  wmi_cpp185 12 "%0%!FUNC!: IoWMIRegistrationControl Devobj %10!p! failed %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdWmiRegisterUpdatedGuids
{
m_FdoDevice->DeviceObject(), ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  wmi_cpp342 13 "%0%!FUNC!: QueryWmiRegInfo devobj %10!p!, S0Idle Instance %11!d!, SxWake Instance %12!d!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdQueryWmiRegInfo
{
rdFdo->DeviceObject(), ItemPtr -- 10
This->m_WmiLibInfo.GuidList[GuidListIndexForS0Idle].InstanceCount, ItemLong -- 11
This->m_WmiLibInfo.GuidList[GuidListIndexForSxWake].InstanceCount, ItemLong -- 12
}
#typev  wmi_cpp837 27 "%0%!FUNC!: unable to create SetWmiPowerData message %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::CreateSetWmiPowerDataMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  wmi_cpp795 26 "%0%!FUNC!: SetWmiPowerData reply returned error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSendWmiPowerDataMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  wmi_cpp780 25 "%0%!FUNC!: unable to send SetWmiPowerData message %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSendWmiPowerDataMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  wmi_cpp624 18 "%0%!FUNC!: Send SetS0Idle %10!d! message to host failed %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSetS0Idle
{
action, ItemLong -- 10
status, ItemNTSTATUS -- 11
}
#typev  wmi_cpp613 17 "%0%!FUNC!: WMI SetS0Idle %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSetS0Idle
{
Value ? L'Enable' : L'Disable', ItemWString -- 10
}
#typev  wmi_cpp655 20 "%0%!FUNC!: Send SetSxWake %10!d! message to host failed %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSetSxWake
{
action, ItemLong -- 10
status, ItemNTSTATUS -- 11
}
#typev  wmi_cpp644 19 "%0%!FUNC!: WMI SetSxWake %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSetSxWake
{
Value ? L'Enable' : L'Disable', ItemWString -- 10
}
#typev  wmi_cpp687 22 "%0%!FUNC!: WMI QueryS0Idle %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdQueryS0Idle
{
*Value ? L'Enabled' : L'Disabled', ItemWString -- 10
}
#typev  wmi_cpp681 21 "%0%!FUNC!: Send QueryS0Idle message to host failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdQueryS0Idle
{
status, ItemNTSTATUS -- 10
}
#typev  wmi_cpp718 24 "%0%!FUNC!: WMI QuerySxWake %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdQuerySxWake
{
*Value ? L'Enabled' : L'Disabled', ItemWString -- 10
}
#typev  wmi_cpp712 23 "%0%!FUNC!: Send QueryS0Idle %10!d! message to host failed %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdQuerySxWake
{
action, ItemLong -- 10
status, ItemNTSTATUS -- 11
}
#typev  wmi_cpp416 14 "%0%!FUNC!: SetWmiDataItem failed devobj %10!p!, %11!s!GuidIndex %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSetWmiDataItem
{
DeviceObject, ItemPtr -- 10
status, ItemNTSTATUS -- 11
GuidIndex, ItemLong -- 12
}
#typev  wmi_cpp476 15 "%0%!FUNC!: SetWmiDataBlock failed devobj %10!p!, %11!s!GuidIndex %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdSetWmiDataBlock
{
DeviceObject, ItemPtr -- 10
status, ItemNTSTATUS -- 11
GuidIndex, ItemLong -- 12
}
#typev  wmi_cpp592 16 "%0%!FUNC!: QueryWmiDataBlock failed devobj %10!p!, %11!s!GuidIndex %12!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_WMI FUNC=RdWmi::RdQueryWmiDataBlock
{
DeviceObject, ItemPtr -- 10
status, ItemNTSTATUS -- 11
GuidIndex, ItemLong -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
047d9635-37fe-0b85-c153-1c2b2346ee97 WUDFRd // SRC=UsbSS.cpp MJ= MN=
#typev  UsbSS_cpp155 12 "%0%!FUNC!: Failed to allocate LPC message for USB SS event %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::Initialize
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  UsbSS_cpp127 11 "%0%!FUNC!: IoAllocateWorkItem failed." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::Initialize
{
}
#typev  UsbSS_cpp109 10 "%0%!FUNC!: IoAllocateIrp failed." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::Initialize
{
}
#typev  UsbSS_cpp865 18 "%0%!FUNC!: IoOpenDeviceRegistryKey failed while trying to open the hardware key. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::CheckRegValueForWinUsbPpoDisable
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  UsbSS_cpp1004 22 "%0%!FUNC!: WinUsb has claimed power policy ownership although the WinUsbPowerPolicyOwnershipDisabled registry value is non-zero." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::ConfirmWinUsbPpoDisabled
{
}
#typev  UsbSS_cpp988 21 "%0%!FUNC!: The size of data returned in response to IOCTL_INTERNAL_WINUSB_GET_POWER_POLICY_SETTING is not what we expected. Expected size: %10!d! bytes. Size returned: %11!I64d! bytes." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::ConfirmWinUsbPpoDisabled
{
sizeof(winusbPpoStatus), ItemLong -- 10
(ULONG64) ioStatus.Information, ItemLongLong -- 11
}
#typev  UsbSS_cpp977 20 "%0%!FUNC!: The driver stack below the redirector has failed IOCTL_INTERNAL_WINUSB_GET_POWER_POLICY_SETTING. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::ConfirmWinUsbPpoDisabled
{
status, ItemNTSTATUS -- 10
}
#typev  UsbSS_cpp949 19 "%0%!FUNC!: Unable to create IRP for querying WinUSB's power policy ownership status. IoBuildDeviceIoControlRequest failed." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::ConfirmWinUsbPpoDisabled
{
}
#typev  UsbSS_cpp809 17 "%0%!FUNC!: 'WinUsbPowerPolicyOwnershipDisabled' value not present or equals zero." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::VerifyWinUsbVersion
{
}
#typev  UsbSS_cpp269 16 "%0%!FUNC!: ERROR: Trying to submit USB idle notification before previous submission complete." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::RdSubmitUsbIdleNotification
{
}
#typev  UsbSS_cpp243 15 "%0%!FUNC!: ERROR: Unable to acquire remove lock on behalf of USB idle notification request - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::RdSubmitUsbIdleNotification
{
status, ItemNTSTATUS -- 10
}
#typev  UsbSS_cpp224 14 "%0%!FUNC!: ERROR - Trying to submit USB idle notification after the device processed the remove IRP" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::RdSubmitUsbIdleNotification
{
}
#typev  UsbSS_cpp210 13 "%0%!FUNC!: ERROR: Failed to acquire USB idle submission lock." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdUsbSelectiveSuspend::RdSubmitUsbIdleNotification
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
271d75dd-a973-d136-3896-985173d95e08 WUDFRd // SRC=safeMdl.cpp MJ= MN=
#typev  safeMdl_cpp477 12 "%0%!FUNC!: Unable to map %10!s! page of MDL %11!p! to create safe MDL - %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdSafeMdl::CaptureMdl
{
copyOperations[index].Name, ItemString -- 10
OriginalMdl, ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  safeMdl_cpp216 11 "%0%!FUNC!: Unable to allocate %10!d! page buffer to hold buffer ends when creating safe MDL - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdSafeMdl::_CreateAndInitialize
{
copyPageCount, ItemLong -- 10
status, ItemNTSTATUS -- 11
}
#typev  safeMdl_cpp187 10 "%0%!FUNC!: Error allocating safe MDL - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdSafeMdl::_CreateAndInitialize
{
status, ItemNTSTATUS -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
99411cc9-4a54-7dc8-6d58-4575607db267 WUDFRd // SRC=Notifications.cpp MJ= MN=
#typev  Notifications_cpp383 12 "%0RdRemoteInterfaceMessages structure not allocated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVIF FUNC=RdRemoteInterfaceRegistration::HandleArrival
{
}
#typev  Notifications_cpp901 21 "%0Sending RemoteInterfaceNotification(CUSTOM_EVENT) message to host. TargetContext: %10!I64u!. Event: %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::PlugPlayNotification
{
m_TargetContext, ItemULongLong -- 10
&NotificationData->Event, ItemGuid -- 11
}
#typev  Notifications_cpp879 20 "%0REMOVE_CANCELLED received without a prior successful QUERY_REMOVE, ignoring." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::PlugPlayNotification
{
}
#typev  Notifications_cpp870 19 "%0Sending RemoteInterfaceNotification(REMOVE_CANCELLED) message to host. TargetContext: %10!I64u!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::PlugPlayNotification
{
m_TargetContext, ItemULongLong -- 10
}
#typev  Notifications_cpp847 18 "%0Sending RemoteInterfaceNotification(REMOVE_COMPLETE) message to host. TargetContext: %10!I64u!. Surprise: %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::PlugPlayNotification
{
m_TargetContext, ItemULongLong -- 10
!m_QueryRemoveSucceeded, ItemListLong(false,true) -- 11
}
#typev  Notifications_cpp829 17 "%0QUERY_REMOVE received after a prior successful QUERY_REMOVE, auto-succeeding." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::PlugPlayNotification
{
}
#typev  Notifications_cpp821 16 "%0Sending RemoteInterfaceNotification(QUERY_REMOVE) message to host. TargetContext: %10!I64u!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::PlugPlayNotification
{
m_TargetContext, ItemULongLong -- 10
}
#typev  Notifications_cpp800 15 "%0We've unregistered, ignoring event." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::_PlugPlayNotification
{
}
#typev  Notifications_cpp289 11 "%0We've unregistered, ignoring event." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DEVIF FUNC=RdRemoteInterfaceRegistration::_PlugPlayNotification
{
}
#typev  Notifications_cpp610 14 "%0%!FUNC!: IoRegisterPlugPlayNotification(EventCategoryTargetDeviceChange) failed. m_hTarget: %10!p!. m_TargetContext: %11!I64u!. NTSTATUS: %12!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::RdTargetDeviceRegistration
{
Parameters->m_hTarget, ItemPtr -- 10
Parameters->m_TargetContext, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  Notifications_cpp586 13 "%0%!FUNC!: ObReferenceObjectByHandle(m_hTarget: %10!p!) failed. m_TargetContext: %11!I64u! NTSTATUS: %12!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdTargetDeviceRegistration::RdTargetDeviceRegistration
{
Parameters->m_hTarget, ItemPtr -- 10
m_TargetContext, ItemULongLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  Notifications_cpp114 10 "%0%!FUNC!: unable to register for RemoteInterfaceRegistration(Guid = %10!s!, DeviceContext = %11!p!): %12!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdRemoteInterfaceRegistration::RdRemoteInterfaceRegistration
{
Parameters->m_InterfaceGuid, ItemGuid -- 10
Parameters->m_DeviceContext, ItemPtr -- 11
ntStatus, ItemNTSTATUS -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
51ede59f-2f6b-18e7-d570-48ed0d8734af WUDFRd // SRC=DeviceInterface.cpp MJ= MN=
#typev  DeviceInterface_cpp243 12 "%0%!FUNC!: unable to enable device interface %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::EnableInterface
{
m_InterfaceSymbolicLink.Buffer, ItemWString -- 10
}
#typev  DeviceInterface_cpp292 13 "%0%!FUNC!: unable to disable device interface %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::DisableInterface
{
m_InterfaceSymbolicLink.Buffer, ItemWString -- 10
}
#typev  DeviceInterface_cpp126 11 "%0%!FUNC!: unable to register device interface %10!s!. %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::RdDeviceInterface
{
&m_InterfaceGuid, ItemGuid -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  DeviceInterface_cpp100 10 "%0%!FUNC!: unable to allocate a buffer for reference string" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceInterface::RdDeviceInterface
{
}
#typev  DeviceInterface_cpp493 25 "%0%!FUNC!: unable to create symbolic link. %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  DeviceInterface_cpp481 24 "%0%!FUNC!: Error while copying the name of the Reference string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp470 23 "%0%!FUNC!: Error while copying the name of the Reference string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp459 22 "%0%!FUNC!: Error while copying the name of the Pdo" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp448 21 "%0%!FUNC!: Unable to allocate a buffer for the PDO name and the reference string" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp433 20 "%0%!FUNC!: Unable to allocate a buffer for symbolic link string" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp421 19 "%0%!FUNC!: Overflow while adding the lengths of the PDO name and the reference string'" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp409 18 "%0%!FUNC!: Overflow while calculating length of the reference string with the additional L'\'" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp390 17 "%0%!FUNC!: Overflow while calculating length of PDO name with terminating L'\0'" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp378 16 "%0%!FUNC!: Symbolic link name is too long, %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  DeviceInterface_cpp361 15 "%0%!FUNC!: Overflow while calculating length of symbolic link with terminating L'\0'" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
#typev  DeviceInterface_cpp348 14 "%0%!FUNC!: RdDeviceSymbolicLink constructor has failed" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_DEVIF FUNC=RdDeviceSymbolicLink::RdDeviceSymbolicLink
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
ef2856b5-e6fa-17eb-ccda-48b541b4e7f6 WUDFRd // SRC=cancel.cpp MJ= MN=
#typev  cancel_cpp744 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::WaitForCancelRoutineToRun
{
}
#typev  cancel_cpp711 23 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::WaitForCancelRoutineToRun
{
CancelWorkItem, ItemPtr -- 10
}
#typev  cancel_cpp1115 34 "%0%!FUNC!: host returned invalid status %10!s! for cancel message.  context 0x%11!p!, ID 0x%12!I64x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CANCEL FUNC=RdCancelWorkItem::CancelReplyHandlerInHostContext
{
ReplyHeader->NtStatus, ItemNTSTATUS -- 10
m_CreateContext, ItemPtr -- 11
m_RequestIdToCancel, ItemLongLongX -- 12
}
#typev  cancel_cpp1105 33 "%0%!FUNC!: host asking to retry cancel message for context 0x%10!p!, ID 0x%11!I64x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CANCEL FUNC=RdCancelWorkItem::CancelReplyHandlerInHostContext
{
m_CreateContext, ItemPtr -- 10
m_RequestIdToCancel, ItemLongLongX -- 11
}
#typev  cancel_cpp124 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::RdCancelWorkItem
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp114 11 "%0%!FUNC!: IoAllocateWorkItem failed." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CANCEL FUNC=RdCancelWorkItem::RdCancelWorkItem
{
}
#typev  cancel_cpp65 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!#I64x!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::RdCancelWorkItem
{
RdFdoDevice, ItemPtr -- 10
CreateContext, ItemPtr -- 11
RequestId, ItemLongLongX -- 12
}
#typev  cancel_cpp687 22 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::ClearCancelRoutine
{
cancelCalled, ItemListLong(false,true) -- 10
}
#typev  cancel_cpp661 21 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::ClearCancelRoutine
{
Irp, ItemPtr -- 10
}
#typev  cancel_cpp295 15 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::SendCancelMessage
{
}
#typev  cancel_cpp287 14 "%0%!FUNC!: cancel message for requestID 0x%10!I64x! already sent" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CANCEL FUNC=RdCancelWorkItem::SendCancelMessage
{
m_RequestIdToCancel, ItemLongLongX -- 10
}
#typev  cancel_cpp179 13 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelWorkItem::SendCancelMessage
{
}
#typev  cancel_cpp852 28 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
}
#typev  cancel_cpp816 27 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
CancelWorkItem, ItemPtr -- 10
}
#typev  cancel_cpp1038 32 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::TimerCallback
{
}
#typev  cancel_cpp980 31 "%0%!FUNC!: host failed to cancel request 0x%10!I64x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::TimerCallback
{
cancelWorkItem->m_RequestIdToCancel, ItemLongLongX -- 10
}
#typev  cancel_cpp959 30 "%0%!FUNC!: found cancelWorkItem = 0x%10!p!. state = 0x%11!x!, timeout = %12!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::TimerCallback
{
cancelWorkItem, ItemPtr -- 10
cancelWorkItem->m_State, ItemLong -- 11
cancelWorkItem->m_CancelTimeoutInSec, ItemLong -- 12
}
#typev  cancel_cpp938 29 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::TimerCallback
{
}
#typev  cancel_cpp794 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
}
#typev  cancel_cpp776 25 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::CancelRoutine
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  cancel_cpp501 18 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::RdCancelSafeQueue
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp491 17 "%0%!FUNC!: unable to allocate timer callback packet %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CANCEL FUNC=RdCancelSafeQueue::RdCancelSafeQueue
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp465 16 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::RdCancelSafeQueue
{
RdDriver, ItemPtr -- 10
}
#typev  cancel_cpp632 20 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::SetCancelRoutine
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  cancel_cpp563 19 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!#I64x!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCancelSafeQueue::SetCancelRoutine
{
Irp, ItemPtr -- 10
RdFdoDevice, ItemPtr -- 11
HostCreateContext, ItemPtr -- 12
RequestId, ItemLongLongX -- 13
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
c63446a4-0c91-cf5b-3e3d-7ef457a0c4c6 WUDFRd // SRC=process.cpp MJ= MN=
#typev  process_cpp369 24 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp355 23 "%0unable to connect to host non-state-changing event port - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp341 22 "%0unable to connect to host system event port - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp327 21 "%0unable to connect to host io cancel port - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp313 20 "%0unable to connect to host io port - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp294 19 "%0%!FUNC!: unable to allocate a host process sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
}
#typev  process_cpp281 18 "%0%!FUNC!: unable to get rddriver" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::ConnectToProcess
{
}
#typev  process_cpp105 14 "%0unable to copy str %10!s!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
strings[i].Source, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  process_cpp93 13 "%0unable to allocate buffer to copy str %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
strings[i].Source, ItemWString -- 10
}
#typev  process_cpp80 12 "%0invalid lpc port name %10!s!, %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
strings[i].Source, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  process_cpp124 15 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::RdProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  process_cpp47 11 "%0%!FUNC!: invalid EPROCESS" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_PROCESS FUNC=RdProcess::RdProcess
{
}
#typev  process_cpp18 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::RdProcess
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  process_cpp189 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::~RdProcess
{
}
#typev  process_cpp159 16 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdProcess::~RdProcess
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
91415071-99b3-c2fe-fef1-cb64a3506c2f WUDFRd // SRC=lpcNotification.cpp MJ= MN=
#typev  lpcNotification_cpp74 13 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsConnected
{
STATUS_SUCCESS, ItemNTSTATUS -- 10
}
#typev  lpcNotification_cpp72 12 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsConnected
{
LpcConnPort, ItemPtr -- 10
LpcCommPort, ItemPtr -- 11
UniqueProcessId, ItemPtr -- 12
}
#typev  lpcNotification_cpp61 11 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsClosed
{
}
#typev  lpcNotification_cpp20 10 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdLpcNotification::PortIsClosed
{
LpcCommPort, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
600b0ecb-663e-7d24-e70f-b0942951c784 WUDFRd // SRC=dmControl.cpp MJ= MN=
#typev  dmControl_cpp151 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
}
#typev  dmControl_cpp134 15 "%0%!FUNC! created DM control object %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
GetName(), ItemWString -- 10
}
#typev  dmControl_cpp122 14 "%0%!FUNC!: unable to adjust device object security descriptor. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp107 13 "%0unable to open a handle to self %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp87 12 "%0%!FUNC!: unable to allocate security descriptor" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
}
#typev  dmControl_cpp75 11 "%0%!FUNC!: unable to allocate a DrvMgr sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
}
#typev  dmControl_cpp55 10 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDrvMgrCtrlDevice
{
RdDriver, ItemPtr -- 10
DeviceName, ItemWString -- 11
ServiceProcessId, ItemPtr -- 12
}
#typev  dmControl_cpp202 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdCreate
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp168 17 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdCreate
{
Irp, ItemPtr -- 10
}
#typev  dmControl_cpp469 33 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
status, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp434 32 "%0%!FUNC!: failure to set host process  for %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
setPidMessage->PdoName, ItemWString -- 10
status, ItemNTSTATUS -- 11
}
#typev  dmControl_cpp420 31 "%0%!FUNC!: failure to find or create host process for %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
setPidMessage->PdoName, ItemWString -- 10
status, ItemNTSTATUS -- 11
}
#typev  dmControl_cpp396 30 "%0%!FUNC!: could not find FDO object for %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
setPidMessage->PdoName, ItemWString -- 10
status, ItemNTSTATUS -- 11
}
#typev  dmControl_cpp363 28 "%0%!FUNC!: string %10!s! from device manager is 0 length - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
stringInfos[i].FieldName, ItemWString -- 10
status, ItemNTSTATUS -- 11
}
#typev  dmControl_cpp349 27 "%0%!FUNC!: invalid string %10!s! from device manager - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
stringInfos[i].FieldName, ItemWString -- 10
status, ItemNTSTATUS -- 11
}
#typev  dmControl_cpp383 29 "%0%!FUNC!: unable to reference process handle %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
status, ItemNTSTATUS -- 10
}
#typev  dmControl_cpp299 26 "%0%!FUNC!: invalide pdo name expectedLen %10!d! != actualLen %11!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
(ULONG) pdoNameLen, ItemLong -- 10
(ULONG) actualPdoNameLen, ItemLong -- 11
}
#typev  dmControl_cpp290 25 "%0%!FUNC!: invalid pdo name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
setPidMessage->PdoName, ItemWString -- 10
status, ItemNTSTATUS -- 11
}
#typev  dmControl_cpp274 24 "%0%!FUNC!: pdo name too long 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
(ULONG) pdoNameSize, ItemLong -- 10
}
#typev  dmControl_cpp266 23 "%0%!FUNC!: message body size is bad" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
}
#typev  dmControl_cpp258 22 "%0%!FUNC!: message body too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
}
#typev  dmControl_cpp249 21 "%0%!FUNC!: message header too smaller" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
}
#typev  dmControl_cpp237 20 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDrvMgrCtrlDevice::RdDeviceIoControl
{
Irp, ItemPtr -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
b82aa038-29a6-3cb4-d4e7-e61b2e62eb85 WUDFRd // SRC=Control.cpp MJ= MN=
#typev  Control_cpp147 10 "%0cancelling irp %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDeviceCreateContext::CancelIo
{
irp, ItemPtr -- 10
}
#typev  Control_cpp212 11 "%0cancelling irp %10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDeviceCreateContext::CancelSyncIo
{
irp, ItemPtr -- 10
}
#typev  Control_cpp1722 62 "%0%!FUNC!: Failed to allocate LPC message for power IRP complete work item %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::AllocatePowerIrpCompletionResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp1699 61 "%0%!FUNC!: Failed to allocate memory for Dx IRP complete work item %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::AllocatePowerIrpCompletionResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp1686 60 "%0%!FUNC!: Failed to allocate memory for Dx IRP complete work item context %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::AllocatePowerIrpCompletionResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2160 71 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2340 76 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2560 82 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp3311 115 "%0%!FUNC!: IoAllocateIrp failed." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdGetStackCapabilities
{
}
#typev  Control_cpp3299 114 "%0%!FUNC!: IoGetAttachedDeviceReference failed." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdGetStackCapabilities
{
}
#typev  Control_cpp3276 113 "%0%!FUNC!: IOCTL_RD_GET_STACK_CAPS output parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdGetStackCapabilities
{
}
#typev  Control_cpp2074 68 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletionWithIrpTracking
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2068 67 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletionWithIrpTracking
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
CreateContext, ItemPtr -- 12
}
#typev  Control_cpp2092 70 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2088 69 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCreateCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
RdCtrl, ItemPtr -- 12
}
#typev  Control_cpp2260 73 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletionWithIrpTracking
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2253 72 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletionWithIrpTracking
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
CreateContext, ItemPtr -- 12
}
#typev  Control_cpp2279 75 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2274 74 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDeviceCloseCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
RdCtrl, ItemPtr -- 12
}
#typev  Control_cpp2492 79 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletionWithIrpTracking
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2485 78 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletionWithIrpTracking
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
CreateContext, ItemPtr -- 12
}
#typev  Control_cpp2511 81 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletion
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2506 80 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdReadWriteCleanupCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
RdCtrl, ItemPtr -- 12
}
#typev  Control_cpp3148 112 "%0%!FUNC!: Invalid argument for RootType" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp3083 111 "%0%!FUNC!: Error: rootPath == NULL and subPath != NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp3064 110 "%0%!FUNC!: propertyStoreMessage->SubPathCch is wrong" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp3050 109 "%0%!FUNC!: Subkey path is not null terminated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp3026 108 "%0%!FUNC!: Root path cannot be empty" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp3007 107 "%0%!FUNC!: Main string must not start with \" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2979 106 "%0%!FUNC!: propertyStoreMessage->RootPathCch is wrong" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2965 105 "%0%!FUNC!: Main string is not null terminated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2949 104 "%0%!FUNC!: Wrong value for string lengths" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2939 103 "%0%!FUNC!: Overflow while calculating total string length" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2924 102 "%0%!FUNC!: Wrong output buffer size" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2912 101 "%0%!FUNC!: The value of DesiredAccess is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2898 100 "%0%!FUNC!: Driver set Volatile to true, but Create is false" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2885 99 "%0%!FUNC!: StoreType not in allowable range" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp2872 98 "%0%!FUNC!: IOCTL_RD_CREATE_PSTORE_REGKEY input parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateRegistryKey
{
}
#typev  Control_cpp3629 123 "%0%!FUNC!: Failed to allocate USB SS object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdInitializeUsbSS
{
}
#typev  Control_cpp3607 122 "%0%!FUNC!: Failed to acquire resource allocation lock for USB SS" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdInitializeUsbSS
{
}
#typev  Control_cpp427 15 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDevice
{
}
#typev  Control_cpp419 14 "%0%!FUNC! created control object %10!s! " //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
GetName(), ItemWString -- 10
}
#typev  Control_cpp374 13 "%0%!FUNC!: unable to get allocate create context list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCtrlDevice
{
}
#typev  Control_cpp346 12 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCtrlDevice
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  Control_cpp1605 59 "%0IOCTL_RD_MAP_IRP_BUFFER - error %10!s! copying mapped address back to host" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp1580 58 "%0IOCTL_RD_MAP_IRP_BUFFER - error %10!s! mapping IRP buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp1556 57 "%0IOCTL_RD_MAP_IRP_BUFFER - Error finding message id %10!#08x! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
mapInput.MessageId, ItemLong -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  Control_cpp1535 56 "%0IOCTL_RD_MAP_IRP_BUFFER - BufferKind %10!d! out of range" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
mapInput.BufferIndex, ItemLong -- 10
}
#typev  Control_cpp1523 55 "%0IOCTL_RD_MAP_IRP_BUFFER - MessageId cannot be zero" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1507 54 "%0Invalid output buffer for IOCTL_RD_MAP_IRP_BUFFER" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1488 53 "%0Invalid input buffer for IOCTL_RD_MAP_IRP_BUFFER" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1453 52 "%0IOCTL_RD_COPY_IRP_BUFFER - error %10!s! copying IRP buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp1428 51 "%0%!FUNC!: IOCTL_RD_COPY_IRP_BUFFER output buffer (%10!p!,%11!d! bytes) was not a valid user-mode buffer - exception %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
OutputBuffer, ItemPtr -- 10
OutputBufferLength, ItemLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  Control_cpp1397 50 "%0IOCTL_RD_COPY_IRP_BUFFER - CopyDirection %10!d! out of range" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
copy.Direction, ItemLong -- 10
}
#typev  Control_cpp1384 49 "%0IOCTL_RD_COPY_IRP_BUFFER - BufferKind %10!d! out of range" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
copy.BufferIndex, ItemLong -- 10
}
#typev  Control_cpp1372 48 "%0IOCTL_RD_COPY_IRP_BUFFER - MessageId cannot be zero" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1362 47 "%0Invalid input buffer for IOCTL_RD_COPY_IRP_BUFFER" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1307 45 "%0IOCTL_RD_SET_POWER_STATE: invalid device state %10!u! to set" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
poStateMsg.DeviceState, ItemLong -- 10
}
#typev  Control_cpp1332 46 "%0IOCTL_RD_SET_POWER_STATE: invalid output buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1296 44 "%0%!FUNC!: IOCTL_RD_SET_POWER_STATE output parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1285 43 "%0IOCTL_RD_SET_POWER_STATE: invalid output buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1270 42 "%0IOCTL_RD_SET_POWER_STATE: invalid input buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1227 41 "%0IOCTL_RD_CANCEL_IO invalid filehandle" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1206 40 "%0invalid input buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1160 39 "%0IOCTL_RD_CANCEL_IO invalid filehandle" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1134 38 "%0IOCTL_RD_CANCEL_IO invalid overlapped" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp1117 37 "%0invalid input buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdFastIoDeviceIoControl
{
}
#typev  Control_cpp2053 66 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCreate
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp2006 65 "%0unable to create control object context" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreate
{
}
#typev  Control_cpp1926 64 "%0%!FUNC!: unexpect process 0x%10!p! trying to open control object ox%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreate
{
PsGetCurrentProcessId(), ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  Control_cpp1921 63 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdCreate
{
Irp, ItemPtr -- 10
}
#typev  Control_cpp2725 92 "%0%!FUNC!: Invalid symbolic link offset" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2821 97 "%0%!FUNC!: unable to find/create an object for symbolic link %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
SymbolicLink, ItemWString -- 10
}
#typev  Control_cpp2797 96 "%0%!FUNC!: Reference string is not null terminated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2778 95 "%0%!FUNC!: Symbolic link name string not null terminated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2762 94 "%0%!FUNC!: Input buffer shorter than expected" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2743 93 "%0%!FUNC!: Invalid reference string offset" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2709 91 "%0%!FUNC!: Overflow while calculating total input buffer size in bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2696 90 "%0%!FUNC!: Overflow while calculating reference string size in bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2686 89 "%0%!FUNC!: Overflow while calculating reference string size in bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2671 88 "%0%!FUNC!: Overflow while calculating total struct size in bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2655 87 "%0%!FUNC!: Overflow while calculating symbolic link length in bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2646 86 "%0%!FUNC!: Overflow while calculating symbolic link length in bytes" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2633 85 "%0%!FUNC!: Symbolic link length is zero" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2615 84 "%0%!FUNC!: StringBuffer not aligned correctly" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp2603 83 "%0%!FUNC!: Symbolic link data too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdCreateSymbolicLink
{
}
#typev  Control_cpp3409 117 "%0%!FUNC!: unable to find/create a object for RemoteInterfaceRegistration: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdRegisterRemoteInterfaceNotification
{
&interfaceRegData->InterfaceGuid, ItemGuid -- 10
}
#typev  Control_cpp3384 116 "%0%!FUNC!: RegisterRemoteInterfaceNotification data too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdRegisterRemoteInterfaceNotification
{
}
#typev  Control_cpp3487 119 "%0%!FUNC!: unable to create a object for TargetDeviceRegistration TargetContext: %10!I64u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdRegisterTargetDeviceNotification
{
targetDeviceRegData->TargetContext, ItemULongLong -- 10
}
#typev  Control_cpp3463 118 "%0%!FUNC!: RegisterTargetDeviceNotification data too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdRegisterTargetDeviceNotification
{
}
#typev  Control_cpp3565 121 "%0%!FUNC!: unable to find a TargetDeviceRegistration object with TargetContext: %10!I64u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdUnregisterTargetDeviceNotification
{
targetDeviceRegData->TargetContext, ItemULongLong -- 10
}
#typev  Control_cpp3541 120 "%0%!FUNC!: UnregisterTargetDeviceNotification data too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdUnregisterTargetDeviceNotification
{
}
#typev  Control_cpp1051 36 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp701 22 "%0%!FUNC!: bad ref. string size 0x%10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(ULONG) refStrSize, ItemLong -- 10
}
#typev  Control_cpp811 26 "%0device interface not registered" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp785 25 "%0%!FUNC!: unable to find/create a object for dev interface (%10!s!, %11!s!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
interfaceGuid, ItemGuid -- 10
refString, ItemWString -- 11
}
#typev  Control_cpp752 24 "%0%!FUNC!: ref. string %10!s! shorter than expected" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
refString, ItemWString -- 10
}
#typev  Control_cpp743 23 "%0%!FUNC!: ref. string not null terminated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp687 21 "%0%!FUNC!: ioctl data too smaller" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp1018 35 "%0%!FUNC!: IOCTL_RD_UPDATE_WMI_IDLE_WAKE_INSTANCE input parameter WmiIdleWakeInstanceUpdate value incorrect %10!d!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
msg->UpdateType, ItemLong -- 10
}
#typev  Control_cpp1008 34 "%0%!FUNC!: IOCTL_RD_UPDATE_WMI_IDLE_WAKE_INSTANCE input parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp874 29 "%0%!FUNC!: invalid device state %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
poMsg->PowerState.DeviceState, ItemLong -- 10
}
#typev  Control_cpp963 33 "%0%!FUNC!: PoRequestPowerIrp failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp927 32 "%0%!FUNC!: Failed to acquire remove lock on behalf of PoRequestPowerIrp callback routine. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  Control_cpp897 31 "%0%!FUNC!: invalid power minor function" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp887 30 "%0%!FUNC!: invalid system state %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
poMsg->PowerState.SystemState, ItemLong -- 10
}
#typev  Control_cpp861 28 "%0%!FUNC!: IOCTL_RD_REQUEST_POWER_IRP output parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp854 27 "%0%!FUNC!: IOCTL_RD_REQUEST_POWER_IRP input parameter size too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp600 20 "%0%!FUNC!: unable to allocate TARGET_DEVICE_CUSTOM_NOTIFICATION" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp587 19 "%0%!FUNC!: message data too large 0x%10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
(ULONG) targetNotifyDataSize, ItemLong -- 10
}
#typev  Control_cpp575 18 "%0%!FUNC!: message body too small" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp566 17 "%0%!FUNC!: message header too smaller" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
}
#typev  Control_cpp540 16 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdCtrlDevice::RdDeviceIoControlHandler
{
Irp, ItemPtr -- 10
}
#typev  Control_cpp2377 77 "%0unexpect process 0x%10!p! trying to open send i/o to control object ox%11!p!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdCtrlDevice::RdReadWriteCleanup
{
PsGetCurrentProcessId(), ItemPtr -- 10
this, ItemPtr -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
87e297d5-85e2-ec6e-2250-76eae0be2e09 WUDFRd // SRC=fdomt.cpp MJ= MN=
#typev  fdomt_cpp295 14 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::MtProcessQueryID
{
}
#typev  fdomt_cpp279 13 "%0Host failed Multi-Transport QueryID message. Error: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::MtProcessQueryID
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdomt_cpp225 12 "%0Unable to communicate with host, while trying to send TRANSPORT_QUERY_ID message - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::MtProcessQueryID
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdomt_cpp191 11 "%0Multi-Transport QueryID Message not allocated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::MtProcessQueryID
{
}
#typev  fdomt_cpp166 10 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::MtProcessQueryID
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
0d78a427-89cb-80b6-8f93-f3bb0383080f WUDFRd // SRC=fdoio.cpp MJ= MN=
#typev  fdoio_cpp149 14 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::~WudfFdoCreateContext
{
}
#typev  fdoio_cpp131 13 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::~WudfFdoCreateContext
{
}
#typev  fdoio_cpp227 16 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CreateMessage
{
msg, ItemPtr -- 10
}
#typev  fdoio_cpp168 15 "%0 Entering %!FUNC!(%10!s!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CreateMessage
{
FileName, ItemPWString -- 10
Irp, ItemPtr -- 11
Security, ItemPtr -- 12
}
#typev  fdoio_cpp309 19 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreateReply
{
}
#typev  fdoio_cpp259 18 "%0%!FUNC!: um driver failed create = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCreateReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp244 17 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreateReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp592 26 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CloseMessage
{
msg, ItemPtr -- 10
}
#typev  fdoio_cpp561 25 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CloseMessage
{
}
#typev  fdoio_cpp671 29 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseReply
{
}
#typev  fdoio_cpp621 28 "%0%!FUNC!: host process failed close message with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCloseReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp609 27 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp771 34 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdClose
{
STATUS_PENDING, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp734 33 "%0%!FUNC!: unable to send alpc msg to host" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdClose
{
}
#typev  fdoio_cpp715 32 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdClose
{
STATUS_PENDING, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp706 31 "%0%!FUNC!: Close IRP with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdClose
{
}
#typev  fdoio_cpp688 30 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdClose
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp825 36 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CleanupMessage
{
msg, ItemPtr -- 10
}
#typev  fdoio_cpp788 35 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CleanupMessage
{
Irp, ItemPtr -- 10
Security, ItemPtr -- 11
}
#typev  fdoio_cpp877 39 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanupReply
{
}
#typev  fdoio_cpp846 38 "%0%!FUNC!: host process failed process clean up message with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCleanupReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp839 37 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanupReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp3871 90 "%0%!FUNC!: Created safe MDL %10!p! for MDL %11!p! (copy = %12!s!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MakeSafeMdl
{
safeMdl, ItemPtr -- 10
OriginalMdl, ItemPtr -- 11
(CopyBuffer ? L'true' : L'false'), ItemWString -- 12
}
#typev  fdoio_cpp3857 89 "%0%!FUNC!: Unable to capture MDL %10!p! into safeMdl %11!p! - %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MakeSafeMdl
{
OriginalMdl, ItemPtr -- 10
safeMdl, ItemPtr -- 11
status, ItemNTSTATUS -- 12
}
#typev  fdoio_cpp3839 88 "%0%!FUNC!: Unable to create safe MDL for mdl %10!p! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MakeSafeMdl
{
OriginalMdl, ItemPtr -- 10
status, ItemNTSTATUS -- 11
}
#typev  fdoio_cpp4180 96 "%0%!FUNC!: The host process tried to complete IRP 0x%10!p! (Major Function: %11!d!) with a successful status code and information %12!I64d! which is greater than the number of bytes (%13!I64d!) copied by the host process to the output buffer. The host process will be terminated." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::ValidateIoStatusBlockInformation
{
Irp, ItemPtr -- 10
irpContext->MajorFunction, ItemLong -- 11
(ULONG64) HostInformation, ItemLongLong -- 12
(ULONG64) bytesCopiedToOutBuf, ItemLongLong -- 13
}
#typev  fdoio_cpp4144 95 "%0%!FUNC!: Completing IRP 0x%10!p! (Major Function: %11!d!) with warning status 0x%12!X! and truncated information %13!I64d!. Original information received from the host process was %14!I64d!." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::ValidateIoStatusBlockInformation
{
Irp, ItemPtr -- 10
irpContext->MajorFunction, ItemLong -- 11
HostStatus, ItemLong -- 12
(ULONG64) bytesCopiedToOutBuf, ItemLongLong -- 13
(ULONG64) HostInformation, ItemLongLong -- 14
}
#typev  fdoio_cpp125 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::WudfFdoCreateContext
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp67 11 "%0%!FUNC!: Impersonation requested, but thread to impersonate is invalid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=WudfFdoCreateContext::WudfFdoCreateContext
{
}
#typev  fdoio_cpp48 10 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfFdoCreateContext::WudfFdoCreateContext
{
Fdo, ItemPtr -- 10
Qos, ItemPtr -- 11
}
#typev  fdoio_cpp546 24 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreate
{
STATUS_PENDING, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp367 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreate
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp358 22 "%0%!FUNC!: Create IRP with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCreate
{
}
#typev  fdoio_cpp343 21 "%0%!FUNC!: ioctl not from user mode" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdCreate
{
}
#typev  fdoio_cpp331 20 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCreate
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1949 70 "%0RdFdoDevice 0x%10!p! completed %11!u! request(s) during the last timeout period" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdCleanupExtendTimeout
{
rdFdo, ItemPtr -- 10
currNumIOsCompleted - lastNumIOsCompleted, ItemLong -- 11
}
#typev  fdoio_cpp2778 75 "%0%!FUNC!: Failure to probe user address %10!p! (%11!d! bytes) for %12!s! - %13!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::ValidateAndGetOriginalIrpBuffer
{
BufferDescriptor->Buffer.Address, ItemPtr -- 10
BufferDescriptor->Length, ItemLong -- 11
probeMode, ItemEnum(_LOCK_OPERATION) -- 12
status, ItemNTSTATUS -- 13
}
#typev  fdoio_cpp2803 76 "%0%!FUNC!: IRP has non-zero buffer length but NULL buffer pointer. Failing with %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::ValidateAndGetOriginalIrpBuffer
{
status, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp3171 80 "%0%!FUNC!: Failed to copy input buffer for IRP %10!p! (address %11!p! length %12!#08x!) - status %13!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::PrepareIrpBufferForTransfer
{
Irp, ItemPtr -- 10
BufferDescriptor->Buffer.Address, ItemPtr -- 11
BufferDescriptor->Length, ItemLong -- 12
status, ItemNTSTATUS -- 13
}
#typev  fdoio_cpp3133 79 "%0%!FUNC!: Failed to allocate intermediate buffer for IRP %10!p! %11!s! buffer - needed %12!d! bytes.  Status %13!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::PrepareIrpBufferForTransfer
{
Irp, ItemPtr -- 10
(Index == IrpBufferIndexPrimary ? L'primary' :                                                                L'secondary'), ItemWString -- 11
BufferDescriptor->Length, ItemLong -- 12
status, ItemNTSTATUS -- 13
}
#typev  fdoio_cpp3065 78 "%0%!FUNC!: Failed to probe and lock %10!s! buffer for IRP %11!p! (address %12!p! length %13!#08x! lock-mode %14!d!) - status %15!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::PrepareIrpBufferForTransfer
{
(Index == IrpBufferIndexPrimary ? L'primary' : L'secondary'), ItemWString -- 10
Irp, ItemPtr -- 11
BufferDescriptor->Buffer.Address, ItemPtr -- 12
BufferDescriptor->Length, ItemLong -- 13
lockOperation, ItemLong -- 14
status, ItemNTSTATUS -- 15
}
#typev  fdoio_cpp3033 77 "%0%!FUNC!: Failed to allocate MDL for IRP %10!p! buffer (type %11!d!) - needed %12!p! bytes.  Status %13!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::PrepareIrpBufferForTransfer
{
Irp, ItemPtr -- 10
BufferDescriptor->Source, ItemLong -- 11
(PVOID) mdlSize, ItemPtr -- 12
status, ItemNTSTATUS -- 13
}
#typev  fdoio_cpp3611 85 "%0%!FUNC!: Failed to map IRP %10!p! buffer (%11!s!, mdl %12!p!) - status %13!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MapIoBuffer
{
Irp, ItemPtr -- 10
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 11
bufferMdl, ItemPtr -- 12
status, ItemNTSTATUS -- 13
}
#typev  fdoio_cpp3542 84 "%0%!FUNC!: Requested to map IRP %10!p! buffer (%11!s!, mdl %12!p!) will require creation of a safe MDL because it is not page aligned (offset 0x%13!08x!, byte count 0x%14!08x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MapIoBuffer
{
Irp, ItemPtr -- 10
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 11
bufferMdl, ItemPtr -- 12
MmGetMdlByteOffset(bufferMdl), ItemLong -- 13
MmGetMdlByteCount(bufferMdl), ItemLong -- 14
}
#typev  fdoio_cpp3497 83 "%0%!FUNC!: Host attempting to copy IRP %10!p! buffer %11!s! a second time" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MapIoBuffer
{
Irp, ItemPtr -- 10
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 11
}
#typev  fdoio_cpp3480 82 "%0%!FUNC!: Host not allowed to map buffer %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MapIoBuffer
{
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 10
}
#typev  fdoio_cpp3467 81 "%0%!FUNC!: Host is not allowed to map %10!s! buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::MapIoBuffer
{
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 10
}
#typev  fdoio_cpp3794 87 "%0%!FUNC!: Performing deferred cleanup of IRP %10!p! SafeMdl %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::UnmapIoBuffers
{
Irp, ItemPtr -- 10
safeMdl, ItemPtr -- 11
}
#typev  fdoio_cpp3768 86 "%0%!FUNC!: Deferring cleanup of IRP %10!p! SafeMDL %11!p! because host process is being run down" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::UnmapIoBuffers
{
Irp, ItemPtr -- 10
safeMdl, ItemPtr -- 11
}
#typev  fdoio_cpp3981 94 "%0%!FUNC!: RdRundownWorker complete - releasing FDO %10!p! reference & exiting." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdRundownWorker
{
this, ItemPtr -- 10
}
#typev  fdoio_cpp3955 93 "%0%!FUNC!: Cleaning up and completing irp %10!p! for FDO %11!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdRundownWorker
{
irp, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  fdoio_cpp3922 92 "%0%!FUNC!: Host process %10!d! for FDO %11!p! has exited" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdRundownWorker
{
hostPid, ItemLong -- 10
this, ItemPtr -- 11
}
#typev  fdoio_cpp3903 91 "%0%!FUNC!: Worker for FDO %10!p! started - waiting for host process %11!d! to exit" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdRundownWorker
{
this, ItemPtr -- 10
hostPid, ItemLong -- 11
}
#typev  fdoio_cpp1005 43 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanup
{
STATUS_PENDING, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp978 42 "%0%!FUNC!: unable to send alpc msg to host" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCleanup
{
}
#typev  fdoio_cpp925 41 "%0%!FUNC!: Cleanup IRP with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdCleanup
{
}
#typev  fdoio_cpp894 40 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCleanup
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1753 65 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIo
{
alwaysReturnPending ? STATUS_PENDING : ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1643 64 "%0%!FUNC!: Error preparing buffer %10!d! for IRP (function %11!d! - %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdIo
{
index, ItemLong -- 10
irpMajorCode, ItemLong -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  fdoio_cpp1609 63 "%0%!FUNC!: io not from kernel mode" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1600 62 "%0%!FUNC!: io not from user mode" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DISPATCH FUNC=RdFdoDevice::RdIo
{
}
#typev  fdoio_cpp1569 61 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!, %13!p!, %14!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIo
{
Irp, ItemPtr -- 10
MessageIoHeader, ItemPtr -- 11
MessageSize, ItemLong -- 12
BufferDescriptors, ItemPtr -- 13
BufferDescriptorsCe, ItemLong -- 14
}
#typev  fdoio_cpp1895 69 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIoReply
{
}
#typev  fdoio_cpp1870 68 "%0%!FUNC!: Requesting rundown worker for FDO %10!p!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIoReply
{
this, ItemPtr -- 10
}
#typev  fdoio_cpp1841 67 "%0%!FUNC!: Deferring FDO %10!p! IRP %11!p! cleanup & completion until host process %12!d! has exited." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdIoReply
{
this, ItemPtr -- 10
Irp, ItemPtr -- 11
(ULONG) RdGetHostProcess()->ProcessId(), ItemLong -- 12
}
#typev  fdoio_cpp1775 66 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdIoReply
{
Irp, ItemPtr -- 10
ReplyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdoio_cpp2197 74 "%0%!FUNC!: Failure copying IRP %10!p! buffer (%11!s!) - %12!p! bytes from %13!p! to %14!p! (%15!s!) - exception %16!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::CopyIoBuffer
{
Irp, ItemPtr -- 10
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 11
(PVOID) CopyCb, ItemPtr -- 12
source, ItemPtr -- 13
destination, ItemPtr -- 14
Direction, ItemEnum(_WUDF_IRP_COPY_DIRECTION) -- 15
status, ItemNTSTATUS -- 16
}
#typev  fdoio_cpp2151 73 "%0%!FUNC!: Failed to map IRP %10!p! buffer (index %11!s!, mdl %12!p!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::CopyIoBuffer
{
Irp, ItemPtr -- 10
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 11
bufferMdl, ItemPtr -- 12
}
#typev  fdoio_cpp2105 72 "%0%!FUNC!: Host attempting to copy IRP %10!p! buffer a second time (index = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::CopyIoBuffer
{
Irp, ItemPtr -- 10
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 11
}
#typev  fdoio_cpp2075 71 "%0%!FUNC!: Host made illegal buffer copy request (index = %10!s!, direction = %11!s!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::CopyIoBuffer
{
BufferIndex, ItemEnum(_WUDF_IRP_BUFFER_INDEX) -- 10
Direction, ItemEnum(_WUDF_IRP_COPY_DIRECTION) -- 11
}
#typev  fdoio_cpp1092 46 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRead
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1031 45 "%0%!FUNC!: Read IRP with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdRead
{
}
#typev  fdoio_cpp1024 44 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRead
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1182 49 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdWrite
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1118 48 "%0%!FUNC!: Write IRP with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdWrite
{
}
#typev  fdoio_cpp1110 47 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdWrite
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1324 52 "%0MethodNeitherAction setting in the registry disallows METHOD_NEITHER IOs.  ioctl: 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdDeviceIoControl
{
thisIrpStack->Parameters.DeviceIoControl.IoControlCode, ItemLong -- 10
}
#typev  fdoio_cpp1373 53 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdDeviceIoControl
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1240 51 "%0%!FUNC!: Ioctl with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdDeviceIoControl
{
}
#typev  fdoio_cpp1232 50 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdDeviceIoControl
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1427 56 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdFlush
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1392 55 "%0%!FUNC!: Flush IRP with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdFlush
{
}
#typev  fdoio_cpp1387 54 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdFlush
{
Irp, ItemPtr -- 10
}
#typev  fdoio_cpp1544 60 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdQuerySetInformation
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdoio_cpp1459 58 "%0%!FUNC!: QuerySetInformation IRP with NULL FileObject is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_IO FUNC=RdFdoDevice::RdQuerySetInformation
{
}
#typev  fdoio_cpp1455 57 "%0 Entering %!FUNC!(%10!p! (%11!s!))" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdQuerySetInformation
{
Irp, ItemPtr -- 10
(isQuery ? L'query' : L'set'), ItemWString -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
f2c9c1a5-c287-5c56-8db5-e99e1b9e3a43 WUDFRd // SRC=fdo.cpp MJ= MN=
#typev  fdo_cpp697 37 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp681 36 "%0%!FUNC!: skipping OpenProcess message since LPC didn't initialize" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
}
#typev  fdo_cpp658 35 "%0%!FUNC!: Open process reply returned error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp643 34 "%0unable to send open process message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
}
#typev  fdo_cpp633 33 "%0%!FUNC! sending WdfProcMgmt_Message_OpenProcess message %10!s! w/ timeout of %11!u! secs" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
GetName(), ItemWString -- 10
queryProcessReply->ProcessTimeout, ItemLong -- 11
}
#typev  fdo_cpp624 32 "%0unable to query process properties %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
queryProcessReplyHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp615 31 "%0unable to query process" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
}
#typev  fdo_cpp605 30 "%0%!FUNC! sending WdfProcMgmt_Message_QueryProcess message %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
GetName(), ItemWString -- 10
}
#typev  fdo_cpp572 29 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSendOpenProcessMessageToDrvMgr
{
}
#typev  fdo_cpp1185 53 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CreateDeviceStackMessage
{
msg, ItemPtr -- 10
}
#typev  fdo_cpp1161 52 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CreateDeviceStackMessage
{
}
#typev  fdo_cpp1396 64 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CloseDeviceStackMessage
{
msg, ItemPtr -- 10
}
#typev  fdo_cpp1380 63 "%0%!FUNC!: Failed to allocate LPC message for close-device-stack %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdFdoDevice::CloseDeviceStackMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1372 62 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::CloseDeviceStackMessage
{
}
#typev  fdo_cpp2136 75 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRemoveDeviceFinal
{
}
#typev  fdo_cpp2501 77 "%0%!FUNC!: Received a wait-wake IRP when a previous wait-wake IRP is already pending" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdWaitWake
{
}
#typev  fdo_cpp2453 76 "%0%!FUNC!: ERROR - Received a wait-wake IRP after the device processed the remove IRP" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdWaitWake
{
}
#typev  fdo_cpp2627 79 "%0%!FUNC!: Attempting to cancel wait-wake IRP." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::CancelWaitWakeWorker
{
}
#typev  fdo_cpp2614 78 "%0%!FUNC!: Wait-wake IRP already completed. Too late to cancel." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::CancelWaitWakeWorker
{
}
#typev  fdo_cpp2969 84 "%0unable to terminate host process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdFdoDevice::RdCloseProcessReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp2956 83 "%0unable to open host process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdFdoDevice::RdCloseProcessReply
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp2926 82 "%0host process fails CloseProcess %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdCloseProcessReply
{
ReplyHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp3591 100 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdWdmDeviceObject2RdFdoDevice
{
rdFdoDevice, ItemPtr -- 10
}
#typev  fdo_cpp3587 99 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdWdmDeviceObject2RdFdoDevice
{
DeviceObject, ItemPtr -- 10
}
#typev  fdo_cpp3622 102 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::HostProcessReady
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp3602 101 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::HostProcessReady
{
}
#typev  fdo_cpp3774 107 "%0%!FUNC!: reporting device failed due to %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPnpDeviceState
{
m_HostProblem.ProblemCode, ItemEnum(WudfProblem) -- 10
}
#typev  fdo_cpp4790 121 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::GetRemoteInterfaceRemovalMessage
{
msg, ItemPtr -- 10
}
#typev  fdo_cpp4758 120 "%0RemoteInterfaceRegistration Pre-allocated Removal Message not allocated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::GetRemoteInterfaceRemovalMessage
{
}
#typev  fdo_cpp4736 119 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::GetRemoteInterfaceRemovalMessage
{
}
#typev  fdo_cpp4908 124 "%0TargetDeviceNotification Message not allocated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::PreAllocateTargetDeviceNotificationMsg
{
}
#typev  fdo_cpp5378 139 "%0%!FUNC!: Direct Mapping threshold size is 0x%10!08x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
m_DirectMappingThreshold, ItemLong -- 10
}
#typev  fdo_cpp5367 138 "%0%!FUNC!: Direct Mapping threshold < PAGE_SIZE * 2 - adjusting to 0x%10!08x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
(PAGE_SIZE * 2), ItemLong -- 10
}
#typev  fdo_cpp5327 137 "%0m_UpperDriverOK = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
m_KernelModeClientPolicy, ItemLong -- 10
}
#typev  fdo_cpp5316 136 "%0Both KernelModeClientPolicy and UpperDriverOK registry values are set.  KernelModeClientPolicy will take precedence." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
}
#typev  fdo_cpp5289 135 "%0m_KernelModeClientPolicy = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
m_KernelModeClientPolicy, ItemLong -- 10
}
#typev  fdo_cpp5283 134 "%0%!FUNC!: Invalid value (%10!u!) for 'KernelModeClientPolicy'" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
*(PWDF_KERNEL_MODE_CLIENT_POLICY_TYPE) keyInfo->Data, ItemLong -- 10
}
#typev  fdo_cpp5243 133 "%0m_MethodNeitherAction = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
m_MethodNeitherAction, ItemLong -- 10
}
#typev  fdo_cpp5237 132 "%0invalid method neither action value in registry %10!u!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
*(PWDF_METHOD_NEITHER_ACTION_TYPE)keyInfo->Data, ItemLong -- 10
}
#typev  fdo_cpp5207 131 "%0%!FUNC!: impersonation not allowed" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
}
#typev  fdo_cpp5196 130 "%0%!FUNC!: impersonation level is set to %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::LoadDeviceRegistrySettings
{
m_ImpersonationLevel, ItemLong -- 10
}
#typev  fdo_cpp843 40 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdPrepareToCommunicateWithHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp722 39 "%0%!FUNC!: no host process associated with device" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPrepareToCommunicateWithHost
{
}
#typev  fdo_cpp713 38 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdPrepareToCommunicateWithHost
{
}
#typev  fdo_cpp1287 60 "%0%!FUNC!: total string size too large %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1273 59 "%0%!FUNC!: invalid reference string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1258 58 "%0%!FUNC!: total string size too large %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1244 57 "%0%!FUNC!: invalid attach device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1228 56 "%0%!FUNC!: invalid pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1359 61 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::AddDeviceMessage
{
msg, ItemPtr -- 10
}
#typev  fdo_cpp1212 55 "%0%!FUNC!: host process object is null" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::AddDeviceMessage
{
}
#typev  fdo_cpp1207 54 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::AddDeviceMessage
{
}
#typev  fdo_cpp1518 66 "%0devobj 0x%10!p! found attached on top of UMDF reflector (this =0x%11!p!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdStartDevice
{
thisDeviceObject, ItemPtr -- 10
this, ItemPtr -- 11
}
#typev  fdo_cpp1494 65 "%0IoGetAttachedDeviceReference should never fail but it did" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdStartDevice
{
}
#typev  fdo_cpp2733 80 "%0%!FUNC!: (%10!u!, %11!u!) PnpTracker is already allocated" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPreallocatePnpTracker
{
IRP_MJ_PNP, ItemLong -- 10
IrpMinorCode, ItemLong -- 11
}
#typev  fdo_cpp2813 81 "%0%!FUNC!: (%10!u!, %11!u!) PnpTracker is already allocated" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPreallocatePowerTracker
{
IRP_MJ_POWER, ItemLong -- 10
IrpMinorCode, ItemLong -- 11
}
#typev  fdo_cpp4196 110 "%0%!FUNC!: asking drvmgr to terminate host for rdFdo 0x%10!p! - normal termination" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendCloseProcessMessage
{
this, ItemPtr -- 10
}
#typev  fdo_cpp4187 109 "%0%!FUNC!: asking drvmgr to terminate host for rdFdo 0x%10!p! for reason %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendCloseProcessMessage
{
this, ItemPtr -- 10
m_HostProblem.ProblemCode, ItemEnum(WudfProblem) -- 11
}
#typev  fdo_cpp4170 108 "%0RtlStringCchLengthW() on PDO name should never fail.  %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendCloseProcessMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp145 14 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::DisableDevice
{
}
#typev  fdo_cpp113 13 "%0%!FUNC!: error %10!s! reporting device termination PNP event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::DisableDevice
{
status, ItemNTSTATUS -- 10
}
#typev  fdo_cpp106 12 "%0%!FUNC!: reported device termination PNP event." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::DisableDevice
{
}
#typev  fdo_cpp53 11 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::DisableDevice
{
}
#typev  fdo_cpp45 10 "%0 Entering %!FUNC!(%10!s!: Operation %11!s! Message %12!s! Status %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::DisableDevice
{
Problem->ProblemCode, ItemEnum(WudfProblem) -- 10
Problem->Operation, ItemEnum(WudfOperationType) -- 11
Problem->Message, ItemEnum(_WUDFMESSAGE) -- 12
Problem->Status, ItemNTSTATUS -- 13
}
#typev  fdo_cpp553 28 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
}
#typev  fdo_cpp521 27 "%0unable to terminate host process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp504 26 "%0unable to open host process %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DMCONTROL FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp468 25 "%0%!FUNC!: Reply to CloseProcess, sent after AddDevice failure, returned error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp458 24 "%0%!FUNC!: unable to send CloseProcess message to driver manager after AddDevice failure." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
}
#typev  fdo_cpp424 23 "%0%!FUNC!: Reply to CloseDeviceStack, sent after AddDevice failure, returned error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp399 22 "%0%!FUNC!: unable to send CloseDeviceStack to host after AddDevice failure. %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
msgSendStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp360 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::SendTeardownMessagesOnAddDeviceFailure
{
}
#typev  fdo_cpp1004 46 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSendCreateDeviceStackMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp951 45 "%0%!FUNC!: Create device stack reply returned error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendCreateDeviceStackMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp925 44 "%0unable to send create device stack message - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendCreateDeviceStackMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp900 43 "%0%!FUNC!: Failed to allocate memory for close device stack work item %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendCreateDeviceStackMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp887 42 "%0%!FUNC!: Failed to allocate memory for close device stack work item context %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendCreateDeviceStackMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp859 41 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSendCreateDeviceStackMessageToHost
{
}
#typev  fdo_cpp1058 49 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdPrepareToSendAddDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1042 48 "%0%!FUNC!: unable to allocate control object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdPrepareToSendAddDevice
{
}
#typev  fdo_cpp1017 47 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdPrepareToSendAddDevice
{
}
#typev  fdo_cpp1114 51 "%0%!FUNC!: Add device reply returned error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendAddDeviceMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1087 50 "%0unable to send add device message - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdFdoDevice::RdSendAddDeviceMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp2092 74 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRemoveDevice
{
}
#typev  fdo_cpp2012 73 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdRemoveDevice
{
RemoveIrp, ItemPtr -- 10
PnpTracker, ItemPtr -- 11
}
#typev  fdo_cpp3401 95 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp3363 94 "%0lower device set DO_POWER_INRUSH.  not supported" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp3314 93 "%0%!FUNC!: unable to attach to devnode. pdo = 0x%10!p!, status = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
m_Pdo, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  fdo_cpp3247 92 "%0%!FUNC!: Unable to allocate rundown work-item - %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp3222 91 "%0%!FUNC!: unable to open device's diagnostics key - %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp3206 90 "%0%!FUNC!: unable to load device's registry settings - %10!s!" //   LEVEL=TRACE_LEVEL_FATAL FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp3181 89 "%0%!FUNC!: unable to get allocate TargetDeviceReg list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp3159 88 "%0%!FUNC!: unable to get allocate InterfaceReg list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp3137 87 "%0%!FUNC!: unable to get allocate symbolic link list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp3115 86 "%0%!FUNC!: unable to get allocate device interface list" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdFdoDevice
{
}
#typev  fdo_cpp3028 85 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdFdoDevice
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  fdo_cpp3576 98 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSetHostProcess
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp3541 97 "%0%!FUNC!: invalid host process object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSetHostProcess
{
}
#typev  fdo_cpp3537 96 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSetHostProcess
{
RdProcess, ItemPtr -- 10
}
#typev  fdo_cpp3761 106 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdFdoDevice::RdReply
{
}
#typev  fdo_cpp3700 104 "%0%!FUNC!: Received bad reply to message %10!d! (%11!p!) - problem %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdReply
{
messageId, ItemLong -- 10
replyHeader, ItemPtr -- 11
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 12
}
#typev  fdo_cpp3711 105 "%0%!FUNC!: Received good reply to message %10!d! (%11!p!) - status %12!#x!" //   LEVEL=(NT_SUCCESS(replyHeader->NtStatus) ? TRACE_LEVEL_INFORMATION : TRACE_LEVEL_ERROR) FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdReply
{
messageId, ItemLong -- 10
replyHeader, ItemPtr -- 11
replyHeader->NtStatus, ItemLong -- 12
}
#typev  fdo_cpp3646 103 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdFdoDevice::RdReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  fdo_cpp4482 112 "%0%!FUNC!: Host replied to synchronous message with error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendSynchronousMessageToHost
{
messageReplyHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp4466 111 "%0%!FUNC!: unable to send synchronous message - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::SendSynchronousMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp4700 118 "%0 Exiting  %!FUNC! => (%10!I64u!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSendRemoteInterfaceArrivalMessageToHost
{
InterfaceContext, ItemULongLong -- 10
}
#typev  fdo_cpp4574 114 "%0%!FUNC!: RemoteInterface SymbolicLink is invalid: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendRemoteInterfaceArrivalMessageToHost
{
pSymbolicLink->Buffer, ItemWString -- 10
}
#typev  fdo_cpp4689 117 "%0Host failed RemoteInterfaceArrival message. Error: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendRemoteInterfaceArrivalMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp4657 116 "%0Unable to communicate with host, while trying to send RemoteInterfaceArrival message - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendRemoteInterfaceArrivalMessageToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp4589 115 "%0RemoteInterfaceRegistration Message not allocated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendRemoteInterfaceArrivalMessageToHost
{
}
#typev  fdo_cpp4544 113 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSendRemoteInterfaceArrivalMessageToHost
{
}
#typev  fdo_cpp4850 123 "%0Host failed RemoteInterfaceRemoval message. Error: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendRemoteInterfaceRemovalMsgToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp4827 122 "%0Unable to communicate with host, while trying to send RemoteInterfaceRemoval message - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendRemoteInterfaceRemovalMsgToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp5092 129 "%0Sent TargetDeviceNotification message to host. NTSTATUS: %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendTargetDeviceNotificationMsgToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp5023 127 "%0TargetDeviceNotification Message not allocated" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendTargetDeviceNotificationMsgToHost
{
}
#typev  fdo_cpp5071 128 "%0Unable to communicate with host, while trying to send TargetDeviceNotification message - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendTargetDeviceNotificationMsgToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp4987 126 "%0Custom Event size was formatted incorrectly, ignoring event" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdSendTargetDeviceNotificationMsgToHost
{
}
#typev  fdo_cpp4972 125 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdSendTargetDeviceNotificationMsgToHost
{
}
#typev  fdo_cpp225 19 "%0%!FUNC!: unable to allocate RdFdoDevice object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
}
#typev  fdo_cpp211 18 "%0%!FUNC!: unable to query pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp197 17 "%0%!FUNC!: unable to allocate memory for pdo name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
}
#typev  fdo_cpp327 20 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp186 16 "%0%!FUNC!: unable to query pdo name length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdAddDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp172 15 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdAddDevice
{
DriverObject, ItemPtr -- 10
PhysicalDeviceObject, ItemPtr -- 11
}
#typev  fdo_cpp1960 72 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseDeviceStackReply
{
}
#typev  fdo_cpp1946 71 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseDeviceStackReply
{
}
#typev  fdo_cpp1912 70 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseDeviceStackReply
{
}
#typev  fdo_cpp1872 69 "%0%!FUNC!: Close device stack failed due to host problem %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdCloseDeviceStackReply
{
Problem->ProblemCode, ItemEnum(WudfProblem) -- 10
}
#typev  fdo_cpp1866 68 "%0%!FUNC!: host process fails close device stack %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_FDO FUNC=RdFdoDevice::RdCloseDeviceStackReply
{
replyLocal.Header.NtStatus, ItemNTSTATUS -- 10
}
#typev  fdo_cpp1828 67 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdFdoDevice::RdCloseDeviceStackReply
{
LpcMessage, ItemPtr -- 10
RdFdo, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
6415ee0a-fe49-dbc0-1852-366c6b4f1b3a WUDFRd // SRC=pnp.cpp MJ= MN=
#typev  pnp_cpp1606 27 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostIrpReply
{
}
#typev  pnp_cpp1418 26 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostIrpReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  pnp_cpp1864 35 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
STATUS_MORE_PROCESSING_REQUIRED, ItemNTSTATUS -- 10
}
#typev  pnp_cpp1844 34 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
}
#typev  pnp_cpp373 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpTracker
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  pnp_cpp363 11 "%0%!FUNC!: unable to allocate workitem ..." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpTracker
{
}
#typev  pnp_cpp283 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpTracker
{
RdFdoDevice, ItemPtr -- 10
Irp, ItemPtr -- 11
Rules, ItemPtr -- 12
AssumeDeviceDisabled, ItemListLong(false,true) -- 13
}
#typev  pnp_cpp1735 29 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostCompletionReply
{
}
#typev  pnp_cpp1642 28 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostCompletionReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  pnp_cpp1822 33 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
status, ItemNTSTATUS -- 10
}
#typev  pnp_cpp1817 32 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
PnpTracker, ItemPtr -- 12
}
#typev  pnp_cpp1381 25 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostReply
{
}
#typev  pnp_cpp1351 24 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!, %13!Id!, %14!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHostReply
{
LpcMessage, ItemPtr -- 10
Irp, ItemPtr -- 11
ReplyHeader, ItemPtr -- 12
ReplyHeaderSize, ItemPtr -- 13
Problem ? Problem->ProblemCode : WudfProblem_None, ItemEnum(WudfProblem) -- 14
}
#typev  pnp_cpp1786 31 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpForwardToLowerDevice
{
}
#typev  pnp_cpp1759 30 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpForwardToLowerDevice
{
}
#typev  pnp_cpp1315 23 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHost
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  pnp_cpp1205 22 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_IO FUNC=RdPnpTracker::RdForwardRequestToHost
{
Irp, ItemPtr -- 10
Completion, ItemListLong(false,true) -- 11
}
#typev  pnp_cpp1157 21 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpProcessor
{
}
#typev  pnp_cpp1105 20 "%0%!FUNC!: completing pnp irp 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpProcessor
{
m_Irp, ItemPtr -- 10
}
#typev  pnp_cpp818 19 "%0%!FUNC!: forward irp to host on its way DOWN" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnpProcessor
{
}
#typev  pnp_cpp762 18 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpProcessor
{
}
#typev  pnp_cpp1907 37 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCallbackAtPassiveInSystemProcess
{
}
#typev  pnp_cpp1891 36 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=RD_TRACE_FDO FUNC=RdPnpTracker::RdPnpCallbackAtPassiveInSystemProcess
{
DeviceObject, ItemPtr -- 10
PnpTracker, ItemPtr -- 11
}
#typev  pnp_cpp676 16 "%0%!FUNC!: completing pnp irp %10!p! due to %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
Irp, ItemPtr -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  pnp_cpp718 17 "%0%!FUNC!: Dispatch: returning %10!s! for PnP irp %11!p! (type %12!#x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
ntStatus, ItemNTSTATUS -- 10
Irp, ItemPtr -- 11
minorFunc, ItemLong -- 12
}
#typev  pnp_cpp632 15 "%0%!FUNC!: no preallocated pnp tracker for semi-critical irp (%10!u!, %11!u!)" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
majorFunc, ItemLong -- 10
minorFunc, ItemLong -- 11
}
#typev  pnp_cpp592 14 "%0%!FUNC!: host process is not ready for irp 0x%10!p!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
Irp, ItemPtr -- 10
}
#typev  pnp_cpp569 13 "%0%!FUNC!: Dispatch: Received PnP irp %10!p! (type %11!#x!)" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=RD_TRACE_PNP FUNC=RdPnpTracker::RdPnp
{
Irp, ItemPtr -- 10
minorFunc, ItemLong -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
e663fcb3-aa54-8602-aa8b-ad70734f6722 WUDFRd // SRC=device.cpp MJ= MN=
#typev  device_cpp368 24 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::~RdDevice
{
}
#typev  device_cpp359 23 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::~RdDevice
{
}
#typev  device_cpp385 26 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdMimicDeviceFlags
{
}
#typev  device_cpp375 25 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdMimicDeviceFlags
{
}
#typev  device_cpp400 28 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdWdmDeviceObject2RdDevice
{
deviceExtension->RdDevice, ItemPtr -- 10
}
#typev  device_cpp396 27 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdWdmDeviceObject2RdDevice
{
DeviceObject, ItemPtr -- 10
}
#typev  device_cpp1189 49 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::ProcessIrp
{
status, ItemNTSTATUS -- 10
}
#typev  device_cpp1128 48 "%0 Entering %!FUNC!(%10!p! (%11!d!))" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::ProcessIrp
{
Irp, ItemPtr -- 10
majorFunc, ItemLong -- 11
}
#typev  device_cpp62 11 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdIoCompletion
{
Irp->IoStatus.Status, ItemNTSTATUS -- 10
}
#typev  device_cpp51 10 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdIoCompletion
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  device_cpp333 22 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp136 13 "%0%!FUNC!: unsupported device type %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
DeviceType, ItemLong -- 10
}
#typev  device_cpp301 21 "%0%!FUNC!: unable to create symbolic link %10!s! for %11!s! %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
m_DosDeviceName.Buffer, ItemWString -- 10
ntDeviceNameUnicode.Buffer, ItemWString -- 11
ntStatus, ItemNTSTATUS -- 12
}
#typev  device_cpp284 20 "%0%!FUNC!: unable to build dos device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp270 19 "%0%!FUNC!: unable to allocate memory for dos device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp259 18 "%0%!FUNC!: dosDeviceNameLen would exceeed MAXUSHORT" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp222 17 "%0%!FUNC!: unable to create device object. status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp180 16 "%0%!FUNC!: unable to build nt device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp166 15 "%0%!FUNC!: unable to allocate memory for nt device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
}
#typev  device_cpp154 14 "%0%!FUNC!: invalid device name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdDevice
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp94 12 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!s!, %13!d!, %14!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDevice::RdDevice
{
RdDriver, ItemPtr -- 10
RdDeviceName, ItemWString -- 11
WdmDeviceName, ItemWString -- 12
DeviceType, ItemLong -- 13
Parent, ItemPtr -- 14
}
#typev  device_cpp1010 46 "%0%!FUNC!: unable to create/open registry key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDevice::RdCreateRegKeyPath
{
}
#typev  device_cpp1047 47 "%0%!FUNC!: unable to open key for user access" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateRegKeyPath
{
}
#typev  device_cpp612 34 "%0%!FUNC!: unable to open hardware sub key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreatePnpRegKey
{
}
#typev  device_cpp589 33 "%0%!FUNC!: unable to open hardware root key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreatePnpRegKey
{
}
#typev  device_cpp517 31 "%0%!FUNC!: caller attempted to create/open subkey %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreatePnpRegKey
{
InvalidPrefixes[i], ItemWString -- 10
}
#typev  device_cpp540 32 "%0%!FUNC!: unable to open device key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreatePnpRegKey
{
}
#typev  device_cpp477 30 "%0%!FUNC!: Unknown value for PnPKeyType" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreatePnpRegKey
{
}
#typev  device_cpp468 29 "%0%!FUNC!: MainString keys must not be NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreatePnpRegKey
{
}
#typev  device_cpp777 40 "%0%!FUNC!: unable to open device interface key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateDevInterfaceRegKey
{
}
#typev  device_cpp746 39 "%0%!FUNC!: unable to find reference string (%10!s!, %11!s!)" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateDevInterfaceRegKey
{
&storeParameters->InterfaceGUID, ItemGuid -- 10
storeParameters->RefString, ItemWString -- 11
}
#typev  device_cpp720 38 "%0%!FUNC!: Wrong value for reference string length" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_CONTROL FUNC=RdDevice::RdCreateDevInterfaceRegKey
{
}
#typev  device_cpp700 37 "%0%!FUNC!: Reference string length is not correct %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateDevInterfaceRegKey
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  device_cpp684 36 "%0%!FUNC!: Failed to probe and read memory" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateDevInterfaceRegKey
{
}
#typev  device_cpp668 35 "%0%!FUNC!: unable to allocate memory for stored parameters" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateDevInterfaceRegKey
{
}
#typev  device_cpp911 45 "%0%!FUNC!: unable to open legacy hardware key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateLegacyHardwareRegKey
{
}
#typev  device_cpp888 44 "%0%!FUNC!: unable to open legacy hardware key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateLegacyHardwareRegKey
{
}
#typev  device_cpp857 43 "%0%!FUNC!: unable to open HKLM\HARDWARE\DEVICEMAP key" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateLegacyHardwareRegKey
{
}
#typev  device_cpp834 42 "%0%!FUNC!: Legacy hardware keys must be created volatile" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateLegacyHardwareRegKey
{
}
#typev  device_cpp826 41 "%0%!FUNC!: LegacyMapName keys must not be NULL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDevice::RdCreateLegacyHardwareRegKey
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
a2c30c2f-cce4-fa56-9bba-f919b245e43e WUDFRd // SRC=driver.cpp MJ= MN=
#typev  driver_cpp156 16 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdUnload
{
}
#typev  driver_cpp144 15 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdUnload
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp426 22 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::~RdDriver
{
}
#typev  driver_cpp399 21 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::~RdDriver
{
}
#typev  driver_cpp547 27 "%0 Exiting  %!FUNC! => (fastio completed:%10!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdFastIoDeviceDispatch
{
requestCompleted, ItemLong -- 10
}
#typev  driver_cpp525 26 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdFastIoDeviceDispatch
{
DeviceObject, ItemPtr -- 10
FileObject, ItemPtr -- 11
}
#typev  driver_cpp582 29 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDispatch
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp562 28 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDispatch
{
DeviceObject, ItemPtr -- 10
Irp, ItemPtr -- 11
}
#typev  driver_cpp662 35 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdFreeUniqueDeviceName
{
UniqueName, ItemWString -- 10
}
#typev  driver_cpp905 46 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::CloseProcessMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp879 45 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::CloseProcessMessage
{
}
#typev  driver_cpp1121 57 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::UnprepareSharedResources
{
}
#typev  driver_cpp1106 56 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::UnprepareSharedResources
{
}
#typev  driver_cpp1358 69 "%0unable to connect to lpc server port %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::InitializeLpcAndConnect
{
m_WdfLpcInterface->WdfGetProcessManagementName(), ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  driver_cpp1343 68 "%0Driver Manager is not available - switching to nil mode." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::InitializeLpcAndConnect
{
}
#typev  driver_cpp1318 67 "%0%!FUNC!: unable to allocate a DrvMgr sid " //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DEVICE FUNC=RdDriver::InitializeLpcAndConnect
{
}
#typev  driver_cpp1297 66 "%0%!FUNC!: unable to allocate RdLpcNotification object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::InitializeLpcAndConnect
{
}
#typev  driver_cpp1287 65 "%0%!FUNC!: unable to allocate lpc object - error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::InitializeLpcAndConnect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1274 64 "%0%!FUNC!: unable to create periodic timer object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::InitializeLpcAndConnect
{
}
#typev  driver_cpp1260 63 "%0%!FUNC!: unable to get lpc interface object - error %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::InitializeLpcAndConnect
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1245 62 "%0%!FUNC!: LPC driver is not yet loaded - device cannot start but will retry later" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::InitializeLpcAndConnect
{
}
#typev  driver_cpp649 34 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdCreateUniqueName
{
name, ItemWString -- 10
}
#typev  driver_cpp641 33 "%0%!FUNC!: unable to create unique name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdCreateUniqueName
{
}
#typev  driver_cpp623 32 "%0%!FUNC!: unable to allocate buffer for unique device name" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdCreateUniqueName
{
}
#typev  driver_cpp602 31 "%0%!FUNC!: ExUuidCreate failed with status %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdCreateUniqueName
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp597 30 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdCreateUniqueName
{
}
#typev  driver_cpp731 38 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::ControlObjectMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp689 37 "%0%!FUNC!: invalid control object name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::ControlObjectMessage
{
ControlObjectName, ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  driver_cpp677 36 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::ControlObjectMessage
{
ControlObjectName, ItemWString -- 10
}
#typev  driver_cpp798 41 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::QueryProcessMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp758 40 "%0%!FUNC!: invalid pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::QueryProcessMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp746 39 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::QueryProcessMessage
{
PdoName, ItemWString -- 10
}
#typev  driver_cpp865 44 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::OpenProcessMessage
{
msg, ItemPtr -- 10
}
#typev  driver_cpp825 43 "%0%!FUNC!: invalid pdo name %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::OpenProcessMessage
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp813 42 "%0 Entering %!FUNC!(%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::OpenProcessMessage
{
PdoName, ItemWString -- 10
}
#typev  driver_cpp1097 55 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::PrepareSharedResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1060 54 "%0unable to init cancel safe queue object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1052 53 "%0unable to allocate cancel safe queue object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp1040 52 "%0control object message failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
replyHeader->NtStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1032 51 "%0unable to sent control object info to drvmgr" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp1022 50 "%0unable to create control object message" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp1011 49 "%0unable to init driver manager control object %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1003 48 "%0unable to create driver manager control object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp973 47 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::PrepareSharedResources
{
}
#typev  driver_cpp393 20 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDriver
{
NT_SUCCESS(ntStatus), ItemListLong(false,true) -- 10
}
#typev  driver_cpp362 19 "%0%!FUNC!: unable to open WUDF key %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp337 18 "%0%!FUNC!: failure to initialize LPC" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdDriver
{
}
#typev  driver_cpp193 17 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdDriver
{
DriverObject, ItemPtr -- 10
}
#typev  driver_cpp129 14 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DriverEntry
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp74 11 "%0%!FUNC!: unable to allocate driver object extension" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=DriverEntry
{
}
#typev  driver_cpp106 13 "%0%!FUNC!: Unable to init RdDriver %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=DriverEntry
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp98 12 "%0%!FUNC!: unable to allocate RdDriver object" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=DriverEntry
{
}
#typev  driver_cpp59 10 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DriverEntry
{
DriverObject, ItemPtr -- 10
RegistryPath, ItemPWString -- 11
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
// PDB:  Last Updated :2010-2-9:4:5:50:156 (UTC) [tracepdb]
a2c30c2f-cce4-fa56-9bba-f919b245e43e WUDFRd // SRC=driver.cpp MJ= MN=
#typev  driver_cpp489 25 "%0 Exiting  %!FUNC! => (%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdGetDriver
{
rdDriver, ItemPtr -- 10
}
#typev  driver_cpp479 24 "%0unable to get driver object extension" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=RD_TRACE_DRIVER FUNC=RdDriver::RdGetDriver
{
}
#typev  driver_cpp471 23 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::RdGetDriver
{
}
#typev  driver_cpp1156 59 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::FindAndReferenceRemoteInterfaceRegistration
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1132 58 "%0 Entering %!FUNC!(InterfaceReg = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::FindAndReferenceRemoteInterfaceRegistration
{
InterfaceReg, ItemPtr -- 10
}
#typev  driver_cpp1191 61 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::FindAndReferenceTargetDeviceRegistration
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  driver_cpp1167 60 "%0 Entering %!FUNC!(TargetDeviceReg = %10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=RdDriver::FindAndReferenceTargetDeviceRegistration
{
TargetDeviceReg, ItemPtr -- 10
}
0d78a427-89cb-80b6-8f93-f3bb0383080f e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
#enumv WudfProblem
{
WudfProblem_None,0x0
WudfProblem_Cancelled,0x1
WudfProblem_SendFailure,0x2
WudfProblem_Timeout,0x3
WudfProblem_InvalidRequest,0x4
WudfProblem_InvalidReply,0x5
WudfProblem_FailedCriticalOperation,0x6
WudfProblem_FailedToExit,0x7
WudfProblem_Disconnect,0x8
WudfProblem_LeakingHandle,0x9
WudfProblem_Max,0xA
}
#enumv _LOCK_OPERATION
{
IoReadAccess,0x0
IoWriteAccess,0x1
IoModifyAccess,0x2
}
#enumv _WUDF_IRP_BUFFER_INDEX
{
IrpBufferIndexPrimary,0x0
IrpBufferIndexSecondary,0x1
IrpBufferIndexMax,0x2
}
#enumv _WUDF_IRP_COPY_DIRECTION
{
CopyDirectionToHost,0x1
CopyDirectionFromHost,0x2
}
f2c9c1a5-c287-5c56-8db5-e99e1b9e3a43 e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
#enumv WudfProblem
{
WudfProblem_None,0x0
WudfProblem_Cancelled,0x1
WudfProblem_SendFailure,0x2
WudfProblem_Timeout,0x3
WudfProblem_InvalidRequest,0x4
WudfProblem_InvalidReply,0x5
WudfProblem_FailedCriticalOperation,0x6
WudfProblem_FailedToExit,0x7
WudfProblem_Disconnect,0x8
WudfProblem_LeakingHandle,0x9
WudfProblem_Max,0xA
}
#enumv WudfOperationType
{
WudfOperation_Invalid,0x0
WudfOperation_Init,0x1
WudfOperation_HostShutdown,0x2
WudfOperation_Pnp,0x3
WudfOperation_Cleanup,0x4
WudfOperation_Close,0x5
WudfOperation_Cancel,0x6
WudfOperation_IO,0x7
WudfOperation_Other,0x8
WudfOperation_Max,0x9
}
#enumv _WUDFMESSAGE
{
WudfMsg_Reserved,0x0
WudfMsg_IRP,0x1
WudfMsg_IRP_Completion,0x2
WudfMsg_CREATE_DEVICE_STACK,0x3
WudfMsg_ADD_DEVICE,0x4
WudfMsg_CREATE,0x5
WudfMsg_CLOSE,0x6
WudfMsg_CLEANUP,0x7
WudfMsg_READ,0x8
WudfMsg_WRITE,0x9
WudfMsg_IOCONTROL,0xA
WudfMsg_FLUSH,0xB
WudfMsg_QUERY_INFORMATION_FILE,0xC
WudfMsg_SET_INFORMATION_FILE,0xD
WudfMsg_Cancel,0xE
WudfMsg_POWER_IRP_COMPLETE,0xF
WudfMsg_USB_SS_EVENT,0x10
WudfMsg_CLOSE_DEVICE_STACK,0x11
WudfMsg_REMOTE_INTERFACE_ARRIVAL,0x12
WudfMsg_REMOTE_INTERFACE_REMOVAL,0x13
WudfMsg_TARGET_DEVICE_NOTIFICATION,0x14
WudfMsg_TRANSPORT_QUERY_ID,0x15
WudfMsg_FramworkMax,0x16
WudfMsg_ExitProcess,0x17
WdfProcMgmt_Message_Reserved,0x18
WdfProcMgmt_Message_ControlObjectName,0x19
WdfProcMgmt_Message_QueryProcess,0x1A
WdfProcMgmt_Message_OpenProcess,0x1B
WdfProcMgmt_Message_CloseProcess,0x1C
WudfMsg_Connect,0x1D
WudfMsg_WMI_POWER_DATA,0x1E
WudfMsg_Max,0x1F
}
6415ee0a-fe49-dbc0-1852-366c6b4f1b3a e:\5359.obj.x86fre\drivers\wdf\umdf\redirector\driver\objfre\i386\WUDFRd.pdb
#enumv WudfProblem
{
WudfProblem_None,0x0
WudfProblem_Cancelled,0x1
WudfProblem_SendFailure,0x2
WudfProblem_Timeout,0x3
WudfProblem_InvalidRequest,0x4
WudfProblem_InvalidReply,0x5
WudfProblem_FailedCriticalOperation,0x6
WudfProblem_FailedToExit,0x7
WudfProblem_Disconnect,0x8
WudfProblem_LeakingHandle,0x9
WudfProblem_Max,0xA
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:985 (UTC) [tracepdb]
3e80e586-486f-78b0-9c71-0a5b78cb4e8c WUDFSvc // SRC=dll.cpp MJ= MN=
#typev  dll_cpp125 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=MGR_TRACE_MGR FUNC=WdfRegisterStopCallback
{
result, ItemWINERROR -- 10
}
#typev  dll_cpp118 11 "%0%!FUNC!: SvcHostGlobalData->RegisterStopCallback failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfRegisterStopCallback
{
result, ItemWINERROR -- 10
}
#typev  dll_cpp97 10 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!p!, %13!p!, %14!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=MGR_TRACE_MGR FUNC=WdfRegisterStopCallback
{
CallbackObject, ItemPtr -- 10
ServiceName, ItemWString -- 11
Event, ItemPtr -- 12
Callback, ItemPtr -- 13
Context, ItemPtr -- 14
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:985 (UTC) [tracepdb]
c7952ece-bdbc-92da-93c2-faca245bce79 WUDFSvc // SRC=process.cpp MJ= MN=
#typev  process_cpp1280 45 "%0host process debugger enabled.  override process timeout" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::QueryProcessTimeout
{
}
#typev  process_cpp1270 44 "%0unable to get host process timeout. use default" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::QueryProcessTimeout
{
}
#typev  process_cpp1252 43 "%0unable to get host process timeout. use default" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::QueryProcessTimeout
{
}
#typev  process_cpp1229 42 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::QueryProcessTimeout
{
HostGuid, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp1212 41 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::QueryProcessTimeout
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp865 39 "%0unable to query %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::LoadRegistrySettings
{
WDF_DRIVER_HOST_IMAGE_PATH, ItemWString -- 10
}
#typev  process_cpp847 38 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::LoadRegistrySettings
{
GetName(), ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp831 37 "%0unable to open reg key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::LoadRegistrySettings
{
WDF_ROOT_SERVICE_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  process_cpp1064 40 "%0::TerminateProcess() failed %10!s!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=MGR_TRACE_DEVNODE FUNC=WdfProcess::TerminateProcess
{
shutdownStatus, ItemWINERROR -- 10
}
#typev  process_cpp628 33 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::WdfProcess
{
NT_SUCCESS(ntStatus), ItemListLong(false,true) -- 10
}
#typev  process_cpp580 32 "%0unable to connect to host process lpc port %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
m_EventPortName[WdfEventPort_System], ItemWString -- 10
ntStatus, ItemNTSTATUS -- 11
}
#typev  process_cpp549 31 "%0hostProcess terminated unexpectedly" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp516 30 "%0unable to get host process to start running %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=LPCDRVR_TRACE_DEVICE FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp473 29 "%0unable to generate path to host process log files - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
hResult, ItemHRESULT -- 10
}
#typev  process_cpp450 28 "%0unable to create hostProcess: %10!s!." //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp414 27 "%0Unable to create host security descriptor: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp385 26 "%0unable to LogonUser: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp365 25 "%0Unable to allocate admin SID" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp340 24 "%0CreateProcess cmdbuf: imagepath:%10!s! args:%11!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
m_HostImagePath, ItemWString -- 10
cmdBuf, ItemWString -- 11
}
#typev  process_cpp330 23 "%0unable to compose create process command %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
winerr, ItemWINERROR -- 10
}
#typev  process_cpp253 20 "%0unable to construct server port name HostProcess-%10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
baseName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  process_cpp239 19 "%0unable to allocate memory for server port name %10!u!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
portNameIndex, ItemLong -- 10
}
#typev  process_cpp226 18 "%0unable to create server port name string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp216 17 "%0unable to create GUID for server portname %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp307 22 "%0unable to allocate cmdline buffer" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp299 21 "%0createprocess cmd length = 0x%10!I64x! characters" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
(ULONGLONG) cmdBufLen, ItemLongLongX -- 10
}
#typev  process_cpp200 16 "%0Unable to convert lifetime ID to string: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp185 15 "%0Unable to copy hardware id: %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
hResultLocal, ItemHRESULT -- 10
}
#typev  process_cpp171 14 "%0Unable to allocate memory for copying Hardware Id" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp162 13 "%0Unable to calculate hardware id length: %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
hResultLocal, ItemHRESULT -- 10
}
#typev  process_cpp141 12 "%0Unable to create lifetime ID for new host process: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
rpcStatus, ItemWINERROR -- 10
}
#typev  process_cpp111 11 "%0Unable to allocate memory for copying Device Group Id string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::WdfProcess
{
}
#typev  process_cpp52 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::WdfProcess
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
#typev  process_cpp801 36 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::~WdfProcess
{
}
#typev  process_cpp757 35 "%0process not terminating gracefully: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfProcess::~WdfProcess
{
result, ItemWINERROR -- 10
}
#typev  process_cpp674 34 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfProcess::~WdfProcess
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:985 (UTC) [tracepdb]
a1c9cc2e-2c37-a5fe-2ace-f03e726e2e2a WUDFSvc // SRC=DrvMgr.cpp MJ= MN=
#typev  DrvMgr_cpp1914 63 "%0unable to find driver in system directory %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1898 62 "%0unable to find image path for driver: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
FileName, ItemWString -- 10
}
#typev  DrvMgr_cpp1887 61 "%0unable to get full path length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1871 60 "%0unable to find system directory %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1860 59 "%0unable to allocate system directory buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=SearchWindowSystemPath
{
}
#typev  DrvMgr_cpp1976 66 "%0driver host guid %10!s! not in {...} format" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
uuidCopy, ItemWString -- 10
}
#typev  DrvMgr_cpp1993 67 "%0invalid host guid: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
uuidCopy, ItemWString -- 10
}
#typev  DrvMgr_cpp1963 65 "%0unable to allocate memory need to validate GUID string" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
}
#typev  DrvMgr_cpp1953 64 "%0guid string too short: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ValidateGUIDString
{
Guid, ItemWString -- 10
}
#typev  DrvMgr_cpp2154 72 "%0Created activity log." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
}
#typev  DrvMgr_cpp2117 71 "%0Failed to configure activity trace: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
hr, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp2096 70 "%0Failed to create activity log session: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
hr, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp2071 69 "%0Failed to create log directory security descriptor: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp2023 68 "%0Starting activity log" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StartActivityLog
{
}
#typev  DrvMgr_cpp2169 73 "%0Stopped activity log." //   LEVEL=TRACE_LEVEL_FATAL FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::StopActivityLog
{
}
#typev  DrvMgr_cpp2315 75 "%0unable to enable device %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::EnableDevice
{
cmResult, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp2368 76 "%0unable to disable device %10!s!.  veto type = 0x%11!x!, veto name %12!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::DisableDevice
{
cmResult, ItemHRESULT -- 10
vetoType, ItemLong -- 11
vetoName, ItemWString -- 12
}
#typev  DrvMgr_cpp2727 86 "%0SetupDiEnumDeviceInfo failed with error %10!s! when we were attempting to check for the presence of device %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=CheckForDevicePresence
{
err, ItemWINERROR -- 10
DeviceInstanceId, ItemWString -- 11
}
#typev  DrvMgr_cpp2706 85 "%0SetupDiGetClassDevs failed with error %10!s! when we were attempting to check for the presence of device %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=CheckForDevicePresence
{
err, ItemWINERROR -- 10
DeviceInstanceId, ItemWString -- 11
}
#typev  DrvMgr_cpp239 16 "%0%!FUNC!: unable to get system directory %10!s!" //   LEVEL=TRACE_LEVEL_CRITICAL FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::InitializePlatformLibrary
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp315 17 "%0Calling WdfDriverManager::WdfDriverManager()...1" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::WdfDriverManager
{
}
#typev  DrvMgr_cpp1101 34 "%0m_DefaultHostProcessGUID = %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_DefaultHostProcessGUID, ItemWString -- 10
}
#typev  DrvMgr_cpp1062 33 "%0registry entry %10!s! not found" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::LoadRegistrySettings
{
WDF_DEFAULT_HOST_PROCESS_GUID, ItemWString -- 10
}
#typev  DrvMgr_cpp1046 32 "%0invalid max. number of device stacks%10!u!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp1040 31 "%0m_NumDeviceStacksMax = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp1034 30 "%0unable to get process exit timeout value. use default" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
}
#typev  DrvMgr_cpp995 29 "%0invalid max. number of device stacks%10!u!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp989 28 "%0m_NumDeviceStacksMax = %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
m_NumDeviceStacksMax, ItemLong -- 10
}
#typev  DrvMgr_cpp983 27 "%0unable to get process exit timeout value. use default" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
}
#typev  DrvMgr_cpp964 26 "%0unable to open reg key %10!s!. er = %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::LoadRegistrySettings
{
WDF_ROOT_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  DrvMgr_cpp1349 37 "%0 Exiting  %!FUNC! => (true)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetControlObject
{
}
#typev  DrvMgr_cpp1346 36 "%0 Exiting  %!FUNC! => (false)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetControlObject
{
}
#typev  DrvMgr_cpp1305 35 "%0 Entering %!FUNC!(%10!s!, %11!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetControlObject
{
ControlObjectName, ItemWString -- 10
ControlObjectNameLen, ItemPtr -- 11
}
#typev  DrvMgr_cpp1456 41 "%0waited %10!u! msec before trying to enable device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
DRVMGR_DEVICE_RESTART_MAX_WAIT_MSEC - retryCount * DRVMGR_DEVICE_RESTART_DELAY_100_MSEC, ItemLong -- 10
}
#typev  DrvMgr_cpp1432 40 "%0%!FUNC!: unable to get device status 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
configRet, ItemLong -- 10
}
#typev  DrvMgr_cpp1412 39 "%0%!FUNC!: SetupDiOpenDeviceInfo() failed %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1395 38 "%0%!FUNC!: unable to get devinfoset %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::RestartFailedDevice
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1837 58 "%0 Exiting  %!FUNC! => (%10!s! (%11!s!))" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetRdProcessId
{
bResult, ItemListLong(false,true) -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1816 57 "%0%!FUNC!: RD_IOCTL_SET_PROCESS_ID call failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDriverManager::SetRdProcessId
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1796 56 "%0%!FUNC!: unable to open control object %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
m_NtControlObjectName, ItemWString -- 10
GetLastError(), ItemWINERROR -- 11
}
#typev  DrvMgr_cpp1773 55 "%0%!FUNC!: unable to copy pdo name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
PdoName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1759 54 "%0%!FUNC!: unable to copy non-state-changing event port name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
NonStateChangingEventPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1744 53 "%0%!FUNC!: unable to copy system event port name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
SystemEventPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1729 52 "%0%!FUNC!: unable to copy io cancel port name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
IoCancelPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1714 51 "%0%!FUNC!: unable to copy io event port name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
IoEventPortName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1699 50 "%0%!FUNC!: unable to copy lifetime id %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
lifetimeIdString, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1685 49 "%0Unable to convert lifetime ID for host process to string: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=WdfDriverManager::SetRdProcessId
{
rpcStatus, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp1673 48 "%0%!FUNC!: unable to allocate set pid message 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
(DWORD) messageSize, ItemLong -- 10
}
#typev  DrvMgr_cpp1663 47 "%0%!FUNC!: set pid message too large 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
(DWORD) messageSize, ItemLong -- 10
}
#typev  DrvMgr_cpp1655 46 "%0pdoNameLen (%10!u!) too large" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
(DWORD) pdoNameLen, ItemLong -- 10
}
#typev  DrvMgr_cpp1646 45 "%0pdoNameLen (%10!u!) too large" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
(DWORD) pdoNameLen, ItemLong -- 10
}
#typev  DrvMgr_cpp1631 44 "%0%!FUNC!: invalid pdo name %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::SetRdProcessId
{
PdoName, ItemWString -- 10
hResult, ItemHRESULT -- 11
}
#typev  DrvMgr_cpp1612 43 "%0 Entering %!FUNC!(%10!p!, %11!s!, %12!s!, %13!s!, %14!s!, %15!s!, %16!s!, %17!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDriverManager::SetRdProcessId
{
ProcessHandle, ItemPtr -- 10
LifetimeId, ItemGuid -- 11
IoEventPortName, ItemWString -- 12
IoCancelPortName, ItemWString -- 13
SystemEventPortName, ItemWString -- 14
NonStateChangingEventPortName, ItemWString -- 15
PdoName, ItemWString -- 16
ProcessTimeout, ItemLong -- 17
}
#typev  DrvMgr_cpp2665 84 "%0numDeviceSucceeded: %10!u!. numDeviceFailed: %11!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
numDeviceSucceeded, ItemLong -- 10
numDeviceFailed, ItemLong -- 11
}
#typev  DrvMgr_cpp2602 83 "%0found a umdf device: status 0x%10!x! and problem 0x%11!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
deviceStatus, ItemLong -- 10
deviceProblem, ItemLong -- 11
}
#typev  DrvMgr_cpp2508 81 "%0%!FUNC!: unable to get device status 0x%10!x!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
configRet, ItemLong -- 10
}
#typev  DrvMgr_cpp2493 80 "%0%!FUNC!: unable to get device detail %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp2472 79 "%0%!FUNC!: unable to get devinfoset %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp2446 78 "%0Disabling all UMDF device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
}
#typev  DrvMgr_cpp2441 77 "%0Enabling all UMDF device" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::ChangeAllDeviceStates
{
}
#typev  DrvMgr_cpp177 15 "%0unable to create default imagepath %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
hResult, ItemHRESULT -- 10
}
#typev  DrvMgr_cpp167 14 "%0unable to allocate memory for imagepath" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
}
#typev  DrvMgr_cpp155 13 "%0unable to find image path for driver: %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
GetName(), ItemWString -- 10
}
#typev  DrvMgr_cpp132 12 "%0unable to get host process guid" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
}
#typev  DrvMgr_cpp106 11 "%0unable to open service key %10!s! : %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
GetName(), ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  DrvMgr_cpp87 10 "%0unable to open service root key : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_SERVICE_KEY FUNC=WdfServiceKey::WdfServiceKey
{
result, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp681 23 "%0%!FUNC!: about to be done with WdfDriverManager::~WdfDriverManager 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::~WdfDriverManager
{
this, ItemPtr -- 10
}
#typev  DrvMgr_cpp624 22 "%0The driver manager service is being shut down, but the host process for a UMDF device is still running." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::~WdfDriverManager
{
}
#typev  DrvMgr_cpp565 21 "%0calling ~WdfDriverManager..." //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::~WdfDriverManager
{
}
#typev  DrvMgr_cpp880 25 "%0unable to disable all UMDF Device" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::Stop
{
}
#typev  DrvMgr_cpp1530 42 "%0%!FUNC!: EnableAllDevices failed while setting state to SERVICE_RUNNING %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::DeferredInitialization
{
status, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp2270 74 "%0Unable to queue workitem to restart devices %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::PostRestartDeviceWorkItem
{
winerr, ItemWINERROR -- 10
}
#typev  DrvMgr_cpp476 20 "%0unable to get lpc interface" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::Initialize
{
}
#typev  DrvMgr_cpp420 19 "%0%!FUNC!: unable to convert service SID into a string %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::Initialize
{
GetLastError(), ItemWINERROR -- 10
}
#typev  DrvMgr_cpp368 18 "%0%!FUNC!: WdfDriverManager .ctor failed - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::Initialize
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  DrvMgr_cpp763 24 "%0Unable to queue workitem to call PrepareToUnload %10!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_MGR FUNC=WdfDriverManager::PrepareToStop
{
winerr, ItemWINERROR -- 10
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:985 (UTC) [tracepdb]
a95e40e4-7efb-83b2-5ade-62378245b154 WUDFSvc // SRC=lpcNotification.cpp MJ= MN=
#typev  lpcNotification_cpp100 11 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::DrvMgrLpcNotification
{
NT_SUCCESS(ntStatus) ? L'succeeded' : L'failed', ItemWString -- 10
}
#typev  lpcNotification_cpp60 10 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::DrvMgrLpcNotification
{
CmdLineArguments, ItemPtr -- 10
}
#typev  lpcNotification_cpp114 13 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::~DrvMgrLpcNotification
{
}
#typev  lpcNotification_cpp106 12 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::~DrvMgrLpcNotification
{
}
#typev  lpcNotification_cpp152 15 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::MarkForDelete
{
}
#typev  lpcNotification_cpp125 14 "%0 Entering %!FUNC!()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::MarkForDelete
{
}
#typev  lpcNotification_cpp178 17 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsClosed
{
}
#typev  lpcNotification_cpp162 16 "%0 Entering %!FUNC!(%10!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsClosed
{
LpcCommPort, ItemPtr -- 10
}
#typev  lpcNotification_cpp257 20 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsConnected
{
ntStatus, ItemNTSTATUS -- 10
}
#typev  lpcNotification_cpp203 19 "%0A user mode component tried to connect to driver manager" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::PortIsConnected
{
}
#typev  lpcNotification_cpp193 18 "%0 Entering %!FUNC!(%10!p!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::PortIsConnected
{
LpcConnPort, ItemPtr -- 10
LpcCommPort, ItemPtr -- 11
}
#typev  lpcNotification_cpp672 34 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp596 33 "%0%!FUNC!: receive WdfProcMgmt_Message_CloseProcess message" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp551 32 "%0open process is not allowed" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp504 31 "%0%!FUNC!: Host process already associated with devnode %10!s!. This means we did not clean up this devnode properly when it was last removed
." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
pdoName, ItemWString -- 10
}
#typev  lpcNotification_cpp475 30 "%0%!FUNC!: receive WdfProcMgmt_Message_OpenProcess %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
pdoName, ItemWString -- 10
}
#typev  lpcNotification_cpp467 29 "%0%!FUNC!: invalide pdo name.  %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
hResult, ItemHRESULT -- 10
}
#typev  lpcNotification_cpp411 28 "%0%!FUNC!: receive WdfProcMgmt_Message_QueryProcess %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
pdoName, ItemWString -- 10
}
#typev  lpcNotification_cpp403 27 "%0%!FUNC!: invalide pdo name.  %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
hResult, ItemHRESULT -- 10
}
#typev  lpcNotification_cpp359 26 "%0%!FUNC!: receive WdfProcMgmt_Message_ControlObjectName %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
controlObjectName, ItemWString -- 10
}
#typev  lpcNotification_cpp351 25 "%0%!FUNC!: invalide control object name.  %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
hResult, ItemHRESULT -- 10
}
#typev  lpcNotification_cpp335 24 "%0%!FUNC!: invalide control object name offset" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp298 23 "%0request not from kernel mode" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp286 22 "%0%!FUNC!: message too small" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_LPC FUNC=DrvMgrLpcNotification::Message
{
}
#typev  lpcNotification_cpp276 21 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!d!, %13!p!, %14!d!, %15!p!, %16!Id!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=DrvMgrLpcNotification::Message
{
LpcPort, ItemPtr -- 10
ImpersonationData, ItemPtr -- 11
ReplyMessageId, ItemLong -- 12
Message, ItemPtr -- 13
MessageSize, ItemLong -- 14
DataBuffer, ItemPtr -- 15
DataBufferSize, ItemPtr -- 16
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:985 (UTC) [tracepdb]
962c50f4-38dc-1edb-ca49-e13ce1169462 WUDFSvc // SRC=devnode.cpp MJ= MN=
#typev  devnode_cpp680 33 "%0new SD is invalid %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp666 32 "%0unable to set new SD %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp651 31 "%0fail to init new SD %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp636 30 "%0unable to allocate a new SD" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp605 28 "%0unable to set ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp586 27 "%0unable to get ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp621 29 "%0new DACL is invalid %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp567 26 "%0unable to set ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp548 25 "%0unable to init new DACL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp532 24 "%0unable to allocate memory for new DACL" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp500 23 "%0Device Parameters key or one of its subkeys has no dacl present for device with InstanceId: %10!s!, HardwareId: %11!s!. PLEASE NOTE that absent dacl is not recommended." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
m_InstanceId, ItemWString -- 10
m_DeviceHardwareId, ItemWString -- 11
}
#typev  devnode_cpp469 22 "%0desired access already given" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp447 21 "%0unable to get ACE %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp414 20 "%0Device Parameters key or one of its subkeys has NULL dacl for device with InstanceId: %10!s!, HardwareId: %11!s!. PLEASE NOTE that NULL dacl is not recommended." //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
m_InstanceId, ItemWString -- 10
m_DeviceHardwareId, ItemWString -- 11
}
#typev  devnode_cpp402 19 "%0dacl not present when it is supposed to" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp394 18 "%0unable to get SD DACL %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp370 17 "%0unable to get SD control %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp353 16 "%0unable to get device parameter SD %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp337 15 "%0unable to allocate memory for SD" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
}
#typev  devnode_cpp327 14 "%0unable to get device parameter key SD size %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp294 13 "%0unable to open sub key %10!s! %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::SetRegKeySecurity
{
subKeyName, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  devnode_cpp1200 53 "%0SetupDiOpenDevRegKey failed: %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::OpenDeviceKey
{
GetLastError(), ItemWINERROR -- 10
}
#typev  devnode_cpp1400 67 "%0Failed to get device hardware id - %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp1383 66 "%0Failed to get device location info - %10!s!" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp1365 65 "%0Failed to get device %10!s! - %11!s!" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
nameType, ItemWString -- 10
winerr, ItemWINERROR -- 11
}
#typev  devnode_cpp1314 64 "%0Failed to get device instance id - %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp1298 63 "%0Failed to allocate flattened instance id buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
}
#typev  devnode_cpp1289 62 "%0Failed to allocate instance id buffer" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
}
#typev  devnode_cpp1275 61 "%0unable to get instance id length %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::GetDeviceProperties
{
GetLastError(), ItemWINERROR -- 10
}
#typev  devnode_cpp1144 52 "%0%!FUNC!: found devinfo data " //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_LPC FUNC=WdfDevNode::FindDeviceInfo
{
}
#typev  devnode_cpp1092 51 "%0%!FUNC!: could not allocate %10!I64u!l bytes to copy instance ID %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=WdfDevNode::FindDeviceInfo
{
(otherPdoNameCch * sizeof(WCHAR)), ItemULongLong -- 10
thisPdoName, ItemWString -- 11
}
#typev  devnode_cpp1084 50 "%0%!FUNC!: PdoName is too long" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=WdfDevNode::FindDeviceInfo
{
}
#typev  devnode_cpp1072 49 "%0%!FUNC!: PdoName is too long" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_LPC FUNC=WdfDevNode::FindDeviceInfo
{
}
#typev  devnode_cpp1246 60 "%0" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
}
#typev  devnode_cpp1241 59 "%0		image path : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_SubNode.m_ServiceKeys[j]->ImagePath(), ItemWString -- 10
}
#typev  devnode_cpp1237 58 "%0		driver name : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_SubNode.m_ServiceKeys[j]->GetName(), ItemWString -- 10
}
#typev  devnode_cpp1231 57 "%0		host GUID : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_SubNode.m_HostGuid, ItemWString -- 10
}
#typev  devnode_cpp1226 56 "%0	timeout : %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
m_HostProcessTimeout, ItemLong -- 10
}
#typev  devnode_cpp1222 55 "%0	device name : %10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
GetName(), ItemWString -- 10
}
#typev  devnode_cpp1218 54 "%0devnode data :" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::PrintDevNode
{
}
#typev  devnode_cpp942 46 "%0Device Group Id:%10!s!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
m_DeviceGroupId, ItemWString -- 10
}
#typev  devnode_cpp934 45 "%0Invalid configuration for Device group id. Expected non-zero length string" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp923 44 "%0Invalid configuration for Device Group ID.  Registry Type is %10!d!, expected REG_SZ" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
type, ItemLong -- 10
}
#typev  devnode_cpp877 41 "%0Invalid driver list - drivers do not use the same host GUID" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp904 43 "%0device stack too deep 0x%10!x!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
m_StackSize, ItemLong -- 10
}
#typev  devnode_cpp886 42 "%0driver node has %10!u! stacks" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
m_StackSize, ItemLong -- 10
}
#typev  devnode_cpp858 40 "%0invalid driver list in registry" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp836 39 "%0unable to load service key : %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
driverName, ItemWString -- 10
}
#typev  devnode_cpp817 38 "%0unable to allocate memory for service key object array" //   LEVEL=TRACE_LEVEL_WARNING FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp808 37 "%0invalid driver list in registry" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp792 36 "%0unable to get process timeout value. use default" //   LEVEL=TRACE_LEVEL_INFORMATION FLAGS=MGR_TRACE_PROCESS FUNC=WdfDevNode::LoadRegistrySettings
{
}
#typev  devnode_cpp771 35 "%0registry entry %10!s! not found" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
WDF_DRIVER_LIST, ItemWString -- 10
}
#typev  devnode_cpp753 34 "%0RegOpenKeyEx %10!s! failed: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadRegistrySettings
{
WUDF_SUB_KEY, ItemWString -- 10
result, ItemWINERROR -- 11
}
#typev  devnode_cpp1021 48 "%0%!FUNC!: RD_IOCTL_SET_PROCESS_ID call failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadProcess
{
winerr, ItemWINERROR -- 10
}
#typev  devnode_cpp997 47 "%0unable to find host process" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::LoadProcess
{
}
#typev  devnode_cpp144 12 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDevNode::WdfDevNode
{
NT_SUCCESS(ntStatus) ? L'success' : L'failure', ItemWString -- 10
}
#typev  devnode_cpp87 11 "%0unable to get host process sid" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_DEVNODE FUNC=WdfDevNode::WdfDevNode
{
}
#typev  devnode_cpp23 10 "%0 Entering %!FUNC!(%10!p!, %11!p!, %12!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WdfDevNode::WdfDevNode
{
Parameters, ItemPtr -- 10
ObjectList, ItemPtr -- 11
Parent, ItemPtr -- 12
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:985 (UTC) [tracepdb]
0eecacd9-6aef-463e-5e7a-bc9cabc9f8f7 WUDFSvc // SRC=security.cpp MJ= MN=
#typev  security_cpp284 13 "%0ScCreateAndSetSD: Fail InitAce i: %10!d! error: %11!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=DmCreateAndSetHostSD
{
i, ItemLong -- 10
winerr, ItemWINERROR -- 11
}
#typev  security_cpp222 12 "%0ScCreateAndSetSD: Fail SACL Create %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=DmCreateAndSetHostSD
{
winerr, ItemWINERROR -- 10
}
#typev  security_cpp205 11 "%0ScCreateAndSetSD: Fail DACL Create %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=DmCreateAndSetHostSD
{
winerr, ItemWINERROR -- 10
}
#typev  security_cpp183 10 "%0SeCreateAndSetSD: No memory to create absolute SD" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_PROCESS FUNC=DmCreateAndSetHostSD
{
}
// PDB:  e:\5359.obj.x86fre\drivers\wdf\umdf\drivermanager\dll\objfre\i386\WUDFSvc.pdb
// PDB:  Last Updated :2010-2-9:4:5:29:985 (UTC) [tracepdb]
83ccde73-bfdc-c9ca-38df-f47233a6c0f0 WUDFSvc // SRC=service.cpp MJ= MN=
#typev  service_cpp514 25 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ReportStatusToSCMgrLockHeld
{
fResult, ItemListLong(false,true) -- 10
}
#typev  service_cpp507 24 "%0service status = %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=ReportStatusToSCMgrLockHeld
{
GetLastError(), ItemWINERROR -- 10
}
#typev  service_cpp487 23 "%0 Entering %!FUNC!(%10!d!, %11!d!, %12!d!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ReportStatusToSCMgrLockHeld
{
CurrentState, ItemLong -- 10
Win32ExitCode, ItemLong -- 11
WaitHint, ItemLong -- 12
}
#typev  service_cpp637 30 "%0 Exiting  %!FUNC! => ()" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ShutdownService
{
}
#typev  service_cpp615 29 "%0UnregisterWait returned %10!u!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=ShutdownService
{
bResult, ItemLong -- 10
}
#typev  service_cpp607 28 "%0%!FUNC!: DrvMgrExt 0x%10!p! released " //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=ShutdownService
{
DriverManager, ItemPtr -- 10
}
#typev  service_cpp596 27 "%0%!FUNC!: releasing DrvMgrExt 0x%10!p!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=ShutdownService
{
DriverManager, ItemPtr -- 10
}
#typev  service_cpp592 26 "%0 Entering %!FUNC!(%10!p!, %11!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ShutdownService
{
DriverManager, ItemPtr -- 10
Timeout, ItemListLong(false,true) -- 11
}
#typev  service_cpp341 22 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ServiceControlHandler
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp315 21 "%0SERVICE_CONTROL_TRY_TO_STOP" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=MGR_TRACE_MGR FUNC=ServiceControlHandler
{
}
#typev  service_cpp302 20 "%0 Entering %!FUNC!(%10!d!, %11!d!, %12!p!, %13!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=ServiceControlHandler
{
ControlCode, ItemLong -- 10
EventType, ItemLong -- 11
EventData, ItemPtr -- 12
Context, ItemPtr -- 13
}
#typev  service_cpp262 19 "%0 Exiting  %!FUNC! => (%10!s!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfServiceMain
{
Status, ItemNTSTATUS -- 10
}
#typev  service_cpp242 18 "%0%!FUNC!: RegisterWaitForSingleObject failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp227 17 "%0%!FUNC!: Unable to new WdfDriverManager %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp215 16 "%0%!FUNC!: Unable to new WdfDriverManager %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp202 15 "%0%!FUNC!: ReportStatusToSCMgr failed while setting state to SERVICE_START_PENDING %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp183 14 "%0%!FUNC!: Unable to initialize platform library %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
hr, ItemHRESULT -- 10
}
#typev  service_cpp168 13 "%0%!FUNC!: Unable to allocate termination event %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp154 12 "%0%!FUNC!: Unable to register service control handler %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp120 11 "%0%!FUNC!: InitializeCriticalSectionAndSpinCount failed %10!s!" //   LEVEL=TRACE_LEVEL_ERROR FLAGS=MGR_TRACE_MGR FUNC=WudfServiceMain
{
Status, ItemWINERROR -- 10
}
#typev  service_cpp109 10 "%0 Entering %!FUNC!(%10!d!, %11!p!)" //   FUNCTIONCALL=FUNCTION_TRACE_AREA() FLAG=FUNCTION_TRACE_FLAG() FUNC=WudfServiceMain
{
Argc, ItemLong -- 10
Argv, ItemPtr -- 11
}
